/* Automatically generated file. Do not edit. 
 * Format:     ANSI C source code
 * Creator:    McStas <http://www.mcstas.org>
 * Instrument: RITA-II.instr (RITA_II)
 * Date:       Fri Oct 11 20:25:28 2019
 * File:       RITA-II.c
 * Compile:    cc -o RITA_II.out RITA-II.c 
 * CFLAGS=
 */


#define MCCODE_STRING "McStas 2.5 - Dec. 12, 2018"
#define FLAVOR "mcstas"
#define FLAVOR_UPPER "MCSTAS"
#define MC_USE_DEFAULT_MAIN
#define MC_TRACE_ENABLED
#define MC_EMBEDDED_RUNTIME

#line 1 "mccode-r.h"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas 2.5
* Version: $Revision$
*
* Runtime system header for McStas/McXtrace.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas/McXtrace version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCCODE_R_H
#define MCCODE_R_H "$Revision$"

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <time.h>
#include <float.h>
#include <inttypes.h>

/* If the runtime is embedded in the simulation program, some definitions can
   be made static. */

#ifdef MC_EMBEDDED_RUNTIME
#define mcstatic static
#else
#define mcstatic
#endif

#ifdef __dest_os
#if (__dest_os == __mac_os)
#define MAC
#endif
#endif

#ifdef __FreeBSD__
#define NEED_STAT_H
#endif

#if defined(__APPLE__) && defined(__GNUC__)
#define NEED_STAT_H
#endif

#ifdef NEED_STAT_H
#include <sys/stat.h>
#endif

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !WIN32 */
#endif /* MC_PATHSEP_C */



/* the version string is replaced when building distribution with mkdist */
#ifndef MCCODE_STRING
#define MCCODE_STRING "McStas 2.5 - Dec. 12, 2018"
#endif

#ifndef MCCODE_DATE
#define MCCODE_DATE "Dec. 12, 2018"
#endif

#ifndef MCCODE_VERSION
#define MCCODE_VERSION "2.5"
#endif

#ifndef MCCODE_NAME
#define MCCODE_NAME "McStas"
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE "neutron"
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV "MCSTAS"
#endif

#ifndef FLAVOR_UPPER
#define FLAVOR_UPPER MCCODE_NAME
#endif

#ifdef MC_PORTABLE
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#ifdef MAC
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (USE_MPI == 0)
#undef USE_MPI
#endif

#ifdef USE_MPI  /* default is to disable signals with MPI, as MPICH uses them to communicate */
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (NOSIGNALS == 0)
#undef NOSIGNALS
#endif

/* Note: the enum instr_formal_types definition MUST be kept
   synchronized with the one in mccode.h and with the
   instr_formal_type_names array in cogen.c. */
enum instr_formal_types
  {
    instr_type_double, instr_type_int, instr_type_string
  };
struct mcinputtable_struct { /* defines instrument parameters */
  char *name; /* name of parameter */
  void *par;  /* pointer to instrument parameter (variable) */
  enum instr_formal_types type;
  char *val;  /* default value */
};

typedef double MCNUM;
typedef struct {MCNUM x, y, z;} Coords;
typedef MCNUM Rotation[3][3];

/* the following variables are defined in the McStas generated C code
   but should be defined externally in case of independent library usage */
#ifndef DANSE
extern struct mcinputtable_struct mcinputtable[]; /* list of instrument parameters */
extern int    mcnumipar;                          /* number of instrument parameters */
extern char   mcinstrument_name[], mcinstrument_source[]; /* instrument name and filename */
extern char  *mcinstrument_exe;                           /* executable path = argv[0] or NULL */
extern MCNUM  mccomp_storein[]; /* 11 coords * number of components in instrument */
extern MCNUM  mcAbsorbProp[];
extern MCNUM  mcScattered;      /* number of SCATTER calls in current component */
extern MCNUM  mcRestore;        /* Flag to indicate if neutron needs to be restored */
#ifndef MC_ANCIENT_COMPATIBILITY
extern int mctraceenabled, mcdefaultmain;
#endif
#endif


/* Useful macros ============================================================ */

/* MPI stuff */

#ifdef USE_MPI
#include "mpi.h"

#ifdef OMPI_MPI_H  /* openmpi does not use signals: we may install our sighandler */
#undef NOSIGNALS
#endif

/*
 * MPI_MASTER(i):
 * execution of i only on master node
 */
#define MPI_MASTER(statement) { \
  if(mpi_node_rank == mpi_node_root)\
  { statement; } \
}

#ifndef MPI_REDUCE_BLOCKSIZE
#define MPI_REDUCE_BLOCKSIZE 1000
#endif

int mc_MPI_Sum(double* buf, long count);
int mc_MPI_Send(void *sbuf, long count, MPI_Datatype dtype, int dest);
int mc_MPI_Recv(void *rbuf, long count, MPI_Datatype dtype, int source);

/* MPI_Finalize exits gracefully and should be preferred to MPI_Abort */
#define exit(code) do {                                   \
    MPI_Finalize();                                       \
    exit(code);                                           \
  } while(0)

#else /* !USE_MPI */
#define MPI_MASTER(instr) instr
#endif /* USE_MPI */

#ifdef USE_MPI
static int mpi_node_count;
#endif

#ifdef USE_THREADS  /* user want threads */
#error Threading (USE_THREADS) support has been removed for very poor efficiency. Use MPI/SSH grid instead.
#endif


void   mcset_ncount(unsigned long long count);    /* wrapper to get mcncount */
unsigned long long int mcget_ncount(void);            /* wrapper to set mcncount */
unsigned long long mcget_run_num(void);           /* wrapper to get mcrun_num=0:mcncount */


/* Following part is only embedded when not redundant with mccode.h ========= */

#ifndef MCCODE_H

#ifndef NOSIGNALS
#include <signal.h>
#define SIG_MESSAGE(msg) strcpy(mcsig_message, msg);
#else
#define SIG_MESSAGE(msg)
#endif /* !NOSIGNALS */

/* Useful macros and constants ============================================== */

#ifndef FLT_MAX
#define FLT_MAX         3.40282347E+38F /* max decimal value of a "float" */
#endif

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif
#ifndef SQR
#define SQR(x) ( (x) * (x) )
#endif
#ifndef SIGN
#define SIGN(x) (((x)>0.0)?(1):(-1))
#endif

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
#  define PI 3.14159265358979323846
# endif
#endif

#define RAD2MIN  ((180*60)/PI)
#define MIN2RAD  (PI/(180*60))
#define DEG2RAD  (PI/180)
#define RAD2DEG  (180/PI)
#define FWHM2RMS 0.424660900144    /* Convert between full-width-half-max and */
#define RMS2FWHM 2.35482004503     /* root-mean-square (standard deviation) */
#define HBAR     1.05457168e-34    /* [Js] h bar Planck constant CODATA 2002 */
#define MNEUTRON 1.67492728e-27    /* [kg] mass of neutron CODATA 2002 */
#define GRAVITY  9.81              /* [m/s^2] gravitational acceleration */
#define NA       6.02214179e23     /* [#atoms/g .mole] Avogadro's number*/


/* wrapper to get absolute and relative position of comp */
/* mccomp_posa and mccomp_posr are defined in McStas generated C code */
#define POS_A_COMP_INDEX(index) \
    (mccomp_posa[index])
#define POS_R_COMP_INDEX(index) \
    (mccomp_posr[index])
/* number of SCATTER calls in current comp: mcScattered defined in generated C code */
#define SCATTERED mcScattered
/* Flag to indicate if neutron needs to be restored: mcRestore defined in generated C code */
#define RESTORE mcRestore


/* Retrieve component information from the kernel */
/* Name, position and orientation (both absolute and relative)  */
/* Any component: For "redundancy", see comment by KN */
#define tmp_name_comp(comp) #comp
#define NAME_COMP(comp) tmp_name_comp(comp)
#define tmp_pos_a_comp(comp) (mcposa ## comp)
#define POS_A_COMP(comp) tmp_pos_a_comp(comp)
#define tmp_pos_r_comp(comp) (mcposr ## comp)
#define POS_R_COMP(comp) tmp_pos_r_comp(comp)
#define tmp_rot_a_comp(comp) (mcrota ## comp)
#define ROT_A_COMP(comp) tmp_rot_a_comp(comp)
#define tmp_rot_r_comp(comp) (mcrotr ## comp)
#define ROT_R_COMP(comp) tmp_rot_r_comp(comp)

/* Current component name, index, position and orientation */
#define NAME_CURRENT_COMP  NAME_COMP(mccompcurname)
#define INDEX_CURRENT_COMP mccompcurindex
#define POS_A_CURRENT_COMP POS_A_COMP(mccompcurname)
#define POS_R_CURRENT_COMP POS_R_COMP(mccompcurname)
#define ROT_A_CURRENT_COMP ROT_A_COMP(mccompcurname)
#define ROT_R_CURRENT_COMP ROT_R_COMP(mccompcurname)

/* Note: The two-stage approach to MC_GETPAR is NOT redundant; without it,
* after #define C sample, MC_GETPAR(C,x) would refer to component C, not to
* component sample. Such are the joys of ANSI C.

* Anyway the usage of MCGETPAR requires that we use sometimes bare names...
*/
#define MC_GETPAR2(comp, par) (mcc ## comp ## _ ## par)
#define MC_GETPAR(comp, par) MC_GETPAR2(comp,par)

/* MCDISPLAY/trace and debugging message sent to stdout */
#ifdef MC_TRACE_ENABLED
#define DEBUG
#endif

#ifdef DEBUG
#define mcDEBUG_INSTR() if(!mcdotrace); else { printf("\nINSTRUMENT:\n"); printf("Instrument '%s' (%s)\n", mcinstrument_name, mcinstrument_source); }
#define mcDEBUG_COMPONENT(name,c,t) if(!mcdotrace); else {\
  printf("COMPONENT: \"%s\"\n" \
         "POS: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         name, c.x, c.y, c.z, t[0][0], t[0][1], t[0][2], \
         t[1][0], t[1][1], t[1][2], t[2][0], t[2][1], t[2][2]); \
  mcAccumulatedILength += coords_len(coords_sub(mcLastComp,c)); \
  printf("Component %30s AT (%g,%g,%g)    %g m from origin\n", name, c.x, c.y, c.z, mcAccumulatedILength); \
  mcLastComp=c;\
  }
#define mcDEBUG_INSTR_END() if(!mcdotrace); else printf("INSTRUMENT END:\n");
#define mcDEBUG_ENTER() if(!mcdotrace); else printf("ENTER:\n");
#define mcDEBUG_COMP(c) if(!mcdotrace); else printf("COMP: \"%s\"\n", c);
#define mcDEBUG_LEAVE() if(!mcdotrace); else printf("LEAVE:\n");
#define mcDEBUG_ABSORB() if(!mcdotrace); else printf("ABSORB:\n");
#else
#define mcDEBUG_INSTR()
#define mcDEBUG_COMPONENT(name,c,t)
#define mcDEBUG_INSTR_END()
#define mcDEBUG_ENTER()
#define mcDEBUG_COMP(c)
#define mcDEBUG_LEAVE()
#define mcDEBUG_ABSORB()
#endif

// mcDEBUG_STATE and mcDEBUG_SCATTER are defined by mcstas-r.h and mcxtrace-r.h



#ifdef TEST
#define test_printf printf
#else
#define test_printf while(0) printf
#endif

/* send MCDISPLAY message to stdout to show gemoetry */
void mcdis_magnify(char *what);
void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2);
void mcdis_dashed_linemcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n);
void mcdis_multiline(int count, ...);
void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height);
void mcdis_box(double x, double y, double z,
	       double width, double height, double length);
void mcdis_circle(char *plane, double x, double y, double z, double r);
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz);
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz);
void mcdis_sphere(double x, double y, double z, double r, int N);

/* selection of random number generator. default is MT */
#ifndef MC_RAND_ALG
#define MC_RAND_ALG 1
#endif

#if MC_RAND_ALG == 0
   /* Use system random() (not recommended). */
#  define MC_RAND_MAX RAND_MAX
#elif MC_RAND_ALG == 1
   /* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
#  define MC_RAND_MAX ((unsigned long)0xffffffff)
#  define random mt_random
#  define srandom mt_srandom
#elif MC_RAND_ALG == 2
   /* Algorithm used in McStas CVS-080208 and earlier (not recommended). */
#  define MC_RAND_MAX 0x7fffffff
#  define random mc_random
#  define srandom mc_srandom
#else
#  error "Bad value for random number generator choice."
#endif

typedef int mc_int32_t;
mc_int32_t mc_random(void);
void mc_srandom (unsigned int x);
unsigned long mt_random(void);
void mt_srandom (unsigned long x);

double rand01();
double randpm1();
double rand0max(double max);
double randminmax(double min, double max);

double randnorm(void);
double randtriangle(void);

#ifndef DANSE
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);
#endif

/* simple vector algebra ==================================================== */
#define vec_prod(x, y, z, x1, y1, z1, x2, y2, z2) \
	vec_prod_func(&x, &y, &z, x1, y1, z1, x2, y2, z2)
mcstatic inline void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1, double x2, double y2, double z2);

mcstatic inline double scalar_prod(
		double x1, double y1, double z1, double x2, double y2, double z2);

#define NORM(x,y,z) \
	norm_func(&x, &y, &z)
mcstatic inline void norm_func(double *x, double *y, double *z) {
	double temp = (*x * *x) + (*y * *y) + (*z * *z);
	if (temp != 0) {
		temp = sqrt(temp);
		*x /= temp;
		*y /= temp;
		*z /= temp;
	}
}
#define normal_vec(nx, ny, nz, x, y, z) \
    normal_vec_func(&(nx), &(ny), &(nz), x, y, z)
mcstatic inline void normal_vec_func(double *nx, double *ny, double *nz,
    double x, double y, double z);

/**
 * Rotate the vector vx,vy,vz psi radians around the vector ax,ay,az
 * and put the result in x,y,z.
 */
#define rotate(x, y, z, vx, vy, vz, phi, ax, ay, az) \
  do { \
    double mcrt_tmpx = (ax), mcrt_tmpy = (ay), mcrt_tmpz = (az); \
    double mcrt_vp, mcrt_vpx, mcrt_vpy, mcrt_vpz; \
    double mcrt_vnx, mcrt_vny, mcrt_vnz, mcrt_vn1x, mcrt_vn1y, mcrt_vn1z; \
    double mcrt_bx, mcrt_by, mcrt_bz; \
    double mcrt_cos, mcrt_sin; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vp = scalar_prod((vx), (vy), (vz), mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vpx = mcrt_vp*mcrt_tmpx; \
    mcrt_vpy = mcrt_vp*mcrt_tmpy; \
    mcrt_vpz = mcrt_vp*mcrt_tmpz; \
    mcrt_vnx = (vx) - mcrt_vpx; \
    mcrt_vny = (vy) - mcrt_vpy; \
    mcrt_vnz = (vz) - mcrt_vpz; \
    vec_prod(mcrt_bx, mcrt_by, mcrt_bz, \
             mcrt_tmpx, mcrt_tmpy, mcrt_tmpz, mcrt_vnx, mcrt_vny, mcrt_vnz); \
    mcrt_cos = cos((phi)); mcrt_sin = sin((phi)); \
    mcrt_vn1x = mcrt_vnx*mcrt_cos + mcrt_bx*mcrt_sin; \
    mcrt_vn1y = mcrt_vny*mcrt_cos + mcrt_by*mcrt_sin; \
    mcrt_vn1z = mcrt_vnz*mcrt_cos + mcrt_bz*mcrt_sin; \
    (x) = mcrt_vpx + mcrt_vn1x; \
    (y) = mcrt_vpy + mcrt_vn1y; \
    (z) = mcrt_vpz + mcrt_vn1z; \
  } while(0)

/**
 * Mirror (xyz) in the plane given by the point (rx,ry,rz) and normal (nx,ny,nz)
 *
 * TODO: This define is seemingly never used...
 */
#define mirror(x,y,z,rx,ry,rz,nx,ny,nz) \
  do { \
    double mcrt_tmpx= (nx), mcrt_tmpy = (ny), mcrt_tmpz = (nz); \
    double mcrt_tmpt; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_tmpt=scalar_prod((rx),(ry),(rz),mcrt_tmpx,mcrt_tmpy,mcrt_tmpz); \
    (x) = rx -2 * mcrt_tmpt*mcrt_rmpx; \
    (y) = ry -2 * mcrt_tmpt*mcrt_rmpy; \
    (z) = rz -2 * mcrt_tmpt*mcrt_rmpz; \
  } while (0)

Coords coords_set(MCNUM x, MCNUM y, MCNUM z);
Coords coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z);
Coords coords_add(Coords a, Coords b);
Coords coords_sub(Coords a, Coords b);
Coords coords_neg(Coords a);
Coords coords_scale(Coords b, double scale);
double coords_sp(Coords a, Coords b);
Coords coords_xp(Coords b, Coords c);
double coords_len(Coords a);
void   coords_print(Coords a);
mcstatic inline void coords_norm(Coords* c);

void rot_set_rotation(Rotation t, double phx, double phy, double phz);
int  rot_test_identity(Rotation t);
void rot_mul(Rotation t1, Rotation t2, Rotation t3);
void rot_copy(Rotation dest, Rotation src);
void rot_transpose(Rotation src, Rotation dst);
Coords rot_apply(Rotation t, Coords a);

void mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
    double *vx, double *vy, double *vz, double *sx, double *sy, double *sz);
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz);

double mcestimate_error(double N, double p1, double p2);
void mcreadparams(void);

/* this is now in mcstas-r.h and mcxtrace-r.h as the number of state parameters is no longer equal*/
/* void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);
*/
void mcgenstate(void);

/* trajectory/shape intersection routines */
int inside_rectangle(double, double, double, double);
int box_intersect(double *dt_in, double *dt_out, double x, double y, double z,
    double vx, double vy, double vz, double dx, double dy, double dz);
int cylinder_intersect(double *t0, double *t1, double x, double y, double z,
    double vx, double vy, double vz, double r, double h);
int sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r);
/* second order equation roots */
int solve_2nd_order(double *t1, double *t2,
    double A,  double B,  double C);

/* random vector generation to shape */
void randvec_target_circle(double *xo, double *yo, double *zo,
    double *solid_angle, double xi, double yi, double zi, double radius);
#define randvec_target_sphere randvec_target_circle
void randvec_target_rect_angular(double *xo, double *yo, double *zo,
    double *solid_angle,
               double xi, double yi, double zi, double height, double width, Rotation A);
#define randvec_target_rect(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)  randvec_target_rect_real(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,0,0,0,1)
void randvec_target_rect_real(double *xo, double *yo, double *zo,
    double *solid_angle,
	       double xi, double yi, double zi, double height, double width, Rotation A,
			 double lx, double ly, double lz, int order);

/* this is the main() */
int mccode_main(int argc, char *argv[]);


#endif /* !MCCODE_H */

#ifndef MCCODE_R_IO_H
#define MCCODE_R_IO_H "$Revision$"

#if (USE_NEXUS == 0)
#undef USE_NEXUS
#endif

#ifndef CHAR_BUF_LENGTH
#define CHAR_BUF_LENGTH 1024
#endif

/* I/O section part ========================================================= */

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */


/* main DETECTOR structure which stores most information to write to data files */
struct mcdetector_struct {
  char   filename[CHAR_BUF_LENGTH];   /* file name of monitor */
  char   position[CHAR_BUF_LENGTH];   /* position of detector component */
  char   component[CHAR_BUF_LENGTH];  /* component instance name */
  char   instrument[CHAR_BUF_LENGTH]; /* instrument name */
  char   type[CHAR_BUF_LENGTH];       /* data type, e.g. 0d, 1d, 2d, 3d */
  char   user[CHAR_BUF_LENGTH];       /* user name, e.g. HOME */
  char   date[CHAR_BUF_LENGTH];       /* date of simulation end/write time */
  char   title[CHAR_BUF_LENGTH];      /* title of detector */
  char   xlabel[CHAR_BUF_LENGTH];     /* X axis label */
  char   ylabel[CHAR_BUF_LENGTH];     /* Y axis label */
  char   zlabel[CHAR_BUF_LENGTH];     /* Z axis label */
  char   xvar[CHAR_BUF_LENGTH];       /* X variable name */
  char   yvar[CHAR_BUF_LENGTH];       /* Y variable name */
  char   zvar[CHAR_BUF_LENGTH];       /* Z variable name */
  char   ncount[CHAR_BUF_LENGTH];     /* number of events initially generated */
  char   limits[CHAR_BUF_LENGTH];     /* X Y Z limits, e.g. [xmin xmax ymin ymax zmin zmax] */
  char   variables[CHAR_BUF_LENGTH];  /* variables written into data block */
  char   statistics[CHAR_BUF_LENGTH]; /* center, mean and half width along axis */
  char   signal[CHAR_BUF_LENGTH];     /* min max and mean of signal (data block) */
  char   values[CHAR_BUF_LENGTH];     /* integrated values e.g. [I I_err N] */
  double xmin,xmax;                   /* min max of axes */
  double ymin,ymax;
  double zmin,zmax;
  double intensity;                   /* integrated values for data block */
  double error;
  double events;
  double min;                         /* statistics for data block */
  double max;
  double mean;
  double centerX;                     /* statistics for axes */
  double halfwidthX;
  double centerY;
  double halfwidthY;
  int    rank;                        /* dimensionaly of monitor, e.g. 0 1 2 3 */
  char   istransposed;                /* flag to transpose matrix for some formats */

  long   m,n,p;                       /* dimensions of data block and along axes */
  long   date_l;                      /* same as date, but in sec since 1970 */

  double *p0, *p1, *p2;               /* pointers to saved data, NULL when freed */
  char   format[CHAR_BUF_LENGTH];    /* format for file generation */
};

typedef struct mcdetector_struct MCDETECTOR;

static   char *mcdirname             = NULL;      /* name of output directory */
static   char *mcsiminfo_name        = "mccode";  /* default output sim file name */
char    *mcformat                    = NULL;      /* NULL (default) or a specific format */

/* file I/O definitions and function prototypes */

#ifndef MC_EMBEDDED_RUNTIME /* the mcstatic variables (from mccode-r.c) */
extern FILE * mcsiminfo_file;     /* handle to the output siminfo file */
extern int    mcgravitation;      /* flag to enable gravitation */
extern int    mcdotrace;          /* flag to print MCDISPLAY messages */
#else
mcstatic FILE *mcsiminfo_file        = NULL;
#endif

/* I/O function prototypes ================================================== */

/* output functions */
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2, char *c, Coords pos);
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
                  char *xvar, double x1, double x2, long n,
                  double *p0, double *p1, double *p2, char *f, char *c, Coords pos);
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2, long m,
                  long n, double *p0, double *p1, double *p2, char *f,
                  char *c, Coords pos);
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa);

/* wrappers to output functions, that automatically set NAME and POSITION */
#define DETECTOR_OUT(p0,p1,p2) mcdetector_out_0D(NAME_CURRENT_COMP,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_0D(t,p0,p1,p2) mcdetector_out_0D(t,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f) \
     mcdetector_out_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f) \
     mcdetector_out_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)

#ifdef USE_NEXUS
#include "napi.h"
NXhandle nxhandle;
#endif

#endif /* ndef MCCODE_R_IO_H */

#endif /* MCCODE_R_H */
/* End of file "mccode-r.h". */

#line 695 "RITA-II.c"

#line 1 "mcstas-r.h"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system header for McStas.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#define MCSTAS_R_H "$Revision$"

/* Following part is only embedded when not redundent with mcstas.h ========= */

#ifndef MCCODE_H

#define AA2MS    629.622368        /* Convert k[1/AA] to v[m/s] */
#define MS2AA    1.58825361e-3     /* Convert v[m/s] to k[1/AA] */
#define K2V      AA2MS
#define V2K      MS2AA
#define Q2V      AA2MS
#define V2Q      MS2AA
#define SE2V     437.393377        /* Convert sqrt(E)[meV] to v[m/s] */
#define VS2E     5.22703725e-6     /* Convert (v[m/s])**2 to E[meV] */

#define SCATTER do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0)
#define ABSORB do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0)

#define STORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcstore_neutron(mccomp_storein,index, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
#define RESTORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcrestore_neutron(mccomp_storein,index, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p);

#define MAGNET_ON \
  do { \
    mcMagnet = 1; \
  } while(0)

#define MAGNET_OFF \
  do { \
    mcMagnet = 0; \
  } while(0)

#define ALLOW_BACKPROP \
  do { \
    mcallowbackprop = 1; \
  } while(0)

#define DISALLOW_BACKPROP \
  do { \
    mcallowbackprop = 0; \
  } while(0)

#define PROP_MAGNET(dt) \
  do { \
  }while (0)
    /* change coordinates from local system to magnet system */
/*    Rotation rotLM, rotTemp; \
      Coords   posLM = coords_sub(POS_A_CURRENT_COMP, mcMagnetPos); \
      rot_transpose(ROT_A_CURRENT_COMP, rotTemp); \
      rot_mul(rotTemp, mcMagnetRot, rotLM); \
      mcMagnetPrecession(mcnlx, mcnly, mcnlz, mcnlt, mcnlvx, mcnlvy, mcnlvz, \
               &mcnlsx, &mcnlsy, &mcnlsz, dt, posLM, rotLM); \
      } while(0)
*/

#define mcPROP_DT(dt) \
  do { \
    if (mcMagnet && dt > 0) PROP_MAGNET(dt);\
    mcnlx += mcnlvx*(dt); \
    mcnly += mcnlvy*(dt); \
    mcnlz += mcnlvz*(dt); \
    mcnlt += (dt); \
    if (isnan(p) || isinf(p)) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
  } while(0)

/* ADD: E. Farhi, Aug 6th, 2001 PROP_GRAV_DT propagation with acceleration */
#define PROP_GRAV_DT(dt, Ax, Ay, Az) \
  do { \
    if(dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
    if (mcMagnet) printf("Spin precession gravity\n"); \
    mcnlx  += mcnlvx*(dt) + (Ax)*(dt)*(dt)/2; \
    mcnly  += mcnlvy*(dt) + (Ay)*(dt)*(dt)/2; \
    mcnlz  += mcnlvz*(dt) + (Az)*(dt)*(dt)/2; \
    mcnlvx += (Ax)*(dt); \
    mcnlvy += (Ay)*(dt); \
    mcnlvz += (Az)*(dt); \
    mcnlt  += (dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_DT(dt) \
  do { \
    if(dt < 0) { RESTORE=1; goto mcabsorbComp; }; \
    if (mcgravitation) { Coords mcLocG; double mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    PROP_GRAV_DT(dt, mc_gx, mc_gy, mc_gz); } \
    else mcPROP_DT(dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_Z0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gz/2, -mcnlvz, -mcnlz); \
    if (mc_ret && mc_dt>=0) {PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); mcnlz=0;}\
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Z0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_Z0 \
  do { \
    double mc_dt; \
    if(mcnlvz == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlz/mcnlvz; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlz = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_X0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gx/2, -mcnlvx, -mcnlx); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_X0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_X0 \
  do { \
    double mc_dt; \
    if(mcnlvx == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlx/mcnlvx; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlx = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_Y0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gy/2, -mcnlvy, -mcnly); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Y0; \
    DISALLOW_BACKPROP;\
  } while(0)


#define mcPROP_Y0 \
  do { \
    double mc_dt; \
    if(mcnlvy == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnly/mcnlvy; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnly = 0; \
    DISALLOW_BACKPROP; \
  } while(0)

/*moved from mccode-r.h*/
void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);

#ifdef DEBUG

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("STATE: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("SCATTER: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);

#else

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p)
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p)

#endif

#endif /* !MCCODE_H */

#endif /* MCSTAS_R_H */
/* End of file "mcstas-r.h". */

#line 928 "RITA-II.c"

#line 1 "mccode-r.c"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y/McXtrace X.Y
* Version: $Revision$
*
* Runtime system for McStas and McXtrace.
* Embedded within instrument in runtime mode.
* Contains SECTIONS:
*   MPI handling (sum, send, recv)
*   format definitions
*   I/O
*   mcdisplay support
*   random numbers
*   coordinates handling
*   vectors math (solve 2nd order, normals, randvec...)
*   parameter handling
*   signal and main handlers
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/


/** Include header files to avoid implicit declarations (not allowed on LLVM) */
#include <ctype.h>
#include <sys/types.h>

// UNIX specific headers (non-Windows)
#if defined(__unix__) || defined(__APPLE__)
#include <unistd.h>
#endif

#include <sys/stat.h>

#ifdef _WIN32 
# define  mkdir( D, M )   _mkdir( D ) 
#endif 

#ifndef DANSE
#ifdef MC_ANCIENT_COMPATIBILITY
int mctraceenabled = 0;
int mcdefaultmain  = 0;
#endif
/* else defined directly in the McCode generated C code */

static   long mcseed                 = 0; /* seed for random generator */
static   long mcstartdate            = 0; /* start simulation time */
static   int  mcdisable_output_files = 0; /* --no-output-files */
mcstatic int  mcgravitation          = 0; /* use gravitation flag, for PROP macros */
int      mcMagnet                    = 0; /* magnet stack flag */
mcstatic int  mcdotrace              = 0; /* flag for --trace and messages for DISPLAY */
int      mcallowbackprop             = 0;         /* flag to enable negative/backprop */

/* Number of particle histories to simulate. */
#ifdef NEUTRONICS
mcstatic unsigned long long int mcncount             = 1;
mcstatic unsigned long long int mcrun_num            = 0;
#else
mcstatic unsigned long long int mcncount             = 1000000;
mcstatic unsigned long long int mcrun_num            = 0;
#endif /* NEUTRONICS */

#else
#include "mcstas-globals.h"
#endif /* !DANSE */

/* SECTION: MPI handling ==================================================== */

#ifdef USE_MPI
/* MPI rank */
static int mpi_node_rank;
static int mpi_node_root = 0;


/*******************************************************************************
* mc_MPI_Reduce: Gathers arrays from MPI nodes using Reduce function.
*******************************************************************************/
int mc_MPI_Sum(double *sbuf, long count)
{
  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to reduce */
  else {
    /* we must cut the buffer into blocks not exceeding the MPI max buffer size of 32000 */
    long   offset=0;
    double *rbuf=NULL;
    int    length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */
    int    i=0;
    rbuf = calloc(count, sizeof(double));
    if (!rbuf)
      exit(-fprintf(stderr, "Error: Out of memory %li (mc_MPI_Sum)\n", count*sizeof(double)));
    while (offset < count) {
      if (!length || offset+length > count-1) length=count-offset;
      else length=MPI_REDUCE_BLOCKSIZE;
      if (MPI_Reduce((double*)(sbuf+offset), (double*)(rbuf+offset),
              length, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD) != MPI_SUCCESS)
        return MPI_ERR_COUNT;
      offset += length;
    }

    for (i=0; i<count; i++) sbuf[i] = rbuf[i];
    free(rbuf);
  }
  return MPI_SUCCESS;
} /* mc_MPI_Sum */

/*******************************************************************************
* mc_MPI_Send: Send array to MPI node by blocks to avoid buffer limit
*******************************************************************************/
int mc_MPI_Send(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int dest)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to send */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Send((void*)(sbuf+offset*dsize), length, dtype, dest, tag++, MPI_COMM_WORLD) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Send */

/*******************************************************************************
* mc_MPI_Recv: Receives arrays from MPI nodes by blocks to avoid buffer limit
*             the buffer must have been allocated previously.
*******************************************************************************/
int mc_MPI_Recv(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int source)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to recv */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Recv((void*)(sbuf+offset*dsize), length, dtype, source, tag++,
            MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Recv */

#endif /* USE_MPI */

/* SECTION: parameters handling ============================================= */

/* Instrument input parameter type handling. */
/*******************************************************************************
* mcparm_double: extract double value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_double(char *s, void *vptr)
{
  char *p;
  double *v = (double *)vptr;

  if (!s) { *v = 0; return(1); }
  *v = strtod(s, &p);
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_double: display parameter type double
*******************************************************************************/
static char *
mcparminfo_double(char *parmname)
{
  return "double";
}

/*******************************************************************************
* mcparmerror_double: display error message when failed extract double
*******************************************************************************/
static void
mcparmerror_double(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for floating point parameter %s (mcparmerror_double)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_double: convert double to string
*******************************************************************************/
static void
mcparmprinter_double(char *f, void *vptr)
{
  double *v = (double *)vptr;
  sprintf(f, "%g", *v);
}

/*******************************************************************************
* mcparm_int: extract int value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_int(char *s, void *vptr)
{
  char *p;
  int *v = (int *)vptr;
  long x;

  if (!s) { *v = 0; return(1); }
  *v = 0;
  x = strtol(s, &p, 10);
  if(x < INT_MIN || x > INT_MAX)
    return 0;                        /* Under/overflow */
  *v = x;
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_int: display parameter type int
*******************************************************************************/
static char *
mcparminfo_int(char *parmname)
{
  return "int";
}

/*******************************************************************************
* mcparmerror_int: display error message when failed extract int
*******************************************************************************/
static void
mcparmerror_int(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for integer parameter %s (mcparmerror_int)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_int: convert int to string
*******************************************************************************/
static void
mcparmprinter_int(char *f, void *vptr)
{
  int *v = (int *)vptr;
  sprintf(f, "%d", *v);
}

/*******************************************************************************
* mcparm_string: extract char* value from 's' into 'vptr' (copy)
*******************************************************************************/
static int
mcparm_string(char *s, void *vptr)
{
  char **v = (char **)vptr;
  if (!s) { *v = NULL; return(1); }
  *v = (char *)malloc(strlen(s) + 1);
  if(*v == NULL)
  {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcparm_string).\n", (long)strlen(s) + 1));
  }
  strcpy(*v, s);
  return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_string: display parameter type string
*******************************************************************************/
static char *
mcparminfo_string(char *parmname)
{
  return "string";
}

/*******************************************************************************
* mcparmerror_string: display error message when failed extract string
*******************************************************************************/
static void
mcparmerror_string(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for string parameter %s (mcparmerror_string)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_string: convert string to string (including esc chars)
*******************************************************************************/
static void
mcparmprinter_string(char *f, void *vptr)
{
  char **v = (char **)vptr;
  char *p;

  if (!*v) { *f='\0'; return; }
  strcpy(f, "");
  for(p = *v; *p != '\0'; p++)
  {
    switch(*p)
    {
      case '\n':
        strcat(f, "\\n");
        break;
      case '\r':
        strcat(f, "\\r");
        break;
      case '"':
        strcat(f, "\\\"");
        break;
      case '\\':
        strcat(f, "\\\\");
        break;
      default:
        strncat(f, p, 1);
    }
  }
  /* strcat(f, "\""); */
} /* mcparmprinter_string */

/* now we may define the parameter structure, using previous functions */
static struct
  {
    int (*getparm)(char *, void *);
    char * (*parminfo)(char *);
    void (*error)(char *, char *);
    void (*printer)(char *, void *);
} mcinputtypes[] = {
  {
    mcparm_double, mcparminfo_double, mcparmerror_double,
    mcparmprinter_double
  }, {
    mcparm_int, mcparminfo_int, mcparmerror_int,
    mcparmprinter_int
  }, {
    mcparm_string, mcparminfo_string, mcparmerror_string,
    mcparmprinter_string
  }
};

/*******************************************************************************
* mcestimate_error: compute sigma from N,p,p2 in Gaussian large numbers approx
*******************************************************************************/
double mcestimate_error(double N, double p1, double p2)
{
  double pmean, n1;
  if(N <= 1)
    return p1;
  pmean = p1 / N;
  n1 = N - 1;
  /* Note: underflow may cause p2 to become zero; the fabs() below guards
     against this. */
  return sqrt((N/n1)*fabs(p2 - pmean*pmean));
}

double (*mcestimate_error_p)
  (double V2, double psum, double p2sum)=mcestimate_error;

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */

#ifndef MCCODE_R_IO_C
#define MCCODE_R_IO_C "$Revision$"

/* SECTION: file i/o handling ================================================ */

#ifndef HAVE_STRCASESTR
// from msysgit: https://code.google.com/p/msysgit/source/browse/compat/strcasestr.c
char *strcasestr(const char *haystack, const char *needle)
{
  int nlen = strlen(needle);
  int hlen = strlen(haystack) - nlen + 1;
  int i;

  for (i = 0; i < hlen; i++) {
    int j;
    for (j = 0; j < nlen; j++) {
            unsigned char c1 = haystack[i+j];
            unsigned char c2 = needle[j];
            if (toupper(c1) != toupper(c2))
                    goto next;
    }
    return (char *) haystack + i;
  next:
    ;
  }
  return NULL;
}


#endif
#ifndef HAVE_STRCASECMP
int strcasecmp( const char *s1, const char *s2 )
{
  int c1, c2;
  do {
    c1 = tolower( (unsigned char) *s1++ );
    c2 = tolower( (unsigned char) *s2++ );
  } while (c1 == c2 && c1 != 0);
  return c2 > c1 ? -1 : c1 > c2;
}
#endif

/*******************************************************************************
* mcfull_file: allocates a full file name=mcdirname+file. Catenate extension if missing.
*******************************************************************************/
char *mcfull_file(char *name, char *ext)
{
  int   dirlen=0;
  char *mem   =NULL;

  dirlen = mcdirname ? strlen(mcdirname) : 0;
  mem = (char*)malloc(dirlen + strlen(name) + CHAR_BUF_LENGTH);
  if(!mem) {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcfull_file)\n", (long)(dirlen + strlen(name) + 256)));
  }
  strcpy(mem, "");

  /* prepend directory name to path if name does not contain a path */
  if (dirlen > 0 && !strchr(name, MC_PATHSEP_C)) {
    strcat(mem, mcdirname);
    strcat(mem, MC_PATHSEP_S);
  } /* dirlen */

  strcat(mem, name);
  if (!strchr(name, '.') && ext && strlen(ext))
  { /* add extension if not in file name already */
    strcat(mem, ".");
    strcat(mem, ext);
  }
  return(mem);
} /* mcfull_file */

/*******************************************************************************
* mcnew_file: opens a new file within mcdirname if non NULL
*             the file is opened in "a" (append, create if does not exist)
*             the extension 'ext' is added if the file name does not include one.
*             the last argument is set to 0 if file did not exist, else to 1.
*******************************************************************************/
FILE *mcnew_file(char *name, char *ext, int *exists)
{
  char *mem;
  FILE *file=NULL;

  if (!name || strlen(name) == 0 || mcdisable_output_files) return(NULL);
  
  mem  = mcfull_file(name, ext); /* create mcdirname/name.ext */
  
  /* check for existence */
  file = fopen(mem, "r"); /* for reading -> fails if does not exist */
  if (file) {
    fclose(file);
    *exists=1;
  } else
    *exists=0;
  
  /* open the file for writing/appending */
#ifdef USE_NEXUS
  if (mcformat && strcasestr(mcformat, "NeXus")) {
    /* NXhandle nxhandle is defined in the .h with USE_NEXUS */
    NXaccess mode = (*exists ? NXACC_CREATE5 | NXACC_RDWR : NXACC_CREATE5);
      
    if (NXopen(mem, mode, &nxhandle) != NX_OK)
      file = NULL;
    else
      file = (FILE*)&nxhandle; /* to make it non NULL */
  } else
#endif
    file = fopen(mem, "a+"); 
    
  if(!file)
    fprintf(stderr, "Warning: could not open output file '%s' for %s (mcnew_file)\n", 
      mem, *exists ? "append" : "create");
  free(mem);

  return file;
} /* mcnew_file */

/*******************************************************************************
* mcdetector_statistics: compute detector statistics, error bars, [x I I_err N] 1D
* RETURN:            updated detector structure
* Used by: mcdetector_import
*******************************************************************************/
MCDETECTOR mcdetector_statistics(
  MCDETECTOR detector)
{

  if (!detector.p1 || !detector.m || !detector.filename)
    return(detector);
  
  /* compute statistics and update MCDETECTOR structure ===================== */
  double sum_z  = 0, min_z  = 0, max_z  = 0;
  double fmon_x =0,  smon_x = 0, fmon_y =0, smon_y=0, mean_z=0;
  double Nsum=0, P2sum=0;

  double sum_xz = 0, sum_yz = 0, sum_x = 0, sum_y = 0, sum_x2z = 0, sum_y2z = 0;
  int    i,j;
  char   hasnan=0, hasinf=0;
  char   israw = ((char*)strcasestr(detector.format,"raw") != NULL);
  double *this_p1=NULL; /* new 1D McCode array [x I E N]. Freed after writing data */

  /* if McCode/PGPLOT and rank==1 we create a new m*4 data block=[x I E N] */
  if (detector.rank == 1 && strcasestr(detector.format,"McCode")) {
    this_p1 = (double *)calloc(detector.m*detector.n*detector.p*4, sizeof(double));
    if (!this_p1)
      exit(-fprintf(stderr, "Error: Out of memory creating %li 1D " MCCODE_STRING " data set for file '%s' (mcdetector_import)\n",
        detector.m*detector.n*detector.p*4*sizeof(double*), detector.filename));
  }

  max_z = min_z = detector.p1[0];
  
  /* compute sum and moments (not for lists) */
  if (!strcasestr(detector.format,"list") && detector.m)
  for(j = 0; j < detector.n*detector.p; j++)
  {
    for(i = 0; i < detector.m; i++)
    {
      double x,y,z;
      double N, E;
      long   index= !detector.istransposed ? i*detector.n*detector.p + j : i+j*detector.m;
      char   hasnaninf=0;

      if (detector.m) 
        x = detector.xmin + (i + 0.5)/detector.m*(detector.xmax - detector.xmin); 
      else x = 0;
      if (detector.n && detector.p) 
        y = detector.ymin + (j + 0.5)/detector.n/detector.p*(detector.ymax - detector.ymin); 
      else y = 0;
      z = detector.p1[index];
      N = detector.p0 ? detector.p0[index] : 1;
      E = detector.p2 ? detector.p2[index] : 0;
      if (detector.p2 && !israw) 
        detector.p2[index] = (*mcestimate_error_p)(detector.p0[index],detector.p1[index],detector.p2[index]); /* set sigma */
      
      if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
        /* fill-in 1D McCode array [x I E N] */
        this_p1[index*4]   = x;
        this_p1[index*4+1] = z;
        this_p1[index*4+2] = detector.p2 ? detector.p2[index] : 0;
        this_p1[index*4+3] = N;
      }
      
      if (isnan(z) || isnan(E) || isnan(N)) hasnaninf=hasnan=1;
      if (isinf(z) || isinf(E) || isinf(N)) hasnaninf=hasinf=1;

      /* compute stats integrals */
      if (!hasnaninf) {
        sum_xz += x*z;
        sum_yz += y*z;
        sum_x  += x;
        sum_y  += y;
        sum_z  += z;
        sum_x2z += x*x*z;
        sum_y2z += y*y*z;
        if (z > max_z) max_z = z;
        if (z < min_z) min_z = z;

        Nsum += N;
        P2sum += E;
      }

    }
  } /* for j */

  /* compute 1st and 2nd moments. For lists, sum_z=0 so this is skipped. */
  if (sum_z && detector.n*detector.m*detector.p)
  {
    fmon_x = sum_xz/sum_z;
    fmon_y = sum_yz/sum_z;
    smon_x = sum_x2z/sum_z-fmon_x*fmon_x; smon_x = smon_x > 0 ? sqrt(smon_x) : 0;
    smon_y = sum_y2z/sum_z-fmon_y*fmon_y; smon_y = smon_y > 0 ? sqrt(smon_y) : 0;
    mean_z = sum_z/detector.n/detector.m/detector.p;
  }
  /* store statistics into detector */
  detector.intensity = sum_z;
  detector.error     = Nsum ? (*mcestimate_error_p)(Nsum, sum_z, P2sum) : 0;
  detector.events    = Nsum;
  detector.min       = min_z;
  detector.max       = max_z;
  detector.mean      = mean_z;
  detector.centerX   = fmon_x;
  detector.halfwidthX= smon_x;
  detector.centerY   = fmon_y;
  detector.halfwidthY= smon_y;

  /* if McCode/PGPLOT and rank==1 replace p1 with new m*4 1D McCode and clear others */
  if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
    
    detector.p1 = this_p1;
    detector.n  = detector.m; detector.m  = 4;
    detector.p0 = detector.p2 = NULL;
    detector.istransposed = 1;
  }

  if (detector.n*detector.m*detector.p > 1)
    snprintf(detector.signal, CHAR_BUF_LENGTH, 
      "Min=%g; Max=%g; Mean=%g;", detector.min, detector.max, detector.mean);
  else
    strcpy(detector.signal, "None");
  snprintf(detector.values, CHAR_BUF_LENGTH,
    "%g %g %g", detector.intensity, detector.error, detector.events);

  switch (detector.rank) {
    case 1:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g;",
      detector.centerX, detector.halfwidthX); break;
    case 2:
    case 3:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g; Y0=%g; dY=%g;",
      detector.centerX, detector.halfwidthX, detector.centerY, detector.halfwidthY);
      break;
    default: strcpy(detector.statistics, "None");
  }
  
  if (hasnan)
    printf("WARNING: Nan detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  if (hasinf)
    printf("WARNING: Inf detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  
  return(detector);
  
} /* mcdetector_statistics */

/*******************************************************************************
* mcdetector_import: build detector structure, merge non-lists from MPI
*                    compute basic stat, write "Detector:" line
* RETURN:            detector structure. Invalid data if detector.p1 == NULL
*                    Invalid detector sets m=0 and filename=""
*                    Simulation data  sets m=0 and filename=mcsiminfo_name
* This function is equivalent to the old 'mcdetector_out', returning a structure
*******************************************************************************/
MCDETECTOR mcdetector_import(
  char *format,
  char *component, char *title,
  long m, long n,  long p,
  char *xlabel, char *ylabel, char *zlabel,
  char *xvar, char *yvar, char *zvar,
  double x1, double x2, double y1, double y2, double z1, double z2,
  char *filename,
  double *p0, double *p1, double *p2,
  Coords position)
{
  time_t t;       /* for detector.date */
  long   date_l;  /* date as a long number */
  char   istransposed=0;
  char   c[CHAR_BUF_LENGTH]; /* temp var for signal label */

  MCDETECTOR detector;

  /* build MCDETECTOR structure ============================================= */
  /* make sure we do not have NULL for char fields */

  /* these also apply to simfile */
  strncpy (detector.filename,  filename ? filename : "",        CHAR_BUF_LENGTH);
  strncpy (detector.format,    format   ? format   : "McCode" , CHAR_BUF_LENGTH);
  /* add extension if missing */
  if (strlen(detector.filename) && !strchr(detector.filename, '.'))
  { /* add extension if not in file name already */
    strcat(detector.filename, ".dat");
  }
  strncpy (detector.component, component ? component : MCCODE_STRING " component", CHAR_BUF_LENGTH);

  snprintf(detector.instrument, CHAR_BUF_LENGTH, "%s (%s)", mcinstrument_name, mcinstrument_source);
  snprintf(detector.user, CHAR_BUF_LENGTH,      "%s on %s",
        getenv("USER") ? getenv("USER") : MCCODE_NAME,
        getenv("HOST") ? getenv("HOST") : "localhost");
  time(&t);         /* get current write time */
  date_l = (long)t; /* same but as a long */
  snprintf(detector.date, CHAR_BUF_LENGTH, "%s", ctime(&t));
  if (strlen(detector.date))   detector.date[strlen(detector.date)-1] = '\0'; /* remove last \n in date */
  detector.date_l = date_l;

  if (!mcget_run_num() || mcget_run_num() >= mcget_ncount())
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%llu", mcget_ncount()
#ifdef USE_MPI
*mpi_node_count
#endif
  );
  else
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%g/%g", (double)mcget_run_num(), (double)mcget_ncount());

  detector.p0         = p0;
  detector.p1         = p1;
  detector.p2         = p2;

  /* handle transposition (not for NeXus) */
  if (!strcasestr(detector.format, "NeXus")) {
    if (m<0 || n<0 || p<0)             istransposed = !istransposed;
    if (strcasestr(detector.format, "transpose")) istransposed = !istransposed;
    if (istransposed) { /* do the swap once for all */
      long i=m; m=n; n=i;
    }
  }

  m=abs(m); n=abs(n); p=abs(p); /* make sure dimensions are positive */
  detector.istransposed = istransposed;

  /* determine detector rank (dimensionality) */
  if (!m || !n || !p || !p1) detector.rank = 4; /* invalid: exit with m=0 filename="" */
  else if (m*n*p == 1)       detector.rank = 0; /* 0D */
  else if (n == 1 || m == 1) detector.rank = 1; /* 1D */
  else if (p == 1)           detector.rank = 2; /* 2D */
  else                       detector.rank = 3; /* 3D */

  /* from rank, set type */
  switch (detector.rank) {
    case 0:  strcpy(detector.type,  "array_0d"); m=n=p=1; break;
    case 1:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_1d(%ld)", m*n*p); m *= n*p; n=p=1; break;
    case 2:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_2d(%ld, %ld)", m, n*p); n *= p; p=1; break;
    case 3:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_3d(%ld, %ld, %ld)", m, n, p); break;
    default: m=0; strcpy(detector.type, ""); strcpy(detector.filename, "");/* invalid */
  }

  detector.m    = m;
  detector.n    = n;
  detector.p    = p;

  /* these only apply to detector files ===================================== */

  snprintf(detector.position, CHAR_BUF_LENGTH, "%g %g %g", position.x, position.y, position.z);
  /* may also store actual detector orientation in the future */

  strncpy(detector.title,      title && strlen(title) ? title : component,       CHAR_BUF_LENGTH);
  strncpy(detector.xlabel,     xlabel && strlen(xlabel) ? xlabel : "X", CHAR_BUF_LENGTH); /* axis labels */
  strncpy(detector.ylabel,     ylabel && strlen(ylabel) ? ylabel : "Y", CHAR_BUF_LENGTH);
  strncpy(detector.zlabel,     zlabel && strlen(zlabel) ? zlabel : "Z", CHAR_BUF_LENGTH);
  strncpy(detector.xvar,       xvar && strlen(xvar) ? xvar :       "x", CHAR_BUF_LENGTH); /* axis variables */
  strncpy(detector.yvar,       yvar && strlen(yvar) ? yvar :       detector.xvar, CHAR_BUF_LENGTH);
  strncpy(detector.zvar,       zvar && strlen(zvar) ? zvar :       detector.yvar, CHAR_BUF_LENGTH);

  /* set "variables" as e.g. "I I_err N" */
  strcpy(c, "I ");
  if (strlen(detector.zvar))      strncpy(c, detector.zvar,32);
  else if (strlen(detector.yvar)) strncpy(c, detector.yvar,32);
  else if (strlen(detector.xvar)) strncpy(c, detector.xvar,32);

  if (detector.rank == 1)
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s %s_err N", detector.xvar, c, c);
  else
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s_err N", c, c);

  /* limits */
  detector.xmin = x1;
  detector.xmax = x2;
  detector.ymin = y1;
  detector.ymax = y2;
  detector.zmin = z1;
  detector.zmax = z2;
  if (abs(detector.rank) == 1)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g", x1, x2);
  else if (detector.rank == 2)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g", x1, x2, y1, y2);
  else
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g %g %g", x1, x2, y1, y2, z1, z2);

  /* if MPI and nodes_nb > 1: reduce data sets when using MPI =============== */
#ifdef USE_MPI
  if (!strcasestr(detector.format,"list") && mpi_node_count > 1 && m) {
    /* we save additive data: reduce everything into mpi_node_root */
    if (p0) mc_MPI_Sum(p0, m*n*p);
    if (p1) mc_MPI_Sum(p1, m*n*p);
    if (p2) mc_MPI_Sum(p2, m*n*p);
    if (!p0) {  /* additive signal must be then divided by the number of nodes */
      int i;
      for (i=0; i<m*n*p; i++) {
        p1[i] /= mpi_node_count;
        if (p2) p2[i] /= mpi_node_count;
      }
    }
  }
#endif /* USE_MPI */

  /* compute statistics, Nsum, intensity, Error bars */
  detector = mcdetector_statistics(detector);

#ifdef USE_MPI
  /* slaves are done */
  if(mpi_node_rank != mpi_node_root) {
    return detector;
  }
#endif

  /* output "Detector:" line ================================================ */
  /* when this is a detector written by a component (not the SAVE from instrument),
     not an event lists */
  if (!m) return(detector);
  if (!strcasestr(detector.format,"list")) {
    if (!strcmp(detector.component, mcinstrument_name)) {
      if (strlen(detector.filename))  /* we name it from its filename, or from its title */
        strncpy(c, detector.filename, CHAR_BUF_LENGTH);
      else
        snprintf(c, CHAR_BUF_LENGTH, "%s", mcinstrument_name);
    } else
      strncpy(c, detector.component, CHAR_BUF_LENGTH);  /* usual detectors written by components */

    printf("Detector: %s_I=%g %s_ERR=%g %s_N=%g",
           c, detector.intensity,
           c, detector.error,
           c, detector.events);
    printf(" \"%s\"\n", strlen(detector.filename) ? detector.filename : detector.component);
  }
  

  return(detector);
} /* mcdetector_import */

/* end MCDETECTOR import section ============================================ */

















/* ========================================================================== */

/*                               ASCII output                                 */
/*     The SIM file is YAML based, the data files have '#' headers            */

/* ========================================================================== */


/*******************************************************************************
* mcinfo_out: output instrument tags/info (only in SIM)
* Used in: mcsiminfo_init (ascii), mcinfo(stdout)
*******************************************************************************/
static void mcinfo_out(char *pre, FILE *f)
{
  char Parameters[CHAR_BUF_LENGTH] = "";
  int  i;

  if (!f || mcdisable_output_files) return;

  /* create parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++)
  {
    char ThisParam[CHAR_BUF_LENGTH];
    if (strlen(mcinputtable[i].name) > CHAR_BUF_LENGTH) break;
    snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
            (*mcinputtypes[mcinputtable[i].type].parminfo)
                (mcinputtable[i].name));
    strcat(Parameters, ThisParam);
    if (strlen(Parameters) >= CHAR_BUF_LENGTH-64) break;
  }

  /* output data ============================================================ */
  if (f != stdout)
    fprintf(f, "%sFile: %s%c%s\n",    pre, mcdirname, MC_PATHSEP_C, mcsiminfo_name);
  else
    fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);

  fprintf(f, "%sSource: %s\n",   pre, mcinstrument_source);
  fprintf(f, "%sParameters: %s\n",    pre, Parameters);
  
  fprintf(f, "%sTrace_enabled: %s\n", pre, mctraceenabled ? "yes" : "no");
  fprintf(f, "%sDefault_main: %s\n",  pre, mcdefaultmain ?  "yes" : "no");
  fprintf(f, "%sEmbedded_runtime: %s\n", pre, 
#ifdef MC_EMBEDDED_RUNTIME
         "yes"
#else
         "no"
#endif
         );

  fflush(f);
} /* mcinfo_out */

/*******************************************************************************
* mcruninfo_out: output simulation tags/info (both in SIM and data files)
* Used in: mcsiminfo_init (ascii case), mcdetector_out_xD_ascii
*******************************************************************************/
static void mcruninfo_out(char *pre, FILE *f)
{
  int i;
  char Parameters[CHAR_BUF_LENGTH];

  if (!f || mcdisable_output_files) return;

  fprintf(f, "%sFormat: %s%s\n",      pre, 
    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME,
    mcformat && strcasestr(mcformat,"McCode") ? " with text headers" : "");
  fprintf(f, "%sURL: %s\n",         pre, "http://www.mccode.org");
  fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);
  fprintf(f, "%sInstrument: %s\n", pre, mcinstrument_source);
  fprintf(f, "%sNcount: %llu\n",        pre, mcget_ncount());
  fprintf(f, "%sTrace: %s\n",       pre, mcdotrace ? "yes" : "no");
  fprintf(f, "%sGravitation: %s\n", pre, mcgravitation ? "yes" : "no");
  snprintf(Parameters, CHAR_BUF_LENGTH, "%ld", mcseed);
  fprintf(f, "%sSeed: %s\n",        pre, Parameters);
  fprintf(f, "%sDirectory: %s\n",        pre, mcdirname ? mcdirname : ".");
#ifdef USE_MPI
  if (mpi_node_count > 1)
    fprintf(f, "%sNodes: %i\n",        pre, mpi_node_count);
#endif

  /* output parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++) {
      if (mcinputtable[i].par){
	/* Parameters with a default value */
	if(mcinputtable[i].val && strlen(mcinputtable[i].val)){
	  (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);
	  fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
        /* ... and those without */
	}else{
	  fprintf(f, "%sParam: %s=NULL\n", pre, mcinputtable[i].name);
	}
      } 
  }
} /* mcruninfo_out */

/*******************************************************************************
* mcsiminfo_out:    wrapper to fprintf(mcsiminfo_file)
*******************************************************************************/
void mcsiminfo_out(char *format, ...)
{
  va_list ap;

  if(mcsiminfo_file && !mcdisable_output_files)
  {
    va_start(ap, format);
    vfprintf(mcsiminfo_file, format, ap);
    va_end(ap);
  }
} /* mcsiminfo_out */


/*******************************************************************************
* mcdatainfo_out: output detector header
*   mcdatainfo_out(prefix, file_handle, detector) writes info to data file
*******************************************************************************/
static void
mcdatainfo_out(char *pre, FILE *f, MCDETECTOR detector)
{
  if (!f || !detector.m || mcdisable_output_files) return;
  
  /* output data ============================================================ */
  fprintf(f, "%sDate: %s (%li)\n",       pre, detector.date, detector.date_l);
  fprintf(f, "%stype: %s\n",       pre, detector.type);
  fprintf(f, "%sSource: %s\n",     pre, detector.instrument);
  fprintf(f, "%scomponent: %s\n",  pre, detector.component);
  fprintf(f, "%sposition: %s\n",   pre, detector.position);

  fprintf(f, "%stitle: %s\n",      pre, detector.title);
  fprintf(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
             "%sNcount: %s\n" : 
             "%sratio: %s\n",  pre, detector.ncount);

  if (strlen(detector.filename)) {
    fprintf(f, "%sfilename: %s\n", pre, detector.filename);
  }

  fprintf(f, "%sstatistics: %s\n", pre, detector.statistics);
  fprintf(f, "%ssignal: %s\n",     pre, detector.signal);
  fprintf(f, "%svalues: %s\n",     pre, detector.values);

  if (detector.rank >= 1)
  {
    fprintf(f, "%sxvar: %s\n",     pre, detector.xvar);
    fprintf(f, "%syvar: %s\n",     pre, detector.yvar);
    fprintf(f, "%sxlabel: %s\n",   pre, detector.xlabel);
    fprintf(f, "%sylabel: %s\n",   pre, detector.ylabel);
    if (detector.rank > 1) {
      fprintf(f, "%szvar: %s\n",   pre, detector.zvar);
      fprintf(f, "%szlabel: %s\n", pre, detector.zlabel);
    }
  }

  fprintf(f, 
    abs(detector.rank)==1 ?
             "%sxlimits: %s\n" : 
             "%sxylimits: %s\n", pre, detector.limits);
  fprintf(f, "%svariables: %s\n", pre, 
    strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
    
  fflush(f);

} /* mcdatainfo_out */

/* mcdetector_out_array_ascii: output a single array to a file
 *   m: columns
 *   n: rows
 *   p: array
 *   f: file handle (already opened)
 */
static void mcdetector_out_array_ascii(long m, long n, double *p, FILE *f, char istransposed)
{
  if(f)
  {
    int i,j;
    for(j = 0; j < n; j++)
    {
      for(i = 0; i < m; i++)
      {
          fprintf(f, "%.10g ", p[!istransposed ? i*n + j : j*m+i]);
      }
      fprintf(f,"\n");
    }
  }
} /* mcdetector_out_array_ascii */

/*******************************************************************************
* mcdetector_out_0D_ascii: called by mcdetector_out_0D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_0D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  /* Write data set information to simulation description file. */
  MPI_MASTER(
    mcsiminfo_out("\nbegin data\n"); // detector.component
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.component, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* write I I_err N */
      fprintf(outfile, "%g %g %g\n", 
        detector.intensity, detector.error, detector.events);
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
} /* mcdetector_out_0D_ascii */

/*******************************************************************************
* mcdetector_out_1D_ascii: called by mcdetector_out_1D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_1D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;

  MPI_MASTER(
    /* Write data set information to simulation description file. */
    mcsiminfo_out("\nbegin data\n"); // detector.filename
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* output the 1D array columns */
      mcdetector_out_array_ascii(detector.m, detector.n, detector.p1, outfile, detector.istransposed);
      
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
  
}  /* mcdetector_out_1D_ascii */

/*******************************************************************************
* mcdetector_out_2D_ascii: called by mcdetector_out_2D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_2D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  MPI_MASTER(
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write header only if file has just been created (not appending) */
      if (!exists) {
        /* Write data set information to simulation description file. */
        mcsiminfo_out("\nbegin data\n"); // detector.filename
        mcdatainfo_out("  ", mcsiminfo_file, detector);
        mcsiminfo_out("end data\n");
      
        mcruninfo_out( "# ", outfile);
        mcdatainfo_out("# ", outfile,   detector);
        fprintf(outfile, "# Data [%s/%s] %s:\n", detector.component, detector.filename, detector.zvar);
      }
      mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
        outfile, detector.istransposed);
      if (detector.p2) {
        fprintf(outfile, "# Errors [%s/%s] %s_err:\n", detector.component, detector.filename, detector.zvar);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p2, 
          outfile, detector.istransposed);
      }
      if (detector.p0) {
        fprintf(outfile, "# Events [%s/%s] N:\n", detector.component, detector.filename);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p0, 
          outfile, detector.istransposed);
      }
      fclose(outfile);
      
      if (!exists) {
        if (strcasestr(detector.format, "list"))
          printf("Events:   \"%s\"\n",  
            strlen(detector.filename) ? detector.filename : detector.component);
      }
    } /* if outfile */
  ); /* MPI_MASTER */
#ifdef USE_MPI
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    int node_i=0;
    /* loop along MPI nodes to write sequentially */
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      /* MPI: slaves wait for the master to write its block, then append theirs */
      MPI_Barrier(MPI_COMM_WORLD);
      if (node_i != mpi_node_root && node_i == mpi_node_rank) {
        if(strlen(detector.filename) && !mcdisable_output_files)	/* Don't write if filename is NULL */
          outfile = mcnew_file(detector.filename, "dat", &exists);
        if (!exists)
          fprintf(stderr, "Warning: [MPI node %i] file '%s' does not exist yet, "
                          "MASTER should have opened it before.\n",
            mpi_node_rank, detector.filename);
        if(outfile) {
          mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
            outfile, detector.istransposed);
          fclose(outfile);
        }
      }
    }
  } /* if strcasestr list */
#endif
  return(detector);
} /* mcdetector_out_2D_ascii */

/*******************************************************************************
* strcpy_valid: makes a valid string for variable names.
*   copy 'original' into 'valid', replacing invalid characters by '_'
*   char arrays must be pre-allocated
*******************************************************************************/
static char *strcpy_valid(char *valid, char *original)
{
  long i;
  int  n=32; /* max length of valid names */

  if (original == NULL || !strlen(original)) return(NULL);

  if (n > strlen(original)) n = strlen(original);
  else original += strlen(original)-n;
  strncpy(valid, original, n);

  for (i=0; i < n; i++)
  {
    if ( (valid[i] > 122)
      || (valid[i] < 32)
      || (strchr("!\"#$%&'()*+,-.:;<=>?@[\\]^`/ \n\r\t", valid[i]) != NULL) )
    {
      if (i) valid[i] = '_'; else valid[i] = 'm';
    }
  }
  valid[i] = '\0';

  return(valid);
} /* strcpy_valid */

/* end ascii output section ================================================= */







#ifdef USE_NEXUS

/* ========================================================================== */

/*                               NeXus output                                 */

/* ========================================================================== */

#define nxprintf(...)    nxstr('d', __VA_ARGS__)
#define nxprintattr(...) nxstr('a', __VA_ARGS__)

/*******************************************************************************
* nxstr: output a tag=value data set (char) in NeXus/current group
*   when 'format' is larger that 1024 chars it is used as value for the 'tag'
*   else the value is assembled with format and following arguments.
*   type='d' -> data set
*        'a' -> attribute for current data set
*******************************************************************************/
static int nxstr(char type, NXhandle *f, char *tag, char *format, ...)
{
  va_list ap;
  char value[CHAR_BUF_LENGTH];
  int  i;
  int  ret=NX_OK;
  
  if (!tag || !format || !strlen(tag) || !strlen(format)) return(NX_OK);
  
  /* assemble the value string */
  if (strlen(format) < CHAR_BUF_LENGTH) {
    va_start(ap, format);
    ret = vsnprintf(value, CHAR_BUF_LENGTH, format, ap);
    va_end(ap);
  
    i = strlen(value);
  } else {
    i = strlen(format);
  }

  if (type == 'd') {
    /* open/put/close data set */
    if (NXmakedata (f, tag, NX_CHAR, 1, &i) != NX_OK) return(NX_ERROR);
    NXopendata (f, tag);
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputdata  (f, value);
    else
      ret = NXputdata  (f, format);
    NXclosedata(f);
  } else {
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputattr  (f, tag, value, strlen(value), NX_CHAR);
    else
      ret = NXputattr  (f, tag, format, strlen(format), NX_CHAR);
  }
  
  return(ret);
  
} /* nxstr */

/*******************************************************************************
* mcinfo_readfile: read a full file into a string buffer which is allocated
*   Think to free the buffer after use.
* Used in: mcinfo_out_nexus (nexus)
*******************************************************************************/
char *mcinfo_readfile(char *filename)
{
  FILE *f = fopen(filename, "rb");
  if (!f) return(NULL);
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  rewind(f);
  char *string = malloc(fsize + 1);
  if (string) {
    int n = fread(string, fsize, 1, f);
    fclose(f);

    string[fsize] = 0;
  }
  return(string);
}

/*******************************************************************************
* mcinfo_out: output instrument/simulation groups in NeXus file
* Used in: mcsiminfo_init (nexus)
*******************************************************************************/
static void mcinfo_out_nexus(NXhandle f)
{
  FILE  *fid;     /* for intrument source code/C/IDF */
  char  *buffer=NULL;
  time_t t     =time(NULL); /* for date */
  char   entry0[CHAR_BUF_LENGTH];
  int    count=0;
  char   name[CHAR_BUF_LENGTH];
  char   class[CHAR_BUF_LENGTH];
  
  if (!f || mcdisable_output_files) return;
  
  /* write NeXus NXroot attributes */
  /* automatically added: file_name, HDF5_Version, file_time, NeXus_version */ 
  nxprintattr(f, "creator",   "%s generated with " MCCODE_STRING, mcinstrument_name);
  
  /* count the number of existing NXentry and create the next one */
  NXgetgroupinfo(f, &count, name, class);
  sprintf(entry0, "entry%i", count+1);

  /* create the main NXentry (mandatory in NeXus) */
  if (NXmakegroup(f, entry0, "NXentry") == NX_OK) 
  if (NXopengroup(f, entry0, "NXentry") == NX_OK) {
    
    nxprintf(nxhandle, "program_name", MCCODE_STRING);
    nxprintf(f, "start_time", ctime(&t));
    nxprintf(f, "title", "%s%s%s simulation generated by instrument %s", 
      mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name,
      mcinstrument_name);
    nxprintattr(f, "program_name", MCCODE_STRING);
    nxprintattr(f, "instrument",   mcinstrument_name);
    nxprintattr(f, "simulation",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);

    /* write NeXus instrument group */
    if (NXmakegroup(f, "instrument", "NXinstrument") == NX_OK)
    if (NXopengroup(f, "instrument", "NXinstrument") == NX_OK) {
      int   i;
      char *string=NULL;

      /* write NeXus parameters(types) data =================================== */
      string = (char*)malloc(CHAR_BUF_LENGTH);
      if (string) {
        strcpy(string, "");
        for(i = 0; i < mcnumipar; i++)
        {
          char ThisParam[CHAR_BUF_LENGTH];
          snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
                  (*mcinputtypes[mcinputtable[i].type].parminfo)
                      (mcinputtable[i].name));
          if (strlen(string) + strlen(ThisParam) < CHAR_BUF_LENGTH)
            strcat(string, ThisParam);
        }
        nxprintattr(f, "Parameters",    string);
        free(string);
      }
        
      nxprintattr(f, "name",          mcinstrument_name);
      nxprintf   (f, "name",          mcinstrument_name);
      nxprintattr(f, "Source",        mcinstrument_source);
      
      nxprintattr(f, "Trace_enabled", mctraceenabled ? "yes" : "no");
      nxprintattr(f, "Default_main",  mcdefaultmain ?  "yes" : "no");
      nxprintattr(f, "Embedded_runtime",  
  #ifdef MC_EMBEDDED_RUNTIME
           "yes"
  #else
           "no"
  #endif
           );
           
      /* add instrument source code when available */
      buffer = mcinfo_readfile(mcinstrument_source);
      if (buffer && strlen(buffer)) {
        long length=strlen(buffer);
        nxprintf (f, "description", buffer);
        NXopendata(f,"description");
        nxprintattr(f, "file_name", mcinstrument_source);
        nxprintattr(f, "file_size", "%li", length);
        nxprintattr(f, "MCCODE_STRING", MCCODE_STRING);
        NXclosedata(f);
        nxprintf (f,"instrument_source", "%s " MCCODE_NAME " " MCCODE_PARTICLE " Monte Carlo simulation", mcinstrument_name);
        free(buffer);
      } else
        nxprintf (f, "description", "File %s not found (instrument description %s is missing)", 
          mcinstrument_source, mcinstrument_name);
      
      /* add Mantid/IDF.xml when available */
      char *IDFfile=NULL;
      IDFfile = (char*)malloc(CHAR_BUF_LENGTH);
      sprintf(IDFfile,"%s%s",mcinstrument_source,".xml");
      buffer = mcinfo_readfile(IDFfile);
      if (buffer && strlen(buffer)) {
        NXmakegroup (nxhandle, "instrument_xml", "NXnote");
        NXopengroup (nxhandle, "instrument_xml", "NXnote");
        nxprintf(f, "data", buffer);
        nxprintf(f, "description", "IDF.xml file found with instrument %s", mcinstrument_source);
        nxprintf(f, "type", "text/xml");
        NXclosegroup(f); /* instrument_xml */
        free(buffer);
      }
      free(IDFfile);
      NXclosegroup(f); /* instrument */
    } /* NXinstrument */

    /* write NeXus simulation group */
    if (NXmakegroup(f, "simulation", "NXnote") == NX_OK)
    if (NXopengroup(f, "simulation", "NXnote") == NX_OK) {

      nxprintattr(f, "name",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);
      
      nxprintf   (f, "name",      "%s",     mcsiminfo_name);
      nxprintattr(f, "Format",    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME);
      nxprintattr(f, "URL",       "http://www.mccode.org");
      nxprintattr(f, "program",   MCCODE_STRING);
      nxprintattr(f, "Instrument",mcinstrument_source);
      nxprintattr(f, "Trace",     mcdotrace ?     "yes" : "no");
      nxprintattr(f, "Gravitation",mcgravitation ? "yes" : "no");
      nxprintattr(f, "Seed",      "%li", mcseed);
      nxprintattr(f, "Directory", mcdirname);
    #ifdef USE_MPI
      if (mpi_node_count > 1)
        nxprintf(f, "Nodes", "%i",        mpi_node_count);
    #endif
    
      /* output parameter string ================================================ */
      if (NXmakegroup(f, "Param", "NXparameters") == NX_OK)
      if (NXopengroup(f, "Param", "NXparameters") == NX_OK) {
        int i;
        char string[CHAR_BUF_LENGTH];
        for(i = 0; i < mcnumipar; i++) {
          if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
            if (mcinputtable[i].par == NULL)
              strncpy(string, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
            else
              (*mcinputtypes[mcinputtable[i].type].printer)(string, mcinputtable[i].par);

            nxprintf(f,  mcinputtable[i].name, "%s", string);
            nxprintattr(f, mcinputtable[i].name, string);
          }
        }
        NXclosegroup(f); /* Param */
      } /* NXparameters */
      
      NXclosegroup(f); /* simulation */
    } /* NXsimulation */
    
    /* create a group to hold all monitors */
    NXmakegroup(f, "data", "NXdetector");

    /* leave the NXentry opened (closed at exit) */
  } /* NXentry */
} /* mcinfo_out_nexus */

/*******************************************************************************
* mcdatainfo_out_nexus: output detector header
*   mcdatainfo_out_nexus(detector) create group and write info to NeXus data file
*   open data:NXdetector then filename:NXdata and write headers/attributes
*   requires: NXentry to be opened
*******************************************************************************/
static void
mcdatainfo_out_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  if (!f || !detector.m || mcdisable_output_files) return;
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* create and open the data group */
    /* this may fail when appending to list -> ignore/skip */
    NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
    
    if (NXmakegroup(f, data_name, "NXdata") == NX_OK)
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
    
      /* output metadata (as attributes) ======================================== */
      nxprintattr(f, "Date",       detector.date);
      nxprintattr(f, "type",       detector.type);
      nxprintattr(f, "Source",     detector.instrument);
      nxprintattr(f, "component",  detector.component);
      nxprintattr(f, "position",   detector.position);

      nxprintattr(f, "title",      detector.title);
      nxprintattr(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
                 "Ncount" : 
                 "ratio",  detector.ncount);

      if (strlen(detector.filename)) {
        nxprintattr(f, "filename", detector.filename);
      }

      nxprintattr(f, "statistics", detector.statistics);
      nxprintattr(f, "signal",     detector.signal);
      nxprintattr(f, "values",     detector.values);

      if (detector.rank >= 1)
      {
        nxprintattr(f, "xvar",     detector.xvar);
        nxprintattr(f, "yvar",     detector.yvar);
        nxprintattr(f, "xlabel",   detector.xlabel);
        nxprintattr(f, "ylabel",   detector.ylabel);
        if (detector.rank > 1) {
          nxprintattr(f, "zvar",   detector.zvar);
          nxprintattr(f, "zlabel", detector.zlabel);
        }
      }

      nxprintattr(f, abs(detector.rank)==1 ?
                 "xlimits" : 
                 "xylimits", detector.limits);
      nxprintattr(f, "variables", 
        strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
      nxprintf(f, "distance", detector.position);
      nxprintf(f, "acquisition_mode",
        strcasestr(detector.format, "list") ? "event" : "summed");
        
      NXclosegroup(f);
    } /* NXdata (filename) */
    NXMEnableErrorReporting();  /* re-enable NeXus error messages */
    NXclosegroup(f);
  } /* NXdetector (data) */
  
} /* mcdatainfo_out_nexus */

/*******************************************************************************
* mcdetector_out_axis_nexus: write detector axis into current NXdata
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_axis_nexus(NXhandle f, char *label, char *var, int rank, long length, double min, double max)
{
  if (!f || length <= 1 || mcdisable_output_files || max == min) return(NX_OK);
  else {
    double axis[length];
    char valid[32];
    int dim=(int)length;
    int i;
    int nprimary=1;
    /* create an axis from [min:max] */
    for(i = 0; i < length; i++)
      axis[i] = min+(max-min)*(i+0.5)/length;
    /* create the data set */
    strcpy_valid(valid, label);
    NXcompmakedata(f, valid, NX_FLOAT64, 1, &dim, NX_COMP_LZW, &dim);
    /* open it */
    if (NXopendata(f, valid) != NX_OK) {
      fprintf(stderr, "Warning: could not open axis rank %i '%s' (NeXus)\n",
        rank, valid);
      return(NX_ERROR);
    }
    /* put the axis and its attributes */
    NXputdata  (f, axis);
    nxprintattr(f, "long_name",  label);
    nxprintattr(f, "short_name", var);
    NXputattr  (f, "axis",       &rank,     1, NX_INT32);
    nxprintattr(f, "units",      var);
    NXputattr  (f, "primary",    &nprimary, 1, NX_INT32);
    NXclosedata(f);
    
    return(NX_OK);
  }
} /* mcdetector_out_axis_nexus */

/*******************************************************************************
* mcdetector_out_array_nexus: write detector array into current NXdata (1D,2D)
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_array_nexus(NXhandle f, char *part, double *data, MCDETECTOR detector)
{
  
  int dims[3]={detector.m,detector.n,detector.p};  /* number of elements to write */
  int signal=1;
  int exists=0;
  int current_dims[3]={0,0,0};
  int ret=NX_OK;
  
  if (!f || !data || !detector.m || mcdisable_output_files) return(NX_OK);
  
  /* when this is a list, we set 1st dimension to NX_UNLIMITED for creation */
  if (strcasestr(detector.format, "list")) dims[0] = NX_UNLIMITED;
  
  /* create the data set in NXdata group */
  NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
  /* NXcompmakedata fails with NX_UNLIMITED */
  if (strcasestr(detector.format, "list"))
    ret = NXmakedata(    f, part, NX_FLOAT64, detector.rank, dims);
  else
    ret = NXcompmakedata(f, part, NX_FLOAT64, detector.rank, dims, NX_COMP_LZW, dims);
  if (ret != NX_OK) {
    /* failed: data set already exists */
    int datatype=0;
    int rank=0;
    exists=1;
    /* inquire current size of data set (nb of events stored) */
    NXopendata(f, part);
    NXgetinfo(f, &rank, current_dims, &datatype);
    NXclosedata(f);
  }
  NXMEnableErrorReporting();  /* re-enable NeXus error messages */
  dims[0] = detector.m; /* restore actual dimension from data writing */
  
  /* open the data set */
  if (NXopendata(f, part) == NX_ERROR) {
    fprintf(stderr, "Warning: could not open DataSet %s '%s' (NeXus)\n",
      part, detector.title);
    return(NX_ERROR);
  }
  if (strcasestr(detector.format, "list")) {
    current_dims[1] = current_dims[2] = 0; /* set starting location for writing slab */
    NXputslab(f, data, current_dims, dims);
    if (!exists)
      printf("Events:   \"%s\"\n",  
        strlen(detector.filename) ? detector.filename : detector.component);
  } else {
    NXputdata (f, data);
  }
  
  if (strstr(part,"data") || strstr(part, "events")) {
    NXputattr(f, "signal", &signal, 1, NX_INT32);
    nxprintattr(f, "short_name", detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);
  }
  nxprintattr(f, "long_name", "%s '%s'", part, detector.title);
  NXclosedata(f);
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

/*******************************************************************************
* mcdetector_out_data_nexus: write detector axes+data into current NXdata
*   The data:NXdetector is opened, then filename:NXdata
*   requires: NXentry to be opened
*******************************************************************************/
int mcdetector_out_data_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  
  if (!f || !detector.m || mcdisable_output_files) return(NX_OK);
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* the NXdata group has been created in mcdatainfo_out_nexus */
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
  
      /* write axes, for histogram data sets, not for lists */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_axis_nexus(f, detector.xlabel, detector.xvar, 
          1, detector.m, detector.xmin, detector.xmax);
          
        mcdetector_out_axis_nexus(f, detector.ylabel, detector.yvar, 
          2, detector.n, detector.ymin, detector.ymax);
          
        mcdetector_out_axis_nexus(f, detector.zlabel, detector.zvar, 
          3, detector.p, detector.zmin, detector.zmax);

      } /* !list */
      
      /* write the actual data (appended if already exists) */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_array_nexus(f, "data", detector.p1, detector);
        mcdetector_out_array_nexus(f, "errors", detector.p2, detector);
        mcdetector_out_array_nexus(f, "ncount", detector.p0, detector);
      } else
        mcdetector_out_array_nexus(  f, "events", detector.p1, detector);
      
      NXclosegroup(f);
    } /* NXdata */
    NXclosegroup(f);
  } /* NXdetector */
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

#ifdef USE_MPI
/*******************************************************************************
* mcdetector_out_list_slaves: slaves send their list data to master which writes
*   requires: NXentry to be opened
* WARNING: this method has a flaw: it requires all nodes to flush the lists
*   the same number of times. In case one node is just below the buffer size
*   when finishing (e.g. monitor_nd), it may not trigger save but others may. 
*   Then the number of recv/send is not constant along nodes, and simulation stalls.  
*******************************************************************************/
MCDETECTOR mcdetector_out_list_slaves(MCDETECTOR detector)
{
  int     node_i=0;
  MPI_MASTER(
	     printf("\n** MPI master gathering slave node list data ** \n");
  );
  
  if (mpi_node_rank != mpi_node_root) {
    /* MPI slave: slaves send their data to master: 2 MPI_Send calls */
    /* m, n, p must be sent first, since all slaves do not have the same number of events */
    int mnp[3]={detector.m,detector.n,detector.p};

    if (mc_MPI_Send(mnp, 3, MPI_INT, mpi_node_root)!= MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send mnp list error (mcdetector_out_list_slaves)\n", mpi_node_rank);
    if (!detector.p1
     || mc_MPI_Send(detector.p1, mnp[0]*mnp[1]*mnp[2], MPI_DOUBLE, mpi_node_root) != MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send p1 list error: mnp=%i (mcdetector_out_list_slaves)\n", mpi_node_rank, abs(mnp[0]*mnp[1]*mnp[2]));
    /* slaves are done: sent mnp and p1 */
    return (detector);
  } /* end slaves */

  /* MPI master: receive data from slaves sequentially: 2 MPI_Recv calls */

  if (mpi_node_rank == mpi_node_root) {
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      double *this_p1=NULL;                               /* buffer to hold the list from slaves */
      int     mnp[3]={0,0,0};  /* size of this buffer */
      if (node_i != mpi_node_root) { /* get data from slaves */
	if (mc_MPI_Recv(mnp, 3, MPI_INT, node_i) != MPI_SUCCESS)
	  fprintf(stderr, "Warning: master from proc %i: "
		  "MPI_Recv mnp list error (mcdetector_write_data)\n", node_i);
	if (mnp[0]*mnp[1]*mnp[2]) {
	  this_p1 = (double *)calloc(mnp[0]*mnp[1]*mnp[2], sizeof(double));
	  if (!this_p1 || mc_MPI_Recv(this_p1, abs(mnp[0]*mnp[1]*mnp[2]), MPI_DOUBLE, node_i)!= MPI_SUCCESS)
	    fprintf(stderr, "Warning: master from proc %i: "
		    "MPI_Recv p1 list error: mnp=%i (mcdetector_write_data)\n", node_i, mnp[0]*mnp[1]*mnp[2]);
	  else {
	    printf(". MPI master writing data for slave node %i\n",node_i);
	    detector.p1 = this_p1;
	    detector.m  = mnp[0]; detector.n  = mnp[1]; detector.p  = mnp[2];
	    
	    mcdetector_out_data_nexus(nxhandle, detector);
	  }
	}
      } /* if not master */
    } /* for */
  MPI_MASTER(
	     printf("\n** Done ** \n");
  );   
  }
}
#endif

MCDETECTOR mcdetector_out_0D_nexus(MCDETECTOR detector)
{
  /* Write data set information to NeXus file. */
  MPI_MASTER(
    mcdatainfo_out_nexus(nxhandle, detector);
  );
  
  return(detector);
} /* mcdetector_out_0D_ascii */

MCDETECTOR mcdetector_out_1D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  return(detector);
} /* mcdetector_out_1D_ascii */

MCDETECTOR mcdetector_out_2D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  
#ifdef USE_MPI // and USE_NEXUS
  /* NeXus: slave nodes have master write their lists */
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    mcdetector_out_list_slaves(detector);
  }
#endif /* USE_MPI */

  return(detector);
} /* mcdetector_out_2D_nexus */

#endif /* USE_NEXUS*/








/* ========================================================================== */

/*                            Main input functions                            */
/*            DETECTOR_OUT_xD function calls -> ascii or NeXus                */

/* ========================================================================== */

/*******************************************************************************
* mcsiminfo_init:   open SIM and write header
*******************************************************************************/
FILE *mcsiminfo_init(FILE *f)
{
  int exists=0;
  int index;
  
  /* check format */      
  if (!mcformat || !strlen(mcformat) 
   || !strcasecmp(mcformat, "MCSTAS") || !strcasecmp(mcformat, "MCXTRACE") 
   || !strcasecmp(mcformat, "PGPLOT") || !strcasecmp(mcformat, "GNUPLOT") || !strcasecmp(mcformat, "MCCODE")
   || !strcasecmp(mcformat, "MATLAB")) {
    mcformat="McCode";
#ifdef USE_NEXUS
  } else if (strcasestr(mcformat, "NeXus")) {
    /* Do nothing */
#endif
  } else {
    fprintf(stderr,
	    "Warning: You have requested the output format %s which is unsupported by this binary. Resetting to standard %s format.\n",mcformat ,"McCode");
    mcformat="McCode";
  }
  
  /* open the SIM file if not defined yet */
  if (mcsiminfo_file || mcdisable_output_files) 
    return (mcsiminfo_file);
    
#ifdef USE_NEXUS
  /* only master writes NeXus header: calls NXopen(nxhandle) */
  if (mcformat && strcasestr(mcformat, "NeXus")) {
	  MPI_MASTER(
	  mcsiminfo_file = mcnew_file(mcsiminfo_name, "h5", &exists);
    if(!mcsiminfo_file)
      fprintf(stderr,
	      "Warning: could not open simulation description file '%s'\n",
	      mcsiminfo_name);
	  else
	    mcinfo_out_nexus(nxhandle);
	  );
    return(mcsiminfo_file); /* points to nxhandle */
  }
#endif
  
  /* write main description file (only MASTER) */
  MPI_MASTER(

  mcsiminfo_file = mcnew_file(mcsiminfo_name, "sim", &exists);
  if(!mcsiminfo_file)
    fprintf(stderr,
	    "Warning: could not open simulation description file '%s'\n",
	    mcsiminfo_name);
  else
  {
    /* write SIM header */
    time_t t=time(NULL);
    mcsiminfo_out("%s simulation description file for %s.\n", 
      MCCODE_NAME, mcinstrument_name);
    mcsiminfo_out("Date:    %s", ctime(&t)); /* includes \n */
    mcsiminfo_out("Program: %s\n\n", MCCODE_STRING);
    
    mcsiminfo_out("begin instrument: %s\n", mcinstrument_name);
    mcinfo_out(   "  ", mcsiminfo_file);
    mcsiminfo_out("end instrument\n");

    mcsiminfo_out("\nbegin simulation: %s\n", mcdirname);
    mcruninfo_out("  ", mcsiminfo_file);
    mcsiminfo_out("end simulation\n");

  }
  return (mcsiminfo_file);
  
  ); /* MPI_MASTER */
  
} /* mcsiminfo_init */

/*******************************************************************************
*   mcsiminfo_close:  close SIM
*******************************************************************************/
void mcsiminfo_close()
{
  MPI_MASTER(
  if(mcsiminfo_file && !mcdisable_output_files) {
#ifdef USE_NEXUS
    if (mcformat && strcasestr(mcformat, "NeXus")) {
      time_t t=time(NULL);
      nxprintf(nxhandle, "end_time", ctime(&t));
      nxprintf(nxhandle, "duration", "%li", (long)t-mcstartdate);
      NXclosegroup(nxhandle); /* NXentry */
      NXclose(&nxhandle);
    } else
#endif
      fclose(mcsiminfo_file);
    );
    mcsiminfo_file = NULL;
  }
} /* mcsiminfo_close */

/*******************************************************************************
* mcdetector_out_0D: wrapper for 0D (single value).
*   Output single detector/monitor data (p0, p1, p2).
*   Title is t, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2,
                         char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " data"),
    1, 1, 1,
    "I", "", "",
    "I", "", "",
    0, 0, 0, 0, 0, 0, "",
    &p0, &p1, &p2, posa); /* write Detector: line */

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_0D_nexus(detector));
  else
#endif
    return(mcdetector_out_0D_ascii(detector));
    
} /* mcdetector_out_0D */



/*******************************************************************************
* mcdetector_out_1D: wrapper for 1D.
*   Output 1d detector data (p0, p1, p2) for n bins linearly
*   distributed across the range x1..x2 (x1 is lower limit of first
*   bin, x2 is upper limit of last bin). Title is t, axis labels are xl
*   and yl. File name is f, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
        char *xvar, double x1, double x2,
        long n,
        double *p0, double *p1, double *p2, char *f,
        char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " 1D data"),
    n, 1, 1,
    xl, yl, (n > 1 ? "Signal per bin" : " Signal"),
    xvar, "(I,I_err)", "I",
    x1, x2, 0, 0, 0, 0, f,
    p0, p1, p2, posa); /* write Detector: line */
  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_1D_nexus(detector));
  else
#endif
    return(mcdetector_out_1D_ascii(detector));
  
} /* mcdetector_out_1D */

/*******************************************************************************
* mcdetector_out_2D: wrapper for 2D.
*   special case for list: master creates file first, then slaves append their blocks without header
*******************************************************************************/
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2,
                  long m, long n,
                  double *p0, double *p1, double *p2, char *f,
                  char *c, Coords posa)
{
  char xvar[CHAR_BUF_LENGTH];
  char yvar[CHAR_BUF_LENGTH];
  
  /* create short axes labels */
  if (xl && strlen(xl)) { strncpy(xvar, xl, CHAR_BUF_LENGTH); xvar[2]='\0'; }
  else strcpy(xvar, "x");
  if (yl && strlen(yl)) { strncpy(yvar, yl, CHAR_BUF_LENGTH); yvar[2]='\0'; }
  else strcpy(yvar, "y");

  MCDETECTOR detector;

  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  if (abs(m) == 1) {/* n>1 on Y, m==1 on X: 1D, no X axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      n, 1, 1,
      yl, "", "Signal per bin",
      yvar, "(I,Ierr)", "I",
      y1, y2, x1, x2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  } else if (abs(n)==1) {/* m>1 on X, n==1 on Y: 1D, no Y axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      m, 1, 1,
      xl, "", "Signal per bin",
      xvar, "(I,Ierr)", "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }else {
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 2D data"),
      m, n, 1,
      xl, yl, "Signal per bin",
      xvar, yvar, "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }

  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_2D_nexus(detector));
  else
#endif
    return(mcdetector_out_2D_ascii(detector));
  
} /* mcdetector_out_2D */

/*******************************************************************************
* mcdetector_out_list: wrapper for list output (calls out_2D with mcformat+"list").
*   m=number of events, n=size of each event
*******************************************************************************/
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa)
{
  char       format_new[CHAR_BUF_LENGTH];
  char      *format_org;
  MCDETECTOR detector;
  
  format_org = mcformat;
  strcpy(format_new, mcformat);
  strcat(format_new, " list");
  mcformat = format_new;

  detector = mcdetector_out_2D(t, xl, yl,
                  1,abs(m),1,abs(n),
                  m,n,
                  NULL, p1, NULL, f,
                  c, posa);
  
  mcformat = format_org;
  return(detector);
}

/*******************************************************************************
 * mcuse_dir: set data/sim storage directory and create it,
 * or exit with error if exists
 ******************************************************************************/
static void
mcuse_dir(char *dir)
{
  if (!dir || !strlen(dir)) return;
#ifdef MC_PORTABLE
  fprintf(stderr, "Error: "
          "Directory output cannot be used with portable simulation (mcuse_dir)\n");
  exit(1);
#else  /* !MC_PORTABLE */
  /* handle file://directory URL type */
  if (strncmp(dir, "file://", strlen("file://")))
    mcdirname = dir;
  else
    mcdirname = dir+strlen("file://");
  
  
  
  MPI_MASTER(
    if(mkdir(mcdirname, 0777)) {
#ifndef DANSE
      fprintf(stderr, "Error: unable to create directory '%s' (mcuse_dir)\n", dir);
      fprintf(stderr, "(Maybe the directory already exists?)\n");
#endif
#ifdef USE_MPI
    MPI_Abort(MPI_COMM_WORLD, -1);
#endif
    exit(-1);
    }
  ); /* MPI_MASTER */
  
  /* remove trailing PATHSEP (if any) */
  while (strlen(mcdirname) && mcdirname[strlen(mcdirname) - 1] == MC_PATHSEP_C)
    mcdirname[strlen(mcdirname) - 1]='\0';
#endif /* !MC_PORTABLE */
} /* mcuse_dir */

/*******************************************************************************
* mcinfo: display instrument simulation info to stdout and exit
*******************************************************************************/
static void
mcinfo(void)
{
  fprintf(stdout, "begin instrument: %s\n", mcinstrument_name);
  mcinfo_out("  ", stdout);
  fprintf(stdout, "end instrument\n");
  fprintf(stdout, "begin simulation: %s\n", mcdirname ? mcdirname : ".");
  mcruninfo_out("  ", stdout);
  fprintf(stdout, "end simulation\n");
  exit(0); /* includes MPI_Finalize in MPI mode */
} /* mcinfo */

#endif /* ndef MCCODE_R_IO_C */

/* end of the I/O section =================================================== */







/*******************************************************************************
* mcset_ncount: set total number of rays to generate
*******************************************************************************/
void mcset_ncount(unsigned long long int count)
{
  mcncount = count;
}

/* mcget_ncount: get total number of rays to generate */
unsigned long long int mcget_ncount(void)
{
  return mcncount;
}

/* mcget_run_num: get curent number of rays in TRACE */
unsigned long long int mcget_run_num(void)
{
  return mcrun_num;
}

/* mcsetn_arg: get ncount from a string argument */
static void
mcsetn_arg(char *arg)
{
  mcset_ncount((long long int) strtod(arg, NULL));
}

/* mcsetseed: set the random generator seed from a string argument */
static void
mcsetseed(char *arg)
{
  mcseed = atol(arg);
  if(mcseed) {
    srandom(mcseed);
  } else {
    fprintf(stderr, "Error: seed must not be zero (mcsetseed)\n");
    exit(1);
  }
}

/* Following part is only embedded when not redundent with mccode-r.h ========= */

#ifndef MCCODE_H

/* SECTION: MCDISPLAY support. =============================================== */

/*******************************************************************************
* Just output MCDISPLAY keywords to be caught by an external plotter client.
*******************************************************************************/

void mcdis_magnify(char *what){
  // Do nothing here, better use interactive zoom from the tools
}

void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2){
  printf("MCDISPLAY: multiline(2,%g,%g,%g,%g,%g,%g)\n",
         x1,y1,z1,x2,y2,z2);
}

void mcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n){
  int i;
  const double dx = (x2-x1)/(2*n+1);
  const double dy = (y2-y1)/(2*n+1);
  const double dz = (z2-z1)/(2*n+1);

  for(i = 0; i < n+1; i++)
    mcdis_line(x1 + 2*i*dx,     y1 + 2*i*dy,     z1 + 2*i*dz,
	       x1 + (2*i+1)*dx, y1 + (2*i+1)*dy, z1 + (2*i+1)*dz);
}

void mcdis_multiline(int count, ...){
  va_list ap;
  double x,y,z;

  printf("MCDISPLAY: multiline(%d", count);
  va_start(ap, count);
  while(count--)
    {
    x = va_arg(ap, double);
    y = va_arg(ap, double);
    z = va_arg(ap, double);
    printf(",%g,%g,%g", x, y, z);
    }
  va_end(ap);
  printf(")\n");
}

void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height){
  /* draws a rectangle in the plane           */
  /* x is ALWAYS width and y is ALWAYS height */
  if (strcmp("xy", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y - height/2, z,
		    x + width/2, y - height/2, z,
		    x + width/2, y + height/2, z,
		    x - width/2, y + height/2, z,
		    x - width/2, y - height/2, z);
  } else if (strcmp("xz", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y, z - height/2,
		    x + width/2, y, z - height/2,
		    x + width/2, y, z + height/2,
		    x - width/2, y, z + height/2,
		    x - width/2, y, z - height/2);
  } else if (strcmp("yz", plane)==0) {
    mcdis_multiline(5,
		    x, y - height/2, z - width/2,
		    x, y - height/2, z + width/2,
		    x, y + height/2, z + width/2,
		    x, y + height/2, z - width/2,
		    x, y - height/2, z - width/2);
  } else {

    fprintf(stderr, "Error: Definition of plane %s unknown\n", plane);
    exit(1);
  }
}

/*  draws a box with center at (x, y, z) and
    width (deltax), height (deltay), length (deltaz) */
void mcdis_box(double x, double y, double z,
	       double width, double height, double length){

  mcdis_rectangle("xy", x, y, z-length/2, width, height);
  mcdis_rectangle("xy", x, y, z+length/2, width, height);
  mcdis_line(x-width/2, y-height/2, z-length/2,
	     x-width/2, y-height/2, z+length/2);
  mcdis_line(x-width/2, y+height/2, z-length/2,
	     x-width/2, y+height/2, z+length/2);
  mcdis_line(x+width/2, y-height/2, z-length/2,
	     x+width/2, y-height/2, z+length/2);
  mcdis_line(x+width/2, y+height/2, z-length/2,
	     x+width/2, y+height/2, z+length/2);
}

void mcdis_circle(char *plane, double x, double y, double z, double r){
  printf("MCDISPLAY: circle('%s',%g,%g,%g,%g)\n", plane, x, y, z, r);
}

/* Draws a circle with center (x,y,z), radius (r), and in the plane
 * with normal (nx,ny,nz)*/
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz){
    int i;
    if(nx==0 && ny && nz==0){
        for (i=0;i<24; i++){
            mcdis_line(x+r*sin(i*2*M_PI/24),y,z+r*cos(i*2*M_PI/24),
                    x+r*sin((i+1)*2*M_PI/24),y,z+r*cos((i+1)*2*M_PI/24));
        }
    }else{
        double mx,my,mz;
        /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
        /*draw circle*/
        for (i=0;i<24; i++){
            double ux,uy,uz;
            double wx,wy,wz;
            rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
            rotate(wx,wy,wz, mx,my,mz, (i+1)*2*M_PI/24, nx,ny,nz);
            mcdis_line(x+ux*r,y+uy*r,z+uz*r,
                    x+wx*r,y+wy*r,z+wz*r);
        }
    }
}

/* Draws a cylinder with center at (x,y,z) with extent (r,height).
 * The cylinder axis is along the vector nx,ny,nz.
 * N determines how many vertical lines are drawn.*/
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz){
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    NORM(nx,ny,nz);
    double h_2=height/2.0;
    mcdis_Circle(x+nx*h_2,y+ny*h_2,z+nz*h_2,r,nx,ny,nz);
    mcdis_Circle(x-nx*h_2,y-ny*h_2,z-nz*h_2,r,nx,ny,nz);

    double mx,my,mz;
    /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
    if(nx==0 && ny && nz==0){
        mx=my=0;mz=1;
    }else{
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
    }
    /*draw circle*/
    for (i=0; i<24; i++){
        double ux,uy,uz;
        rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
        mcdis_line(x+nx*h_2+ux*r, y+ny*h_2+uy*r, z+nz*h_2+uz*r,
                 x-nx*h_2+ux*r, y-ny*h_2+uy*r, z-nz*h_2+uz*r);
    }
}

/* draws a sphere with center at (x,y,z) with extent (r)
 * The sphere is drawn using N longitudes and N latitudes.*/
void mcdis_sphere(double x, double y, double z, double r, int N){
    double nx,ny,nz;
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    nx=0;ny=0;nz=1;
    mcdis_Circle(x,y,z,r,nx,ny,nz);
    for (i=1;i<N;i++){
        rotate(nx,ny,nz, nx,ny,nz, M_PI/N, 0,1,0);
        mcdis_Circle(x,y,z,r,nx,ny,nz);
    }
    /*lastly draw a great circle perpendicular to all N circles*/
    //mcdis_Circle(x,y,z,radius,1,0,0);

    for (i=1;i<=N;i++){
        double yy=-r+ 2*r*((double)i/(N+1));
        mcdis_Circle(x,y+yy ,z,  sqrt(r*r-yy*yy) ,0,1,0);
    }
}

/* SECTION: coordinates handling ============================================ */

/*******************************************************************************
* Since we use a lot of geometric calculations using Cartesian coordinates,
* we collect some useful routines here. However, it is also permissible to
* work directly on the underlying struct coords whenever that is most
* convenient (that is, the type Coords is not abstract).
*
* Coordinates are also used to store rotation angles around x/y/z axis.
*
* Since coordinates are used much like a basic type (such as double), the
* structure itself is passed and returned, rather than a pointer.
*
* At compile-time, the values of the coordinates may be unknown (for example
* a motor position). Hence coordinates are general expressions and not simple
* numbers. For this we used the type Coords_exp which has three CExp
* fields. For runtime (or calculations possible at compile time), we use
* Coords which contains three double fields.
*******************************************************************************/

/* coords_set: Assign coordinates. */
Coords
coords_set(MCNUM x, MCNUM y, MCNUM z)
{
  Coords a;

  a.x = x;
  a.y = y;
  a.z = z;
  return a;
}

/* coords_get: get coordinates. Required when 'x','y','z' are #defined as ray pars */
Coords
coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z)
{
  *x = a.x;
  *y = a.y;
  *z = a.z;
  return a;
}

/* coords_add: Add two coordinates. */
Coords
coords_add(Coords a, Coords b)
{
  Coords c;

  c.x = a.x + b.x;
  c.y = a.y + b.y;
  c.z = a.z + b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_sub: Subtract two coordinates. */
Coords
coords_sub(Coords a, Coords b)
{
  Coords c;

  c.x = a.x - b.x;
  c.y = a.y - b.y;
  c.z = a.z - b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_neg: Negate coordinates. */
Coords
coords_neg(Coords a)
{
  Coords b;

  b.x = -a.x;
  b.y = -a.y;
  b.z = -a.z;
  return b;
}

/* coords_scale: Scale a vector. */
Coords coords_scale(Coords b, double scale) {
  Coords a;

  a.x = b.x*scale;
  a.y = b.y*scale;
  a.z = b.z*scale;
  return a;
}

/* coords_sp: Scalar product: a . b */
double coords_sp(Coords a, Coords b) {
  double value;

  value = a.x*b.x + a.y*b.y + a.z*b.z;
  return value;
}

/* coords_xp: Cross product: a = b x c. */
Coords coords_xp(Coords b, Coords c) {
  Coords a;

  a.x = b.y*c.z - c.y*b.z;
  a.y = b.z*c.x - c.z*b.x;
  a.z = b.x*c.y - c.x*b.y;
  return a;
}

/* coords_len: Gives length of coords set. */
double coords_len(Coords a) {
  return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

/* coords_mirror: Mirror a in plane (through the origin) defined by normal n*/
Coords coords_mirror(Coords a, Coords n) {
  double t = scalar_prod(n.x, n.y, n.z, n.x, n.y, n.z);
  Coords b;
  if (t!=1) {
    t = sqrt(t);
    n.x /= t;
    n.y /= t;
    n.z /= t;
  }
  t=scalar_prod(a.x, a.y, a.z, n.x, n.y, n.z);
  b.x = a.x-2*t*n.x;
  b.y = a.y-2*t*n.y;
  b.z = a.z-2*t*n.z;
  return b;
}

/* coords_print: Print out vector values. */
void coords_print(Coords a) {

  fprintf(stdout, "(%f, %f, %f)\n", a.x, a.y, a.z);
  return;
}

mcstatic inline void coords_norm(Coords* c) {
	double temp = coords_sp(*c,*c);

	// Skip if we will end dividing by zero
	if (temp == 0) return;

	temp = sqrt(temp);

	c->x /= temp;
	c->y /= temp;
	c->z /= temp;
}

/*******************************************************************************
* The Rotation type implements a rotation transformation of a coordinate
* system in the form of a double[3][3] matrix.
*
* Contrary to the Coords type in coords.c, rotations are passed by
* reference. Functions that yield new rotations do so by writing to an
* explicit result parameter; rotations are not returned from functions. The
* reason for this is that arrays cannot by returned from functions (though
* structures can; thus an alternative would have been to wrap the
* double[3][3] array up in a struct). Such are the ways of C programming.
*
* A rotation represents the tranformation of the coordinates of a vector when
* changing between coordinate systems that are rotated with respect to each
* other. For example, suppose that coordinate system Q is rotated 45 degrees
* around the Z axis with respect to coordinate system P. Let T be the
* rotation transformation representing a 45 degree rotation around Z. Then to
* get the coordinates of a vector r in system Q, apply T to the coordinates
* of r in P. If r=(1,0,0) in P, it will be (sqrt(1/2),-sqrt(1/2),0) in
* Q. Thus we should be careful when interpreting the sign of rotation angles:
* they represent the rotation of the coordinate systems, not of the
* coordinates (which has opposite sign).
*******************************************************************************/

/*******************************************************************************
* rot_set_rotation: Get transformation for rotation first phx around x axis,
* then phy around y, then phz around z.
*******************************************************************************/
void
rot_set_rotation(Rotation t, double phx, double phy, double phz)
{
  if ((phx == 0) && (phy == 0) && (phz == 0)) {
    t[0][0] = 1.0;
    t[0][1] = 0.0;
    t[0][2] = 0.0;
    t[1][0] = 0.0;
    t[1][1] = 1.0;
    t[1][2] = 0.0;
    t[2][0] = 0.0;
    t[2][1] = 0.0;
    t[2][2] = 1.0;
  } else {
    double cx = cos(phx);
    double sx = sin(phx);
    double cy = cos(phy);
    double sy = sin(phy);
    double cz = cos(phz);
    double sz = sin(phz);

    t[0][0] = cy*cz;
    t[0][1] = sx*sy*cz + cx*sz;
    t[0][2] = sx*sz - cx*sy*cz;
    t[1][0] = -cy*sz;
    t[1][1] = cx*cz - sx*sy*sz;
    t[1][2] = sx*cz + cx*sy*sz;
    t[2][0] = sy;
    t[2][1] = -sx*cy;
    t[2][2] = cx*cy;
  }
}

/*******************************************************************************
* rot_test_identity: Test if rotation is identity
*******************************************************************************/
int
rot_test_identity(Rotation t)
{
  return (t[0][0] + t[1][1] + t[2][2] == 3);
}

/*******************************************************************************
* rot_mul: Matrix multiplication of transformations (this corresponds to
* combining transformations). After rot_mul(T1, T2, T3), doing T3 is
* equal to doing first T2, then T1.
* Note that T3 must not alias (use the same array as) T1 or T2.
*******************************************************************************/
void
rot_mul(Rotation t1, Rotation t2, Rotation t3)
{
  if (rot_test_identity(t1)) {
    rot_copy(t3, t2);
  } else if (rot_test_identity(t2)) {
    rot_copy(t3, t1);
  } else {
    int i,j;
    for(i = 0; i < 3; i++)
      for(j = 0; j < 3; j++)
	t3[i][j] = t1[i][0]*t2[0][j] + t1[i][1]*t2[1][j] + t1[i][2]*t2[2][j];
  }
}

/*******************************************************************************
* rot_copy: Copy a rotation transformation (arrays cannot be assigned in C).
*******************************************************************************/
void
rot_copy(Rotation dest, Rotation src)
{
  int i,j;
  for(i = 0; i < 3; i++)
    for(j = 0; j < 3; j++)
      dest[i][j] = src[i][j];
}

/*******************************************************************************
* rot_transpose: Matrix transposition, which is inversion for Rotation matrices
*******************************************************************************/
void
rot_transpose(Rotation src, Rotation dst)
{
  dst[0][0] = src[0][0];
  dst[0][1] = src[1][0];
  dst[0][2] = src[2][0];
  dst[1][0] = src[0][1];
  dst[1][1] = src[1][1];
  dst[1][2] = src[2][1];
  dst[2][0] = src[0][2];
  dst[2][1] = src[1][2];
  dst[2][2] = src[2][2];
}

/*******************************************************************************
* rot_apply: returns t*a
*******************************************************************************/
Coords
rot_apply(Rotation t, Coords a)
{
  Coords b;
  if (rot_test_identity(t)) {
    return a;
  } else {
    b.x = t[0][0]*a.x + t[0][1]*a.y + t[0][2]*a.z;
    b.y = t[1][0]*a.x + t[1][1]*a.y + t[1][2]*a.z;
    b.z = t[2][0]*a.x + t[2][1]*a.y + t[2][2]*a.z;
    return b;
  }
}

/**
 * Pretty-printing of rotation matrices.
 */
void rot_print(Rotation rot) {
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[0][0], rot[0][1], rot[0][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[1][0], rot[1][1], rot[1][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n\n",
			rot[2][0], rot[2][1], rot[2][2]);
}

/**
 * Vector product: used by vec_prod (mccode-r.h). Use coords_xp for Coords.
 */
mcstatic inline void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
    *x = (y1)*(z2) - (y2)*(z1);
    *y = (z1)*(x2) - (z2)*(x1);
    *z = (x1)*(y2) - (x2)*(y1);
}

/**
 * Scalar product: use coords_sp for Coords.
 */
mcstatic inline double scalar_prod(
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
	return ((x1 * x2) + (y1 * y2) + (z1 * z2));
}

/*******************************************************************************
* mccoordschange: applies rotation to (x y z) and (vx vy vz) and Spin (sx,sy,sz)
*******************************************************************************/
void
mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *x;
  b.y = *y;
  b.z = *z;
  c = rot_apply(t, b);
  b = coords_add(c, a);
  *x = b.x;
  *y = b.y;
  *z = b.z;

  if ( (vz && vy  && vx) && (*vz != 0.0 || *vx != 0.0 || *vy != 0.0) ) mccoordschange_polarisation(t, vx, vy, vz);

  if ( (sz && sy  && sx) && (*sz != 0.0 || *sx != 0.0 || *sy != 0.0) ) mccoordschange_polarisation(t, sx, sy, sz);

}

/*******************************************************************************
* mccoordschange_polarisation: applies rotation to vector (sx sy sz)
*******************************************************************************/
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *sx;
  b.y = *sy;
  b.z = *sz;
  c = rot_apply(t, b);
  *sx = c.x;
  *sy = c.y;
  *sz = c.z;
}

/* SECTION: vector math  ==================================================== */

/* normal_vec_func: Compute normal vector to (x,y,z). */
mcstatic inline void normal_vec_func(double *nx, double *ny, double *nz,
                double x, double y, double z)
{
  double ax = fabs(x);
  double ay = fabs(y);
  double az = fabs(z);
  double l;
  if(x == 0 && y == 0 && z == 0)
  {
    *nx = 0;
    *ny = 0;
    *nz = 0;
    return;
  }
  if(ax < ay)
  {
    if(ax < az)
    {                           /* Use X axis */
      l = sqrt(z*z + y*y);
      *nx = 0;
      *ny = z/l;
      *nz = -y/l;
      return;
    }
  }
  else
  {
    if(ay < az)
    {                           /* Use Y axis */
      l = sqrt(z*z + x*x);
      *nx = z/l;
      *ny = 0;
      *nz = -x/l;
      return;
    }
  }
  /* Use Z axis */
  l = sqrt(y*y + x*x);
  *nx = y/l;
  *ny = -x/l;
  *nz = 0;
} /* normal_vec */

/*******************************************************************************
 * solve_2nd_order: second order equation solve: A*t^2 + B*t + C = 0
 * solve_2nd_order(&t1, NULL, A,B,C)
 *   returns 0 if no solution was found, or set 't1' to the smallest positive
 *   solution.
 * solve_2nd_order(&t1, &t2, A,B,C)
 *   same as with &t2=NULL, but also returns the second solution.
 * EXAMPLE usage for intersection of a trajectory with a plane in gravitation
 * field (gx,gy,gz):
 * The neutron starts at point r=(x,y,z) with velocityv=(vx vy vz). The plane
 * has a normal vector n=(nx,ny,nz) and contains the point W=(wx,wy,wz).
 * The problem consists in solving the 2nd order equation:
 *      1/2.n.g.t^2 + n.v.t + n.(r-W) = 0
 * so that A = 0.5 n.g; B = n.v; C = n.(r-W);
 * Without acceleration, t=-n.(r-W)/n.v
 ******************************************************************************/
int solve_2nd_order(double *t1, double *t2,
                  double A,  double B,  double C)
{
  int ret=0;

  if (!t1) return 0;
  *t1 = 0;
  if (t2) *t2=0;

  if (fabs(A) < 1E-10) /* approximate to linear equation: A ~ 0 */
  {
    if (B) {  *t1 = -C/B; ret=1; if (t2) *t2=*t1; }
    /* else no intersection: A=B=0 ret=0 */
  }
  else
  {
    double D;
    D = B*B - 4*A*C;
    if (D >= 0) /* Delta > 0: two solutions */
    {
      double sD, dt1, dt2;
      sD = sqrt(D);
      dt1 = (-B + sD)/2/A;
      dt2 = (-B - sD)/2/A;
      /* we identify very small values with zero */
      if (fabs(dt1) < 1e-10) dt1=0.0;
      if (fabs(dt2) < 1e-10) dt2=0.0;

      /* now we choose the smallest positive solution */
      if      (dt1<=0.0 && dt2>0.0) ret=2; /* dt2 positive */
      else if (dt2<=0.0 && dt1>0.0) ret=1; /* dt1 positive */
      else if (dt1> 0.0 && dt2>0.0)
      {  if (dt1 < dt2) ret=1; else ret=2; } /* all positive: min(dt1,dt2) */
      /* else two solutions are negative. ret=-1 */
      if (ret==1) { *t1 = dt1;  if (t2) *t2=dt2; }
      else        { *t1 = dt2;  if (t2) *t2=dt1; }
      ret=2;  /* found 2 solutions and t1 is the positive one */
    } /* else Delta <0: no intersection. ret=0 */
  }
  return(ret);
} /* solve_2nd_order */

/*******************************************************************************
 * randvec_target_circle: Choose random direction towards target at (x,y,z)
 * with given radius.
 * If radius is zero, choose random direction in full 4PI, no target.
 ******************************************************************************/
void
randvec_target_circle(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double radius)
{
  double l2, phi, theta, nx, ny, nz, xt, yt, zt, xu, yu, zu;

  if(radius == 0.0)
  {
    /* No target, choose uniformly a direction in full 4PI solid angle. */
    theta = acos (1 - rand0max(2));
    phi = rand0max(2 * PI);
    if(solid_angle)
      *solid_angle = 4*PI;
    nx = 1;
    ny = 0;
    nz = 0;
    yi = sqrt(xi*xi+yi*yi+zi*zi);
    zi = 0;
    xi = 0;
  }
  else
  {
    double costheta0;
    l2 = xi*xi + yi*yi + zi*zi; /* sqr Distance to target. */
    costheta0 = sqrt(l2/(radius*radius+l2));
    if (radius < 0) costheta0 *= -1;
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
        *solid_angle = 2*PI*(1 - costheta0);
    }

    /* Now choose point uniformly on circle surface within angle theta0 */
    theta = acos (1 - rand0max(1 - costheta0)); /* radius on circle */
    phi = rand0max(2 * PI); /* rotation on circle at given radius */
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around a
       perpendicular axis u=i x n and then angle phi around i. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, xu, yu, zu);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xi, yi, zi);
} /* randvec_target_circle */

/*******************************************************************************
 * randvec_target_rect_angular: Choose random direction towards target at
 * (xi,yi,zi) with given ANGULAR dimension height x width. height=phi_x=[0,PI],
 * width=phi_y=[0,2*PI] (radians)
 * If height or width is zero, choose random direction in full 4PI, no target.
 *******************************************************************************/
void
randvec_target_rect_angular(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double width, double height, Rotation A)
{
  double theta, phi, nx, ny, nz, xt, yt, zt, xu, yu, zu;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
      *solid_angle = 2*fabs(width*sin(height/2));
    }

    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Now choose point uniformly on the unit sphere segment with angle theta/phi */
    phi   = width*randpm1()/2.0;
    theta = asin(randpm1()*sin(height/2.0));
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around
       n, and then phi around u. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, nx, ny, nz);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xu,  yu,  zu);

  /* Go back to local coordinate system */
  tmp = coords_set(*xo, *yo, *zo);
  tmp = rot_apply(A, tmp);
  coords_get(tmp, &*xo, &*yo, &*zo);

} /* randvec_target_rect_angular */

/*******************************************************************************
 * randvec_target_rect_real: Choose random direction towards target at (xi,yi,zi)
 * with given dimension height x width (in meters !).
 *
 * Local emission coordinate is taken into account and corrected for 'order' times.
 * (See remarks posted to mcstas-users by George Apostolopoulus <gapost@ipta.demokritos.gr>)
 *
 * If height or width is zero, choose random direction in full 4PI, no target.
 *
 * Traditionally, this routine had the name randvec_target_rect - this is now a
 * a define (see mcstas-r.h) pointing here. If you use the old rouine, you are NOT
 * taking the local emmission coordinate into account.
*******************************************************************************/

void
randvec_target_rect_real(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi,
               double width, double height, Rotation A,
               double lx, double ly, double lz, int order)
{
  double dx, dy, dist, dist_p, nx, ny, nz, mx, my, mz, n_norm, m_norm;
  double cos_theta;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {

    /* Now choose point uniformly on rectangle within width x height */
    dx = width*randpm1()/2.0;
    dy = height*randpm1()/2.0;

    /* Determine distance to target plane*/
    dist = sqrt(xi*xi + yi*yi + zi*zi);
    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Determine vector normal to trajectory axis (z) and gravity [0 1 0] */
    vec_prod(nx, ny, nz, xi, yi, zi, 0, 1, 0);

    /* This now defines the x-axis, normalize: */
    n_norm=sqrt(nx*nx + ny*ny + nz*nz);
    nx = nx/n_norm;
    ny = ny/n_norm;
    nz = nz/n_norm;

    /* Now, determine our y-axis (vertical in many cases...) */
    vec_prod(mx, my, mz, xi, yi, zi, nx, ny, nz);
    m_norm=sqrt(mx*mx + my*my + mz*mz);
    mx = mx/m_norm;
    my = my/m_norm;
    mz = mz/m_norm;

    /* Our output, random vector can now be defined by linear combination: */

    *xo = xi + dx * nx + dy * mx;
    *yo = yi + dx * ny + dy * my;
    *zo = zi + dx * nz + dy * mz;

    /* Go back to local coordinate system */
    tmp = coords_set(*xo, *yo, *zo);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &*xo, &*yo, &*zo);

    /* Go back to local coordinate system */
    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    if (solid_angle) {
      /* Calculate vector from local point to remote random point */
      lx = *xo - lx;
      ly = *yo - ly;
      lz = *zo - lz;
      dist_p = sqrt(lx*lx + ly*ly + lz*lz);

      /* Adjust the 'solid angle' */
      /* 1/r^2 to the chosen point times cos(\theta) between the normal */
      /* vector of the target rectangle and direction vector of the chosen point. */
      cos_theta = (xi * lx + yi * ly + zi * lz) / (dist * dist_p);
      *solid_angle = width * height / (dist_p * dist_p);
      int counter;
      for (counter = 0; counter < order; counter++) {
	*solid_angle = *solid_angle * cos_theta;
      }
    }
  }
} /* randvec_target_rect_real */

/* SECTION: random numbers ================================================== */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * This is derived from the Berkeley source:
 *        @(#)random.c        5.5 (Berkeley) 7/6/88
 * It was reworked for the GNU C Library by Roland McGrath.
 * Rewritten to use reentrant functions by Ulrich Drepper, 1995.
 */

/*******************************************************************************
* Modified for McStas from glibc 2.0.7pre1 stdlib/random.c and
* stdlib/random_r.c.
*
* This way random() is more than four times faster compared to calling
* standard glibc random() on ix86 Linux, probably due to multithread support,
* ELF shared library overhead, etc. It also makes McStas generated
* simulations more portable (more likely to behave identically across
* platforms, important for parrallel computations).
*******************************************************************************/


#define        TYPE_3                3
#define        BREAK_3                128
#define        DEG_3                31
#define        SEP_3                3

static mc_int32_t randtbl[DEG_3 + 1] =
  {
    TYPE_3,

    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,
    1627687941, -179304937, -2073333483, 1780058412, -1989503057,
    -615974602, 344556628, 939512070, -1249116260, 1507946756,
    -812545463, 154635395, 1388815473, -1926676823, 525320961,
    -1009028674, 968117788, -123449607, 1284210865, 435012392,
    -2017506339, -911064859, -370259173, 1132637927, 1398500161,
    -205601318,
  };

static mc_int32_t *fptr = &randtbl[SEP_3 + 1];
static mc_int32_t *rptr = &randtbl[1];
static mc_int32_t *state = &randtbl[1];
#define rand_deg DEG_3
#define rand_sep SEP_3
static mc_int32_t *end_ptr = &randtbl[sizeof (randtbl) / sizeof (randtbl[0])];

mc_int32_t
mc_random (void)
{
  mc_int32_t result;

  *fptr += *rptr;
  /* Chucking least random bit.  */
  result = (*fptr >> 1) & 0x7fffffff;
  ++fptr;
  if (fptr >= end_ptr)
  {
    fptr = state;
    ++rptr;
  }
  else
  {
    ++rptr;
    if (rptr >= end_ptr)
      rptr = state;
  }
  return result;
}

void
mc_srandom (unsigned int x)
{
  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
  state[0] = x ? x : 1;
  {
    long int i;
    for (i = 1; i < rand_deg; ++i)
    {
      /* This does:
         state[i] = (16807 * state[i - 1]) % 2147483647;
         but avoids overflowing 31 bits.  */
      long int hi = state[i - 1] / 127773;
      long int lo = state[i - 1] % 127773;
      long int test = 16807 * lo - 2836 * hi;
      state[i] = test + (test < 0 ? 2147483647 : 0);
    }
    fptr = &state[rand_sep];
    rptr = &state[0];
    for (i = 0; i < 10 * rand_deg; ++i)
      random ();
  }
}

/* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
/* See http://www.math.keio.ac.jp/~matumoto/emt.html for original source. */


/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using mt_srandom(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.keio.ac.jp/matumoto/emt.html
   email: matumoto@math.keio.ac.jp
*/

#include <stdio.h>

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void mt_srandom(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] =
            (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
void init_by_array(unsigned long init_key[], unsigned long key_length)
{
    int i, j, k;
    mt_srandom(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long mt_random(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if mt_srandom() has not been called, */
            mt_srandom(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }

    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

#undef N
#undef M
#undef MATRIX_A
#undef UPPER_MASK
#undef LOWER_MASK

/* End of "Mersenne Twister". */

/* End of McCode random number routine. */

/* randnorm: generate a random number from normal law */
double
randnorm(void)
{
  static double v1, v2, s;
  static int phase = 0;
  double X, u1, u2;

  if(phase == 0)
  {
    do
    {
      u1 = rand01();
      u2 = rand01();
      v1 = 2*u1 - 1;
      v2 = 2*u2 - 1;
      s = v1*v1 + v2*v2;
    } while(s >= 1 || s == 0);

    X = v1*sqrt(-2*log(s)/s);
  }
  else
  {
    X = v2*sqrt(-2*log(s)/s);
  }

  phase = 1 - phase;
  return X;
}

/**
 * Generate a random number from -1 to 1 with triangle distribution
 */
double randtriangle(void) {
	double randnum = rand01();
	if (randnum>0.5) return(1-sqrt(2*(randnum-0.5)));
	else return(sqrt(2*randnum)-1);
}

/**
 * Random number between 0.0 and 1.0 (including?)
 */
double rand01() {
	double randnum;
	randnum = (double) random();
	randnum /= (double) MC_RAND_MAX + 1;
	return randnum;
}

/**
 * Return a random number between 1 and -1
 */
double randpm1() {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / 2;
	randnum -= 1;
	return randnum;
}

/**
 * Return a random number between 0 and max.
 */
double rand0max(double max) {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / max;
	return randnum;
}

/**
 * Return a random number between min and max.
 */
double randminmax(double min, double max) {
	return rand0max(max - min) + max;
}

/* SECTION: main and signal handlers ======================================== */

/*******************************************************************************
* mchelp: displays instrument executable help with possible options
*******************************************************************************/
static void
mchelp(char *pgmname)
{
  int i;

  fprintf(stderr, "%s (%s) instrument simulation, generated with " MCCODE_STRING " (" MCCODE_DATE ")\n", mcinstrument_name, mcinstrument_source);
  fprintf(stderr, "Usage: %s [options] [parm=value ...]\n", pgmname);
  fprintf(stderr,
"Options are:\n"
"  -s SEED   --seed=SEED      Set random seed (must be != 0)\n"
"  -n COUNT  --ncount=COUNT   Set number of " MCCODE_PARTICLE "s to simulate.\n"
"  -d DIR    --dir=DIR        Put all data files in directory DIR.\n"
"  -t        --trace          Enable trace of " MCCODE_PARTICLE "s through instrument.\n"
"  -g        --gravitation    Enable gravitation for all trajectories.\n"
"  --no-output-files          Do not write any data files.\n"
"  -h        --help           Show this help message.\n"
"  -i        --info           Detailed instrument information.\n"
"  --format=FORMAT            Output data files using FORMAT="
   FLAVOR_UPPER
#ifdef USE_NEXUS
   " NEXUS"
#endif
"\n\n"
);
#ifdef USE_MPI
  fprintf(stderr,
  "This instrument has been compiled with MPI support.\n  Use 'mpirun %s [options] [parm=value ...]'.\n", pgmname);
#endif
  if(mcnumipar > 0)
  {
    fprintf(stderr, "Instrument parameters are:\n");
    for(i = 0; i < mcnumipar; i++)
      if (mcinputtable[i].val && strlen(mcinputtable[i].val))
        fprintf(stderr, "  %-16s(%s) [default='%s']\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name),
        mcinputtable[i].val);
      else
        fprintf(stderr, "  %-16s(%s)\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name));
  }

#ifndef NOSIGNALS
  fprintf(stderr, "Known signals are: "
#ifdef SIGUSR1
  "USR1 (status) "
#endif
#ifdef SIGUSR2
  "USR2 (save) "
#endif
#ifdef SIGBREAK
  "BREAK (save) "
#endif
#ifdef SIGTERM
  "TERM (save and exit)"
#endif
  "\n");
#endif /* !NOSIGNALS */
} /* mchelp */


/* mcshowhelp: show help and exit with 0 */
static void
mcshowhelp(char *pgmname)
{
  mchelp(pgmname);
  exit(0);
}

/* mcusage: display usage when error in input arguments and exit with 1 */
static void
mcusage(char *pgmname)
{
  fprintf(stderr, "Error: incorrect command line arguments\n");
  mchelp(pgmname);
  exit(1);
}

/* mcenabletrace: enable trace/mcdisplay or error if requires recompile */
static void
mcenabletrace(void)
{
 if(mctraceenabled)
  mcdotrace = 1;
 else
 {
   fprintf(stderr,
           "Error: trace not enabled (mcenabletrace)\n"
           "Please re-run the " MCCODE_NAME " compiler "
                   "with the --trace option, or rerun the\n"
           "C compiler with the MC_TRACE_ENABLED macro defined.\n");
   exit(1);
 }
}

/*******************************************************************************
* mcreadparams: request parameters from the prompt (or use default)
*******************************************************************************/
void
mcreadparams(void)
{
  int i,j,status;
  static char buf[CHAR_BUF_LENGTH];
  char *p;
  int len;

  MPI_MASTER(printf("Instrument parameters for %s (%s)\n",
                    mcinstrument_name, mcinstrument_source));

  for(i = 0; mcinputtable[i].name != 0; i++)
  {
    do
    {
      MPI_MASTER(
                 if (mcinputtable[i].val && strlen(mcinputtable[i].val))
                   printf("Set value of instrument parameter %s (%s) [default='%s']:\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name), mcinputtable[i].val);
                 else
                   printf("Set value of instrument parameter %s (%s):\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name));
                 fflush(stdout);
                 );
#ifdef USE_MPI
      if(mpi_node_rank == mpi_node_root)
        {
          p = fgets(buf, CHAR_BUF_LENGTH, stdin);
          if(p == NULL)
            {
              fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
              exit(1);
            }
        }
      else
        p = buf;
      MPI_Bcast(buf, CHAR_BUF_LENGTH, MPI_CHAR, mpi_node_root, MPI_COMM_WORLD);
#else /* !USE_MPI */
      p = fgets(buf, CHAR_BUF_LENGTH, stdin);
      if(p == NULL)
        {
          fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
          exit(1);
        }
#endif /* USE_MPI */
      len = strlen(buf);
      if (!len || (len == 1 && (buf[0] == '\n' || buf[0] == '\r')))
      {
        if (mcinputtable[i].val && strlen(mcinputtable[i].val)) {
          strncpy(buf, mcinputtable[i].val, CHAR_BUF_LENGTH);  /* use default value */
          len = strlen(buf);
        }
      }
      for(j = 0; j < 2; j++)
      {
        if(len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
        {
          len--;
          buf[len] = '\0';
        }
      }

      status = (*mcinputtypes[mcinputtable[i].type].getparm)
                   (buf, mcinputtable[i].par);
      if(!status)
      {
        (*mcinputtypes[mcinputtable[i].type].error)(mcinputtable[i].name, buf);
        if (!mcinputtable[i].val || strlen(mcinputtable[i].val)) {
          fprintf(stderr, "       Change %s default value in instrument definition.\n", mcinputtable[i].name);
          exit(1);
        }
      }
    } while(!status);
  }
} /* mcreadparams */

/*******************************************************************************
* mcparseoptions: parse command line arguments (options, parameters)
*******************************************************************************/
void
mcparseoptions(int argc, char *argv[])
{
  int i, j;
  char *p;
  int paramset = 0, *paramsetarray;
  char *usedir=NULL;

  /* Add one to mcnumipar to avoid allocating zero size memory block. */
  paramsetarray = (int*)malloc((mcnumipar + 1)*sizeof(*paramsetarray));
  if(paramsetarray == NULL)
  {
    fprintf(stderr, "Error: insufficient memory (mcparseoptions)\n");
    exit(1);
  }
  for(j = 0; j < mcnumipar; j++)
    {
      paramsetarray[j] = 0;
      if (mcinputtable[j].val != NULL && strlen(mcinputtable[j].val))
      {
        int  status;
        char buf[CHAR_BUF_LENGTH];
        strncpy(buf, mcinputtable[j].val, CHAR_BUF_LENGTH);
        status = (*mcinputtypes[mcinputtable[j].type].getparm)
                   (buf, mcinputtable[j].par);
        if(!status) fprintf(stderr, "Invalid '%s' default value %s in instrument definition (mcparseoptions)\n", mcinputtable[j].name, buf);
        else paramsetarray[j] = 1;
      } else {
        (*mcinputtypes[mcinputtable[j].type].getparm)
          (NULL, mcinputtable[j].par);
        paramsetarray[j] = 0;
      }
    }
  for(i = 1; i < argc; i++)
  {
    if(!strcmp("-s", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("-s", argv[i], 2))
      mcsetseed(&argv[i][2]);
    else if(!strcmp("--seed", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("--seed=", argv[i], 7))
      mcsetseed(&argv[i][7]);
    else if(!strcmp("-n", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("-n", argv[i], 2))
      mcsetn_arg(&argv[i][2]);
    else if(!strcmp("--ncount", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("--ncount=", argv[i], 9))
      mcsetn_arg(&argv[i][9]);
    else if(!strcmp("-d", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];  /* will create directory after parsing all arguments (end of this function) */
    else if(!strncmp("-d", argv[i], 2))
      usedir=&argv[i][2];
    else if(!strcmp("--dir", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];
    else if(!strncmp("--dir=", argv[i], 6))
      usedir=&argv[i][6];
    else if(!strcmp("-h", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("--help", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("-i", argv[i])) {
      mcformat=FLAVOR_UPPER;
      mcinfo();
    }
    else if(!strcmp("--info", argv[i]))
      mcinfo();
    else if(!strcmp("-t", argv[i]))
      mcenabletrace();
    else if(!strcmp("--trace", argv[i]))
      mcenabletrace();
    else if(!strcmp("--gravitation", argv[i]))
      mcgravitation = 1;
    else if(!strcmp("-g", argv[i]))
      mcgravitation = 1;
    else if(!strncmp("--format=", argv[i], 9)) {
      mcformat=&argv[i][9];
    }
    else if(!strcmp("--format", argv[i]) && (i + 1) < argc) {
      mcformat=argv[++i];
    }
    else if(!strcmp("--no-output-files", argv[i]))
      mcdisable_output_files = 1;
    else if(argv[i][0] != '-' && (p = strchr(argv[i], '=')) != NULL)
    {
      *p++ = '\0';

      for(j = 0; j < mcnumipar; j++)
        if(!strcmp(mcinputtable[j].name, argv[i]))
        {
          int status;
          status = (*mcinputtypes[mcinputtable[j].type].getparm)(p,
                        mcinputtable[j].par);
          if(!status || !strlen(p))
          {
            (*mcinputtypes[mcinputtable[j].type].error)
              (mcinputtable[j].name, p);
            exit(1);
          }
          paramsetarray[j] = 1;
          paramset = 1;
          break;
        }
      if(j == mcnumipar)
      {                                /* Unrecognized parameter name */
        fprintf(stderr, "Error: unrecognized parameter %s (mcparseoptions)\n", argv[i]);
        exit(1);
      }
    }
    else if(argv[i][0] == '-') {
      fprintf(stderr, "Error: unrecognized option argument %s (mcparseoptions). Ignored.\n", argv[i++]);
    }
    else {
      fprintf(stderr, "Error: unrecognized argument %s (mcparseoptions). Aborting.\n", argv[i]);
      mcusage(argv[0]);
    }
  }
  if(!paramset)
    mcreadparams();                /* Prompt for parameters if not specified. */
  else
  {
    for(j = 0; j < mcnumipar; j++)
      if(!paramsetarray[j])
      {
        fprintf(stderr, "Error: Instrument parameter %s left unset (mcparseoptions)\n",
                mcinputtable[j].name);
        exit(1);
      }
  }
  free(paramsetarray);
#ifdef USE_MPI
  if (mcdotrace) mpi_node_count=1; /* disable threading when in trace mode */
#endif
  if (usedir && strlen(usedir) && !mcdisable_output_files) mcuse_dir(usedir);
} /* mcparseoptions */

#ifndef NOSIGNALS
mcstatic char  mcsig_message[256];


/*******************************************************************************
* sighandler: signal handler that makes simulation stop, and save results
*******************************************************************************/
void sighandler(int sig)
{
  /* MOD: E. Farhi, Sep 20th 2001: give more info */
  time_t t1, t0;
#define SIG_SAVE 0
#define SIG_TERM 1
#define SIG_STAT 2
#define SIG_ABRT 3

  printf("\n# " MCCODE_STRING ": [pid %i] Signal %i detected", getpid(), sig);
#ifdef USE_MPI
  printf(" [proc %i]", mpi_node_rank);
#endif
#if defined(SIGUSR1) && defined(SIGUSR2) && defined(SIGKILL)
  if (!strcmp(mcsig_message, "sighandler") && (sig != SIGUSR1) && (sig != SIGUSR2))
  {
    printf("\n# Fatal : unrecoverable loop ! Suicide (naughty boy).\n");
    kill(0, SIGKILL); /* kill myself if error occurs within sighandler: loops */
  }
#endif
  switch (sig) {
#ifdef SIGINT
    case SIGINT : printf(" SIGINT (interrupt from terminal, Ctrl-C)"); sig = SIG_TERM; break;
#endif
#ifdef SIGILL
    case SIGILL  : printf(" SIGILL (Illegal instruction)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGFPE
    case SIGFPE  : printf(" SIGFPE (Math Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGSEGV
    case SIGSEGV : printf(" SIGSEGV (Mem Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGTERM
    case SIGTERM : printf(" SIGTERM (Termination)"); sig = SIG_TERM; break;
#endif
#ifdef SIGABRT
    case SIGABRT : printf(" SIGABRT (Abort)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGQUIT
    case SIGQUIT : printf(" SIGQUIT (Quit from terminal)"); sig = SIG_TERM; break;
#endif
#ifdef SIGTRAP
    case SIGTRAP : printf(" SIGTRAP (Trace trap)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGPIPE
    case SIGPIPE : printf(" SIGPIPE (Broken pipe)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGUSR1
    case SIGUSR1 : printf(" SIGUSR1 (Display info)"); sig = SIG_STAT; break;
#endif
#ifdef SIGUSR2
    case SIGUSR2 : printf(" SIGUSR2 (Save simulation)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGHUP
    case SIGHUP  : printf(" SIGHUP (Hangup/update)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGBUS
    case SIGBUS  : printf(" SIGBUS (Bus error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGURG
    case SIGURG  : printf(" SIGURG (Urgent socket condition)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGBREAK
    case SIGBREAK: printf(" SIGBREAK (Break signal, Ctrl-Break)"); sig = SIG_SAVE; break;
#endif
    default : printf(" (look at signal list for signification)"); sig = SIG_ABRT; break;
  }
  printf("\n");
  printf("# Simulation: %s (%s) \n", mcinstrument_name, mcinstrument_source);
  printf("# Breakpoint: %s ", mcsig_message);
  if (strstr(mcsig_message, "Save") && (sig == SIG_SAVE))
    sig = SIG_STAT;
  SIG_MESSAGE("sighandler");
  if (mcget_ncount() == 0)
    printf("(0 %%)\n" );
  else
  {
    printf("%.2f %% (%10.1f/%10.1f)\n", 100.0*mcget_run_num()/mcget_ncount(), 1.0*mcget_run_num(), 1.0*mcget_ncount());
  }
  t0 = (time_t)mcstartdate;
  t1 = time(NULL);
  printf("# Date:      %s", ctime(&t1));
  printf("# Started:   %s", ctime(&t0));

  if (sig == SIG_STAT)
  {
    printf("# " MCCODE_STRING ": Resuming simulation (continue)\n");
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_SAVE)
  {
    printf("# " MCCODE_STRING ": Saving data and resume simulation (continue)\n");
    mcsave(NULL);
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_TERM)
  {
    printf("# " MCCODE_STRING ": Finishing simulation (save results and exit)\n");
    mcfinally();
    exit(0);
  }
  else
  {
    fflush(stdout);
    perror("# Last I/O Error");
    printf("# " MCCODE_STRING ": Simulation stop (abort).\n");
// This portion of the signal handling only works on UNIX
#if defined(__unix__) || defined(__APPLE__)
    signal(sig, SIG_DFL); /* force to use default sighandler now */
    kill(getpid(), sig);  /* and trigger it with the current signal */
#endif
    exit(-1);
  }
#undef SIG_SAVE
#undef SIG_TERM
#undef SIG_STAT
#undef SIG_ABRT

} /* sighandler */
#endif /* !NOSIGNALS */

/*******************************************************************************
* mccode_main: McCode main() function.
*******************************************************************************/
int mccode_main(int argc, char *argv[])
{
/*  double run_num = 0; */
  time_t  t;
#ifdef USE_MPI
  char mpi_node_name[MPI_MAX_PROCESSOR_NAME];
  int  mpi_node_name_len;
#endif /* USE_MPI */

#ifdef MAC
  argc = ccommand(&argv);
#endif

#ifdef USE_MPI
  MPI_Init(&argc,&argv);
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_node_count); /* get number of nodes */
  MPI_Comm_rank(MPI_COMM_WORLD, &mpi_node_rank);
  MPI_Comm_set_name(MPI_COMM_WORLD, mcinstrument_name);
  MPI_Get_processor_name(mpi_node_name, &mpi_node_name_len);
#endif /* USE_MPI */

t = time(NULL);
mcseed = (long)t+(long)getpid();

#ifdef USE_MPI
/* *** print number of nodes *********************************************** */
  if (mpi_node_count > 1) {
    MPI_MASTER(
    printf("Simulation '%s' (%s): running on %i nodes (master is '%s', MPI version %i.%i).\n",
      mcinstrument_name, mcinstrument_source, mpi_node_count, mpi_node_name, MPI_VERSION, MPI_SUBVERSION);
    );
  }
#endif /* USE_MPI */
  
  mcstartdate = (long)t;  /* set start date before parsing options and creating sim file */

/* *** parse options ******************************************************* */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;
  mcinstrument_exe = argv[0]; /* store the executable path */
  /* read simulation parameters and options */
  mcparseoptions(argc, argv); /* sets output dir and format */
  
#ifdef USE_MPI
  if (mpi_node_count > 1) {
    /* share the same seed, then adapt random seed for each node */
    MPI_Bcast(&mcseed, 1, MPI_LONG, 0, MPI_COMM_WORLD); /* root sends its seed to slaves */
    mcseed += mpi_node_rank; /* make sure we use different seeds per node */
  }
#endif
  srandom(mcseed);

/* *** install sig handler, but only once !! after parameters parsing ******* */
#ifndef NOSIGNALS
#ifdef SIGQUIT
  if (signal( SIGQUIT ,sighandler) == SIG_IGN)
    signal( SIGQUIT,SIG_IGN);   /* quit (ASCII FS) */
#endif
#ifdef SIGABRT
  if (signal( SIGABRT ,sighandler) == SIG_IGN)
    signal( SIGABRT,SIG_IGN);   /* used by abort, replace SIGIOT in the future */
#endif
#ifdef SIGTERM
  if (signal( SIGTERM ,sighandler) == SIG_IGN)
    signal( SIGTERM,SIG_IGN);   /* software termination signal from kill */
#endif
#ifdef SIGUSR1
  if (signal( SIGUSR1 ,sighandler) == SIG_IGN)
    signal( SIGUSR1,SIG_IGN);   /* display simulation status */
#endif
#ifdef SIGUSR2
  if (signal( SIGUSR2 ,sighandler) == SIG_IGN)
    signal( SIGUSR2,SIG_IGN);
#endif
#ifdef SIGHUP
  if (signal( SIGHUP ,sighandler) == SIG_IGN)
    signal( SIGHUP,SIG_IGN);
#endif
#ifdef SIGILL
  if (signal( SIGILL ,sighandler) == SIG_IGN)
    signal( SIGILL,SIG_IGN);    /* illegal instruction (not reset when caught) */
#endif
#ifdef SIGFPE
  if (signal( SIGFPE ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* floating point exception */
#endif
#ifdef SIGBUS
  if (signal( SIGBUS ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* bus error */
#endif
#ifdef SIGSEGV
  if (signal( SIGSEGV ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);   /* segmentation violation */
#endif
#endif /* !NOSIGNALS */
  mcsiminfo_init(NULL); /* open SIM */
  SIG_MESSAGE("main (Init)");
  mcinit();
#ifndef NOSIGNALS
#ifdef SIGINT
  if (signal( SIGINT ,sighandler) == SIG_IGN)
    signal( SIGINT,SIG_IGN);    /* interrupt (rubout) only after INIT */
#endif
#endif /* !NOSIGNALS */

/* ================ main particle generation/propagation loop ================ */
#if defined (USE_MPI)
  /* sliced Ncount on each MPI node */
  mcncount = mpi_node_count > 1 ?
    floor(mcncount / mpi_node_count) :
    mcncount; /* number of rays per node */
#endif

/* main particle event loop */
while(mcrun_num < mcncount || mcrun_num < mcget_ncount())
  {
#ifndef NEUTRONICS
    mcgenstate();
#endif
    /* old init: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
    mcraytrace();
    mcrun_num++;
  }

#ifdef USE_MPI
 /* merge run_num from MPI nodes */
  if (mpi_node_count > 1) {
  double mcrun_num_double = (double)mcrun_num;
  mc_MPI_Sum(&mcrun_num_double, 1);
  mcrun_num = (unsigned long long)mcrun_num_double;
  }
#endif

/* save/finally executed by master node/thread */
  mcfinally();

#ifdef USE_MPI
  MPI_Finalize();
#endif /* USE_MPI */

  return 0;
} /* mccode_main */

#ifdef NEUTRONICS
/*Main neutronics function steers the McStas calls, initializes parameters etc */
/* Only called in case NEUTRONICS = TRUE */
void neutronics_main_(float *inx, float *iny, float *inz, float *invx, float *invy, float *invz, float *intime, float *insx, float *insy, float *insz, float *inw, float *outx, float *outy, float *outz, float *outvx, float *outvy, float *outvz, float *outtime, float *outsx, float *outsy, float *outsz, float *outwgt)
{

  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  /* External code governs iteration - McStas is iterated once per call to neutronics_main. I.e. below counter must be initiancated for each call to neutronics_main*/
  mcrun_num=0;

  time_t t;
  t = (time_t)mcstartdate;
  mcstartdate = t;  /* set start date before parsing options and creating sim file */
  mcinit();

  /* *** parse options *** */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;

  /* Set neutron state based on input from neutronics code */
  mcsetstate(*inx,*iny,*inz,*invx,*invy,*invz,*intime,*insx,*insy,*insz,*inw);

  /* main neutron event loop - runs only one iteration */

  //mcstas_raytrace(&mcncount); /* prior to McStas 1.12 */

  mcallowbackprop = 1; //avoid absorbtion from negative dt
  int argc=1;
  char *argv[0];
  int dummy = mccode_main(argc, argv);

  *outx =  mcnx;
  *outy =  mcny;
  *outz =  mcnz;
  *outvx =  mcnvx;
  *outvy =  mcnvy;
  *outvz =  mcnvz;
  *outtime =  mcnt;
  *outsx =  mcnsx;
  *outsy =  mcnsy;
  *outsz =  mcnsz;
  *outwgt =  mcnp;

  return;
} /* neutronics_main */

#endif /*NEUTRONICS*/

#endif /* !MCCODE_H */
/* End of file "mccode-r.c". */
/* End of file "mccode-r.c". */

#line 4947 "RITA-II.c"

#line 1 "mcstas-r.c"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system for McStas.
* Embedded within instrument in runtime mode.
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#include "mcstas-r.h"
#endif
#ifdef DANSE
#include "mcstas-globals.h"
#endif

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/

/*the magnet stack*/
#ifdef MC_POL_COMPAT
void (*mcMagnetPrecession) (double, double, double, double, double, double,
    double, double*, double*, double*, double, Coords, Rotation)=NULL;
Coords   mcMagnetPos;
Rotation mcMagnetRot;
double*  mcMagnetData                = NULL;
/* mcMagneticField(x, y, z, t, Bx, By, Bz) */
int (*mcMagneticField) (double, double, double, double,
    double*, double*, double*, void *) = NULL;
#endif

#ifndef MCSTAS_H

/*******************************************************************************
* mcstore_neutron: stores neutron coodinates into global array (per component)
*******************************************************************************/
void
mcstore_neutron(MCNUM *s, int index, double x, double y, double z,
               double vx, double vy, double vz, double t,
               double sx, double sy, double sz, double p)
{
    double *dptr = &s[11*index];
    *dptr++  = x;
    *dptr++  = y ;
    *dptr++  = z ;
    *dptr++  = vx;
    *dptr++  = vy;
    *dptr++  = vz;
    *dptr++  = t ;
    *dptr++  = sx;
    *dptr++  = sy;
    *dptr++  = sz;
    *dptr    = p ;
} /* mcstore_neutron */

/*******************************************************************************
* mcrestore_neutron: restores neutron coodinates from global array
*******************************************************************************/
void
mcrestore_neutron(MCNUM *s, int index, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *t,
               double *sx, double *sy, double *sz, double *p)
{
    double *dptr = &s[11*index];
    *x  =  *dptr++;
    *y  =  *dptr++;
    *z  =  *dptr++;
    *vx =  *dptr++;
    *vy =  *dptr++;
    *vz =  *dptr++;
    *t  =  *dptr++;
    *sx =  *dptr++;
    *sy =  *dptr++;
    *sz =  *dptr++;
    *p  =  *dptr;
} /* mcrestore_neutron */

/*******************************************************************************
* mcsetstate: transfer parameters into global McStas variables 
*******************************************************************************/
void
mcsetstate(double x, double y, double z, double vx, double vy, double vz,
           double t, double sx, double sy, double sz, double p)
{
  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  mcnx = x;
  mcny = y;
  mcnz = z;
  mcnvx = vx;
  mcnvy = vy;
  mcnvz = vz;
  mcnt = t;
  mcnsx = sx;
  mcnsy = sy;
  mcnsz = sz;
  mcnp = p;
} /* mcsetstate */

/*******************************************************************************
* mcgenstate: set default neutron parameters 
*******************************************************************************/
void
mcgenstate(void)
{
  mcsetstate(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  /* old initialisation: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
}

/* intersection routines ==================================================== */

/*******************************************************************************
* inside_rectangle: Check if (x,y) is inside rectangle (xwidth, yheight) 
* return 0 if outside and 1 if inside 
*******************************************************************************/
int inside_rectangle(double x, double y, double xwidth, double yheight)
{
  if (x>-xwidth/2 && x<xwidth/2 && y>-yheight/2 && y<yheight/2)
    return 1;
  else
    return 0;
}

/*******************************************************************************
 * box_intersect: compute time intersection with a box
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times dt_in and dt_out
 * This function written by Stine Nyborg, 1999. 
 *******************************************************************************/
int box_intersect(double *dt_in, double *dt_out,
                  double x, double y, double z,
                  double vx, double vy, double vz,
                  double dx, double dy, double dz)
{
  double x_in, y_in, z_in, tt, t[6], a, b;
  int i, count, s;

      /* Calculate intersection time for each of the six box surface planes
       *  If the box surface plane is not hit, the result is zero.*/

  if(vx != 0)
   {
    tt = -(dx/2 + x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[0] = tt;
    else
      t[0] = 0;

    tt = (dx/2 - x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[1] = tt;
    else
      t[1] = 0;
   }
  else
    t[0] = t[1] = 0;

  if(vy != 0)
   {
    tt = -(dy/2 + y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[2] = tt;
    else
      t[2] = 0;

    tt = (dy/2 - y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[3] = tt;
    else
      t[3] = 0;
   }
  else
    t[2] = t[3] = 0;

  if(vz != 0)
   {
    tt = -(dz/2 + z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[4] = tt;
    else
      t[4] = 0;

    tt = (dz/2 - z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[5] = tt;
    else
      t[5] = 0;
   }
  else
    t[4] = t[5] = 0;

  /* The intersection is evaluated and *dt_in and *dt_out are assigned */

  a = b = s = 0;
  count = 0;

  for( i = 0; i < 6; i = i + 1 )
    if( t[i] == 0 )
      s = s+1;
    else if( count == 0 )
    {
      a = t[i];
      count = 1;
    }
    else
    {
      b = t[i];
      count = 2;
    }

  if ( a == 0 && b == 0 )
    return 0;
  else if( a < b )
  {
    *dt_in = a;
    *dt_out = b;
    return 1;
  }
  else
  {
    *dt_in = b;
    *dt_out = a;
    return 1;
  }

} /* box_intersect */

/*******************************************************************************
 * cylinder_intersect: compute intersection with a cylinder
 * returns 0 when no intersection is found
 *      or 2/4/8/16 bits depending on intersection,
 *     and resulting times t0 and t1
 * Written by: EM,NB,ABA 4.2.98 
  *******************************************************************************/
int
cylinder_intersect(double *t0, double *t1, double x, double y, double z,
                   double vx, double vy, double vz, double r, double h)
{
  double D, t_in, t_out, y_in, y_out;
  int ret=1;

  D = (2*vx*x + 2*vz*z)*(2*vx*x + 2*vz*z)
    - 4*(vx*vx + vz*vz)*(x*x + z*z - r*r);

  if (D>=0)
  {
    if (vz*vz + vx*vx) {
      t_in  = (-(2*vz*z + 2*vx*x) - sqrt(D))/(2*(vz*vz + vx*vx));
      t_out = (-(2*vz*z + 2*vx*x) + sqrt(D))/(2*(vz*vz + vx*vx));
    } else if (vy) { /* trajectory parallel to cylinder axis */
      t_in = (-h/2-y)/vy;
      t_out = (h/2-y)/vy;
      if (t_in>t_out){
        double tmp=t_in;
        t_in=t_out;t_out=tmp;
      }
    } else return 0;
    y_in = vy*t_in + y;
    y_out =vy*t_out + y;

    if ( (y_in > h/2 && y_out > h/2) || (y_in < -h/2 && y_out < -h/2) )
      return 0;
    else
    {
      if (y_in > h/2)
        { t_in = ((h/2)-y)/vy; ret += 2; }
      else if (y_in < -h/2)
        { t_in = ((-h/2)-y)/vy; ret += 4; }
      if (y_out > h/2)
        { t_out = ((h/2)-y)/vy; ret += 8; }
      else if (y_out < -h/2)
        { t_out = ((-h/2)-y)/vy; ret += 16; }
    }
    *t0 = t_in;
    *t1 = t_out;
    return ret;
  }
  else
  {
    *t0 = *t1 = 0;
    return 0;
  }
} /* cylinder_intersect */


/*******************************************************************************
 * sphere_intersect: Calculate intersection between a line and a sphere.
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times t0 and t1 
 *******************************************************************************/
int
sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r)
{
  double A, B, C, D, v;

  v = sqrt(vx*vx + vy*vy + vz*vz);
  A = v*v;
  B = 2*(x*vx + y*vy + z*vz);
  C = x*x + y*y + z*z - r*r;
  D = B*B - 4*A*C;
  if(D < 0)
    return 0;
  D = sqrt(D);
  *t0 = (-B - D) / (2*A);
  *t1 = (-B + D) / (2*A);
  return 1;
} /* sphere_intersect */

/*******************************************************************************
 * plane_intersect: Calculate intersection between a plane and a line.
 * returns 0 when no intersection is found (i.e. line is parallel to the plane)
 * returns 1 or -1 when intersection time is positive and negative respectively
 *******************************************************************************/
int
plane_intersect(double *t, double x, double y, double z,
                 double vx, double vy, double vz, double nx, double ny, double nz, double wx, double wy, double wz)
{
  double s;
  if (fabs(s=scalar_prod(nx,ny,nz,vx,vy,vz))<FLT_EPSILON) return 0;
  *t = - scalar_prod(nx,ny,nz,x-wx,y-wy,z-wz)/s;
  if (*t<0) return -1;
  else return 1;
} /* plane_intersect */

#endif /* !MCSTAS_H */
/* End of file "mcstas-r.c". */

#line 5307 "RITA-II.c"
#ifdef MC_TRACE_ENABLED
int mctraceenabled = 1;
#else
int mctraceenabled = 0;
#endif
#define MCSTAS "/usr/share/mcstas/2.5/"
int mcdefaultmain = 1;
char mcinstrument_name[] = "RITA_II";
char mcinstrument_source[] = "RITA-II.instr";
char *mcinstrument_exe=NULL; /* will be set to argv[0] in main */
int main(int argc, char *argv[]){return mccode_main(argc, argv);}
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);

/* Shared user declarations for all components 'Source_gen4'. */
#line 150 "/usr/share/mcstas/2.5/contrib/Source_gen4.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions.
*
* This library may be used directly as an external library. It has no dependency
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#define READ_TABLE_LIB_H "$Revision$"

#define READ_TABLE_STEPTOL  0.04 /* tolerancy for constant step approx */

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#ifdef MAC
#define MC_PATHSEP_C ':'
#define MC_PATHSEP_S ":"
#else  /* !MAC */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MC_PATHSEP_C */

#ifndef MCSTAS
#ifdef WIN32
#define MCSTAS "C:\\mcstas\\lib"
#else  /* !WIN32 */
#ifdef MAC
#define MCSTAS ":mcstas:lib" /* ToDo: What to put here? */
#else  /* !MAC */
#define MCSTAS "/usr/local/lib/mcstas"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MCSTAS */

#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

  typedef struct struct_table
  {
    char    filename[1024];
    long    filesize;
    char   *header;  /* text header, e.g. comments */
    double *data;    /* vector { x[0], y[0], ... x[n-1], y[n-1]... } */
    double  min_x;   /* min value of first column */
    double  max_x;   /* max value of first column */
    double  step_x;  /* minimal step value of first column */
    long    rows;    /* number of rows in matrix block */
    long    columns; /* number of columns in matrix block */

    long    begin;   /* start fseek index of block */
    long    end;     /* stop  fseek index of block */
    long    block_number;  /* block index. 0 is catenation of all */
    long    array_length;  /* number of elements in the t_Table array */
    char    monotonic;     /* true when 1st column/vector data is monotonic */
    char    constantstep;  /* true when 1st column/vector data has constant step */
    char    method[32];    /* interpolation method: nearest, linear */
  } t_Table;

typedef struct t_Read_table_file_item {
    int ref_count;
    t_Table *table_ref;
} t_Read_table_file_item;

typedef enum enum_Read_table_file_actions {STORE,FIND,GC}  t_Read_table_file_actions;

/* read_table-lib function prototypes */
/* ========================================================================= */

/* 'public' functions */
long     Table_Read              (t_Table *Table, char *File, long block_number);
long     Table_Read_Offset       (t_Table *Table, char *File, long block_number,
                                  long *offset, long max_lines);
long     Table_Read_Offset_Binary(t_Table *Table, char *File, char *Type,
                                  long *Offset, long Rows, long Columns);
long     Table_Rebin(t_Table *Table); /* rebin table with regular 1st column and interpolate all columns 2:end */
long     Table_Info (t_Table Table);
double   Table_Index(t_Table Table,   long i, long j); /* get indexed value */
double   Table_Value(t_Table Table, double X, long j); /* search X in 1st column and return interpolated value in j-column */
t_Table *Table_Read_Array(char *File, long *blocks);
void     Table_Free_Array(t_Table *Table);
long     Table_Info_Array(t_Table *Table);
int      Table_SetElement(t_Table *Table, long i, long j, double value);
long     Table_Init(t_Table *Table, long rows, long columns); /* create a Table */
double   Table_Value2d(t_Table Table, double X, double Y);    /* same as Table_Index with non-integer indices and 2d interpolation */
MCDETECTOR Table_Write(t_Table Table, char*file, char*xl, char*yl, 
           double x1, double x2, double y1, double y2); /* write Table to disk */
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier);
t_Table *Table_File_List_find(char *name, int block, int offset);
int Table_File_List_gc(t_Table *tab);
void *Table_File_List_store(t_Table *tab);

#define Table_ParseHeader(header, ...) \
  Table_ParseHeader_backend(header,__VA_ARGS__,NULL);

char **Table_ParseHeader_backend(char *header, ...);

/* private functions */
void Table_Free(t_Table *Table);
long Table_Read_Handle(t_Table *Table, FILE *fid, long block_number, long max_lines, char *name);
static void Table_Stat(t_Table *Table);
double Table_Interp1d(double x, double x1, double y1, double x2, double y2);
double Table_Interp1d_nearest(double x, double x1, double y1, double x2, double y2);
double Table_Interp2d(double x, double y, double x1, double y1, double x2, double y2,
double z11, double z12, double z21, double z22);

#endif

/* end of read_table-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas CVS_090504
* Version: $Revision: 5052 $
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#endif


/*******************************************************************************
 * void *Table_File_List_Handler(action, item, item_modifier)
 *   ACTION: handle file entries in the read_table-lib file list. If a file is read - it is supposed to be
 *   stored in a list such that we can avoid reading the same file many times.
 *   input  action: FIND, STORE, GC. check if file exists in the list, store an item in the list, or check if it can be garbage collected.
 *   input item: depends on the action.
 *    FIND)  item is a filename, and item_modifier is the block number
 *    STORE) item is the Table to store - item_modifier is ignored
 *    GC)    item is the Table to check. If it has a ref_count >1 then this is simply decremented.
 *   return  depends on the action
 *    FIND)  return a reference to a table+ref_count item if found - NULL otherwise. I.e. NULL means the file has not been read before and must be read again.
 *    STORE) return NULL always
 *    GC)    return NULL if no garbage collection is needed, return an adress to the t_Table which should be garbage collected. 0x1 is returned if
 *           the item is not found in the list
*******************************************************************************/
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier){

    /* logic here is Read_Table should include a call to FIND. If found the return value should just be used as
     * if the table had been read from disk. If not found then read the table and STORE.
     * Table_Free should include a call to GC. If this returns non-NULL then we should proceed with freeing the memory
     * associated with the table item - otherwise only decrement the reference counter since there are more references
     * that may need it.*/

    static t_Read_table_file_item read_table_file_list[1024];  
    static int read_table_file_count=0;

    t_Read_table_file_item *tr;
    switch(action){
        case FIND:
            /*interpret data item as a filename, if it is found return a pointer to the table and increment refcount.
             * if not found return the item itself*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                int i=*((int*) item_modifier);
                int j=*( ((int*) item_modifier)+1);
                if ( !strcmp(tr->table_ref->filename,(char *) item) &&
                        tr->table_ref->block_number==i && tr->table_ref->begin==j ){
                    tr->ref_count++;
                    return (void *) tr;
                }
                tr++;
            }
            return NULL;
        case STORE:
            /*find an available slot and store references to table there*/
            tr=&(read_table_file_list[read_table_file_count++]);
            tr->table_ref=(t_Table *)calloc(1,sizeof(t_Table));
            /*copy the contents of the table handle*/
            *(tr->table_ref)= *((t_Table *) item);
            tr->ref_count++;
            return NULL;
        case GC:
            /* Should this item be garbage collected (freed) - if so scratch the entry and return the address of the item - 
             * else decrement ref_count and return NULL.
             * A non-NULL return expects the item to actually be freed afterwards.*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                if ( tr->table_ref->data ==((t_Table *)item)->data && 
                        tr->table_ref->block_number == ((t_Table *)item)->block_number){
                    /*matching item found*/
                    if (tr->ref_count>1){
                        /*the item is found and no garbage collection needed*/
                        tr->ref_count--;
                        return NULL;
                    }else{
                        /* The item is found and the reference counter is 1.
                         * This means we should garbage collect. Move remaining list items up one slot,
                         * and return the table for garbage collection by caller*/
                        while (tr->table_ref!=NULL){
                            *tr=*(tr+1);
                            tr++;
                        }
                        read_table_file_count--;
                        return (t_Table *) item;
                    }
                }
                tr++;
            }
            /* item not found, and so should be garbage collected. This could be the case if freeing a
             * Table that has been constructed from code - not read from file. Return 0x1 to flag it for
             * collection.*/
            return (void *) 0x1 ;
    }
}

/* Access functions to the handler*/

/********************************************
 * t_Table *Table_File_List_find(char *name, int block, int offset)
 * input name: filename to search for in the file list
 * input block: data block in the file as each file may contain more than 1 data block.
 * return a ref. to a table if it is found (you may use this pointer and skip reading the file), NULL otherwise (i.e. go ahead and read the file)
*********************************************/
t_Table *Table_File_List_find(char *name, int block, int offset){
    int vars[2]={block,offset};
    t_Read_table_file_item *item = Table_File_List_Handler(FIND,name, vars);
    if (item == NULL){
        return NULL;
    }else{
        return item->table_ref;
    }
}
/********************************************
 * int Table_File_List_gc(t_Table *tab)
 * input tab: the table to check for references.
 * return 0: no garbage collection needed
 *        1: Table's data and header (at least) should be freed.
*********************************************/
int Table_File_List_gc(t_Table *tab){
    void *rval=Table_File_List_Handler(GC,tab,0);
    if (rval==NULL) return 0;
    else return 1;
}


/*****************************************************************************
 * void *Table_File_List_store(t_Table *tab)
 * input tab: pointer to table to store.
 * return None. 
*******************************************************************************/
void *Table_File_List_store(t_Table *tab){
    Table_File_List_Handler(STORE,tab,0);
}


/*******************************************************************************
* FILE *Open_File(char *name, char *Mode, char *path)
*   ACTION: search for a file and open it. Optionally return the opened path.
*   input   name:  file name from which table should be extracted
*           mode: "r", "w", "a" or any valid fopen mode
*           path:  NULL or a pointer to at least 1024 allocated chars
*   return  initialized file handle or NULL in case of error
*******************************************************************************/

  FILE *Open_File(char *File, const char *Mode, char *Path)
  {
    char path[1024];
    FILE *hfile = NULL;
    
    if (!File || File[0]=='\0')                     return(NULL);
    if (!strcmp(File,"NULL") || !strcmp(File,"0"))  return(NULL);
    
    /* search in current or full path */
    strncpy(path, File, 1024);
    hfile = fopen(path, Mode);
    if(!hfile)
    {
      char dir[1024];

      if (!hfile && mcinstrument_source && strlen(mcinstrument_source)) /* search in instrument source location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_source, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_source;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_source, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile && mcinstrument_exe && strlen(mcinstrument_exe)) /* search in PWD instrument executable location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_exe, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_exe;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_exe, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile) /* search in HOME or . */
      {
        strcpy(dir, getenv("HOME") ? getenv("HOME") : ".");
        snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MCSTAS/data */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "data", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MVCSTAS/contrib */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "contrib", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if(!hfile)
      {
        fprintf(stderr, "Error: Could not open input file '%s' (Open_File)\n", File);
        return (NULL);
      }
    }
    if (Path) strncpy(Path, path, 1024);
    return(hfile);
  } /* end Open_File */

/*******************************************************************************
* long Read_Table(t_Table *Table, char *name, int block_number)
*   ACTION: read a single Table from a text file
*   input   Table: pointer to a t_Table structure
*           name:  file name from which table should be extracted
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* File is opened, read and closed
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebinned with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read(t_Table *Table, char *File, long block_number)
  { /* reads all or a single data block from 'file' and returns a Table structure  */
    return(Table_Read_Offset(Table, File, block_number, NULL, 0));
  } /* end Table_Read */

/*******************************************************************************
* long Table_Read_Offset(t_Table *Table, char *name, int block_number, long *offset
*                        long max_rows)
*   ACTION: read a single Table from a text file, starting at offset
*     Same as Table_Read(..) except:
*   input   offset:    pointer to an offset (*offset should be 0 at start)
*           max_rows: max number of data rows to read from file (0 means all)
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset(t_Table *Table, char *File,
                         long block_number, long *offset,
                         long max_rows)
  { /* reads all/a data block in 'file' and returns a Table structure  */
    FILE *hfile;
    long  nelements=0;
    long  begin=0;
    long  filesize=0;
    char  name[1024];
    char  path[1024];
    struct stat stfile;

    /*Need to be able to store the pointer*/
    if (!Table) return(-1);
    
    //if (offset && *offset) snprintf(name, 1024, "%s@%li", File, *offset);
    //else                   
    strncpy(name, File, 1024);
    if(offset && *offset){
        begin=*offset;
    }
    /* Check if the table has already been read from file.
     * If so just reuse the table, if not (this is flagged by returning NULL
     * set up a new table and read the data into it */
    t_Table *tab_p= Table_File_List_find(name,block_number,begin);
    if ( tab_p!=NULL ){
        /*table was found in the Table_File_List*/
        // printf("Reusing input file '%s' (Table_Read_Offset)\n", name);
        *Table=*tab_p;
        return Table->rows*Table->columns;
    }

    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read_Offset)\n", path);
      );
    }
    
    /* read file state */
    stat(path,&stfile); filesize = stfile.st_size;
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    
    Table_Init(Table, 0, 0);

    /* read file content and set the Table */
    nelements = Table_Read_Handle(Table, hfile, block_number, max_rows, name);
    Table->begin = begin;
    Table->end   = ftell(hfile);
    Table->filesize = (filesize>0 ? filesize : 0);
    Table_Stat(Table);
    
    Table_File_List_store(Table);

    if (offset) *offset=Table->end;
    fclose(hfile);
    return(nelements);

  } /* end Table_Read_Offset */

/*******************************************************************************
* long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
*                               long *offset, long rows, long columns)
*   ACTION: read a single Table from a binary file, starting at offset
*     Same as Table_Read_Offset(..) except that it handles binary files.
*   input   type: may be "float"/NULL or "double"
*           offset: pointer to an offset (*offset should be 0 at start)
*           rows   : number of rows (0 means read all)
*           columns: number of columns
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
                                long *offset, long rows, long columns)
  { /* reads all/a data block in binary 'file' and returns a Table structure  */
    long    nelements, sizeofelement;
    long    filesize;
    FILE   *hfile;
    char    path[1024];
    struct stat stfile;
    double *data;
    long    i;
    long    begin;

    if (!Table) return(-1);

    Table_Init(Table, 0, 0);
    
    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read, Binary)\n", path);
      );
    }
    
    /* read file state */
    stat(File,&stfile);
    filesize = stfile.st_size;
    Table->filesize=filesize;
    
    /* read file content */
    if (type && !strcmp(type,"double")) sizeofelement = sizeof(double);
    else  sizeofelement = sizeof(float);
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    if (rows && filesize > sizeofelement*columns*rows)
      nelements = columns*rows;
    else nelements = (long)(filesize/sizeofelement);
    if (!nelements || filesize <= *offset) return(0);
    data    = (double*)malloc(nelements*sizeofelement);
    if (!data) {
      fprintf(stderr,"Error: allocating %ld elements for %s file '%s'. Too big (Table_Read_Offset_Binary).\n", nelements, type, File);
      exit(-1);
    }
    nelements = fread(data, sizeofelement, nelements, hfile);

    if (!data || !nelements)
    {
      fprintf(stderr,"Error: reading %ld elements from %s file '%s' (Table_Read_Offset_Binary)\n", nelements, type, File);
      exit(-1);
    }
    Table->begin   = begin;
    Table->end     = ftell(hfile);
    if (offset) *offset=Table->end;
    fclose(hfile);
    data = (double*)realloc(data, (double)nelements*sizeofelement);
    /* copy file data into Table */
    if (type && !strcmp(type,"double")) Table->data = data;
    else {
      float  *s;
      double *dataf;
      s     = (float*)data;
      dataf = (double*)malloc(sizeof(double)*nelements);
      for (i=0; i<nelements; i++)
        dataf[i]=s[i];
      free(data);
      Table->data = dataf;
    }
    strncpy(Table->filename, File, 1024);
    Table->rows    = nelements/columns;
    Table->columns = columns;
    Table->array_length = 1;
    Table->block_number = 1;

    Table_Stat(Table);

    return(nelements);
  } /* end Table_Read_Offset_Binary */

/*******************************************************************************
* long Table_Read_Handle(t_Table *Table, FILE *fid, int block_number, long max_rows, char *name)
*   ACTION: read a single Table from a text file handle (private)
*   input   Table:pointer to a t_Table structure
*           fid:  pointer to FILE handle
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*           max_rows: if non 0, only reads that number of lines
*   return  initialized single Table t_Table structure containing data, header, ...
*           modified Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebined with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read_Handle(t_Table *Table, FILE *hfile,
                         long block_number, long max_rows, char *name)
  { /* reads all/a data block from 'file' handle and returns a Table structure  */
    double *Data;
    char *Header              = NULL;
    long  malloc_size         = CHAR_BUF_LENGTH;
    long  malloc_size_h       = 4096;
    long  Rows = 0,   Columns = 0;
    long  count_in_array      = 0;
    long  count_in_header     = 0;
    long  block_Current_index = 0;
    char  flag_End_row_loop   = 0;

    if (!Table) return(-1);
    Table_Init(Table, 0, 0);
    if (name && name[0]!='\0') strncpy(Table->filename, name, 1024);

    if(!hfile) {
       fprintf(stderr, "Error: File handle is NULL (Table_Read_Handle).\n");
       return (-1);
    }
    Header = (char*)  calloc(malloc_size_h, sizeof(char));
    Data   = (double*)calloc(malloc_size,   sizeof(double));
    if ((Header == NULL) || (Data == NULL)) {
       fprintf(stderr, "Error: Could not allocate Table and Header (Table_Read_Handle).\n");
       return (-1);
    }

    int flag_In_array = 0;
    do { /* while (!flag_End_row_loop) */
      char  line[1024*CHAR_BUF_LENGTH];
      long  back_pos=0;   /* ftell start of line */

      back_pos = ftell(hfile);
      if (fgets(line, 1024*CHAR_BUF_LENGTH, hfile) != NULL) { /* analyse line */
        /* first skip blank and tabulation characters */
        int i = strspn(line, " \t");

        /* handle comments: stored in header */
        if (NULL != strchr("#%;/", line[i]))
        { /* line is a comment */
          count_in_header += strlen(line);
          if (count_in_header >= malloc_size_h) {
            /* if succeed and in array : add (and realloc if necessary) */
            malloc_size_h = count_in_header+4096;
            Header        = (char*)realloc(Header, malloc_size_h*sizeof(char));
          }
          strncat(Header, line, 4096);
          flag_In_array=0;
          /* exit line and file if passed desired block */
          if (block_number > 0 && block_number == block_Current_index) {
            flag_End_row_loop = 1;
          }

          /* Continue with next line */
          continue;
        }

        /* get the number of columns splitting line with strtok */
        char  *lexeme;
        char  flag_End_Line = 0;
        long  block_Num_Columns = 0;
        const char seps[] = " ,;\t\n\r";

        lexeme = strtok(line, seps);
        while (!flag_End_Line) {
          if ((lexeme != NULL) && (lexeme[0] != '\0')) {
            /* reading line: the token is not empty */
            double X;
            int    count=1;
            /* test if we have 'NaN','Inf' */
            if (!strncasecmp(lexeme,"NaN",3))
              X = 0;
            else if (!strncasecmp(lexeme,"Inf",3) || !strncasecmp(lexeme,"+Inf",4))
              X = FLT_MAX;
            else if (!strncasecmp(lexeme,"-Inf",4))
              X = -FLT_MAX;
            else
              count = sscanf(lexeme,"%lg",&X);
            if (count == 1) {
              /* reading line: the token is a number in the line */
              if (!flag_In_array) {
                /* reading num: not already in a block: starts a new data block */
                block_Current_index++;
                flag_In_array    = 1;
                block_Num_Columns= 0;
                if (block_number > 0) {
                  /* initialise a new data block */
                  Rows = 0;
                  count_in_array = 0;
                } /* else append */
              }
              /* reading num: all blocks or selected block */
              if (flag_In_array && (block_number == 0 ||
                  block_number == block_Current_index)) {
                /* starting block: already the desired number of rows ? */
                if (block_Num_Columns == 0 &&
                    max_rows > 0 && Rows >= max_rows) {
                  flag_End_Line      = 1;
                  flag_End_row_loop  = 1;
                  flag_In_array      = 0;
                  /* reposition to begining of line (ignore line) */
                  fseek(hfile, back_pos, SEEK_SET);
                } else { /* store into data array */
                  if (count_in_array >= malloc_size) {
                    /* realloc data buffer if necessary */
                    malloc_size = count_in_array+CHAR_BUF_LENGTH;
                    Data = (double*) realloc(Data, malloc_size*sizeof(double));
                    if (Data == NULL) {
                      fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Handle).\n",
                              malloc_size*sizeof(double));
                      return (-1);
                    }
                  }
                  if (0 == block_Num_Columns) Rows++;
                  Data[count_in_array] = X;
                  count_in_array++;
                  block_Num_Columns++;
                }
              } /* reading num: end if flag_In_array */
            } /* end reading num: end if sscanf lexeme -> numerical */
            else {
              /* reading line: the token is not numerical in that line. end block */
              if (block_Current_index == block_number) {
                flag_End_Line = 1;
                flag_End_row_loop = 1;
              } else {
                flag_In_array = 0;
                flag_End_Line = 1;
              }
            }
          }
          else {
            /* no more tokens in line */
            flag_End_Line = 1;
            if (block_Num_Columns > 0) Columns = block_Num_Columns;
          }

          // parse next token
          lexeme = strtok(NULL, seps);

        } /* while (!flag_End_Line) */
      } /* end: if fgets */
      else flag_End_row_loop = 1; /* else fgets : end of file */

    } while (!flag_End_row_loop); /* end while flag_End_row_loop */

    Table->block_number = block_number;
    Table->array_length = 1;

    // shrink header to actual size (plus terminating 0-byte)
    if (count_in_header) {
      Header = (char*)realloc(Header, count_in_header*sizeof(char) + 1);
    }
    Table->header = Header;

    if (count_in_array*Rows*Columns == 0)
    {
      Table->rows         = 0;
      Table->columns      = 0;
      free(Data);
      return (0);
    }
    if (Rows * Columns != count_in_array)
    {
      fprintf(stderr, "Warning: Read_Table :%s %s Data has %li values that should be %li x %li\n",
        (Table->filename ? Table->filename : ""),
        (!block_number ? " catenated" : ""),
        count_in_array, Rows, Columns);
      Columns = count_in_array; Rows = 1;
    }
    Data     = (double*)realloc(Data, count_in_array*sizeof(double));
    Table->data         = Data;
    Table->rows         = Rows;
    Table->columns      = Columns;

    return (count_in_array);

  } /* end Table_Read_Handle */

/*******************************************************************************
* long Table_Rebin(t_Table *Table)
*   ACTION: rebin a single Table, sorting 1st column in ascending order
*   input   Table: single table containing data.
*                  The data block is reallocated in this process
*   return  updated Table with increasing, evenly spaced first column (index 0)
*           number of data elements (-1: error, 0:empty data)
*******************************************************************************/
  long Table_Rebin(t_Table *Table)
  {
    double new_step=0;
    long   i;
    /* performs linear interpolation on X axis (0-th column) */

    if (!Table) return(-1);
    if (!Table->data 
    || Table->rows*Table->columns == 0 || !Table->step_x)
      return(0);
    Table_Stat(Table); /* recompute statitstics and minimal step */
    new_step = Table->step_x; /* minimal step in 1st column */

    if (!(Table->constantstep)) /* not already evenly spaced */
    {
      long Length_Table;
      double *New_Table;

      Length_Table = ceil(fabs(Table->max_x - Table->min_x)/new_step)+1;
      New_Table    = (double*)malloc(Length_Table*Table->columns*sizeof(double));

      for (i=0; i < Length_Table; i++)
      {
        long   j;
        double X;
        X = Table->min_x + i*new_step;
        New_Table[i*Table->columns] = X;
        for (j=1; j < Table->columns; j++)
          New_Table[i*Table->columns+j]
                = Table_Value(*Table, X, j);
      } /* end for i */

      Table->rows = Length_Table;
      Table->step_x = new_step;
      Table->max_x = Table->min_x + (Length_Table-1)*new_step; 
      /*max might not be the same anymore
       * Use Length_Table -1 since the first and laset rows are the limits of the defined interval.*/
      free(Table->data);
      Table->data = New_Table;
      Table->constantstep=1;
    } /* end else (!constantstep) */
    return (Table->rows*Table->columns);
  } /* end Table_Rebin */

/*******************************************************************************
* double Table_Index(t_Table Table, long i, long j)
*   ACTION: read an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*   return  Value = data[i][j]
* Returns Value from the i-th row, j-th column of Table
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif

double Table_Index(t_Table Table, long i, long j)
{
  long AbsIndex;

  if (Table.rows == 1 || Table.columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table.columns*Table.rows - 1);
    i = 0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table.rows - 1);
    j = MIN(MAX(0, j), Table.columns - 1);
  }

  /* handle vectors specifically */
  AbsIndex = i*(Table.columns)+j;

  if (Table.data != NULL)
    return (Table.data[AbsIndex]);
  else
    return 0;
} /* end Table_Index */

/*******************************************************************************
* void Table_SetElement(t_Table *Table, long i, long j, double value)
*   ACTION: set an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*           value = data[i][j]
* Returns 0 in case of error
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/
int Table_SetElement(t_Table *Table, long i, long j,
                     double value)
{
  long AbsIndex;

  if (Table->rows == 1 || Table->columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table->columns*Table->rows - 1); i=0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table->rows - 1);
    j = MIN(MAX(0, j), Table->columns - 1);
  }

  AbsIndex = i*(Table->columns)+j;
  if (Table->data != NULL) {
    Table->data[AbsIndex] = value;
    return 1;
  }

  return 0;
} /* end Table_SetElement */

/*******************************************************************************
* double Table_Value(t_Table Table, double X, long j)
*   ACTION: read column [j] of a single Table at row which 1st column is X
*   input   Table: table containing data.
*           X : data value in the first column (index 0)
*           j : index of column from which is extracted the Value (0:Columns-1)
*   return  Value = data[index for X][j] with linear interpolation
* Returns Value from the j-th column of Table corresponding to the
* X value for the 1st column (index 0)
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
double Table_Value(t_Table Table, double X, long j)
{
  long   Index = -1;
  double X1=0, Y1=0, X2=0, Y2=0;
  double ret=0;

  if (X > Table.max_x) return Table_Index(Table,Table.rows-1  ,j);
  if (X < Table.min_x) return Table_Index(Table,0  ,j);

  // Use constant-time lookup when possible
  if(Table.constantstep) {
    Index = (long)floor(
              (X - Table.min_x) / (Table.max_x - Table.min_x) * (Table.rows-1));
    X1 = Table_Index(Table,Index  ,0);
    X2 = Table_Index(Table,Index+1,0);
  }
  // Use binary search on large, monotonic tables
  else if(Table.monotonic && Table.rows > 100) {
    long left = Table.min_x;
    long right = Table.max_x;

    while (!((X1 <= X) && (X < X2)) && (right - left > 1)) {
      Index = (left + right) / 2;

      X1 = Table_Index(Table, Index-1, 0);
      X2 = Table_Index(Table, Index,   0);

      if (X < X1) {
        right = Index;
      } else {
        left  = Index;
      }
    }
  }

  // Fall back to linear search, if no-one else has set X1, X2 correctly
  if (!((X1 <= X) && (X < X2))) {
    /* look for index surrounding X in the table -> Index */
    for (Index=1; Index <= Table.rows-1; Index++) {
        X1 = Table_Index(Table, Index-1,0);
        X2 = Table_Index(Table, Index  ,0);
        if ((X1 <= X) && (X < X2)) break;
      } /* end for Index */
  }

  Y1 = Table_Index(Table,Index-1,j);
  Y2 = Table_Index(Table,Index  ,j);

  if (!strcmp(Table.method,"linear")) {
    ret = Table_Interp1d(X, X1,Y1, X2,Y2);
  }
  else if (!strcmp(Table.method,"nearest")) {
    ret = Table_Interp1d_nearest(X, X1,Y1, X2,Y2);
  }

  return ret;
} /* end Table_Value */

/*******************************************************************************
* double Table_Value2d(t_Table Table, double X, double Y)
*   ACTION: read element [X,Y] of a matrix Table
*   input   Table: table containing data.
*           X : row index, may be non integer
*           Y : column index, may be non integer
*   return  Value = data[index X][index Y] with bi-linear interpolation
* Returns Value for the indices [X,Y]
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
  double Table_Value2d(t_Table Table, double X, double Y)
  {
    long   x1,x2,y1,y2;
    double z11,z12,z21,z22;
    double ret=0;

    x1 = (long)floor(X);
    y1 = (long)floor(Y);

    if (x1 > Table.rows-1 || x1 < 0) {
      x2 = x1;
    } else {
      x2 = x1 + 1;
    }

    if (y1 > Table.columns-1 || y1 < 0) {
      y2 = y1;
    } else {
      y2 = y1 + 1;
    }

    z11 = Table_Index(Table, x1, y1);

    if (y2 != y1) z12=Table_Index(Table, x1, y2); else z12 = z11;
    if (x2 != x1) z21=Table_Index(Table, x2, y1); else z21 = z11;
    if (y2 != y1) z22=Table_Index(Table, x2, y2); else z22 = z21;

    if (!strcmp(Table.method,"linear"))
      ret = Table_Interp2d(X,Y, x1,y1,x2,y2, z11,z12,z21,z22);
    else {
      if (fabs(X-x1) < fabs(X-x2)) {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z11; else ret = z12;
      } else {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z21; else ret = z22;
      }
    }
    return ret;
  } /* end Table_Value2d */


/*******************************************************************************
* void Table_Free(t_Table *Table)
*   ACTION: free a single Table. First Call Table_File_list_gc. If this returns
*   non-zero it means there are more refernces to the table, and so the table
*   should not bee freed.
*   return: empty Table
*******************************************************************************/
  void Table_Free(t_Table *Table)
  {
    if( !Table_File_List_gc(Table) ){
       return;
    } 
    if (!Table) return;
    if (Table->data   != NULL) free(Table->data);
    if (Table->header != NULL) free(Table->header);
    Table->data   = NULL;
    Table->header = NULL;
  } /* end Table_Free */

/******************************************************************************
* void Table_Info(t_Table Table)
*    ACTION: print informations about a single Table
*******************************************************************************/
  long Table_Info(t_Table Table)
  {
    char buffer[256];
    long ret=0;

    if (!Table.block_number) strcpy(buffer, "catenated");
    else sprintf(buffer, "block %li", Table.block_number);
    printf("Table from file '%s' (%s)",
      Table.filename ? Table.filename : "", buffer);
    if ((Table.data != NULL) && (Table.rows*Table.columns))
    {
      printf(" is %li x %li ", Table.rows, Table.columns);
      if (Table.rows*Table.columns > 1)
        printf("(x=%g:%g)", Table.min_x, Table.max_x);
      else printf("(x=%g) ", Table.min_x);
      ret = Table.rows*Table.columns;
      if (Table.monotonic)    printf(", monotonic");
      if (Table.constantstep) printf(", constant step");
      printf(". interpolation: %s\n", Table.method);
    }
    else printf(" is empty.\n");

    if (Table.header && strlen(Table.header)) {
      char *header;
      int  i;
      header = malloc(80);
      if (!header) return(ret);
      for (i=0; i<80; header[i++]=0);
      strncpy(header, Table.header, 75);
      if (strlen(Table.header) > 75) {
        strcat( header, " ...");
      }
      for (i=0; i<strlen(header); i++)
        if (header[i] == '\n' || header[i] == '\r') header[i] = ';';
      printf("  '%s'\n", header);
      free(header);
    }

    return(ret);
  } /* end Table_Info */

/******************************************************************************
* long Table_Init(t_Table *Table, m, n)
*   ACTION: initialise a Table to empty m by n table
*   return: empty Table
******************************************************************************/
long Table_Init(t_Table *Table, long rows, long columns)
{
  double *data=NULL;
  long   i;

  if (!Table) return(0);

  Table->header  = NULL;
  Table->filename[0]= '\0';
  Table->filesize= 0;
  Table->min_x   = 0;
  Table->max_x   = 0;
  Table->step_x  = 0;
  Table->block_number = 0;
  Table->array_length = 0;
  Table->monotonic    = 0;
  Table->constantstep = 0;
  Table->begin   = 0;
  Table->end     = 0;
  strcpy(Table->method,"linear");

  if (rows*columns >= 1) {
    data    = (double*)malloc(rows*columns*sizeof(double));
    if (data) for (i=0; i < rows*columns; data[i++]=0);
    else {
      fprintf(stderr,"Error: allocating %ld double elements."
                     "Too big (Table_Init).\n", rows*columns);
      rows = columns = 0;
    }
  }
  Table->rows    = (rows >= 1 ? rows : 0);
  Table->columns = (columns >= 1 ? columns : 0);
  Table->data    = data;
  return(Table->rows*Table->columns);
} /* end Table_Init */

/******************************************************************************
* long Table_Write(t_Table Table, char *file, x1,x2, y1,y2)
*   ACTION: write a Table to disk (ascii).
*     when x1=x2=0 or y1=y2=0, the table default limits are used.
*   return: 0=all is fine, non-0: error
*******************************************************************************/
MCDETECTOR Table_Write(t_Table Table, char *file, char *xl, char *yl, 
  double x1, double x2, double y1, double y2)
{
  long    i =0;
  MCDETECTOR detector;

  if ((Table.data == NULL) && (Table.rows*Table.columns)) {
    detector.m = 0;
    return(detector); /* Table is empty - nothing to do */
  }
  if (!x1 && !x2) {
    x1 = Table.min_x;
    x2 = Table.max_x;
  }
  if (!y1 && !y2) {
    y1 = 1;
    y2 = Table.columns;
  }

  /* transfer content of the Table into a 2D detector */
  Coords coords = { 0, 0, 0};

  if (Table.rows == 1 || Table.columns == 1) {
    detector = mcdetector_out_1D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      "x", x1, x2,
                      Table.rows * Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  } else {
    detector = mcdetector_out_2D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      x1, x2, y1, y2,
                      Table.rows, Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  }
  return(detector);
}

/******************************************************************************
* void Table_Stat(t_Table *Table)
*   ACTION: computes min/max/mean step of 1st column for a single table (private)
*   return: updated Table
*******************************************************************************/
  static void Table_Stat(t_Table *Table)
  {
    long   i;
    double max_x, min_x;
    double row=1;
    char   monotonic=1;
    char   constantstep=1;
    double step=0;
    long n;

    if (!Table) return;
    if (!Table->rows || !Table->columns) return;
    if (Table->rows == 1) row=0; // single row
    max_x = -FLT_MAX;
    min_x =  FLT_MAX;
    n     = (row ? Table->rows : Table->columns);
    /* get min and max of first column/vector */
    for (i=0; i < n; i++)
    {
      double X;
      X = (row ? Table_Index(*Table,i  ,0)
                               : Table_Index(*Table,0, i));
      if (X < min_x) min_x = X;
      if (X > max_x) max_x = X;
    } /* for */
    
    /* test for monotonicity and constant step if the table is an XY or single vector */
    if (n > 1) {
      /* mean step */
      step = (max_x - min_x)/(n-1);
      /* now test if table is monotonic on first column, and get minimal step size */
      for (i=0; i < n-1; i++) {
        double X, diff;;
        X    = (row ? Table_Index(*Table,i  ,0)
                    : Table_Index(*Table,0,  i));
        diff = (row ? Table_Index(*Table,i+1,0)
                    : Table_Index(*Table,0,  i+1)) - X;
        if (diff && fabs(diff) < fabs(step)) step = diff;
        /* change sign ? */
        if ((max_x - min_x)*diff < 0 && monotonic)
          monotonic = 0;
      } /* end for */
      
      /* now test if steps are constant within READ_TABLE_STEPTOL */
      if(!step){
        /*means there's a disconitnuity -> not constantstep*/
        constantstep=0;
      }else if (monotonic) {
        for (i=0; i < n-1; i++) {
          double X, diff;
          X    = (row ? Table_Index(*Table,i  ,0)
              : Table_Index(*Table,0,  i));
          diff = (row ? Table_Index(*Table,i+1,0)
              : Table_Index(*Table,0,  i+1)) - X;
          if ( fabs(step)*(1+READ_TABLE_STEPTOL) < fabs(diff) ||
                fabs(diff) < fabs(step)*(1-READ_TABLE_STEPTOL) )
          { constantstep = 0; break; }
        }
      }

    }
    Table->step_x= step;
    Table->max_x = max_x;
    Table->min_x = min_x;
    Table->monotonic = monotonic;
    Table->constantstep = constantstep;
  } /* end Table_Stat */

/******************************************************************************
* t_Table *Table_Read_Array(char *File, long *blocks)
*   ACTION: read as many data blocks as available, iteratively from file
*   return: initialized t_Table array, last element is an empty Table.
*           the number of extracted blocks in non NULL pointer *blocks
*******************************************************************************/
  t_Table *Table_Read_Array(char *File, long *blocks)
  {
    t_Table *Table_Array=NULL;
    long offset=0;
    long block_number=0;
    long allocated=256;
    long nelements=1;

    /* first allocate an initial empty t_Table array */
    Table_Array = (t_Table *)malloc(allocated*sizeof(t_Table));
    if (!Table_Array) {
      fprintf(stderr, "Error: Can not allocate memory %li (Table_Read_Array).\n",
         allocated*sizeof(t_Table));
      *blocks = 0;
      return (NULL);
    }

    while (nelements > 0)
    {
      t_Table Table;

      /* if ok, set t_Table block number else exit loop */
      block_number++;
      Table.block_number = block_number;
      
      /* access file at offset and get following block. Block number is from the set offset
       * hence the hardcoded 1 - i.e. the next block counted from offset.*/
      nelements = Table_Read_Offset(&Table, File, 1, &offset,0);
      /*if the block is empty - don't store it*/
      if (nelements>0){
          /* if t_Table array is not long enough, expand and realocate */
          if (block_number >= allocated-1) {
              allocated += 256;
              Table_Array = (t_Table *)realloc(Table_Array,
                      allocated*sizeof(t_Table));
              if (!Table_Array) {
                  fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Array).\n",
                          allocated*sizeof(t_Table));
                  *blocks = 0;
                  return (NULL);
              }
          }
          /* store it into t_Table array */
          //snprintf(Table.filename, 1024, "%s#%li", File, block_number-1);
          Table_Array[block_number-1] = Table;
      }
      /* continues until we find an empty block */
    }
    /* send back number of extracted blocks */
    if (blocks) *blocks = block_number-1;

    /* now store total number of elements in Table array */
    for (offset=0; offset < block_number;
      Table_Array[offset++].array_length = block_number-1);

    return(Table_Array);
  } /* end Table_Read_Array */
/*******************************************************************************
* void Table_Free_Array(t_Table *Table)
*   ACTION: free a Table array
*******************************************************************************/
  void Table_Free_Array(t_Table *Table)
  {
    long index;
    if (!Table) return;
    for (index=0;index < Table[0].array_length; index++){
            Table_Free(&Table[index]);
    }
    free(Table);
  } /* end Table_Free_Array */

/******************************************************************************
* long Table_Info_Array(t_Table *Table)
*    ACTION: print informations about a Table array
*    return: number of elements in the Table array
*******************************************************************************/
  long Table_Info_Array(t_Table *Table)
  {
    long index=0;

    if (!Table) return(-1);
    while (index < Table[index].array_length
       && (Table[index].data || Table[index].header)
       && (Table[index].rows*Table[index].columns) ) {
      Table_Info(Table[index]);
      index++;
    }
    printf("This Table array contains %li elements\n", index);
    return(index);
  } /* end Table_Info_Array */

/******************************************************************************
* char **Table_ParseHeader(char *header, symbol1, symbol2, ..., NULL)
*    ACTION: search for char* symbols in header and return their value or NULL
*            the search is not case sensitive.
*            Last argument MUST be NULL
*    return: array of char* with line following each symbol, or NULL if not found
*******************************************************************************/
#ifndef MyNL_ARGMAX
#define MyNL_ARGMAX 50
#endif

char **Table_ParseHeader_backend(char *header, ...){
  va_list ap;
  char exit_flag=0;
  int counter   =0;
  char **ret    =NULL;
  if (!header || header[0]=='\0') return(NULL);

  ret = (char**)calloc(MyNL_ARGMAX, sizeof(char*));
  if (!ret) {
    printf("Table_ParseHeader: Cannot allocate %i values array for Parser (Table_ParseHeader).\n",
      MyNL_ARGMAX);
    return(NULL);
  }
  for (counter=0; counter < MyNL_ARGMAX; ret[counter++] = NULL);
  counter=0;

  va_start(ap, header);
  while(!exit_flag && counter < MyNL_ARGMAX-1)
  {
    char *arg_char=NULL;
    char *pos     =NULL;
    /* get variable argument value as a char */
    arg_char = va_arg(ap, char *);
    if (!arg_char || arg_char[0]=='\0'){
      exit_flag = 1; break;
    }
    /* search for the symbol in the header */
    pos = (char*)strcasestr(header, arg_char);
    if (pos) {
      char *eol_pos;
      eol_pos = strchr(pos+strlen(arg_char), '\n');
      if (!eol_pos)
        eol_pos = strchr(pos+strlen(arg_char), '\r');
      if (!eol_pos)
        eol_pos = pos+strlen(pos)-1;
      ret[counter] = (char*)malloc(eol_pos - pos);
      if (!ret[counter]) {
        printf("Table_ParseHeader: Cannot allocate value[%i] array for Parser searching for %s (Table_ParseHeader).\n",
          counter, arg_char);
        exit_flag = 1; break;
      }
      strncpy(ret[counter], pos+strlen(arg_char), eol_pos - pos - strlen(arg_char));
      ret[counter][eol_pos - pos - strlen(arg_char)]='\0';
    }
    counter++;
  }
  va_end(ap);
  return(ret);
} /* Table_ParseHeader */

/******************************************************************************
* double Table_Interp1d(x, x1, y1, x2, y2)
*    ACTION: interpolates linearly at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d(double x,
  double x1, double y1,
  double x2, double y2)
{
  double slope;
  if (x2 == x1) return (y1+y2)/2;
  if (y1 == y2) return  y1;
  slope = (y2 - y1)/(x2 - x1);
  return y1+slope*(x - x1);
} /* Table_Interp1d */

/******************************************************************************
* double Table_Interp1d_nearest(x, x1, y1, x2, y2)
*    ACTION: table lookup with nearest method at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d_nearest(double x,
  double x1, double y1,
  double x2, double y2)
{
  if (fabs(x-x1) < fabs(x-x2)) return (y1);
  else return(y2);
} /* Table_Interp1d_nearest */

/******************************************************************************
* double Table_Interp2d(x,y, x1,y1, x2,y2, z11,z12,z21,z22)
*    ACTION: interpolates bi-linearly at (x,y) between z1=f(x1,y1) and z2=f(x2,y2)
*    return: z=f(x,y) value
*    x,y |   x1   x2
*    ----------------
*     y1 |   z11  z21
*     y2 |   z12  z22
*******************************************************************************/
double Table_Interp2d(double x, double y,
  double x1, double y1,
  double x2, double y2,
  double z11, double z12, double z21, double z22)
{
  double ratio_x, ratio_y;
  if (x2 == x1) return Table_Interp1d(y, y1,z11, y2,z12);
  if (y1 == y2) return Table_Interp1d(x, x1,z11, x2,z21);

  ratio_y = (y - y1)/(y2 - y1);
  ratio_x = (x - x1)/(x2 - x1);
  return (1-ratio_x)*(1-ratio_y)*z11 + ratio_x*(1-ratio_y)*z21
    + ratio_x*ratio_y*z22         + (1-ratio_x)*ratio_y*z12;
} /* Table_Interp2d */

/* end of read_table-lib.c */


#ifndef SOURCE_GEN_DEF
#define SOURCE_GEN_DEF
/*******************************************************************************
* str_dup_numeric: makes a clean copy of a string and allocate as numeric
*******************************************************************************/
char *str_dup_numeric(char *orig)
{
  long i;
  char *valid;

  if (!orig || !strlen(orig)) return(NULL);

  for (i=0; i < strlen(orig); i++)
  {
    if ( (orig[i] > 122)
      || (orig[i] < 32)
      || (strchr("!\"#$%&'()*,:;<=>?@[\\]^`/ ", orig[i]) != NULL) )
    {
      orig[i] = ' ';
    }
  }
  orig[i] = '\0';
  /* now skip spaces */
  for (i=0; i < strlen(orig); i++) {
    if (*orig == ' ') orig++;
    else break;
  }

  return(orig);
} /* str_dup_numeric */
#endif
#line 6796 "RITA-II.c"

/* Shared user declarations for all components 'Guide'. */
#line 63 "/usr/share/mcstas/2.5/optics/Guide.comp"

/*****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.h
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Depends on read_table-lib
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/


#ifndef REF_LIB_H
#define REF_LIB_H "$Revision$"

void StdReflecFunc(double, double*, double*);
void TableReflecFunc(double, t_Table*, double*);

#endif

/* end of ref-lib.h */
/****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.c
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Variable names have prefix 'mc_ref_' for 'McStas Reflection' 
* to avoid conflicts
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/

#ifndef REF_LIB_H
#include "ref-lib.h"
#endif

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#include "read_table-lib.c"
#endif

/****************************************************************************
* void StdReflecFunc(double q, double *par, double *r)
* 
* The McStas standard analytic parametrization of the reflectivity.
* The parameters are:
* R0:      [1]    Low-angle reflectivity
* Qc:      [AA-1] Critical scattering vector
* alpha:   [AA]   Slope of reflectivity
* m:       [1]    m-value of material. Zero means completely absorbing.
* W:       [AA-1] Width of supermirror cut-off
*****************************************************************************/
void StdReflecFunc(double mc_pol_q, double *mc_pol_par, double *mc_pol_r) {
    double R0    = mc_pol_par[0];
    double Qc    = mc_pol_par[1];
    double alpha = mc_pol_par[2];
    double m     = mc_pol_par[3];
    double W     = mc_pol_par[4];
    double beta  = 0;
    mc_pol_q     = fabs(mc_pol_q);
    double arg;
        
    /* Simpler parametrization from Henrik Jacobsen uses these values that depend on m only.
       double m_value=m*0.9853+0.1978;
       double W=-0.0002*m_value+0.0022;
       double alpha=0.2304*m_value+5.0944;
       double beta=-7.6251*m_value+68.1137; 
       If W and alpha are set to 0, use Henrik's approach for estimating these parameters
       and apply the formulation:
       arg = R0*0.5*(1-tanh(arg))*(1-alpha*(q-Qc)+beta*(q-Qc)*(q-Qc));
    */  
    if (W==0 && alpha==0) {
      m=m*0.9853+0.1978;
      W=-0.0002*m+0.0022;
      alpha=0.2304*m+5.0944;
      beta=-7.6251*m+68.1137;
      if (m<=3) {
	alpha=m;
	beta=0;
      }
    }
    
    arg = W > 0 ? (mc_pol_q - m*Qc)/W : 11;

    if (arg > 10 || m <= 0 || Qc <=0 || R0 <= 0) {
      *mc_pol_r = 0;
      return;
    }
    
    if (m < 1) { Qc *= m; m=1; }
    
    if(mc_pol_q <= Qc) {      
      *mc_pol_r = R0;
      return;
    }
    
    
    *mc_pol_r = R0*0.5*(1 - tanh(arg))*(1 - alpha*(mc_pol_q - Qc) + beta*(mc_pol_q - Qc)*(mc_pol_q - Qc));
    
    return;
  }

/****************************************************************************
* void TableReflecFunc(double q, t_Table *par, double *r) {
* 
* Looks up the reflectivity in a table using the routines in read_table-lib.
*****************************************************************************/
void TableReflecFunc(double mc_pol_q, t_Table *mc_pol_par, double *mc_pol_r) {
    
  *mc_pol_r = Table_Value(*mc_pol_par, mc_pol_q, 1);
  if(*mc_pol_r>1)
    *mc_pol_r = 1;
  return;
}

/* end of ref-lib.c */

#line 6949 "RITA-II.c"

/* Shared user declarations for all components 'Monochromator_curved'. */
#line 109 "/usr/share/mcstas/2.5/optics/Monochromator_curved.comp"
#ifndef GAUSS
/* Define these arrays only once for all instances. */
/* Values for Gauss quadrature. Taken from Brice Carnahan, H. A. Luther and
James O Wilkes, "Applied numerical methods", Wiley, 1969, page 103.
This reference is available from the Copenhagen UB2 library */
double Gauss_X[] = {-0.987992518020485, -0.937273392400706, -0.848206583410427,
-0.724417731360170, -0.570972172608539, -0.394151347077563,
-0.201194093997435, 0, 0.201194093997435,
0.394151347077563, 0.570972172608539, 0.724417731360170,
0.848206583410427, 0.937273392400706, 0.987992518020485};
double Gauss_W[] = {0.030753241996117, 0.070366047488108, 0.107159220467172,
0.139570677926154, 0.166269205816994, 0.186161000115562,
0.198431485327111, 0.202578241925561, 0.198431485327111,
0.186161000115562, 0.166269205816994, 0.139570677926154,
0.107159220467172, 0.070366047488108, 0.030753241996117};


#define GAUSS(x,mean,rms) \
  (exp(-((x)-(mean))*((x)-(mean))/(2*(rms)*(rms)))/(sqrt(2*PI)*(rms)))
#endif


#line 6975 "RITA-II.c"

/* Shared user declarations for all components 'Filter_gen'. */
#line 82 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
#ifndef FILTER_GEN
  #define FILTER_GEN $Revision$
  #define UNKNOWN_TABLE    0
  #define ENERGY_TABLE     1
  #define WAVEVECTOR_TABLE 2
  #define WAVELENGTH_TABLE 3
  #define FLUX_ADAPT_SET   0
  #define FLUX_ADAPT_MULT  1
  #define FLUX_ADAPT_ADD   2

  char FilterGen_Mode(char *str, char *Mode, char *Type, double *verbose)
  {
    long i;
    char *c;
    if (!str || !strlen(str)) return(0);
    c = malloc(strlen(str));
    for (i=0; i<strlen(str); i++) c[i] = tolower(str[i]);
    /* setup options */
    if (strstr(str," k ") || strstr(str," q ") || strstr(str,"wavevector"))
      *Type = WAVEVECTOR_TABLE;
    if (strstr(str,"omega") || strstr(str," e ") || strstr(str,"energy"))
      *Type = ENERGY_TABLE;
    if (strstr(str,"lambda") || strstr(str,"wavelength") || strstr(str," L "))
      *Type = WAVELENGTH_TABLE;
    if (strstr(str,"set")) *Mode  = FLUX_ADAPT_SET;
    if (strstr(str,"add")) *Mode  = FLUX_ADAPT_ADD;
    if (strstr(str,"multiply")) *Mode  = FLUX_ADAPT_MULT;
    if (strstr(str,"verbose")) *verbose = 1;

    return(*Mode);
  }

#endif
#line 7012 "RITA-II.c"

/* Shared user declarations for all components 'Virtual_output'. */
#line 67 "/usr/share/mcstas/2.5/sources/Virtual_output.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H

#define MONITOR_ND_LIB_H "$Revision$"
#define MONnD_COORD_NMAX  30  /* max number of variables to record */

  typedef struct MonitornD_Defines
  {
    int COORD_NONE  ;
    int COORD_X     ;
    int COORD_Y     ;
    int COORD_Z     ;
    int COORD_RADIUS; 
    int COORD_VX    ;
    int COORD_VY    ;
    int COORD_VZ    ;
    int COORD_V     ;
    int COORD_T     ;
    int COORD_P     ;
    int COORD_SX    ;
    int COORD_SY    ;
    int COORD_SZ    ;
    int COORD_KX    ;
    int COORD_KY    ;
    int COORD_KZ    ;
    int COORD_K     ;
    int COORD_ENERGY;
    int COORD_LAMBDA;
    int COORD_KXY   ;
    int COORD_KYZ   ;
    int COORD_KXZ   ;
    int COORD_VXY   ;
    int COORD_VYZ   ;
    int COORD_VXZ   ;
    int COORD_HDIV  ;
    int COORD_VDIV  ;
    int COORD_ANGLE ;
    int COORD_NCOUNT;
    int COORD_THETA ;
    int COORD_PHI   ;
    int COORD_USER1 ;
    int COORD_USER2 ;
    int COORD_USER3 ;
    int COORD_XY    ;
    int COORD_XZ    ;
    int COORD_YZ    ;
    int COORD_PIXELID;

    /* token modifiers */
    int COORD_VAR   ; /* next token should be a variable or normal option */
    int COORD_MIN   ; /* next token is a min value */
    int COORD_MAX   ; /* next token is a max value */
    int COORD_DIM   ; /* next token is a bin value */
    int COORD_FIL   ; /* next token is a filename */
    int COORD_EVNT  ; /* next token is a buffer size value */
    int COORD_3HE   ; /* next token is a 3He pressure value */
    int COORD_LOG   ; /* next variable will be in log scale */
    int COORD_ABS   ; /* next variable will be in abs scale */
    int COORD_SIGNAL; /* next variable will be the signal var */
    int COORD_AUTO  ; /* set auto limits */

    char TOKEN_DEL[32]; /* token separators */

    char SHAPE_SQUARE; /* shape of the monitor */
    char SHAPE_DISK  ;
    char SHAPE_SPHERE;
    char SHAPE_CYLIND;
    char SHAPE_BANANA; /* cylinder without top/bottom, on restricted angular area */
    char SHAPE_BOX   ;
    char SHAPE_PREVIOUS;
    char SHAPE_OFF;

  } MonitornD_Defines_type;

  typedef struct MonitornD_Variables
  {
    double area;
    double Sphere_Radius     ;
    double Cylinder_Height   ;
    char   Flag_With_Borders ;   /* 2 means xy borders too */
    char   Flag_List         ;   /* 1 store 1 buffer, 2 is list all, 3 list all+append */
    char   Flag_Multiple     ;   /* 1 when n1D, 0 for 2D */
    char   Flag_Verbose      ;
    int    Flag_Shape        ;
    char   Flag_Auto_Limits  ;   /* get limits from first Buffer */
    char   Flag_Absorb       ;   /* monitor is also a slit */
    char   Flag_per_cm2      ;   /* flux is per cm2 */
    char   Flag_log          ;   /* log10 of the flux */
    char   Flag_parallel     ;   /* set neutron state back after detection (parallel components) */
    char   Flag_Binary_List  ;
    char   Flag_capture      ;   /* lambda monitor with lambda/lambda(2200m/s = 1.7985 Angs) weightening */
    int    Flag_signal       ;   /* 0:monitor p, else monitor a mean value */
    int    Flag_mantid       ;   /* 0:normal monitor, else do mantid-event specifics */
    int    Flag_OFF          ;   /* Flag to indicate external geometry from OFF file */
    unsigned long OFF_polyidx;   /* When intersection is done externally by off_intersect, this gives the 
				    polygon number, i.e. pixel index */

    unsigned long Coord_Number      ;   /* total number of variables to monitor, plus intensity (0) */
    unsigned long Coord_NumberNoPixel;  /* same but without counting PixelID */
    unsigned long Buffer_Block      ;   /* Buffer size for list or auto limits */
    unsigned long Neutron_Counter   ;   /* event counter, simulation total counts is mcget_ncount() */
    unsigned long Buffer_Counter    ;   /* index in Buffer size (for realloc) */
    unsigned long Buffer_Size       ;
    int    Coord_Type[MONnD_COORD_NMAX];      /* type of variable */
    char   Coord_Label[MONnD_COORD_NMAX][30]; /* label of variable */
    char   Coord_Var[MONnD_COORD_NMAX][30];   /* short id of variable */
    long   Coord_Bin[MONnD_COORD_NMAX];       /* bins of variable array */
    long   Coord_BinProd[MONnD_COORD_NMAX];   /* product of bins of variable array */
    double Coord_Min[MONnD_COORD_NMAX];
    double Coord_Max[MONnD_COORD_NMAX];
    char   Monitor_Label[MONnD_COORD_NMAX*30];/* Label for monitor */
    char   Mon_File[128];                     /* output file name */

    double cx,cy,cz;
    double cvx, cvy, cvz;
    double ckx, cky, ckz;
    double csx, csy, csz;
    double cEx, cEy, cEz;
    double cs1, cs2, ct, cphi, cp;
    double He3_pressure;
    char   Flag_UsePreMonitor    ;   /* use a previously stored neutron parameter set */
    char   UserName1[128];
    char   UserName2[128];
    char   UserName3[128];
    double UserVariable1;
    double UserVariable2;
    double UserVariable3;
    char   option[CHAR_BUF_LENGTH];

    long long int Nsum;
    double psum, p2sum;
    double **Mon2D_N;
    double **Mon2D_p;
    double **Mon2D_p2;
    double *Mon2D_Buffer;
    unsigned long PixelID;

    double mxmin,mxmax,mymin,mymax,mzmin,mzmax;
    double mean_dx, mean_dy, min_x, min_y, max_x, max_y, mean_p;

    char   compcurname[128];
    Coords compcurpos;

  } MonitornD_Variables_type;

/* monitor_nd-lib function prototypes */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *, MonitornD_Variables_type *, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, int);
int Monitor_nD_Trace(MonitornD_Defines_type *, MonitornD_Variables_type *);
MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_Finally(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_McDisplay(MonitornD_Defines_type *,
 MonitornD_Variables_type *);

#define MONND_DECLARE(monname) \
  struct MonitornD_Variables *mcmonnd ## monname;
#define MONND_USER_TITLE(monname, num, title) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    strcpy(mcmonnd ## monname->UserName ## num, title); }
#define MONND_USER_VALUE(monname, num, value) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    mcmonnd ## monname->UserVariable ## num = (value); }

#endif

/* end of monitor_nd-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H
#error McStas : please import this library with %include "monitor_nd-lib"
#endif

/* ========================================================================= */
/* Monitor_nD_Init: this routine is used to parse options                    */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars,
  MCNUM xwidth,
  MCNUM yheight,
  MCNUM zdepth,
  MCNUM xmin,
  MCNUM xmax,
  MCNUM ymin,
  MCNUM ymax,
  MCNUM zmin,
  MCNUM zmax,
  int offflag)
  {
    long carg = 1;
    char *option_copy, *token;
    char Flag_New_token = 1;
    char Flag_End       = 1;
    char Flag_All       = 0;
    char Flag_No        = 0;
    char Flag_abs       = 0;
    int  Flag_auto      = 0;  /* -1: all, 1: the current variable */
    int  Set_Vars_Coord_Type;
    char Set_Vars_Coord_Label[64];
    char Set_Vars_Coord_Var[64];
    char Short_Label[MONnD_COORD_NMAX][64];
    int  Set_Coord_Mode;
    long i=0, j=0;
    double lmin, lmax, XY=0;
    long t;


    t = (long)time(NULL);

/* initialize DEFS */
/* Variables to monitor */
    DEFS->COORD_NONE   =0;
    DEFS->COORD_X      =1;
    DEFS->COORD_Y      =2;
    DEFS->COORD_Z      =3;
    DEFS->COORD_RADIUS =19;
    DEFS->COORD_VX     =4;
    DEFS->COORD_VY     =5;
    DEFS->COORD_VZ     =6;
    DEFS->COORD_V      =16;
    DEFS->COORD_T      =7;
    DEFS->COORD_P      =8;
    DEFS->COORD_SX     =9;
    DEFS->COORD_SY     =10;
    DEFS->COORD_SZ     =11;
    DEFS->COORD_KX     =12;
    DEFS->COORD_KY     =13;
    DEFS->COORD_KZ     =14;
    DEFS->COORD_K      =15;
    DEFS->COORD_ENERGY =17;
    DEFS->COORD_LAMBDA =18;
    DEFS->COORD_HDIV   =20;
    DEFS->COORD_VDIV   =21;
    DEFS->COORD_ANGLE  =22;
    DEFS->COORD_NCOUNT =23;
    DEFS->COORD_THETA  =24;
    DEFS->COORD_PHI    =25;
    DEFS->COORD_USER1  =26;
    DEFS->COORD_USER2  =27;
    DEFS->COORD_USER3  =28;
    DEFS->COORD_XY     =37;
    DEFS->COORD_YZ     =31;
    DEFS->COORD_XZ     =32;
    DEFS->COORD_VXY    =30;
    DEFS->COORD_VYZ    =34;
    DEFS->COORD_VXZ    =36;
    DEFS->COORD_KXY    =29;
    DEFS->COORD_KYZ    =33;
    DEFS->COORD_KXZ    =35;
    DEFS->COORD_PIXELID=38;

/* token modifiers */
    DEFS->COORD_VAR    =0;    /* next token should be a variable or normal option */
    DEFS->COORD_MIN    =1;    /* next token is a min value */
    DEFS->COORD_MAX    =2;    /* next token is a max value */
    DEFS->COORD_DIM    =3;    /* next token is a bin value */
    DEFS->COORD_FIL    =4;    /* next token is a filename */
    DEFS->COORD_EVNT   =5;    /* next token is a buffer size value */
    DEFS->COORD_3HE    =6;    /* next token is a 3He pressure value */
    DEFS->COORD_LOG    =64;   /* next variable will be in log scale */
    DEFS->COORD_ABS    =128;  /* next variable will be in abs scale */
    DEFS->COORD_SIGNAL =256;  /* next variable will be the signal var */
    DEFS->COORD_AUTO   =512;  /* set auto limits */

    strcpy(DEFS->TOKEN_DEL, " =,;[](){}:");  /* token separators */

    DEFS->SHAPE_SQUARE =0;    /* shape of the monitor */
    DEFS->SHAPE_DISK   =1;
    DEFS->SHAPE_SPHERE =2;
    DEFS->SHAPE_CYLIND =3;
    DEFS->SHAPE_BANANA =4;
    DEFS->SHAPE_BOX    =5;
    DEFS->SHAPE_PREVIOUS=6;
    DEFS->SHAPE_OFF=7;

    Vars->Sphere_Radius     = 0;
    Vars->Cylinder_Height   = 0;
    Vars->Flag_With_Borders = 0;   /* 2 means xy borders too */
    Vars->Flag_List         = 0;   /* 1=store 1 buffer, 2=list all, 3=re-use buffer */
    Vars->Flag_Multiple     = 0;   /* 1 when n1D, 0 for 2D */
    Vars->Flag_Verbose      = 0;
    Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    Vars->Flag_Auto_Limits  = 0;   /* get limits from first Buffer */
    Vars->Flag_Absorb       = 0;   /* monitor is also a slit */
    Vars->Flag_per_cm2      = 0;   /* flux is per cm2 */
    Vars->Flag_log          = 0;   /* log10 of the flux */
    Vars->Flag_parallel     = 0;   /* set neutron state back after detection (parallel components) */
    Vars->Flag_Binary_List  = 0;   /* save list as a binary file (smaller) */
    Vars->Coord_Number      = 0;   /* total number of variables to monitor, plus intensity (0) */
    Vars->Coord_NumberNoPixel=0;   /* same but without counting PixelID */

/* Allow to specify size of Monitor_nD buffer via a define*/
#ifndef MONND_BUFSIZ
    Vars->Buffer_Block      = 100000;     /* Buffer size for list or auto limits */
#else
	Vars->Buffer_Block      = MONND_BUFSIZ;     /* Buffer size for list or auto limits */	
#endif
    Vars->Neutron_Counter   = 0;   /* event counter, simulation total counts is mcget_ncount() */
    Vars->Buffer_Counter    = 0;   /* index in Buffer size (for realloc) */
    Vars->Buffer_Size       = 0;
    Vars->UserVariable1     = 0;
    Vars->UserVariable2     = 0;
    Vars->He3_pressure      = 0;
    Vars->Flag_capture      = 0;
    Vars->Flag_signal       = DEFS->COORD_P;
    Vars->Flag_mantid       = 0;
    Vars->Flag_OFF          = offflag;
    Vars->OFF_polyidx       = -1;
    Vars->mean_dx=Vars->mean_dy=0;
    Vars->min_x = Vars->max_x  =0;
    Vars->min_y = Vars->max_y  =0;

    Set_Vars_Coord_Type = DEFS->COORD_NONE;
    Set_Coord_Mode = DEFS->COORD_VAR;

    /* handle size parameters */
    /* normal use is with xwidth, yheight, zdepth */
    /* if xmin,xmax,ymin,ymax,zmin,zmax are non 0, use them */
    if (fabs(xmin-xmax) == 0)
      { Vars->mxmin = -fabs(xwidth)/2; Vars->mxmax = fabs(xwidth)/2; }
    else
      { if (xmin < xmax) {Vars->mxmin = xmin; Vars->mxmax = xmax;}
        else {Vars->mxmin = xmax; Vars->mxmax = xmin;}
      }
    if (fabs(ymin-ymax) == 0)
      { Vars->mymin = -fabs(yheight)/2; Vars->mymax = fabs(yheight)/2; }
    else
      { if (ymin < ymax) {Vars->mymin = ymin; Vars->mymax = ymax;}
        else {Vars->mymin = ymax; Vars->mymax = ymin;}
      }
    if (fabs(zmin-zmax) == 0)
      { Vars->mzmin = -fabs(zdepth)/2; Vars->mzmax = fabs(zdepth)/2; }
    else
      { if (zmin < zmax) {Vars->mzmin = zmin; Vars->mzmax = zmax; }
        else {Vars->mzmin = zmax; Vars->mzmax = zmin; }
      }

    if (fabs(Vars->mzmax-Vars->mzmin) == 0)
      Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    else
      Vars->Flag_Shape        = DEFS->SHAPE_BOX;

    if (Vars->Flag_OFF) {
      Vars->Flag_Shape        = DEFS->SHAPE_OFF;
    }
    
    /* parse option string */

    option_copy = (char*)malloc(strlen(Vars->option)+1);
    if (option_copy == NULL)
    {
      fprintf(stderr,"Monitor_nD: %s cannot allocate 'options' copy (%li). Fatal.\n", Vars->compcurname, (long)strlen(Vars->option));
      exit(-1);
    }

    if (strlen(Vars->option))
    {
      Flag_End = 0;
      strcpy(option_copy, Vars->option);
    }

    if (strstr(Vars->option, "cm2") || strstr(Vars->option, "cm^2")) Vars->Flag_per_cm2 = 1;

    if (strstr(Vars->option, "binary") || strstr(Vars->option, "float"))
      Vars->Flag_Binary_List  = 1;
    if (strstr(Vars->option, "double"))
      Vars->Flag_Binary_List  = 2;

    strcpy(Vars->Coord_Label[0],"Intensity");
    strncpy(Vars->Coord_Var[0],"p",30);
    Vars->Coord_Type[0] = DEFS->COORD_P;
    Vars->Coord_Bin[0] = 1;
    Vars->Coord_Min[0] = 0;
    Vars->Coord_Max[0] = FLT_MAX;

    /* default file name is comp_name+dateID */
    sprintf(Vars->Mon_File, "%s_%li", Vars->compcurname, t);

    carg = 1;
    while((Flag_End == 0) && (carg < 128))
    {

      if (Flag_New_token) /* retain previous token or get a new one */
      {
        if (carg == 1) token=(char *)strtok(option_copy,DEFS->TOKEN_DEL);
        else token=(char *)strtok(NULL,DEFS->TOKEN_DEL);
        if (token == NULL) Flag_End=1;
      }
      Flag_New_token = 1;
      if ((token != NULL) && (strlen(token) != 0))
      {
        char iskeyword=0; /* left at 0 when variables are processed, 1 for modifiers */
        int  old_Mode;
        /* change token to lower case */
        for (i=0; i<strlen(token); i++) token[i]=tolower(token[i]);
        /* first handle option values from preceeding keyword token detected */
        old_Mode = Set_Coord_Mode;
        if (Set_Coord_Mode == DEFS->COORD_MAX)  /* max=%i */
        {
          if (!Flag_All)
            Vars->Coord_Max[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Max[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_MIN)  /* min=%i */
        {
          if (!Flag_All)
            Vars->Coord_Min[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Min[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_MAX;
        }
        if (Set_Coord_Mode == DEFS->COORD_DIM)  /* bins=%i */
        {
          if (!Flag_All)
            Vars->Coord_Bin[Vars->Coord_Number] = atoi(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Bin[i++] = atoi(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_FIL)  /* file=%s */
        {
          if (!Flag_No) strncpy(Vars->Mon_File,token,128);
          else { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1;}
          Set_Coord_Mode = DEFS->COORD_VAR;
        }
        if (Set_Coord_Mode == DEFS->COORD_EVNT) /* list=%i */
        {
          if (!strcmp(token, "all") || Flag_All) Vars->Flag_List = 2;
          else { i = (long)ceil(atof(token)); if (i) Vars->Buffer_Block = i;
            Vars->Flag_List = 1; }
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_3HE)  /* pressure=%g */
        {
            Vars->He3_pressure = atof(token);
            Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }

        /* now look for general option keywords */
        if (!strcmp(token, "borders"))  {Vars->Flag_With_Borders = 1; iskeyword=1; }
        if (!strcmp(token, "verbose"))  {Vars->Flag_Verbose      = 1; iskeyword=1; }
        if (!strcmp(token, "log"))      {Vars->Flag_log          = 1; iskeyword=1; }
        if (!strcmp(token, "abs"))      {Flag_abs                = 1; iskeyword=1; }
        if (!strcmp(token, "multiple")) {Vars->Flag_Multiple     = 1; iskeyword=1; }
        if (!strcmp(token, "list") || !strcmp(token, "events")) {
          Vars->Flag_List = 1; Set_Coord_Mode = DEFS->COORD_EVNT;  }
        if (!strcmp(token, "limits") || !strcmp(token, "min"))
          Set_Coord_Mode = DEFS->COORD_MIN;
        if (!strcmp(token, "slit") || !strcmp(token, "absorb")) {
          Vars->Flag_Absorb = 1;  iskeyword=1; }
        if (!strcmp(token, "max"))  Set_Coord_Mode = DEFS->COORD_MAX;
        if (!strcmp(token, "bins") || !strcmp(token, "dim")) Set_Coord_Mode = DEFS->COORD_DIM;
        if (!strcmp(token, "file") || !strcmp(token, "filename")) {
          Set_Coord_Mode = DEFS->COORD_FIL;
          if (Flag_No) { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1; }
        }
        if (!strcmp(token, "unactivate")) {
          Flag_End = 1; Vars->Coord_Number = 0; iskeyword=1; }
        if (!strcmp(token, "all"))    { Flag_All = 1;  iskeyword=1; }
        if (!strcmp(token, "sphere")) { Vars->Flag_Shape = DEFS->SHAPE_SPHERE; iskeyword=1; }
        if (!strcmp(token, "cylinder")) { Vars->Flag_Shape = DEFS->SHAPE_CYLIND; iskeyword=1; }
        if (!strcmp(token, "banana")) { Vars->Flag_Shape = DEFS->SHAPE_BANANA; iskeyword=1; }
        if (!strcmp(token, "square")) { Vars->Flag_Shape = DEFS->SHAPE_SQUARE; iskeyword=1; }
        if (!strcmp(token, "disk"))   { Vars->Flag_Shape = DEFS->SHAPE_DISK; iskeyword=1; }
        if (!strcmp(token, "box"))     { Vars->Flag_Shape = DEFS->SHAPE_BOX; iskeyword=1; }
        if (!strcmp(token, "previous")) { Vars->Flag_Shape = DEFS->SHAPE_PREVIOUS; iskeyword=1; }
        if (!strcmp(token, "parallel")){ Vars->Flag_parallel = 1; iskeyword=1; }
        if (!strcmp(token, "capture")) { Vars->Flag_capture = 1; iskeyword=1; }
        if (!strcmp(token, "auto") && (Flag_auto != -1)) {
          Vars->Flag_Auto_Limits = 1;
          if (Flag_All) Flag_auto = -1;
          else          Flag_auto = 1;
          iskeyword=1; Flag_All=0; }
        if (!strcmp(token, "premonitor")) {
          Vars->Flag_UsePreMonitor = 1; iskeyword=1; }
        if (!strcmp(token, "3He_pressure") || !strcmp(token, "pressure")) {
          Vars->He3_pressure = 3; iskeyword=1; }
        if (!strcmp(token, "no") || !strcmp(token, "not")) { Flag_No = 1;  iskeyword=1; }
        if (!strcmp(token, "signal")) Set_Coord_Mode = DEFS->COORD_SIGNAL;
        if (!strcmp(token, "mantid")) { Vars->Flag_mantid = 1; iskeyword=1; }

        /* Mode has changed: this was a keyword or value  ? */
        if (Set_Coord_Mode != old_Mode) iskeyword=1;

        /* now look for variable names to monitor */
        Set_Vars_Coord_Type = DEFS->COORD_NONE; lmin = 0; lmax = 0;

        if (!strcmp(token, "x"))
          { Set_Vars_Coord_Type = DEFS->COORD_X; strcpy(Set_Vars_Coord_Label,"x [m]"); strcpy(Set_Vars_Coord_Var,"x");
          lmin = Vars->mxmin; lmax = Vars->mxmax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mxmin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mxmax;}
        if (!strcmp(token, "y"))
          { Set_Vars_Coord_Type = DEFS->COORD_Y; strcpy(Set_Vars_Coord_Label,"y [m]"); strcpy(Set_Vars_Coord_Var,"y");
          lmin = Vars->mymin; lmax = Vars->mymax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mymin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mymax;}
        if (!strcmp(token, "z"))
          { Set_Vars_Coord_Type = DEFS->COORD_Z; strcpy(Set_Vars_Coord_Label,"z [m]"); strcpy(Set_Vars_Coord_Var,"z"); lmin = Vars->mzmin; lmax = Vars->mzmax; }
        if (!strcmp(token, "k") || !strcmp(token, "wavevector"))
          { Set_Vars_Coord_Type = DEFS->COORD_K; strcpy(Set_Vars_Coord_Label,"|k| [Angs-1]"); strcpy(Set_Vars_Coord_Var,"k"); lmin = 0; lmax = 10; }
        if (!strcmp(token, "v"))
          { Set_Vars_Coord_Type = DEFS->COORD_V; strcpy(Set_Vars_Coord_Label,"Velocity [m/s]"); strcpy(Set_Vars_Coord_Var,"v"); lmin = 0; lmax = 10000; }
        if (!strcmp(token, "t") || !strcmp(token, "time") || !strcmp(token, "tof"))
          { Set_Vars_Coord_Type = DEFS->COORD_T; strcpy(Set_Vars_Coord_Label,"TOF [s]"); strcpy(Set_Vars_Coord_Var,"t"); lmin = 0; lmax = .1; }
        if ((!strcmp(token, "p") || !strcmp(token, "i") || !strcmp(token, "intensity") || !strcmp(token, "flux")))
          { Set_Vars_Coord_Type = DEFS->COORD_P;
            strcpy(Set_Vars_Coord_Label,"Intensity");
            strncat(Set_Vars_Coord_Label, " [n/s", 30);
            if (Vars->Flag_per_cm2) strncat(Set_Vars_Coord_Label, "/cm2", 30);
            if (XY > 1 && Vars->Coord_Number)
              strncat(Set_Vars_Coord_Label, "/bin", 30);
            strncat(Set_Vars_Coord_Label, "]", 30);
            strcpy(Set_Vars_Coord_Var,"I");
            lmin = 0; lmax = FLT_MAX;
            if (Flag_auto>0) Flag_auto=0;
          }

        if (!strcmp(token, "vx"))
          { Set_Vars_Coord_Type = DEFS->COORD_VX; strcpy(Set_Vars_Coord_Label,"vx [m/s]"); strcpy(Set_Vars_Coord_Var,"vx"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VY; strcpy(Set_Vars_Coord_Label,"vy [m/s]"); strcpy(Set_Vars_Coord_Var,"vy"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VZ; strcpy(Set_Vars_Coord_Label,"vz [m/s]"); strcpy(Set_Vars_Coord_Var,"vz"); lmin = -10000; lmax = 10000; }
        if (!strcmp(token, "kx"))
          { Set_Vars_Coord_Type = DEFS->COORD_KX; strcpy(Set_Vars_Coord_Label,"kx [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "ky"))
          { Set_Vars_Coord_Type = DEFS->COORD_KY; strcpy(Set_Vars_Coord_Label,"ky [Angs-1]"); strcpy(Set_Vars_Coord_Var,"ky"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "kz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KZ; strcpy(Set_Vars_Coord_Label,"kz [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kz"); lmin = -10; lmax = 10; }
        if (!strcmp(token, "sx"))
          { Set_Vars_Coord_Type = DEFS->COORD_SX; strcpy(Set_Vars_Coord_Label,"sx [1]"); strcpy(Set_Vars_Coord_Var,"sx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sy"))
          { Set_Vars_Coord_Type = DEFS->COORD_SY; strcpy(Set_Vars_Coord_Label,"sy [1]"); strcpy(Set_Vars_Coord_Var,"sy"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sz"))
          { Set_Vars_Coord_Type = DEFS->COORD_SZ; strcpy(Set_Vars_Coord_Label,"sz [1]"); strcpy(Set_Vars_Coord_Var,"sz"); lmin = -1; lmax = 1; }

        if (!strcmp(token, "energy") || !strcmp(token, "omega") || !strcmp(token, "e"))
          { Set_Vars_Coord_Type = DEFS->COORD_ENERGY; strcpy(Set_Vars_Coord_Label,"Energy [meV]"); strcpy(Set_Vars_Coord_Var,"E"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "lambda") || !strcmp(token, "wavelength") || !strcmp(token, "l"))
          { Set_Vars_Coord_Type = DEFS->COORD_LAMBDA; strcpy(Set_Vars_Coord_Label,"Wavelength [Angs]"); strcpy(Set_Vars_Coord_Var,"L"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "radius") || !strcmp(token, "r"))
          { Set_Vars_Coord_Type = DEFS->COORD_RADIUS; strcpy(Set_Vars_Coord_Label,"Radius [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xy"))
          { Set_Vars_Coord_Type = DEFS->COORD_XY; strcpy(Set_Vars_Coord_Label,"Radius (xy) [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "yz"))
          { Set_Vars_Coord_Type = DEFS->COORD_YZ; strcpy(Set_Vars_Coord_Label,"Radius (yz) [m]"); strcpy(Set_Vars_Coord_Var,"yz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xz"))
          { Set_Vars_Coord_Type = DEFS->COORD_XZ; strcpy(Set_Vars_Coord_Label,"Radius (xz) [m]"); strcpy(Set_Vars_Coord_Var,"xz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "vxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXY; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xy) [m]"); strcpy(Set_Vars_Coord_Var,"Vxy"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXY; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xy) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxy"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VYZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (yz) [m]"); strcpy(Set_Vars_Coord_Var,"Vyz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KYZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (yz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kyz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xz) [m]"); strcpy(Set_Vars_Coord_Var,"Vxz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "angle") || !strcmp(token, "a"))
          { Set_Vars_Coord_Type = DEFS->COORD_ANGLE; strcpy(Set_Vars_Coord_Label,"Angle [deg]"); strcpy(Set_Vars_Coord_Var,"A"); lmin = -50; lmax = 50; }
        if (!strcmp(token, "hdiv")|| !strcmp(token, "divergence") || !strcmp(token, "xdiv") || !strcmp(token, "hd") || !strcmp(token, "dx"))
          { Set_Vars_Coord_Type = DEFS->COORD_HDIV; strcpy(Set_Vars_Coord_Label,"Hor. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"hd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "vdiv") || !strcmp(token, "ydiv") || !strcmp(token, "vd") || !strcmp(token, "dy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VDIV; strcpy(Set_Vars_Coord_Label,"Vert. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"vd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "theta") || !strcmp(token, "longitude") || !strcmp(token, "th"))
          { Set_Vars_Coord_Type = DEFS->COORD_THETA; strcpy(Set_Vars_Coord_Label,"Longitude [deg]"); strcpy(Set_Vars_Coord_Var,"th"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "phi") || !strcmp(token, "lattitude") || !strcmp(token, "ph"))
          { Set_Vars_Coord_Type = DEFS->COORD_PHI; strcpy(Set_Vars_Coord_Label,"Lattitude [deg]"); strcpy(Set_Vars_Coord_Var,"ph"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "ncounts") || !strcmp(token, "n") || !strcmp(token, "neutron"))
          { Set_Vars_Coord_Type = DEFS->COORD_NCOUNT; strcpy(Set_Vars_Coord_Label,"Neutron ID [1]"); strcpy(Set_Vars_Coord_Var,"n"); lmin = 0; lmax = mcget_ncount(); if (Flag_auto>0) Flag_auto=0; }
        if (!strcmp(token, "id") || !strcmp(token, "pixel"))
          { Set_Vars_Coord_Type = DEFS->COORD_PIXELID; 
            strcpy(Set_Vars_Coord_Label,"Pixel ID [1]"); 
            strcpy(Set_Vars_Coord_Var,"id"); lmin = 0; lmax = FLT_MAX; 
            if (Flag_auto>0) Flag_auto=0;
            Vars->Flag_List = 1; }
        if (!strcmp(token, "user") || !strcmp(token, "user1") || !strcmp(token, "u1"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER1; strncpy(Set_Vars_Coord_Label,Vars->UserName1,30); strcpy(Set_Vars_Coord_Var,"U1"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user2") || !strcmp(token, "u2"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER2; strncpy(Set_Vars_Coord_Label,Vars->UserName2,30); strcpy(Set_Vars_Coord_Var,"U2"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user3") || !strcmp(token, "u3"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER3; strncpy(Set_Vars_Coord_Label,Vars->UserName3,30); strcpy(Set_Vars_Coord_Var,"U3"); lmin = -1e10; lmax = 1e10; }

        /* now stores variable keywords detected, if any */
        if (Set_Vars_Coord_Type != DEFS->COORD_NONE)
        {
          int Coord_Number = Vars->Coord_Number;
          if (Vars->Flag_log) { Set_Vars_Coord_Type |= DEFS->COORD_LOG; Vars->Flag_log = 0; }
          if (Flag_abs) { Set_Vars_Coord_Type |= DEFS->COORD_ABS; Flag_abs = 0; }
          if (Flag_auto != 0) { Set_Vars_Coord_Type |= DEFS->COORD_AUTO; 
            if (Flag_auto > 0) Flag_auto = 0; }
          if (Set_Coord_Mode == DEFS->COORD_SIGNAL)
          {
            Coord_Number = 0;
            Vars->Flag_signal = Set_Vars_Coord_Type;
          }
          else
          {
            if (Coord_Number < MONnD_COORD_NMAX)
            { Coord_Number++;
              Vars->Coord_Number = Coord_Number; 
              if (Set_Vars_Coord_Type != DEFS->COORD_PIXELID)
                Vars->Coord_NumberNoPixel++;
            }
            else if (Vars->Flag_Verbose) printf("Monitor_nD: %s reached max number of variables (%i).\n", Vars->compcurname, MONnD_COORD_NMAX);
          }
          Vars->Coord_Type[Coord_Number] = Set_Vars_Coord_Type;
          strncpy(Vars->Coord_Label[Coord_Number], Set_Vars_Coord_Label,30);
          strncpy(Vars->Coord_Var[Coord_Number], Set_Vars_Coord_Var,30);
          if (lmin > lmax) { XY = lmin; lmin=lmax; lmax = XY; }
          Vars->Coord_Min[Coord_Number] = lmin;
          Vars->Coord_Max[Coord_Number] = lmax;
          if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT || Set_Vars_Coord_Type == DEFS->COORD_PIXELID || Set_Vars_Coord_Type == DEFS->COORD_SIGNAL)
            Vars->Coord_Bin[Coord_Number] = 1;
          else
            Vars->Coord_Bin[Coord_Number] = 20;
          Set_Coord_Mode = DEFS->COORD_VAR;
          Flag_All = 0;
          Flag_No  = 0;
        } else {
          /* no variable name could be read from options */
          if (!iskeyword) {
            if (strcmp(token, "cm2") && strcmp(token, "incoming")
             && strcmp(token, "outgoing") && strcmp(token, "cm2")
             && strcmp(token, "cm^2") && strcmp(token, "float")
             && strcmp(token, "double") && strcmp(token, "binary")
             && strcmp(token, "steradian") && Vars->Flag_Verbose)
              printf("Monitor_nD: %s: unknown '%s' keyword in 'options'. Ignoring.\n", Vars->compcurname, token);
          }
        }
      carg++;
      } /* end if token */
    } /* end while carg */
    free(option_copy);
    if (carg == 128) printf("Monitor_nD: %s reached max number of tokens (%i). Skipping.\n", Vars->compcurname, 128);

    if ((Vars->Flag_Shape == DEFS->SHAPE_BOX) && (fabs(Vars->mzmax - Vars->mzmin) == 0)) Vars->Flag_Shape = DEFS->SHAPE_SQUARE;

    if (Vars->Flag_log == 1) Vars->Coord_Type[0] |= DEFS->COORD_LOG;
    if (Vars->Coord_Number == 0)
    { Vars->Flag_Auto_Limits=0; Vars->Flag_Multiple=0; Vars->Flag_List=0; }

    /* now setting Monitor Name from variable labels */
    strcpy(Vars->Monitor_Label,"");
    XY = 1; /* will contain total bin number */
    for (i = 0; i <= Vars->Coord_Number; i++)
    {
      if (Flag_auto != 0) Vars->Coord_Type[i] |= DEFS->COORD_AUTO;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if ((Set_Vars_Coord_Type == DEFS->COORD_X)
       || (Set_Vars_Coord_Type == DEFS->COORD_Y)
       || (Set_Vars_Coord_Type == DEFS->COORD_Z))
       strcpy(Short_Label[i],"Position");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_THETA)
       || (Set_Vars_Coord_Type == DEFS->COORD_PHI)
       || (Set_Vars_Coord_Type == DEFS->COORD_ANGLE))
       strcpy(Short_Label[i],"Angle");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_XY)
       || (Set_Vars_Coord_Type == DEFS->COORD_XZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_YZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_RADIUS))
       strcpy(Short_Label[i],"Radius");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_VX)
       || (Set_Vars_Coord_Type == DEFS->COORD_VY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_V)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXZ))
       strcpy(Short_Label[i],"Velocity");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_KX)
       || (Set_Vars_Coord_Type == DEFS->COORD_KY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_K))
       strcpy(Short_Label[i],"Wavevector");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_SX)
       || (Set_Vars_Coord_Type == DEFS->COORD_SY)
       || (Set_Vars_Coord_Type == DEFS->COORD_SZ))
       strcpy(Short_Label[i],"Spin");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_HDIV)
       || (Set_Vars_Coord_Type == DEFS->COORD_VDIV))
       strcpy(Short_Label[i],"Divergence");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY)
       strcpy(Short_Label[i],"Energy");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA)
       strcpy(Short_Label[i],"Wavelength");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT)
       strcpy(Short_Label[i],"Neutron_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID)
       strcpy(Short_Label[i],"Pixel_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_T)
          strcpy(Short_Label[i],"Time_Of_Flight");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_P)
          strcpy(Short_Label[i],"Intensity");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER1)
          strncpy(Short_Label[i],Vars->UserName1,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER2)
          strncpy(Short_Label[i],Vars->UserName2,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER3)
          strncpy(Short_Label[i],Vars->UserName3,30);
      else
          strcpy(Short_Label[i],"Unknown");

      if (Vars->Coord_Type[i] & DEFS->COORD_ABS)
      { strcat(Vars->Coord_Label[i]," (abs)"); }

      if (Vars->Coord_Type[i] & DEFS->COORD_LOG)
      { strcat(Vars->Coord_Label[i]," (log)"); }

      strcat(Vars->Monitor_Label, " ");
      strcat(Vars->Monitor_Label, Short_Label[i]);
      XY *= Vars->Coord_Bin[i];

    } /* end for Short_Label */

    if ((Vars->Coord_Type[0] & (DEFS->COORD_LOG-1)) == DEFS->COORD_P) {
      strncat(Vars->Coord_Label[0], " [n/s", 30);
      if (Vars->Flag_per_cm2) strncat(Vars->Coord_Label[0], "/cm2", 30);

      if (XY > 1 && Vars->Coord_Number)
        strncat(Vars->Coord_Label[0], "/bin", 30);
      strncat(Vars->Coord_Label[0], "]", 30);
    }

    /* update label 'signal per bin' if more than 1 bin */
    if (XY > 1 && Vars->Coord_Number) {
      if (Vars->Flag_capture)
        printf("Monitor_nD: %s: Using capture flux weightening on %ld bins.\n"
               "WARNING     Use binned data with caution, and prefer monitor integral value (I,Ierr).\n", Vars->compcurname, (long)XY);
    }

    strcat(Vars->Monitor_Label, " Monitor");
    if (Vars->Flag_Shape == DEFS->SHAPE_SQUARE) strcat(Vars->Monitor_Label, " (Square)");
    if (Vars->Flag_Shape == DEFS->SHAPE_DISK)   strcat(Vars->Monitor_Label, " (Disk)");
    if (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) strcat(Vars->Monitor_Label, " (Sphere)");
    if (Vars->Flag_Shape == DEFS->SHAPE_CYLIND) strcat(Vars->Monitor_Label, " (Cylinder)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BANANA) strcat(Vars->Monitor_Label, " (Banana)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BOX)    strcat(Vars->Monitor_Label, " (Box)");
    if (Vars->Flag_Shape == DEFS->SHAPE_PREVIOUS) strcat(Vars->Monitor_Label, " (on PREVIOUS)");
    if (Vars->Flag_Shape == DEFS->SHAPE_OFF) strcat(Vars->Monitor_Label, " (OFF geometry)");
    if ((Vars->Flag_Shape == DEFS->SHAPE_CYLIND) || (Vars->Flag_Shape == DEFS->SHAPE_BANANA) || (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) || (Vars->Flag_Shape == DEFS->SHAPE_BOX))
    {
      if (strstr(Vars->option, "incoming"))
      {
        Vars->Flag_Shape = abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [in]");
      }
      else /* if strstr(Vars->option, "outgoing")) */
      {
        Vars->Flag_Shape = -abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [out]");
      }
    }
    if (Vars->Flag_UsePreMonitor == 1)
    {
        strcat(Vars->Monitor_Label, " at ");
        strncat(Vars->Monitor_Label, Vars->UserName1,30);
    }
    if (Vars->Flag_log == 1) strcat(Vars->Monitor_Label, " [log] ");

    /* now allocate memory to store variables in TRACE */

    /* Vars->Coord_Number  0   : intensity or signal
     * Vars->Coord_Number  1:n : detector variables */

    if ((Vars->Coord_NumberNoPixel != 2) && !Vars->Flag_Multiple && !Vars->Flag_List)
    { Vars->Flag_Multiple = 1; /* default is n1D */
      if (Vars->Coord_Number != Vars->Coord_NumberNoPixel) Vars->Flag_List = 1; }

    /* list and auto limits case : Vars->Flag_List or Vars->Flag_Auto_Limits
     * -> Buffer to flush and suppress after Vars->Flag_Auto_Limits
     */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      Vars->Mon2D_Buffer = (double *)malloc((Vars->Coord_Number+1)*Vars->Buffer_Block*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
      { printf("Monitor_nD: %s cannot allocate Vars->Mon2D_Buffer (%li). No list and auto limits.\n", Vars->compcurname, Vars->Buffer_Block*(Vars->Coord_Number+1)*sizeof(double)); Vars->Flag_List = 0; Vars->Flag_Auto_Limits = 0; }
      else
      {
        for (i=0; i < (Vars->Coord_Number+1)*Vars->Buffer_Block; Vars->Mon2D_Buffer[i++] = (double)0);
      }
      Vars->Buffer_Size = Vars->Buffer_Block;
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_NumberNoPixel)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, (Vars->Coord_Number)*sizeof(double *)); exit(-1); }
      for (i= 1; i <= Vars->Coord_Number; i++)
      {
        Vars->Mon2D_N[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p2[i-1] = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[i], i, (Vars->Coord_Bin[i])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[i]; j++ )
          { Vars->Mon2D_N[i-1][j] = (double)0; Vars->Mon2D_p[i-1][j] = (double)0; Vars->Mon2D_p2[i-1][j] = (double)0; }
        }
      }
    }
    else /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], (Vars->Coord_Bin[1])*sizeof(double *)); exit(-1); }
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        Vars->Mon2D_N[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p2[i] = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], i, (Vars->Coord_Bin[2])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[2]; j++ )
          { Vars->Mon2D_N[i][j] = (double)0; Vars->Mon2D_p[i][j] = (double)0; Vars->Mon2D_p2[i][j] = (double)0; }
        }
      }
    }
    else {
      Vars->Mon2D_N = Vars->Mon2D_p = Vars->Mon2D_p2 = NULL;
    }
      /* no Mon2D allocated for
       * (Vars->Coord_Number != 2) && !Vars->Flag_Multiple && Vars->Flag_List */

    Vars->psum  = 0;
    Vars->p2sum = 0;
    Vars->Nsum  = 0;

    Vars->area  = fabs(Vars->mxmax - Vars->mxmin)*fabs(Vars->mymax - Vars->mymin)*1E4; /* in cm**2 for square and box shapes */
    Vars->Sphere_Radius = fabs(Vars->mxmax - Vars->mxmin)/2;
    if ((abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    {
      Vars->area = PI*Vars->Sphere_Radius*Vars->Sphere_Radius*1E4; /* disk shapes */
    }


    if (Vars->area == 0 && abs(Vars->Flag_Shape) != DEFS->SHAPE_PREVIOUS ) {
      if (abs(Vars->Flag_Shape) != DEFS->SHAPE_OFF) {  
	Vars->Coord_Number = 0;
      }
    }
    if (Vars->Coord_Number == 0 && Vars->Flag_Verbose)
      printf("Monitor_nD: %s is unactivated (0D)\n", Vars->compcurname);
    Vars->Cylinder_Height = fabs(Vars->mymax - Vars->mymin);

    if (Vars->Flag_Verbose)
    {
      printf("Monitor_nD: %s is a %s.\n", Vars->compcurname, Vars->Monitor_Label);
      printf("Monitor_nD: version %s with options=%s\n", MONITOR_ND_LIB_H, Vars->option);
    }
    
    /* compute the product of bin dimensions for PixelID */
    Vars->Coord_BinProd[0]=1;
    for (i = 1; i <= Vars->Coord_Number; i++)
      Vars->Coord_BinProd[i]=Vars->Coord_Bin[i]*Vars->Coord_BinProd[i-1];
  } /* end Monitor_nD_Init */

/* ========================================================================= */
/* Monitor_nD_Trace: this routine is used to monitor one propagating neutron */
/* return values: 0=neutron was absorbed, -1=neutron was outside bounds, 1=neutron was measured*/
/* ========================================================================= */

int Monitor_nD_Trace(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
{

  double  XY=0, pp=0;
  int     retval;
  long    i =0, j =0;
  double  Coord[MONnD_COORD_NMAX];
  long    Coord_Index[MONnD_COORD_NMAX];
  char    While_End   =0;
  long    While_Buffer=0;
  char    Set_Vars_Coord_Type = DEFS->COORD_NONE;
  
  /* the logic below depends mainly on:
       Flag_List:        1=store 1 buffer, 2=list all, 3=re-use buffer 
       Flag_Auto_Limits: 0 (no auto limits/list), 1 (store events into Buffer), 2 (re-emit store events)
   */

  /* Vars->Flag_Auto_Limits=1: buffer full, we read the Buffer, and determine min and max bounds */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 1) && (Vars->Coord_Number > 0))
  {
    /* auto limits case : get limits in Buffer for each variable */
          /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
    if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
    for (i = 1; i <= Vars->Coord_Number; i++)
    {
      if (Vars->Coord_Type[i] & DEFS->COORD_AUTO)
      {
        Vars->Coord_Min[i] =  FLT_MAX;
        Vars->Coord_Max[i] = -FLT_MAX;
        for (j = 0; j < Vars->Buffer_Counter; j++)
        {
          XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
          if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
          if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
        }
        if  (Vars->Flag_Verbose)  
          printf("  %s: min=%g max=%g\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i]);
      }
    }
    Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step (read Buffer and generate new events to store in histograms) */
  } /* end if Flag_Auto_Limits == 1 */

  /* manage realloc for 'list all' if Buffer size exceeded: flush Buffer to file */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List >= 2))
  {
    if (Vars->Buffer_Size >= 1000000 || Vars->Flag_List == 3)
    { /* save current (possibly append) and re-use Buffer */
      Monitor_nD_Save(DEFS, Vars);
      Vars->Flag_List = 3;
      Vars->Buffer_Block = Vars->Buffer_Size;
      Vars->Buffer_Counter  = 0;
      Vars->Neutron_Counter = 0;
    }
    else
    {
      Vars->Mon2D_Buffer  = (double *)realloc(Vars->Mon2D_Buffer, (Vars->Coord_Number+1)*(Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
            { printf("Monitor_nD: %s cannot reallocate Vars->Mon2D_Buffer[%li] (%li). Skipping.\n", Vars->compcurname, i, (Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double)); Vars->Flag_List = 1; }
      else { Vars->Buffer_Counter = 0; Vars->Buffer_Size = Vars->Neutron_Counter+Vars->Buffer_Block; }
    }
  } /* end if Buffer realloc */

  char    outsidebounds=0;
  while (!While_End)
  { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) or passing neutron */
    if ((Vars->Flag_Auto_Limits == 2) && (Vars->Coord_Number > 0))
    { /* Vars->Flag_Auto_Limits == 2: read back from Buffer (Buffer is filled or auto limits have been computed) */
      if (While_Buffer < Vars->Buffer_Block)
      {
        /* first while loop (While_Buffer) */
        /* auto limits case : scan Buffer within limits and store in Mon2D */
        Coord[0] = pp = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

        for (i = 1; i <= Vars->Coord_Number; i++)
        {
          /* scanning variables in Buffer */
          if (Vars->Coord_Bin[i] <= 1) continue;
          XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);

          Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
          if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
          else        Coord_Index[i] = 0;
          if (Vars->Flag_With_Borders)
          {
            if (Coord_Index[i] < 0)                   Coord_Index[i] = 0;
            if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
          }
        } /* end for */
        
        /* update the PixelID, we compute it from the previous variables index */
        if (Vars->Coord_NumberNoPixel < Vars->Coord_Number) /* there is a Pixel variable */
        for (i = 1; i <= Vars->Coord_Number; i++) {
          char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
          if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
            char flag_outside=0;
            Coord_Index[i] = Coord[i] = 0;
            for (j= 1; j < i; j++) {
              /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
              if (Vars->Coord_Bin[j] == 1) continue; 
              if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                flag_outside=1;
                Coord[i] = 0;
                break;
              }
              Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
            }
            if (!flag_outside) {
              Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
            }
          } /* end if PixelID */
        }
        While_Buffer++;
      } /* end if in Buffer */
      else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
      {
        Vars->Flag_Auto_Limits = 0;
        if (!Vars->Flag_List) /* free Buffer not needed anymore (no list to output) */
        { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, p2) */
          free(Vars->Mon2D_Buffer); Vars->Mon2D_Buffer = NULL;
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
      }
    } /* if Vars->Flag_Auto_Limits == 2 */
    
    if (Vars->Flag_Auto_Limits != 2 || !Vars->Coord_Number) /* Vars->Flag_Auto_Limits == 0 (no auto limits/list) or 1 (store events into Buffer) */
    {
      /* automatically compute area and steradian solid angle when in AUTO mode */
      /* compute the steradian solid angle incoming on the monitor */
      double v;
      v=sqrt(Vars->cvx*Vars->cvx
            +Vars->cvy*Vars->cvy
            +Vars->cvz*Vars->cvz);
      if (Vars->min_x > Vars->cx) Vars->min_x = Vars->cx;
      if (Vars->max_x < Vars->cx) Vars->max_x = Vars->cx;
      if (Vars->min_y > Vars->cy) Vars->min_y = Vars->cy;
      if (Vars->max_y < Vars->cy) Vars->max_y = Vars->cy;
      Vars->mean_p  += Vars->cp;
      if (v) {
        Vars->mean_dx += Vars->cp*fabs(Vars->cvx/v);
        Vars->mean_dy += Vars->cp*fabs(Vars->cvy/v);
      }

      for (i = 0; i <= Vars->Coord_Number; i++)
      { /* handle current neutron : last while */
        XY = 0;
        Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
        /* get values for variables to monitor */
        if (Set_Vars_Coord_Type == DEFS->COORD_X) XY = Vars->cx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Y) XY = Vars->cy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Z) XY = Vars->cz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VX) XY = Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VY) XY = Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VZ) XY = Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KX) XY = V2K*Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KY) XY = V2K*Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KZ) XY = V2K*Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SX) XY = Vars->csx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SY) XY = Vars->csy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SZ) XY = Vars->csz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_T) XY = Vars->ct;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_P) XY = Vars->cp;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_HDIV) XY = RAD2DEG*atan2(Vars->cvx,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VDIV) XY = RAD2DEG*atan2(Vars->cvy,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_V) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XY)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy)*(Vars->cx > 0 ? 1 : -1);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_YZ) XY = sqrt(Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XZ)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXY) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXZ) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VYZ) XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_K) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXY) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXZ) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KYZ) { XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY) { XY = Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz;  XY *= VS2E; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; if (XY != 0) XY = 2*PI/XY; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT) XY = Vars->Neutron_Counter;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
        {  XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
           if (Vars->cvz != 0)
                XY = RAD2DEG*atan2(XY,Vars->cvz)*(Vars->cx > 0 ? 1 : -1);
           else XY = 0;
        }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_THETA)  { if (Vars->cz != 0) XY = RAD2DEG*atan2(Vars->cx,Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PHI) { if (Vars->cz != 0) XY = RAD2DEG*asin(Vars->cy/Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER1) XY = Vars->UserVariable1;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER2) XY = Vars->UserVariable2;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER3) XY = Vars->UserVariable3;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID && !Vars->Flag_Auto_Limits) {
          /* compute the PixelID from previous coordinates 
             the PixelID is the product of Coord_Index[i] in the detector geometry 
             pixelID = sum( Coord_Index[j]*prod(Vars->Coord_Bin[1:(j-1)]) )
             
             this does not apply when we store events in the buffer as Coord_Index
             is not set. Then the pixelID will be re-computed during SAVE.
          */
          char flag_outside=0;
          for (j= 1; j < i; j++) {
            /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
            if (Vars->Coord_Bin[j] <= 1) continue; 
            if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) { 
              flag_outside=1; XY=0; break;
            }
            XY += Coord_Index[j]*Vars->Coord_BinProd[j-1];
          }
	  if (Vars->Flag_mantid && Vars->Flag_OFF && Vars->OFF_polyidx >=0) XY=Vars->OFF_polyidx;
          if (!flag_outside) XY += Vars->Coord_Min[i];
        }
        
        /* handle 'abs' and 'log' keywords */
        if (Vars->Coord_Type[i] & DEFS->COORD_ABS) XY=fabs(XY);

        if (Vars->Coord_Type[i] & DEFS->COORD_LOG) /* compute log of variable if requested */
        {  if (XY > 0) XY = log(XY)/log(10);
           else        XY = -100; }

        Coord[i] = XY; Coord_Index[i] = 0;
        if (i == 0) { pp = XY; Coord_Index[i] = 0; }
        else {
        /* check bounds for variables which have no automatic limits */
          if ((!Vars->Flag_Auto_Limits || !(Vars->Coord_Type[i] & DEFS->COORD_AUTO)) && Vars->Coord_Bin[i]>1)
          { /* compute index in histograms for each variable to monitor */
            XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
            if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
            if (Vars->Flag_With_Borders)
            {
              if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              if (Coord_Index[i] < 0) Coord_Index[i] = 0;
            }
            //if (0 > Coord_Index[i] || Coord_Index[i] >= Vars->Coord_Bin[i])
            //  outsidebounds=1;
          } /* else will get Index later from Buffer when Flag_Auto_Limits == 2 */
        }
        
      } /* end for i */
      While_End = 1;
    }/* end else if Vars->Flag_Auto_Limits == 2 */
    
    /* ====================================================================== */
    /* store n1d/2d neutron from Buffer (Auto_Limits == 2) or current neutron in while */
    if (Vars->Flag_Auto_Limits != 1) /* not when storing auto limits Buffer */
    {
      /* apply per cm2 */
      if (Vars->Flag_per_cm2 && Vars->area != 0)
        pp /= Vars->area;

      /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
      if ( Vars->Coord_NumberNoPixel == 2 && !Vars->Flag_Multiple)
      { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
        
        i = Coord_Index[1];
        j = Coord_Index[2];
        if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
        {
          if (Vars->Mon2D_N) { 
            Vars->Mon2D_N[i][j]++;
            Vars->Mon2D_p[i][j] += pp;
            Vars->Mon2D_p2[i][j] += pp*pp;
          }
        } else {
          outsidebounds=1; 
        }
      } else {
        /* 1D and n1D case : Vars->Flag_Multiple */
        /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          
        for (i= 1; i <= Vars->Coord_Number; i++) {
          j = Coord_Index[i];
          if (j >= 0 && j < Vars->Coord_Bin[i]) {
            if  (Vars->Flag_Multiple && Vars->Mon2D_N) {
              Vars->Mon2D_N[i-1][j]++;
              Vars->Mon2D_p[i-1][j]  += pp;
              Vars->Mon2D_p2[i-1][j] += pp*pp;
            }
          } else { 
            outsidebounds=1;
            break;
          }
        }
      }
    } /* end (Vars->Flag_Auto_Limits != 1) */
    
    if (Vars->Flag_Auto_Limits != 2 && !outsidebounds) /* not when reading auto limits Buffer */
    { /* now store Coord into Buffer (no index needed) if necessary (list or auto limits) */
      if ((Vars->Buffer_Counter < Vars->Buffer_Block) && ((Vars->Flag_List) || (Vars->Flag_Auto_Limits == 1)))
      {
          
        for (i = 0; i <= Vars->Coord_Number; i++)
        {
          Vars->Mon2D_Buffer[i + Vars->Neutron_Counter*(Vars->Coord_Number+1)] = Coord[i];
        }
        Vars->Buffer_Counter++;
        if (Vars->Flag_Verbose && (Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List == 1)) 
          printf("Monitor_nD: %s %li neutrons stored in List.\n", Vars->compcurname, Vars->Buffer_Counter);
      }
      Vars->Neutron_Counter++;
    } /* end (Vars->Flag_Auto_Limits != 2) */
    
  } /* end while */
  Vars->Nsum++;
  Vars->psum  += pp;
  Vars->p2sum += pp*pp;

  /*determine return value: 1:neutron was in bounds and measured, -1: outside bounds, 0: outside bounds, should be absorbed.*/
  if(outsidebounds){
      if(Vars->Flag_Absorb){
          return 0;
      }else{
          return -1;
      }
  }
  return 1;
} /* end Monitor_nD_Trace */

/* ========================================================================= */
/* Monitor_nD_Save: this routine is used to save data files                  */
/* ========================================================================= */

MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
  {
    char   *fname;
    long    i,j;
    double *p0m = NULL;
    double *p1m = NULL;
    double *p2m = NULL;
    char    Coord_X_Label[CHAR_BUF_LENGTH];
    double  min1d, max1d;
    double  min2d, max2d;
    long    bin1d, bin2d;
    char    While_End = 0;
    long    While_Buffer = 0;
    double  XY=0, pp=0;
    double  Coord[MONnD_COORD_NMAX];
    long    Coord_Index[MONnD_COORD_NMAX];
    char    label[CHAR_BUF_LENGTH];
    double  ratio;

    MCDETECTOR detector;

    ratio = 100.0*mcget_run_num()/mcget_ncount();
    if (Vars->Flag_Verbose && Vars->Flag_per_cm2) {
      printf("Monitor_nD: %s: active flat detector area is %g [cm^2], total area is %g [cm^2]\n",
        Vars->compcurname, (Vars->max_x-Vars->min_x)
                          *(Vars->max_y-Vars->min_y)*1E4, Vars->area);
      printf("Monitor_nD: %s: beam solid angle is %g [st] (%g x %g [deg^2])\n",
        Vars->compcurname,
        2*fabs(2*atan(Vars->mean_dx/Vars->mean_p)
         *sin(2*atan(Vars->mean_dy/Vars->mean_p)/2)),
        atan(Vars->mean_dx/Vars->mean_p)*RAD2DEG,
        atan(Vars->mean_dy/Vars->mean_p)*RAD2DEG);
    }

    /* check Buffer flush when end of simulation reached */
    if ((Vars->Buffer_Counter <= Vars->Buffer_Block) && Vars->Flag_Auto_Limits && Vars->Mon2D_Buffer && Vars->Buffer_Counter)
    {
      /* Get Auto Limits */
      if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);

      for (i = 1; i <= Vars->Coord_Number; i++)
      {
        if ((Vars->Coord_Type[i] & DEFS->COORD_AUTO) && Vars->Coord_Bin[i] > 1)
        {
          Vars->Coord_Min[i] = FLT_MAX;
          Vars->Coord_Max[i] = -FLT_MAX;
          for (j = 0; j < Vars->Buffer_Counter; j++)
          {
            XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
            if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
            if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
          }
          if  (Vars->Flag_Verbose)  
            printf("  %s: min=%g max=%g in %li bins\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i], Vars->Coord_Bin[i]);
        }
      }
      Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step */
      Vars->Buffer_Block = Vars->Buffer_Counter;

      while (!While_End)
      { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) */
        /* simulation ended before Buffer was filled. Limits have to be computed, and stored events must be sent into histograms */
        
        if (While_Buffer < Vars->Buffer_Block)
        {
          /* first while loops (While_Buffer) */
          Coord[0] = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

          /* auto limits case : scan Buffer within limits and store in Mon2D */
          for (i = 1; i <= Vars->Coord_Number; i++)
          {
            /* scanning variables in Buffer */
            if (Vars->Coord_Bin[i] <= 1) Coord_Index[i] = 0;
            else {
              XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
              Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
              if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
              else Coord_Index[i] = 0;
              if (Vars->Flag_With_Borders)
              {
                if (Coord_Index[i] < 0) Coord_Index[i] = 0;
                if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              }
            }
          } /* end for */

          /* update the PixelID, we compute it from the previous variables index */
          for (i = 1; i <= Vars->Coord_Number; i++) {
            char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
            if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
              char outsidebounds=0;
              Coord_Index[i] = Coord[i] = 0;
              for (j= 1; j < i; j++) {
                /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
                if (Vars->Coord_Bin[j] == 1) continue; 
                if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                  outsidebounds=1;
                  Coord[i] = 0;
                  break;
                }
                Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
              }
              if (!outsidebounds) {
                Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
              }
            } /* end if PixelID */
          }
          While_Buffer++;
        } /* end if in Buffer */
        else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
        {
          Vars->Flag_Auto_Limits = 0;
          While_End = 1;
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
        }

        /* store n1d/2d section from Buffer */

        pp = Coord[0];
        /* apply per cm2 or per st */
        if (Vars->Flag_per_cm2 && Vars->area      != 0)
          pp /= Vars->area;
        
        /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
        if (!Vars->Flag_Multiple && Vars->Coord_NumberNoPixel == 2)
        { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
          i = Coord_Index[1];
          j = Coord_Index[2];
          if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
          {
            if (Vars->Mon2D_N) {
              Vars->Mon2D_N[i][j]++;
              Vars->Mon2D_p[i][j] += pp;
              Vars->Mon2D_p2[i][j] += pp*pp;
            }
          } else if (Vars->Flag_Absorb) pp=0;
        }
        else
        /* 1D and n1D case : Vars->Flag_Multiple */
        { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          for (i= 1; i <= Vars->Coord_Number; i++)
          {
            j = Coord_Index[i];
            if (j >= 0 && j < Vars->Coord_Bin[i])
            {
              if (Vars->Flag_Multiple && Vars->Mon2D_N) {
                Vars->Mon2D_N[i-1][j]++;
                Vars->Mon2D_p[i-1][j] += pp;
                Vars->Mon2D_p2[i-1][j] += pp*pp;
              }
            } else if (Vars->Flag_Absorb) {
              pp=0; break;
            }
          }
        } /* end store 2D/1D */
        
      } /* end while */
    } /* end Force Get Limits */

    /* write output files (sent to file as p[i*n + j] vectors) */
    if (Vars->Coord_Number == 0)
    {
      double Nsum;
      double psum, p2sum;
      Nsum = Vars->Nsum;
      psum = Vars->psum;
      p2sum= Vars->p2sum;
      if (Vars->Flag_signal != DEFS->COORD_P && Nsum > 0)
      { psum /=Nsum; p2sum /= Nsum*Nsum; }
      /* DETECTOR_OUT_0D(Vars->Monitor_Label, Vars->Nsum, Vars->psum, Vars->p2sum); */
      detector = mcdetector_out_0D(Vars->Monitor_Label, Nsum, psum, p2sum, Vars->compcurname, Vars->compcurpos);
    }
    else
    if (strlen(Vars->Mon_File) > 0)
    {
      fname = (char*)malloc(strlen(Vars->Mon_File)+10*Vars->Coord_Number);
      if (Vars->Flag_List && Vars->Mon2D_Buffer) /* List: DETECTOR_OUT_2D */
      {
       
        if (Vars->Flag_List >= 2) Vars->Buffer_Size = Vars->Neutron_Counter;
        if (Vars->Buffer_Size >= Vars->Neutron_Counter)
          Vars->Buffer_Size = Vars->Neutron_Counter;
        strcpy(fname,Vars->Mon_File);
        if (strchr(Vars->Mon_File,'.') == NULL) strcat(fname, "_list");

        strcpy(Coord_X_Label,"");
        for (i= 0; i <= Vars->Coord_Number; i++)
        {
          strcat(Coord_X_Label, Vars->Coord_Var[i]);
          strcat(Coord_X_Label, " ");
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i]); }
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s List (%lix%li).\n", Vars->compcurname, fname,bin2d,bin1d);

        /* handle the type of list output */
        strcpy(label, Vars->Monitor_Label);
        
        detector = mcdetector_out_list(
              label, "List of neutron events", Coord_X_Label,
              -Vars->Buffer_Size, Vars->Coord_Number+1,
              Vars->Mon2D_Buffer,
              fname, Vars->compcurname, Vars->compcurpos);
      }
      if (Vars->Flag_Multiple) /* n1D: DETECTOR_OUT_1D */
      {
        for (i= 0; i < Vars->Coord_Number; i++)
        {

          strcpy(fname,Vars->Mon_File);
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i+1]); }
          sprintf(Coord_X_Label, "%s monitor", Vars->Coord_Label[i+1]);
          strcpy(label, Coord_X_Label);
          if (Vars->Coord_Bin[i+1] > 0) { /* 1D monitor */
            if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 1D (%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[i+1]);
            min1d = Vars->Coord_Min[i+1];
            max1d = Vars->Coord_Max[i+1];
            if (min1d == max1d) max1d = min1d+1e-6;
            p1m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            p2m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            if (p2m == NULL) /* use Raw Buffer line output */
            {
              if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for output. Using raw data.\n", Vars->compcurname);
              if (p1m != NULL) free(p1m);
              detector = mcdetector_out_1D(
              label,
              Vars->Coord_Label[i+1],
              Vars->Coord_Label[0],
              Vars->Coord_Var[i+1],
              min1d, max1d,
              Vars->Coord_Bin[i+1],
              Vars->Mon2D_N[i],Vars->Mon2D_p[i],Vars->Mon2D_p2[i],
              fname, Vars->compcurname, Vars->compcurpos);
            } /* if (p2m == NULL) */
            else
            {
              if (Vars->Flag_log != 0)
              {
                XY = FLT_MAX;
                for (j=0; j < Vars->Coord_Bin[i+1]; j++) /* search min of signal */
                  if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j] > 0)) XY = Vars->Mon2D_p[i][j];
                if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
              } /* if */

              for (j=0; j < Vars->Coord_Bin[i+1]; j++)
              {
                p1m[j] = Vars->Mon2D_p[i][j];
                p2m[j] = Vars->Mon2D_p2[i][j];
                if (Vars->Flag_signal != DEFS->COORD_P && Vars->Mon2D_N[i][j] > 0)
                { /* normalize mean signal to the number of events */
                  p1m[j] /= Vars->Mon2D_N[i][j];
                  p2m[j] /= Vars->Mon2D_N[i][j]*Vars->Mon2D_N[i][j];
                }
                if (Vars->Flag_log != 0)
                {
                  if ((p1m[j] > 0) && (p2m[j] > 0))
                  {
                    p2m[j] /= p1m[j]*p1m[j];
                    p1m[j] = log(p1m[j])/log(10);
                  }
                  else
                  {
                    p1m[j] = XY;
                    p2m[j] = 0;
                  }
                }
              } /* for */
              detector = mcdetector_out_1D(
                label,
                Vars->Coord_Label[i+1],
                Vars->Coord_Label[0],
                Vars->Coord_Var[i+1],
                min1d, max1d,
                Vars->Coord_Bin[i+1],
                Vars->Mon2D_N[i],p1m,p2m,
                fname, Vars->compcurname, Vars->compcurpos);

            } /* else */
            /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
            if (p1m != NULL) free(p1m); p1m=NULL;
            if (p2m != NULL) free(p2m); p2m=NULL;
            */
          } else { /* 0d monitor */
            detector = mcdetector_out_0D(label, Vars->Mon2D_p[i][0], Vars->Mon2D_p2[i][0], Vars->Mon2D_N[i][0], Vars->compcurname, Vars->compcurpos);
          }


        } /* for */
      } /* if 1D */
      else
      if (Vars->Coord_NumberNoPixel == 2)  /* 2D: DETECTOR_OUT_2D */
      {
        strcpy(fname,Vars->Mon_File);

        p0m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p1m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p2m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        if (p2m == NULL)
        {
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for 2D array (%li). Skipping.\n", Vars->compcurname, 3*Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          */
        }
        else
        {
          if (Vars->Flag_log != 0)
          {
            XY = FLT_MAX;
            for (i= 0; i < Vars->Coord_Bin[1]; i++)
              for (j= 0; j < Vars->Coord_Bin[2]; j++) /* search min of signal */
                if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j]>0)) XY = Vars->Mon2D_p[i][j];
            if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
          }
          for (i= 0; i < Vars->Coord_Bin[1]; i++)
          {
            for (j= 0; j < Vars->Coord_Bin[2]; j++)
            {
              long index;
              index = j + i*Vars->Coord_Bin[2];
              p0m[index] = Vars->Mon2D_N[i][j];
              p1m[index] = Vars->Mon2D_p[i][j];
              p2m[index] = Vars->Mon2D_p2[i][j];
              if (Vars->Flag_signal != DEFS->COORD_P && p0m[index] > 0)
              {
                  p1m[index] /= p0m[index];
                  p2m[index] /= p0m[index]*p0m[index];
              }

              if (Vars->Flag_log != 0)
              {
                if ((p1m[index] > 0) && (p2m[index] > 0))
                {
                  p2m[index] /= (p1m[index]*p1m[index]);
                  p1m[index] = log(p1m[index])/log(10);

                }
                else
                {
                  p1m[index] = XY;
                  p2m[index] = 0;
                }
              }
            }
          }
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[1]);
              strcat(fname, "_"); strcat(fname, Vars->Coord_Var[2]); }
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 2D (%lix%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[1], Vars->Coord_Bin[2]);

          min1d = Vars->Coord_Min[1];
          max1d = Vars->Coord_Max[1];
          if (min1d == max1d) max1d = min1d+1e-6;
          min2d = Vars->Coord_Min[2];
          max2d = Vars->Coord_Max[2];
          if (min2d == max2d) max2d = min2d+1e-6;
          strcpy(label, Vars->Monitor_Label);
          if (Vars->Coord_Bin[1]*Vars->Coord_Bin[2] > 1
           && Vars->Flag_signal == DEFS->COORD_P)
            strcat(label, " per bin");

          detector = mcdetector_out_2D(
            label,
            Vars->Coord_Label[1],
            Vars->Coord_Label[2],
            min1d, max1d,
            min2d, max2d,
            Vars->Coord_Bin[1],
            Vars->Coord_Bin[2],
            p0m,p1m,p2m,
            fname, Vars->compcurname, Vars->compcurpos);

          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          if (p2m != NULL) free(p2m);
          */
        }
      }
      free(fname);
    }
    return(detector);
  } /* end Monitor_nD_Save */

/* ========================================================================= */
/* Monitor_nD_Finally: this routine is used to free memory                   */
/* ========================================================================= */

void Monitor_nD_Finally(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    int i;

    /* Now Free memory Mon2D.. */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      if (Vars->Mon2D_Buffer != NULL) free(Vars->Mon2D_Buffer);
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_Number)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      for (i= 0; i < Vars->Coord_Number; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }


    /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }
  } /* end Monitor_nD_Finally */

/* ========================================================================= */
/* Monitor_nD_McDisplay: this routine is used to display component           */
/* ========================================================================= */

void Monitor_nD_McDisplay(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    double radius, h;
    double xmin;
    double xmax;
    double ymin;
    double ymax;
    double zmin;
    double zmax;
    int    i;
    double hdiv_min=-180, hdiv_max=180, vdiv_min=-90, vdiv_max=90;
    char   restricted = 0;

    radius = Vars->Sphere_Radius;
    h = Vars->Cylinder_Height;
    xmin = Vars->mxmin;
    xmax = Vars->mxmax;
    ymin = Vars->mymin;
    ymax = Vars->mymax;
    zmin = Vars->mzmin;
    zmax = Vars->mzmax;

    /* determine if there are angular limits set at start (no auto) in coord_types
     * cylinder/banana: look for hdiv
     * sphere: look for angle, radius (->atan2(val,radius)), hdiv, vdiv
     * this activates a 'restricted' flag, to draw a region as blades on cylinder/sphere
     */
    for (i= 0; i <= Vars->Coord_Number; i++)
    {
      int Set_Vars_Coord_Type;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if (Set_Vars_Coord_Type == DEFS->COORD_HDIV || Set_Vars_Coord_Type == DEFS->COORD_THETA)
      { hdiv_min = Vars->Coord_Min[i]; hdiv_max = Vars->Coord_Max[i]; restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_VDIV || Set_Vars_Coord_Type == DEFS->COORD_PHI)
      { vdiv_min = Vars->Coord_Min[i]; vdiv_max = Vars->Coord_Max[i];restricted = 1;  }
      else if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
      { hdiv_min = vdiv_min = Vars->Coord_Min[i];
        hdiv_max = vdiv_max = Vars->Coord_Max[i];
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
      { double angle;
        angle = RAD2DEG*atan2(Vars->Coord_Max[i], radius);
        hdiv_min = vdiv_min = angle;
        hdiv_max = vdiv_max = angle;
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_Y && abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)
      {
        vdiv_min = atan2(ymin,radius)*RAD2DEG;
        vdiv_max = atan2(ymax,radius)*RAD2DEG;
        restricted = 1;
      }
    }
    /* full sphere */
    if ((!restricted && (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    || abs(Vars->Flag_Shape) == DEFS->SHAPE_PREVIOUS)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
      mcdis_circle("xz",0,0,0,radius);
      mcdis_circle("yz",0,0,0,radius);
    }
    /* banana/cylinder/sphere portion */
    else
    if (restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)))
    {
      int NH=24, NV=24;
      int ih, iv;
      double width, height;
      int issphere;
      issphere = (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE);
      width = (hdiv_max-hdiv_min)/NH;
      if (!issphere) NV=1; /* cylinder has vertical axis */
      else height= (vdiv_max-vdiv_min)/NV;
      
      /* check width and height of elements (sphere) to make sure the nb
         of plates remains limited */
      if (width < 10  && NH > 1) { width = 10;  NH=(hdiv_max-hdiv_min)/width; width=(hdiv_max-hdiv_min)/NH; }
      if (height < 10 && NV > 1) { height = 10; NV=(vdiv_max-vdiv_min)/height; height= (vdiv_max-vdiv_min)/NV; }
      
      mcdis_magnify("xyz");
      for(ih = 0; ih < NH; ih++)
        for(iv = 0; iv < NV; iv++)
        {
          double theta0, phi0, theta1, phi1;          /* angles in spherical coordinates */
          double x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3; /* vertices at plate edges */
          phi0 = (hdiv_min+ width*ih-90)*DEG2RAD;        /* in xz plane */
          phi1 = (hdiv_min+ width*(ih+1)-90)*DEG2RAD;
          if (issphere)
          {
            theta0= (vdiv_min+height* iv + 90)   *DEG2RAD; /* in vertical plane */
            theta1= (vdiv_min+height*(iv+1) + 90)*DEG2RAD;
            if (y0 < ymin) y0=ymin; 
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin; 
            if (y1 > ymax) y1=ymax;
            
            y0 = -radius*cos(theta0);            /* z with Z vertical */
            y1 = -radius*cos(theta1);
            if (y0 < ymin) y0=ymin;
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin;
            if (y1 > ymax) y1=ymax;
          } else {
            y0 = ymin;
            y1 = ymax;
            theta0=theta1=90*DEG2RAD;
          }

          x0 = radius*sin(theta0)*cos(phi0); /* x with Z vertical */
          z0 =-radius*sin(theta0)*sin(phi0); /* y with Z vertical */
          x1 = radius*sin(theta1)*cos(phi0); 
          z1 =-radius*sin(theta1)*sin(phi0);
          x2 = radius*sin(theta1)*cos(phi1); 
          z2 =-radius*sin(theta1)*sin(phi1);
          x3 = radius*sin(theta0)*cos(phi1); 
          z3 =-radius*sin(theta0)*sin(phi1);
          y2 = y1; y3 = y0;

          mcdis_multiline(5,
            x0,y0,z0,
            x1,y1,z1,
            x2,y2,z2,
            x3,y3,z3,
            x0,y0,z0);
        }
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dt, dy;
	dt = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_BANANA_DET:  %g, %g, %g, %g, %g, %li, %li, %g\n", radius, 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]); 
      }
    }
    /* disk (circle) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
    }
    /* rectangle (square) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_SQUARE)
    {
      mcdis_magnify("xy");
      mcdis_multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
      
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dx, dy;
	dx = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_RECTANGULAR_DET:  %g, %g, %g, %g, %li, %li, %g\n", 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]);
      }
    }
    /* full cylinder/banana */
    else
    if (!restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)))
    {
      mcdis_magnify("xyz");
      mcdis_circle("xz", 0,  h/2.0, 0, radius);
      mcdis_circle("xz", 0, -h/2.0, 0, radius);
      mcdis_line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
      mcdis_line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
      mcdis_line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
      mcdis_line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
    }
    else
    /* box */
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_BOX)
    {
      mcdis_magnify("xyz");
      mcdis_multiline(5, xmin, ymin, zmin,
                   xmax, ymin, zmin,
                   xmax, ymax, zmin,
                   xmin, ymax, zmin,
                   xmin, ymin, zmin);
      mcdis_multiline(5, xmin, ymin, zmax,
                   xmax, ymin, zmax,
                   xmax, ymax, zmax,
                   xmin, ymax, zmax,
                   xmin, ymin, zmax);
      mcdis_line(xmin, ymin, zmin, xmin, ymin, zmax);
      mcdis_line(xmax, ymin, zmin, xmax, ymin, zmax);
      mcdis_line(xmin, ymax, zmin, xmin, ymax, zmax);
      mcdis_line(xmax, ymax, zmin, xmax, ymax, zmax);
    }
  } /* end Monitor_nD_McDisplay */

/* end of monitor_nd-lib.c */

#line 8954 "RITA-II.c"

/* Shared user declarations for all components 'Virtual_input'. */
#line 74 "/usr/share/mcstas/2.5/sources/Virtual_input.comp"


long Virtual_input_Read_Input(char *aFile, char *aType, t_Table *aTable, long *aOffset)
  {
    long max_lines = 50000;
    long length=0;
    char bType[32];

    if (!aFile) return (0);
    if (aType) strcpy(bType, aType);
    else strcpy(bType, "???");

    Table_Free(aTable);

    /* Try to Open neutron input text filename. */
    if((aFile && aType == NULL) || !strcmp(bType,"text")) {
      Table_Read_Offset(aTable, aFile, 0, aOffset, max_lines);  /* read data from filename into rTable */
      strcpy(bType, "text");
    }
    if (!aTable->data && aType && aType[0] != 't')
      Table_Read_Offset_Binary(aTable, aFile, aType, aOffset, max_lines, 11);

    return(aTable->rows);
  }
#line 8982 "RITA-II.c"

/* Shared user declarations for all components 'Monitor_nD'. */
#line 214 "/usr/share/mcstas/2.5/monitors/Monitor_nD.comp"


/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff.h
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Release: 
* Version: 
*
* Object File Format intersection header for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format:
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#define INTEROFF_LIB_H "$Revision$"

#ifndef EPSILON
#define EPSILON 1e-13
#endif

#define OFF_INTERSECT_MAX 100

//#include <float.h>

#define N_VERTEX_DISPLAYED    200000

typedef struct intersection {
	MCNUM time;  	  //time of the intersection
	Coords v;	      //intersection point
	Coords normal;  //normal vector of the surface intersected
	short in_out;	  //1 if the ray enters the volume, -1 otherwise
	short edge;	    //1 if the intersection is on the boundary of the polygon, and error is possible
	unsigned long index; // index of the face
} intersection;

typedef struct polygon {
  MCNUM* p;       //vertices of the polygon in adjacent order, this way : x1 | y1 | z1 | x2 | y2 | z2 ...
  int npol;       //number of vertices
  Coords normal;
} polygon;

typedef struct off_struct {
    long vtxSize;
    long polySize;
    long faceSize;
    Coords* vtxArray;
    Coords* normalArray;
    unsigned long* faceArray;
    char *filename;
    int mantidflag;
    long mantidoffset;
    intersection intersects[OFF_INTERSECT_MAX]; // After a call to off_intersect_all contains the list of intersections.
    int nextintersect;                 // 'Next' intersection (first t>0) solution after call to off_intersect_all
    int numintersect;               // Number of intersections after call to off_intersect_all
} off_struct;

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box. 
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure 
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth, 
                int notcenter, off_struct* data);

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data );

/*******************************************************************************
* int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data );

/*****************************************************************************
* int off_intersectx(double* l0, double* l3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double kx, double ky, double kz, 
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z, 
     double kx, double ky, double kz, 
     off_struct data );

/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED points from the object
*******************************************************************************/
void off_display(off_struct);

#endif

/* end of interoff-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff-lib.c
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Origin: ILL
* Release: $Revision$
* Version: McStas X.Y
*
* Object File Format intersection library for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format (it supports comments):
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#include "interoff-lib.h"
#endif

double off_F(double x, double y,double z,double A,double B,double C,double D) {
  return ( A*x + B*y + C*z + D );
}

char off_sign(double a) {
  if (a<0)       return(-1);
  else if (a==0) return(0);
  else           return(1);
}

// off_normal ******************************************************************
//gives the normal vector of p
void off_normal(Coords* n, polygon p)
{
  //using Newell method
  int i=0,j=0;
  n->x=0;n->y=0;n->z=0;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++)
  {
    MCNUM x1=p.p[3*i],
          y1=p.p[3*i+1],
          z1=p.p[3*i+2];
    MCNUM x2=p.p[3*j],
          y2=p.p[3*j+1],
          z2=p.p[3*j+2];
    // n is the cross product of v1*v2
    n->x += (y1 - y2) * (z1 + z2);
    n->y += (z1 - z2) * (x1 + x2);
    n->z += (x1 - x2) * (y1 + y2);
  }
} /* off_normal */

// off_pnpoly ******************************************************************
//based on http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
//return 0 if the vertex is out
//    1 if it is in
//   -1 if on the boundary
int off_pnpoly(polygon p, Coords v)
{
  int i=0, c = 0;
  MCNUM minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;
  MCNUM rangex=0,rangey=0,rangez=0;

  int pol2dx=0,pol2dy=1;          //2d restriction of the poly
  MCNUM x=v.x,y=v.y;


  //take the most relevant 2D projection (prevent from instability)
  for (i=0; i<p.npol; ++i)
  {
    if (p.p[3*i]<minx)   minx=p.p[3*i];
    if (p.p[3*i]>maxx)   maxx=p.p[3*i];
    if (p.p[3*i+1]<miny) miny=p.p[3*i+1];
    if (p.p[3*i+1]>maxy) maxy=p.p[3*i+1];
    if (p.p[3*i+2]<minz) minz=p.p[3*i+2];
    if (p.p[3*i+2]>maxz) maxz=p.p[3*i+2];
  }
  rangex=maxx-minx;
  rangey=maxy-miny;
  rangez=maxz-minz;

  if (rangex<rangez)
  {
    if (rangex<rangey) {
      pol2dx=2;
      x=v.z;
    } else {
      pol2dy=2;
      y=v.z;
    }
  }
  else if (rangey<rangez) {
    pol2dy=2;
    y=v.z;
  }

  //trace rays and test number of intersection
  int j;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++) {
    if (((((p.p[3*i+pol2dy])<=y) && (y<(p.p[3*j+pol2dy]))) ||
         (((p.p[3*j+pol2dy])<=y) && (y<(p.p[3*i+pol2dy])))) &&
        (x < ( (p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
             / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx]) ))
      c = !c;

    if (((fabs(p.p[3*i+pol2dy]-y)<=EPSILON) || ((fabs(p.p[3*j+pol2dy]-y)<=EPSILON))) &&
        fabs(x -((p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
          / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx])) < EPSILON)
    {
      //the point lies on the edge
      c=-1;
      break;
    }
  }

  return c;
} /* off_pnpoly */

// off_intersectPoly ***********************************************************
//gives the intersection vertex between ray [a,b) and polygon p and its parametric value on (a b)
//based on http://geometryalgorithms.com/Archive/algorithm_0105/algorithm_0105.htm
int off_intersectPoly(intersection *inter, Coords a, Coords b, polygon p)
{
  //direction vector of [a,b]
  Coords dir = {b.x-a.x, b.y-a.y, b.z-a.z};

  //the normal vector to the polygon
  Coords normale=p.normal;
  //off_normal(&normale, p); done at the init stage

  //direction vector from a to a vertex of the polygon
  Coords w0 = {a.x-p.p[0], a.y-p.p[1], a.z-p.p[2]};

  //scalar product
  MCNUM nw0  =-scalar_prod(normale.x,normale.y,normale.z,w0.x,w0.y,w0.z);
  MCNUM ndir = scalar_prod(normale.x,normale.y,normale.z,dir.x,dir.y,dir.z);
  inter->time = inter->edge = inter->in_out=0;
  inter->v = inter->normal = coords_set(0,0,1);

  if (fabs(ndir) < EPSILON)    // ray is parallel to polygon plane
  {
    if (nw0 == 0)              // ray lies in polygon plane (infinite number of solution)
      return 0;
    else return 0;             // ray disjoint from plane (no solution)
  }

  // get intersect point of ray with polygon plane
  inter->time = nw0 / ndir;            //parametric value the point on line (a,b)

  inter->v = coords_set(a.x + inter->time * dir.x,// intersect point of ray and plane
    a.y + inter->time * dir.y,
    a.z + inter->time * dir.z);

  int res=off_pnpoly(p,inter->v);

  inter->edge=(res==-1);
  if (ndir<0)
    inter->in_out=1;  //the negative dot product means we enter the surface
  else
    inter->in_out=-1;

  inter->normal=p.normal;

  return res;         //true if the intersection point lies inside the poly
} /* off_intersectPoly */


// off_getBlocksIndex **********************************************************
/*reads the indexes at the beginning of the off file as this :
line 1  OFF
line 2  nbVertex nbFaces nbEdges
*/
FILE *off_getBlocksIndex(char* filename, long* vtxSize, long* polySize )
{
  FILE* f = Open_File(filename,"r", NULL); /* from read_table-lib: FILE *Open_File(char *name, char *Mode, char *path) */
  if (!f) return (f);
  
  char line[CHAR_BUF_LENGTH];
  char *ret=0;
  *vtxSize = *polySize = 0;

  /* **************** start to read the file header */
  /* OFF file:
     'OFF' or '3'
   */

  ret=fgets(line,CHAR_BUF_LENGTH , f);// line 1 = "OFF"
  if (ret == NULL)
  {
    fprintf(stderr, "Error: Can not read 1st line in file %s (interoff/off_getBlocksIndex)\n", filename);
    exit(1);
  }
  if (strlen(line)>5)
  {
      fprintf(stderr,"Error: First line in %s is too long (=%d). Possibly the line is not terminated by '\\n'.\n" 
              "       The first line is required to be exactly 'OFF', '3' or 'ply'.\n",filename,strlen(line));
      fclose(f);
      return(NULL);
  }

  if (strncmp(line,"OFF",3) && strncmp(line,"3",1) && strncmp(line,"ply",1))
  {
    fprintf(stderr, "Error: %s is probably not an OFF, NOFF or PLY file (interoff/off_getBlocksIndex).\n"
                    "       Requires first line to be 'OFF', '3' or 'ply'.\n",filename);
    fclose(f);
    return(NULL);
  }

  if (!strncmp(line,"OFF",3) || !strncmp(line,"3",1)) {
    do  /* OFF file: skip # comments which may be there */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
    } while (line[0]=='#');
    //line = nblines of vertex,faces and edges arrays
    sscanf(line,"%lu %lu",vtxSize,polySize);
  } else {
    do  /* PLY file: read all lines until find 'end_header'
           and locate 'element faces' and 'element vertex' */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
      if (!strncmp(line,"element face",12))
        sscanf(line,"element face %lu",polySize);
      else if (!strncmp(line,"element vertex",14))
        sscanf(line,"element vertex %lu",vtxSize);
      else if (!strncmp(line,"format binary",13))
        exit(fprintf(stderr,
          "Error: Can not read binary PLY file %s, only 'format ascii' (interoff/off_getBlocksIndex)\n%s\n",
          filename, line));
    } while (strncmp(line,"end_header",10));
  }
  
  /* The FILE is left opened ready to read 'vtxSize' vertices (vtxSize *3 numbers)
     and then polySize polygons (rows) */

  return(f);
} /* off_getBlocksIndex */

// off_init_planes *************************************************************
//gives the equations of 2 perpandicular planes of [ab]
void off_init_planes(Coords a, Coords b,
  MCNUM* A1, MCNUM* C1, MCNUM* D1, MCNUM *A2, MCNUM* B2, MCNUM* C2, MCNUM* D2)
{
  //direction vector of [a b]
  Coords dir={b.x-a.x, b.y-a.y, b.z-a.z};

  //the plane parallel to the 'y' is computed with the normal vector of the projection of [ab] on plane 'xz'
  *A1= dir.z;
  *C1=-dir.x;
  if(*A1!=0 || *C1!=0)
    *D1=-(a.x)*(*A1)-(a.z)*(*C1);
  else
  {
    //the plane does not support the vector, take the one parallel to 'z''
    *A1=1;
    //B1=dir.x=0
    *D1=-(a.x);
  }
  //the plane parallel to the 'x' is computed with the normal vector of the projection of [ab] on plane 'yz'
  *B2= dir.z;
  *C2=-dir.y;
  *A2= 0;
  if (*B2==0 && *C2==0)
  {
    //the plane does not support the vector, take the one parallel to 'z'
    *B2=1;
    //B1=dir.x=0
    *D2=-(a.y);
  }
  else {
    if (dir.z==0)
    {
      //the planes are the same, take the one parallel to 'z'
      *A2= dir.y;
      *B2=-dir.x;
      *D2=-(a.x)*(*A2)-(a.y)*(*B2);
    }
    else
      *D2=-(a.y)**B2-(a.z)**C2;
  }
} /* off_init_planes */

// off_clip_3D_mod *************************************************************
int off_clip_3D_mod(intersection* t, Coords a, Coords b,
  Coords* vtxArray, unsigned long vtxSize, unsigned long* faceArray,
  unsigned long faceSize, Coords* normalArray)
{
  MCNUM A1=0, C1=0, D1=0, A2=0, B2=0, C2=0, D2=0;      //perpendicular plane equations to [a,b]
  off_init_planes(a, b, &A1, &C1, &D1, &A2, &B2, &C2, &D2);

  int t_size=0;
  //unsigned long vtxSize=vtxTable.rows, faceSize=faceTable.columns;  //Size of the corresponding tables
  char sg[vtxSize];  //array telling if vertex is left or right of the plane
  MCNUM popol[3*CHAR_BUF_LENGTH];
  unsigned long i=0,indPoly=0;
  for (i=0; i < vtxSize; ++i)
  {
    sg[i]=off_sign(off_F(vtxArray[i].x,vtxArray[i].y,vtxArray[i].z,A1,0,C1,D1));
  }

  //exploring the polygons :
  i=indPoly=0;
  while (i<faceSize)
  {
    polygon pol;
    pol.npol  = faceArray[i];                //nb vertex of polygon
    pol.p     = popol;
    pol.normal= coords_set(0,0,1);
    unsigned long indVertP1=faceArray[++i];  //polygon's first vertex index in vtxTable
    int j=1;
    while (j<pol.npol)
    {
      //polygon's j-th vertex index in vtxTable
      if (sg[indVertP1]!=sg[faceArray[i+j]]) //if the plane intersect the polygon
        break;

      ++j;
    }

    if (j<pol.npol)          //ok, let's test with the second plane
    {
      char sg1=off_sign(off_F(vtxArray[indVertP1].x,vtxArray[indVertP1].y,vtxArray[indVertP1].z,A2,B2,C2,D2));//tells if vertex is left or right of the plane

      j=1;
      while (j<pol.npol)
      {
        //unsigned long indVertPi=faceArray[i+j];  //polyg's j-th vertex index in vtxTable
        Coords vertPi=vtxArray[faceArray[i+j]];
        if (sg1!=off_sign(off_F(vertPi.x,vertPi.y,vertPi.z,A2,B2,C2,D2)))//if the plane intersect the polygon
          break;
        ++j;
      }
      if (j<pol.npol)
      {
        if (t_size>CHAR_BUF_LENGTH)
        {
          fprintf(stderr, "Warning: number of intersection exceeded (%d) (interoff-lib/off_clip_3D_mod)\n", CHAR_BUF_LENGTH);
            return (t_size);
        }
        //both planes intersect the polygon, let's find the intersection point
        //our polygon :
        int k;
        for (k=0; k<pol.npol; ++k)
        {
          Coords vertPk=vtxArray[faceArray[i+k]];
          pol.p[3*k]  =vertPk.x;
          pol.p[3*k+1]=vertPk.y;
          pol.p[3*k+2]=vertPk.z;
        }
        pol.normal=normalArray[indPoly];
        intersection x;
        if (off_intersectPoly(&x, a, b, pol))
        {
          x.index = indPoly;
          t[t_size++]=x;
        }
      } /* if (j<pol.npol) */
    } /* if (j<pol.npol) */
    i += pol.npol;
    indPoly++;
  } /* while i<faceSize */
  return t_size;
} /* off_clip_3D_mod */


// off_compare *****************************************************************
int off_compare (void const *a, void const *b)
{
   intersection const *pa = a;
   intersection const *pb = b;

   return off_sign(pa->time - pb->time);
} /* off_compare */

// off_cleanDouble *************************************************************
//given an array of intersections throw those which appear several times
//returns 1 if there is a possibility of error
int off_cleanDouble(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    int j=i;
    //for each intersection with the same time
    while (j<*t_size && fabs(prev.time-t[j].time)<EPSILON)
    {
      //if the intersection is the exact same erase it
      if (prev.in_out==t[j].in_out)
      {
        int k;
        for (k=j+1; k<*t_size; ++k)
        {
          t[k-1]=t[k];
        }
        *t_size-=1;
      }
      else
        ++j;
    }
    prev=t[i];
    ++i;

  }
  return 1;
} /* off_cleanDouble */

// off_cleanInOut **************************************************************
//given an array of intesections throw those which enter and exit in the same time
//Meaning the ray passes very close to the volume
//returns 1 if there is a possibility of error
int off_cleanInOut(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    //if two intersection have the same time but one enters and the other exits erase both
    //(such intersections must be adjacent in the array : run off_cleanDouble before)
    if (fabs(prev.time-t[i].time)<EPSILON && prev.in_out!=t[i].in_out)
    {
      int j=0;
      for (j=i+1; j<*t_size; ++j)
      {
        t[j-2]=t[j];
      }
      *t_size-=2;
      prev=t[i-1];
    }
    else
    {
      prev=t[i];
      ++i;
    }
  }
  return (*t_size);
} /* off_cleanInOut */

/* PUBLIC functions ******************************************************** */

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box.
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth,
                int notcenter, off_struct* data)
{
  // data to be initialized
  long    vtxSize =0, polySize=0, i=0, ret=0, faceSize=0;
  Coords* vtxArray        =NULL;
  Coords* normalArray     =NULL;
  unsigned long* faceArray=NULL;
  FILE*   f               =NULL; /* the FILE with vertices and polygons */
  double minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;

  // get the indexes
  if (!data) return(0);
  
  MPI_MASTER(
  printf("Loading geometry file (OFF/PLY): %s\n", offfile);
  );
  
  f=off_getBlocksIndex(offfile,&vtxSize,&polySize);
  if (!f) return(0);
  
  // read vertex table = [x y z | x y z | ...] =================================
  // now we read the vertices as 'vtxSize*3' numbers and store it in vtxArray 
  MPI_MASTER(
  printf("  Number of vertices: %ld\n", vtxSize);
  );
  vtxArray   = malloc(vtxSize*sizeof(Coords));
  if (!vtxArray) return(0);
  i=0;
  while (i<vtxSize && ~feof(f))
  {
    double x,y,z;
    ret=fscanf(f, "%lg%lg%lg", &x,&y,&z);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 3) {
      fprintf(stderr, "Error: can not read [xyz] coordinates for vertex %li in file %s (interoff/off_init). Read %i values.\n", 
        i, offfile, ret);
      exit(2);
    }
    vtxArray[i].x=x;
    vtxArray[i].y=y;
    vtxArray[i].z=z;

    //bounding box
    if (vtxArray[i].x<minx) minx=vtxArray[i].x;
    if (vtxArray[i].x>maxx) maxx=vtxArray[i].x;
    if (vtxArray[i].y<miny) miny=vtxArray[i].y;
    if (vtxArray[i].y>maxy) maxy=vtxArray[i].y;
    if (vtxArray[i].z<minz) minz=vtxArray[i].z;
    if (vtxArray[i].z>maxz) maxz=vtxArray[i].z;
    i++; // inquire next vertex
  }

  // resizing and repositioning params
  double centerx=0, centery=0, centerz=0;
  if (!notcenter) {
    centerx=(minx+maxx)*0.5;
    centery=(miny+maxy)*0.5;
    centerz=(minz+maxz)*0.5;
  }

  double rangex=-minx+maxx,
         rangey=-miny+maxy,
         rangez=-minz+maxz;

  double ratiox=1,ratioy=1,ratioz=1;

  if (xwidth && rangex)
  {
    ratiox=xwidth/rangex;
    ratioy=ratiox;
    ratioz=ratiox;
  }

  if (yheight && rangey)
  {
    ratioy=yheight/rangey;
    if(!xwidth)  ratiox=ratioy;
    ratioz=ratioy;
  }

  if (zdepth && rangez)
  {
    ratioz=zdepth/rangez;
    if(!xwidth)  ratiox=ratioz;
    if(!yheight) ratioy=ratioz;
  }

  rangex *= ratiox;
  rangey *= ratioy;
  rangez *= ratioz;

  //center and resize the object
  for (i=0; i<vtxSize; ++i)
  {
    vtxArray[i].x=(vtxArray[i].x-centerx)*ratiox+(!notcenter ? 0 : centerx);
    vtxArray[i].y=(vtxArray[i].y-centery)*ratioy+(!notcenter ? 0 : centery);
    vtxArray[i].z=(vtxArray[i].z-centerz)*ratioz+(!notcenter ? 0 : centerz);
  }
  
  // read face table = [nbvertex v1 v2 vn | nbvertex v1 v2 vn ...] =============
  MPI_MASTER(
  printf("  Number of polygons: %ld\n", polySize);
  );
  normalArray= malloc(polySize*sizeof(Coords));
  faceArray  = malloc(polySize*10*sizeof(unsigned long)); // we assume polygons have less than 9 vertices
  if (!normalArray || !faceArray) return(0);
  
  // fill faces
  faceSize=0;
  i=0;
  while (i<polySize && ~feof(f)) {
    int  nbVertex=0, j=0;
    // read the length of this polygon
    ret=fscanf(f, "%d", &nbVertex);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 1) {
      fprintf(stderr, "Error: can not read polygon %i length in file %s (interoff/off_init)\n", 
        i, offfile);
      exit(3);
    }
    if (faceSize > polySize*10) {
      fprintf(stderr, "Error: %li exceeded allocated polygon array[%li] in file %s (interoff/off_init)\n", 
        faceSize, polySize*10, offfile);
    }
    faceArray[faceSize++] = nbVertex; // length of the polygon/face
    // then read the vertex ID's
    for (j=0; j<nbVertex; j++) {
      double vtx=0;
      fscanf(f, "%lg", &vtx);
      faceArray[faceSize++] = vtx;   // add vertices index after length of polygon
    }
    i++;
  }

  // precomputes normals
  long indNormal=0;//index in polyArray
  i=0;    //index in faceArray
  while (i<faceSize)
  {
    int    nbVertex=faceArray[i];//nb of vertices of this polygon
    double vertices[3*nbVertex];
    int j;

    for (j=0; j<nbVertex; ++j)
    {
      unsigned long indVertPj=faceArray[i+j+1];
      vertices[3*j]  =vtxArray[indVertPj].x;
      vertices[3*j+1]=vtxArray[indVertPj].y;
      vertices[3*j+2]=vtxArray[indVertPj].z;
    }

    polygon p;
    p.p   =vertices;
    p.npol=nbVertex;
    off_normal(&(p.normal),p);

    normalArray[indNormal]=p.normal;

    i += nbVertex+1;
    indNormal++;

  }
  
  MPI_MASTER(
  if (ratiox!=ratioy || ratiox!=ratioz || ratioy!=ratioz)
    printf("Warning: Aspect ratio of the geometry %s was modified.\n"
           "         If you want to keep the original proportions, specifiy only one of the dimensions.\n",
           offfile);
  if ( xwidth==0 && yheight==0 && zdepth==0 ) {
    printf("Warning: Neither xwidth, yheight or zdepth are defined.\n"
	   "           The file-defined (non-scaled) geometry the OFF geometry %s will be applied!\n", 
           offfile);
  }
  printf("  Bounding box dimensions for geometry %s:\n", offfile);
  printf("    Length=%f (%.3f%%)\n", rangex, ratiox*100);
  printf("    Width= %f (%.3f%%)\n", rangey, ratioy*100);
  printf("    Depth= %f (%.3f%%)\n", rangez, ratioz*100);
  );

  data->vtxArray   = vtxArray;
  data->normalArray= normalArray;
  data->faceArray  = faceArray;
  data->vtxSize    = vtxSize;
  data->polySize   = polySize;
  data->faceSize   = faceSize;
  data->filename   = offfile;
  return(polySize);
} /* off_init */

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct *data )
{
    Coords A={x, y, z};
    Coords B={x+vx, y+vy, z+vz};
    int t_size=off_clip_3D_mod(data->intersects, A, B,
      data->vtxArray, data->vtxSize, data->faceArray, data->faceSize, data->normalArray );
    qsort(data->intersects, t_size, sizeof(intersection),  off_compare);
    off_cleanDouble(data->intersects, &t_size);
    off_cleanInOut(data->intersects,  &t_size);

    /*find intersections "closest" to 0 (favouring positive ones)*/
    if(t_size>0){
      int i=0;
      if(t_size>1) {
        for (i=1; i < t_size-1; i++){
          if (data->intersects[i-1].time > 0 && data->intersects[i].time > 0)
            break;
        }
	
	data->nextintersect=i-1;
	data->numintersect=t_size;

        if (t0) *t0 = data->intersects[i-1].time;
        if (n0) *n0 = data->intersects[i-1].normal;
        if (t3) *t3 = data->intersects[i].time;
        if (n3) *n3 = data->intersects[i].normal;
      } else {
        if (t0) *t0 = data->intersects[0].time; 	 
	      if (n0) *n0 = data->intersects[0].normal;
      }
      /* should also return t[0].index and t[i].index as polygon ID */
      return t_size;
    }
    return 0;
} /* off_intersect */

/*******************************************************************************
* int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct data )
{
  return off_intersect_all(t0, t3, n0, n3, x, y, z, vx, vy, vz, &data );
} /* off_intersect */

/*****************************************************************************
* int off_x_intersect(double* l0, double* l3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double kx, double ky, double kz,
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double kx, double ky, double kz,
     off_struct data )
{
  /*This function simply reformats and calls off_intersect (as for neutrons)
   *by normalizing the wavevector - this will yield the intersection lengths
   *in m*/
  double jx,jy,jz,invk;
  int n;
  invk=1/sqrt(scalar_prod(kx,ky,kz,kx,ky,kz));
  jx=kx*invk;jy=ky*invk;jz=kz*invk;
  n=off_intersect(l0,l3,n0,n3,x,y,z,jx,jy,jz,data);
  return n;
}


/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED polygons from the object
*******************************************************************************/
void off_display(off_struct data)
{
  unsigned int i;
  double ratio=(double)(N_VERTEX_DISPLAYED)/(double)data.faceSize;
  unsigned int pixel=0;
  for (i=0; i<data.faceSize-1; i++) {
    int j;
    int nbVertex = data.faceArray[i];
    double x0,y0,z0;
    x0 = data.vtxArray[data.faceArray[i+1]].x;
    y0 = data.vtxArray[data.faceArray[i+1]].y;
    z0 = data.vtxArray[data.faceArray[i+1]].z;
    double x1=x0,y1=y0,z1=z0;
    double cmx=0,cmy=0,cmz=0;
    
    int drawthis = rand01() < ratio;
    // First pass, calculate center of mass location...
    for (j=1; j<=nbVertex; j++) {
      cmx = cmx+data.vtxArray[data.faceArray[i+j]].x;
      cmy = cmy+data.vtxArray[data.faceArray[i+j]].y;
      cmz = cmz+data.vtxArray[data.faceArray[i+j]].z;
    }
    cmx /= nbVertex;
    cmy /= nbVertex;
    cmz /= nbVertex;
    
    char pixelinfo[1024];    
    sprintf(pixelinfo, "%u,%u,%u,%i,%g,%g,%g,%g,%g,%g", data.mantidoffset+pixel, data.mantidoffset, data.mantidoffset+data.polySize-1, nbVertex, cmx, cmy, cmz, x1-cmx, y1-cmy, z1-cmz);
    for (j=2; j<=nbVertex; j++) {
      double x2,y2,z2;
      x2 = data.vtxArray[data.faceArray[i+j]].x;
      y2 = data.vtxArray[data.faceArray[i+j]].y;
      z2 = data.vtxArray[data.faceArray[i+j]].z;
      sprintf(pixelinfo, "%s,%g,%g,%g", pixelinfo, x2-cmx, y2-cmy, z2-cmz); 
      if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x2,y2,z2);
      }
      x1 = x2; y1 = y2; z1 = z2;
    }
    if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x0,y0,z0);
      }
    if (data.mantidflag) {
      printf("MANTID_PIXEL: %s\n", pixelinfo);
      pixel++;
    }
    i += nbVertex;
  }
} /* off_display */

/* end of interoff-lib.c */

#line 9980 "RITA-II.c"

/* Shared user declarations for all components 'Incoherent'. */
#line 128 "/usr/share/mcstas/2.5/samples/Incoherent.comp"



struct StructVarsInc
{
double  sigma_a; /* Absorption cross section per atom (barns) */
    double  sigma_i; /* Incoherent scattering cross section per atom (barns) */
    double  rho;     /* Density of atoms (AA-3) */
    double  my_s;
    double  my_a_v;
    int     shape;       /* 0 cylinder, 1 box, 2 sphere, 3 OFF file */
    double  aw,ah;       /* rectangular angular dimensions */
    double  xw,yh;       /* rectangular metrical dimensions */
    double  tx,ty,tz;    /* target coords */
    };
#line 9999 "RITA-II.c"

/* Shared user declarations for all components 'PowderN'. */
#line 216 "/usr/share/mcstas/2.5/samples/PowderN.comp"
/* used for reading data table from file */


/* Declare structures and functions only once in each instrument. */
#ifndef POWDERN_DECL
#define POWDERN_DECL
/* format definitions in the order {j d F2 DW Dd inv2d q F strain} */
#ifndef Crystallographica
#define Crystallographica { 4,5,7,0,0,0,0,0,0 }
#define Fullprof          { 4,0,8,0,0,5,0,0,0 }
#define Lazy              {17,6,0,0,0,0,0,13,0 }
#define Undefined         { 0,0,0,0,0,0,0,0,0 }
#endif
  
struct line_data
{
double F2;                  /* Value of structure factor */
double q;                   /* Qvector */
int j;                      /* Multiplicity */
double DWfactor;            /* Debye-Waller factor */
double w;                   /* Intrinsic line width */
double Epsilon;             /* Strain=delta_d_d/d shift in ppm */
};

struct line_info_struct
{
struct line_data *list;     /* Reflection array */
int  count;                  /* Number of reflections */
double Dd;
double DWfactor;
double V_0;
double rho;
double at_weight;
double at_nb;
double sigma_a;
double sigma_i;
char   compname[256];
double flag_barns;
int    shape; /* 0 cylinder, 1 box, 2 sphere, 3 OFF file */
int    column_order[9]; /* column signification */
int    flag_warning;
char   type;  /* interaction type of event t=Transmit, i=Incoherent, c=Coherent */
int    itype; /* int representation of type */ 
double dq;    /* wavevector transfer [Angs-1] */
double Epsilon; /* global strain in ppm */
double XsectionFactor;
double my_s_v2_sum;
double my_a_v;
double my_inc;
double lfree; // store mean free path for the last event;
double *w_v,*q_v, *my_s_v2;
double radius_i,xwidth_i,yheight_i,zdepth_i;
double v; /* last velocity (cached) */
double Nq;
int    nb_reuses, nb_refl, nb_refl_count;
double v_min, v_max;
double xs_Nq[CHAR_BUF_LENGTH];
double xs_sum[CHAR_BUF_LENGTH];
double neutron_passed;
long   xs_compute, xs_reuse, xs_calls;
};

  off_struct offdata;

  // PN_list_compare *****************************************************************

  int PN_list_compare (void const *a, void const *b)
  {
     struct line_data const *pa = a;
     struct line_data const *pb = b;
     double s = pa->q - pb->q;

     if (!s) return 0;
     else    return (s < 0 ? -1 : 1);
  } /* PN_list_compare */

  int read_line_data(char *SC_file, struct line_info_struct *info)
  {
    struct line_data *list = NULL;
    int    size = 0;
    t_Table sTable; /* sample data table structure from SC_file */
    int    i=0;
    int    mult_count  =0;
    char   flag=0;
    double q_count=0, j_count=0, F2_count=0;
    char **parsing;
    int    list_count=0;

    if (!SC_file || !strlen(SC_file) || !strcmp(SC_file, "NULL")) {
      MPI_MASTER(
      printf("PowderN: %s: Using incoherent elastic scattering only.\n",
          info->compname);
      );
      info->count = 0;
      return(0);
    }
    Table_Read(&sTable, SC_file, 1); /* read 1st block data from SC_file into sTable*/

    /* parsing of header */
    parsing = Table_ParseHeader(sTable.header,
      "Vc","V_0",
      "sigma_abs","sigma_a ",
      "sigma_inc","sigma_i ",
      "column_j",
      "column_d",
      "column_F2",
      "column_DW",
      "column_Dd",
      "column_inv2d", "column_1/2d", "column_sintheta/lambda",
      "column_q", /* 14 */
      "DW", "Debye_Waller",
      "delta_d_d/d",
      "column_F ",
      "V_rho",
      "density",
      "weight",
      "nb_atoms","multiplicity", /* 23 */
      "column_ppm","column_strain",
      NULL);

    if (parsing) {
      if (parsing[0] && !info->V_0)     info->V_0    =atof(parsing[0]);
      if (parsing[1] && !info->V_0)     info->V_0    =atof(parsing[1]);
      if (parsing[2] && !info->sigma_a) info->sigma_a=atof(parsing[2]);
      if (parsing[3] && !info->sigma_a) info->sigma_a=atof(parsing[3]);
      if (parsing[4] && !info->sigma_i) info->sigma_i=atof(parsing[4]);
      if (parsing[5] && !info->sigma_i) info->sigma_i=atof(parsing[5]);
      if (parsing[6])                   info->column_order[0]=atoi(parsing[6]);
      if (parsing[7])                   info->column_order[1]=atoi(parsing[7]);
      if (parsing[8])                   info->column_order[2]=atoi(parsing[8]);
      if (parsing[9])                   info->column_order[3]=atoi(parsing[9]);
      if (parsing[10])                  info->column_order[4]=atoi(parsing[10]);
      if (parsing[11])                  info->column_order[5]=atoi(parsing[11]);
      if (parsing[12])                  info->column_order[5]=atoi(parsing[12]);
      if (parsing[13])                  info->column_order[5]=atoi(parsing[13]);
      if (parsing[14])                  info->column_order[6]=atoi(parsing[14]);
      if (parsing[15] && info->DWfactor<=0)    info->DWfactor=atof(parsing[15]);
      if (parsing[16] && info->DWfactor<=0)    info->DWfactor=atof(parsing[16]);
      if (parsing[17] && info->Dd <0)          info->Dd      =atof(parsing[17]);
      if (parsing[18])                  info->column_order[7]=atoi(parsing[18]);
      if (parsing[19] && !info->V_0)    info->V_0    =1/atof(parsing[19]);
      if (parsing[20] && !info->rho)    info->rho    =atof(parsing[20]);
      if (parsing[21] && !info->at_weight)     info->at_weight    =atof(parsing[21]);
      if (parsing[22] && info->at_nb <= 1)  info->at_nb    =atof(parsing[22]);
      if (parsing[23] && info->at_nb <= 1)  info->at_nb    =atof(parsing[23]);
      if (parsing[24])                  info->column_order[8]=atoi(parsing[24]);
      if (parsing[25])                  info->column_order[8]=atoi(parsing[25]);
      for (i=0; i<=25; i++) if (parsing[i]) free(parsing[i]);
      free(parsing);
    }

    if (!sTable.rows)
      exit(fprintf(stderr, "PowderN: %s: Error: The number of rows in %s "
       "should be at least %d\n", info->compname, SC_file, 1));
    else
      size = sTable.rows;

    MPI_MASTER(
    Table_Info(sTable);
    printf("PowderN: %s: Reading %d rows from %s\n",
          info->compname, size, SC_file);
    );

    if (info->column_order[0] == 4 && info->flag_barns !=0)
    MPI_MASTER(
      printf("PowderN: %s: Powder file probably of type Crystallographica/Fullprof (lau)\n"
           "WARNING: but F2 unit is set to barns=1 (barns). Intensity might be 100 times too high.\n",
           info->compname);
    );
    if (info->column_order[0] == 17 && info->flag_barns == 0)
    MPI_MASTER(
      printf("PowderN: %s: Powder file probably of type Lazy Pulver (laz)\n"
           "WARNING: but F2 unit is set to barns=0 (fm^2). Intensity might be 100 times too low.\n",
           info->compname);
    );
    /* allocate line_data array */
    list = (struct line_data*)malloc(size*sizeof(struct line_data));

    for (i=0; i<size; i++)
    {
      /*      printf("Reading in line %i\n",i);*/
      double j=0, d=0, w=0, q=0, DWfactor=0, F2=0, Epsilon=0;
      int index;

      if (info->Dd >= 0)      w         = info->Dd;
      if (info->DWfactor > 0) DWfactor  = info->DWfactor;
      if (info->Epsilon)      Epsilon   = info->Epsilon*1e-6;

      /* get data from table using columns {j d F2 DW Dd inv2d q F} */
      /* column indexes start at 1, thus need to substract 1 */
      if (info->column_order[0] >0)
        j = Table_Index(sTable, i, info->column_order[0]-1);
      if (info->column_order[1] >0)
        d = Table_Index(sTable, i, info->column_order[1]-1);
      if (info->column_order[2] >0)
        F2 = Table_Index(sTable, i, info->column_order[2]-1);
      if (info->column_order[3] >0)
        DWfactor = Table_Index(sTable, i, info->column_order[3]-1);
      if (info->column_order[4] >0)
        w = Table_Index(sTable, i, info->column_order[4]-1);
      if (info->column_order[5] >0)
        { d = Table_Index(sTable, i, info->column_order[5]-1);
          d = (d > 0? 1/d/2 : 0); }
      if (info->column_order[6] >0)
        { q = Table_Index(sTable, i, info->column_order[6]-1);
          d = (q > 0 ? 2*PI/q : 0); }
      if (info->column_order[7] >0  && !F2)
        { F2 = Table_Index(sTable, i, info->column_order[7]-1); F2 *= F2; }
      if (info->column_order[8] >0  && !Epsilon)
        { Epsilon = Table_Index(sTable, i, info->column_order[8]-1)*1e-6; }

      /* assign and check values */
      j        = (j > 0 ? j : 0);
      q        = (d > 0 ? 2*PI/d : 0); /* this is q */
      if (Epsilon && fabs(Epsilon) < 1e6) {
        q     -= Epsilon*q; /* dq/q = -delta_d_d/d = -Epsilon */
      }
      DWfactor = (DWfactor > 0 ? DWfactor : 1);
      w        = (w>0 ? w : 0); /* this is q and d relative spreading */
      F2       = (F2 >= 0 ? F2 : 0);
      if (j == 0 || q == 0) {
        MPI_MASTER(
        printf("PowderN: %s: line %i has invalid definition\n"
               "         (mult=0 or q=0 or d=0)\n", info->compname, i);
        );
        continue;
      }
      list[list_count].j = j;
      list[list_count].q = q;
      list[list_count].DWfactor = DWfactor;
      list[list_count].w = w;
      list[list_count].F2= F2;
      list[list_count].Epsilon = Epsilon;

      /* adjust multiplicity if j-column + multiple d-spacing lines */
      /* if  d = previous d, increase line duplication index */
      if (!q_count)      q_count  = q;
      if (!j_count)      j_count  = j;
      if (!F2_count)     F2_count = F2;
      if (fabs(q_count-q) < 0.0001*fabs(q)
       && fabs(F2_count-F2) < 0.0001*fabs(F2) && j_count == j) {
       mult_count++; flag=0; }
      else flag=1;
      if (i == size-1) flag=1;
      /* else if d != previous d : just passed equivalent lines */
      if (flag) {
        if (i == size-1) list_count++;
      /*   if duplication index == previous multiplicity */
      /*      set back multiplicity of previous lines to 1 */
        if ((mult_count && list_count>0)
            && (mult_count == list[list_count-1].j
                || ((list_count < size) && (i == size - 1)
                    && (mult_count == list[list_count].j))) ) {
          MPI_MASTER(
          printf("PowderN: %s: Set multiplicity to 1 for lines [%i:%i]\n"
                  "         (d-spacing %g is duplicated %i times)\n",
            info->compname, list_count-mult_count, list_count-1, list[list_count-1].q, mult_count);
          );
          for (index=list_count-mult_count; index<list_count; list[index++].j = 1);
          mult_count = 1;
          q_count   = q;
          j_count   = j;
          F2_count  = F2;
        }
        if (i == size-1) list_count--;
        flag=0;
      }
      list_count++;
    } /* end for */

    Table_Free(&sTable);

    /* sort the list with increasing q */
    qsort(list, list_count, sizeof(struct line_data),  PN_list_compare);

    MPI_MASTER(
    printf("PowderN: %s: Read %i reflections from file '%s'\n",
      info->compname, list_count, SC_file);
    );

    info->list  = list;
    info->count = list_count;

    return(list_count);
  } /* read_line_data */


/* computes the number of possible reflections (return value), and the total xsection 'sum' */
/* this routine looks for a pre-computed value in the Nq and sum cache tables               */
/* when found, the earch starts from the corresponding lower element in the table           */
int calc_xsect(double v, double *qv, double *my_sv2, int count, double *sum,
  struct line_info_struct *line_info) {
  int    Nq = 0, line=0, line0=0;
  *sum=0;

  /* check if a line_info element has been recorded already */
  if (v >= line_info->v_min && v <= line_info->v_max && line_info->neutron_passed >= CHAR_BUF_LENGTH) {
    line = (int)floor(v - line_info->v_min)*CHAR_BUF_LENGTH/(line_info->v_max - line_info->v_min);
    Nq    = line_info->xs_Nq[line];
    *sum  = line_info->xs_sum[line];
    if (!Nq && *sum == 0) {
      /* not yet set: we compute the sum up to the corresponding speed in the table cache */
      double line_v = line_info->v_min + line*(line_info->v_max - line_info->v_min)/CHAR_BUF_LENGTH;
      for(line0=0; line0<count; line0++) {
        if (qv[line0] <= 2*line_v) { /* q < 2*kf: restrict structural range */
          *sum += my_sv2[line0];
          if (Nq < line0+1) Nq=line0+1; /* determine maximum line index which can scatter */
        } else break;
      }
      line_info->xs_Nq[line] = Nq;
      line_info->xs_sum[line]= *sum;
      line_info->xs_compute++;
    } else line_info->xs_reuse++;
    line0 = Nq;
  }

  line_info->xs_calls++;

  for(line=line0; line<count; line++) {
    if (qv[line] <= 2*v) { /* q < 2*kf: restrict structural range */
      *sum += my_sv2[line];
      if (Nq < line+1) Nq=line+1; /* determine maximum line index which can scatter */
    } else break;
  }

  return(Nq);
} /* calc_xsect */

#endif /* !POWDERN_DECL */

#line 10333 "RITA-II.c"

/* Shared user declarations for all components 'Single_crystal'. */
#line 289 "/usr/share/mcstas/2.5/samples/Single_crystal.comp"
/* used for reading data table from file */


/* Declare structures and functions only once in each instrument. */
#ifndef SINGLE_CRYSTAL_DECL
#define SINGLE_CRYSTAL_DECL

#ifndef Mosaic_AB_Undefined
#define Mosaic_AB_Undefined {0,0, 0,0,0, 0,0,0}
#endif

struct hkl_data
{
int h,k,l;                  /* Indices for this reflection */
double F2;                  /* Value of structure factor */
double tau_x, tau_y, tau_z; /* Coordinates in reciprocal space */
double tau;                 /* Length of (tau_x, tau_y, tau_z) */
      double u1x, u1y, u1z;       /* First axis of local coordinate system */
      double u2x, u2y, u2z;       /* Second axis of local coordinate system */
      double u3x, u3y, u3z;       /* Third axis of local coordinate system */
      double sig123;              /* The product sig1*sig2*sig3 = volume of spot */
      double m1, m2, m3;          /* Diagonal matrix representation of Gauss */
      double cutoff;              /* Cutoff value for Gaussian tails */
    };

  struct tau_data
    {
      int index;                  /* Index into reflection table */
      double refl;
      double xsect;
      /* The following vectors are in local koordinates. */
      double rho_x, rho_y, rho_z; /* The vector ki - tau */
      double rho;                 /* Length of rho vector */
      double ox, oy, oz;          /* Origin of Ewald sphere tangent plane */
      double b1x, b1y, b1z;       /* Spanning vectors of Ewald sphere tangent */
      double b2x, b2y, b2z;
      double l11, l12, l22;       /* Cholesky decomposition L of 2D Gauss */
      double y0x, y0y;            /* 2D Gauss center in tangent plane */
    };

  struct hkl_info_struct
    {
      struct hkl_data *list;      /* Reflection array */
      int count;                  /* Number of reflections */
      struct tau_data *tau_list;  /* Reflections close to Ewald Sphere */
      double m_delta_d_d;         /* Delta-d/d FWHM */
      double m_ax,m_ay,m_az;      /* First unit cell axis (direct space, AA) */
      double m_bx,m_by,m_bz;      /* Second unit cell axis */
      double m_cx,m_cy,m_cz;      /* Third unit cell axis */
      double asx,asy,asz;         /* First reciprocal lattice axis (1/AA) */
      double bsx,bsy,bsz;         /* Second reciprocal lattice axis */
      double csx,csy,csz;         /* Third reciprocal lattice axis */
      double m_a, m_b, m_c;       /* length of lattice parameter lengths */
      double m_aa, m_bb, m_cc;    /* lattice angles */
      double sigma_a, sigma_i;    /* abs and inc X sect */
      double rho;                 /* density */
      double at_weight;           /* atomic weight */
      double at_nb;               /* nb of atoms in a cell */
      double V0;                  /* Unit cell volume (AA**3) */
      int    column_order[5];     /* column signification [h,k,l,F,F2] */
      int    recip;               /* Flag to indicate if recip or direct cell axes given */
      int    shape;               /* 0:cylinder, 1:box, 2:sphere 3:any shape*/
      int    flag_warning;        /* number of warnings */
      char   type;                /* type of last event: t=transmit,c=coherent or i=incoherent */
      int    h,k,l;               /* last coherent scattering momentum transfer indices */
      int    tau_count;           /* Number of reflections within cutoff */
      double coh_refl, coh_xsect; /* cross section computed with last tau_list */
      double kix, kiy, kiz;       /* last incoming neutron ki */
      int    nb_reuses, nb_refl, nb_refl_count;
    };

  int SX_list_compare (void const *a, void const *b)
  {
     struct hkl_data const *pa = a;
     struct hkl_data const *pb = b;
     double s = pa->tau - pb->tau;

     if (!s) return 0;
     else    return (s < 0 ? -1 : 1);
  } /* PN_list_compare */

  /* ------------------------------------------------------------------------ */
  int
  read_hkl_data(char *SC_file, struct hkl_info_struct *info,
      double SC_mosaic, double SC_mosaic_a, double SC_mosaic_b, double SC_mosaic_c, double *SC_mosaic_AB)
  {
    struct hkl_data *list = NULL;
    int size = 0;
    t_Table sTable; /* sample data table structure from SC_file */
    int i=0;
    double tmp_x, tmp_y, tmp_z;
    char **parsing;
    char flag=0;
    double nb_atoms=1;

    if (!SC_file || !strlen(SC_file) || !strcmp(SC_file,"NULL") || !strcmp(SC_file,"0")) {
      info->count = 0;
      flag=1;
    }
    if (!flag) {
      Table_Read(&sTable, SC_file, 1); /* read 1st block data from SC_file into sTable*/
      if (sTable.columns < 4) {
        fprintf(stderr, "Single_crystal: Error: The number of columns in %s should be at least %d for [h,k,l,F2]\n", SC_file, 4);
        return(0);
      }
      if (!sTable.rows) {
        fprintf(stderr, "Single_crystal: Error: The number of rows in %s should be at least %d\n", SC_file, 1);
        return(0);
      } else size = sTable.rows;

      /* parsing of header */
      parsing = Table_ParseHeader(sTable.header,
        "sigma_abs","sigma_a ",
        "sigma_inc","sigma_i ",
        "column_h",
        "column_k",
        "column_l",
        "column_F ",
        "column_F2",
        "Delta_d/d",
        "lattice_a ",
        "lattice_b ",
        "lattice_c ",
        "lattice_aa",
        "lattice_bb",
        "lattice_cc",
        "nb_atoms","multiplicity",
        NULL);

      if (parsing) {
        if (parsing[0] && !info->sigma_a) info->sigma_a=atof(parsing[0]);
        if (parsing[1] && !info->sigma_a) info->sigma_a=atof(parsing[1]);
        if (parsing[2] && !info->sigma_i) info->sigma_i=atof(parsing[2]);
        if (parsing[3] && !info->sigma_i) info->sigma_i=atof(parsing[3]);
        if (parsing[4])                   info->column_order[0]=atoi(parsing[4]);
        if (parsing[5])                   info->column_order[1]=atoi(parsing[5]);
        if (parsing[6])                   info->column_order[2]=atoi(parsing[6]);
        if (parsing[7])                   info->column_order[3]=atoi(parsing[7]);
        if (parsing[8])                   info->column_order[4]=atoi(parsing[8]);
        if (parsing[9] && info->m_delta_d_d <0) info->m_delta_d_d=atof(parsing[9]);
        if (parsing[10] && !info->m_a)    info->m_a =atof(parsing[10]);
        if (parsing[11] && !info->m_b)    info->m_b =atof(parsing[11]);
        if (parsing[12] && !info->m_c)    info->m_c =atof(parsing[12]);
        if (parsing[13] && !info->m_aa)   info->m_aa=atof(parsing[13]);
        if (parsing[14] && !info->m_bb)   info->m_bb=atof(parsing[14]);
        if (parsing[15] && !info->m_cc)   info->m_cc=atof(parsing[15]);
        if (parsing[16])   nb_atoms=atof(parsing[16]);
        if (parsing[17])   nb_atoms=atof(parsing[17]);
        for (i=0; i<=17; i++) if (parsing[i]) free(parsing[i]);
        free(parsing);
      }
    }

    if (nb_atoms > 1) { info->sigma_a *= nb_atoms; info->sigma_i *= nb_atoms; }

    /* special cases for the structure definition */
    if (info->m_ax || info->m_ay || info->m_az) info->m_a=0; /* means we specify by hand the vectors */
    if (info->m_bx || info->m_by || info->m_bz) info->m_b=0;
    if (info->m_cx || info->m_cy || info->m_cz) info->m_c=0;

    /* compute the norm from vector a if missing */
    if (info->m_ax || info->m_ay || info->m_az) {
      double as=sqrt(info->m_ax*info->m_ax+info->m_ay*info->m_ay+info->m_az*info->m_az);
      if (!info->m_bx && !info->m_by && !info->m_bz) info->m_a=info->m_b=as;
      if (!info->m_cx && !info->m_cy && !info->m_cz) info->m_a=info->m_c=as;
    }
    if (info->m_a && !info->m_b) info->m_b=info->m_a;
    if (info->m_b && !info->m_c) info->m_c=info->m_b;

    /* compute the lattive angles if not set from data file. Not used when in vector mode. */
    if (info->m_a && !info->m_aa) info->m_aa=90;
    if (info->m_aa && !info->m_bb) info->m_bb=info->m_aa;
    if (info->m_bb && !info->m_cc) info->m_cc=info->m_bb;

    /* parameters consistency checks */
    if (!info->m_ax && !info->m_ay && !info->m_az && !info->m_a) {
      fprintf(stderr,
              "Single_crystal: Error: Wrong a lattice vector definition\n");
      return(0);
    }
    if (!info->m_bx && !info->m_by && !info->m_bz && !info->m_b) {
      fprintf(stderr,
              "Single_crystal: Error: Wrong b lattice vector definition\n");
      return(0);
    }
    if (!info->m_cx && !info->m_cy && !info->m_cz && !info->m_c) {
      fprintf(stderr,
              "Single_crystal: Error: Wrong c lattice vector definition\n");
      return(0);
    }
    if (info->m_aa && info->m_bb && info->m_cc && info->recip) {
      fprintf(stderr,
              "Single_crystal: Error: Selecting reciprocal cell and angles is unmeaningful\n");
      return(0);
    }

    /* when lengths a,b,c + angles are given (instead of vectors a,b,c) */
    if (info->m_aa && info->m_bb && info->m_cc)
    {
      double as,bs,cs;
      if (info->m_a) as = info->m_a;
      else as = sqrt(info->m_ax*info->m_ax+info->m_ay*info->m_ay+info->m_az*info->m_az);
      if (info->m_b) bs = info->m_b;
      else bs = sqrt(info->m_bx*info->m_bx+info->m_by*info->m_by+info->m_bz*info->m_bz);
      if (info->m_c) cs = info->m_c;
      else cs =  sqrt(info->m_cx*info->m_cx+info->m_cy*info->m_cy+info->m_cz*info->m_cz);

      info->m_bz = as; info->m_by = 0; info->m_bx = 0;
      info->m_az = bs*cos(info->m_cc*DEG2RAD);
      info->m_ay = bs*sin(info->m_cc*DEG2RAD);
      info->m_ax = 0;
      info->m_cz = cs*cos(info->m_bb*DEG2RAD);
      info->m_cy = cs*(cos(info->m_aa*DEG2RAD)-cos(info->m_cc*DEG2RAD)*cos(info->m_bb*DEG2RAD))
                     /sin(info->m_cc*DEG2RAD);
      info->m_cx = sqrt(cs*cs - info->m_cz*info->m_cz - info->m_cy*info->m_cy);

      printf("Single_crystal: %s structure a=%g b=%g c=%g aa=%g bb=%g cc=%g ",
        (flag ? "INC" : SC_file), as, bs, cs, info->m_aa, info->m_bb, info->m_cc);
    } else {
      if (!info->recip) {
        printf("Single_crystal: %s structure a=[%g,%g,%g] b=[%g,%g,%g] c=[%g,%g,%g] ",
	       (flag ? "INC" : SC_file), info->m_ax ,info->m_ay ,info->m_az,
	       info->m_bx ,info->m_by ,info->m_bz,
	       info->m_cx ,info->m_cy ,info->m_cz);
      } else {
        printf("Single_crystal: %s structure a*=[%g,%g,%g] b*=[%g,%g,%g] c*=[%g,%g,%g] ",
	       (flag ? "INC" : SC_file), info->m_ax ,info->m_ay ,info->m_az,
	       info->m_bx ,info->m_by ,info->m_bz,
	       info->m_cx ,info->m_cy ,info->m_cz);
      }
    }
    /* Compute reciprocal or direct lattice vectors. */
    if (!info->recip) {
      vec_prod(tmp_x, tmp_y, tmp_z,
	       info->m_bx, info->m_by, info->m_bz,
	       info->m_cx, info->m_cy, info->m_cz);
      info->V0 = fabs(scalar_prod(info->m_ax, info->m_ay, info->m_az, tmp_x, tmp_y, tmp_z));
      printf("V0=%g\n", info->V0);

      info->asx = 2*PI/info->V0*tmp_x;
      info->asy = 2*PI/info->V0*tmp_y;
      info->asz = 2*PI/info->V0*tmp_z;
      vec_prod(tmp_x, tmp_y, tmp_z, info->m_cx, info->m_cy, info->m_cz, info->m_ax, info->m_ay, info->m_az);
      info->bsx = 2*PI/info->V0*tmp_x;
      info->bsy = 2*PI/info->V0*tmp_y;
      info->bsz = 2*PI/info->V0*tmp_z;
      vec_prod(tmp_x, tmp_y, tmp_z, info->m_ax, info->m_ay, info->m_az, info->m_bx, info->m_by, info->m_bz);
      info->csx = 2*PI/info->V0*tmp_x;
      info->csy = 2*PI/info->V0*tmp_y;
      info->csz = 2*PI/info->V0*tmp_z;
    } else {
      info->asx = info->m_ax;
      info->asy = info->m_ay;
      info->asz = info->m_az;
      info->bsx = info->m_bx;
      info->bsy = info->m_by;
      info->bsz = info->m_bz;
      info->csx = info->m_cx;
      info->csy = info->m_cy;
      info->csz = info->m_cz;

      vec_prod(tmp_x, tmp_y, tmp_z,
	       info->bsx/(2*PI), info->bsy/(2*PI), info->bsz/(2*PI),
	       info->csx/(2*PI), info->csy/(2*PI), info->csz/(2*PI));
      info->V0 = 1/fabs(scalar_prod(info->asx/(2*PI), info->asy/(2*PI), info->asz/(2*PI), tmp_x, tmp_y, tmp_z));
      printf("V0=%g\n", info->V0);

      /*compute the direct cell parameters, ofr completeness*/
      info->m_ax = tmp_x*info->V0;
      info->m_ay = tmp_y*info->V0;
      info->m_az = tmp_z*info->V0;
      vec_prod(tmp_x, tmp_y, tmp_z,info->csx/(2*PI), info->csy/(2*PI), info->csz/(2*PI),info->asx/(2*PI), info->asy/(2*PI), info->asz/(2*PI));
      info->m_bx = tmp_x*info->V0;
      info->m_by = tmp_y*info->V0;
      info->m_bz = tmp_z*info->V0;
      vec_prod(tmp_x, tmp_y, tmp_z,info->asx/(2*PI), info->asy/(2*PI), info->asz/(2*PI),info->bsx/(2*PI), info->bsy/(2*PI), info->bsz/(2*PI));
      info->m_cx = tmp_x*info->V0;
      info->m_cy = tmp_y*info->V0;
      info->m_cz = tmp_z*info->V0;
    }

    if (flag) return(-1);

    if (!info->column_order[0] || !info->column_order[1] || !info->column_order[2]) {
      fprintf(stderr,
              "Single_crystal: Error: Wrong h,k,l column definition\n");
      return(0);
    }
    if (!info->column_order[3] && !info->column_order[4]) {
      fprintf(stderr,
              "Single_crystal: Error: Wrong F,F2 column definition\n");
      return(0);
    }

    /* allocate hkl_data array */
    list = (struct hkl_data*)malloc(size*sizeof(struct hkl_data));

    for (i=0; i<size; i++)
    {
      double h=0, k=0, l=0, F2=0;
      double b1[3], b2[3];
      double sig1, sig2, sig3;

      /* get data from table */
      h = Table_Index(sTable, i, info->column_order[0]-1);
      k = Table_Index(sTable, i, info->column_order[1]-1);
      l = Table_Index(sTable, i, info->column_order[2]-1);
      if (info->column_order[3])
      { F2= Table_Index(sTable, i, info->column_order[3]-1); F2 *= F2; }
      else if (info->column_order[4])
        F2= Table_Index(sTable, i, info->column_order[4]-1);

      list[i].h = h;
      list[i].k = k;
      list[i].l = l;
      list[i].F2 = F2;

      /* Precompute some values */
      list[i].tau_x = h*info->asx + k*info->bsx + l*info->csx;
      list[i].tau_y = h*info->asy + k*info->bsy + l*info->csy;
      list[i].tau_z = h*info->asz + k*info->bsz + l*info->csz;
      list[i].tau = sqrt(list[i].tau_x*list[i].tau_x +
                         list[i].tau_y*list[i].tau_y +
                         list[i].tau_z*list[i].tau_z);
      list[i].u1x = list[i].tau_x/list[i].tau;
      list[i].u1y = list[i].tau_y/list[i].tau;
      list[i].u1z = list[i].tau_z/list[i].tau;
      sig1 = FWHM2RMS*info->m_delta_d_d*list[i].tau;

      /* Find two arbitrary axes perpendicular to tau and each other. */
      normal_vec(b1[0], b1[1], b1[2],
                 list[i].u1x, list[i].u1y, list[i].u1z);
      vec_prod(b2[0], b2[1], b2[2],
               list[i].u1x, list[i].u1y, list[i].u1z,
               b1[0], b1[1], b1[2]);

      /* Find the two mosaic axes perpendicular to tau. */
      if(SC_mosaic > 0) {
        /* Use isotropic mosaic. */
        list[i].u2x = b1[0];
        list[i].u2y = b1[1];
        list[i].u2z = b1[2];
        sig2 = FWHM2RMS*list[i].tau*MIN2RAD*SC_mosaic;
        list[i].u3x = b2[0];
        list[i].u3y = b2[1];
        list[i].u3z = b2[2];
        sig3 = FWHM2RMS*list[i].tau*MIN2RAD*SC_mosaic;
      } else if(SC_mosaic_a > 0 && SC_mosaic_b > 0 && SC_mosaic_c > 0) {
        /* Use anisotropic mosaic. */
        fprintf(stderr,"Single_crystal: Warning: you are using an experimental feature:\n"
          "  anistropic mosaicity. Please examine your data carefully.\n");
        /* compute the jacobian of (tau_v,tau_n) from rotations around the unit cell vectors. */
        struct hkl_data *l =&(list[i]);
        double xia_x,xia_y,xia_z,xib_x,xib_y,xib_z,xic_x,xic_y,xic_z;
        /*input parameters are in arc minutes*/
        double sig_fi_a=SC_mosaic_a*MIN2RAD;
        double sig_fi_b=SC_mosaic_b*MIN2RAD;
        double sig_fi_c=SC_mosaic_c*MIN2RAD;
        if(info->m_a==0) info->m_a=sqrt(scalar_prod( info->m_ax,info->m_ay,info->m_az,info->m_ax,info->m_ay,info->m_az));
        if(info->m_b==0) info->m_b=sqrt(scalar_prod( info->m_bx,info->m_by,info->m_bz,info->m_bx,info->m_by,info->m_bz));
        if(info->m_c==0) info->m_c=sqrt(scalar_prod( info->m_cx,info->m_cy,info->m_cz,info->m_cx,info->m_cy,info->m_cz));

        l->u2x = b1[0];
        l->u2y = b1[1];
        l->u2z = b1[2];
        l->u3x = b2[0];
        l->u3y = b2[1];
        l->u3z = b2[2];

        xia_x=l->tau_x-(M_2_PI*h/info->m_a)*info->asx;
        xia_y=l->tau_y-(M_2_PI*h/info->m_a)*info->asy;
        xia_z=l->tau_z-(M_2_PI*h/info->m_a)*info->asz;
        xib_x=l->tau_x-(M_2_PI*h/info->m_b)*info->bsx;
        xib_y=l->tau_y-(M_2_PI*h/info->m_b)*info->bsy;
        xib_z=l->tau_z-(M_2_PI*h/info->m_b)*info->bsz;
        xic_x=l->tau_x-(M_2_PI*h/info->m_c)*info->csx;
        xic_y=l->tau_y-(M_2_PI*h/info->m_c)*info->csy;
        xic_z=l->tau_z-(M_2_PI*h/info->m_c)*info->csz;

        double xia=sqrt(xia_x*xia_x + xia_y*xia_y + xia_z*xia_z);
        double xib=sqrt(xib_x*xib_x + xib_y*xib_y + xib_z*xib_z);
        double xic=sqrt(xic_x*xic_x + xic_y*xic_y + xic_z*xic_z);

        vec_prod(tmp_x,tmp_y,tmp_z,l->tau_x,l->tau_y,l->tau_z, l->u2x,l->u2y,l->u2z);
        double J_n_fia= xia/info->m_a/l->tau*scalar_prod(info->asx,info->asy,info->asz,tmp_x,tmp_y,tmp_z);
        vec_prod(tmp_x,tmp_y,tmp_z,l->tau_x,l->tau_y,l->tau_z, l->u2x,l->u2y,l->u2z);
        double J_n_fib= xib/info->m_b/l->tau*scalar_prod(info->bsx,info->bsy,info->bsz,tmp_x,tmp_y,tmp_z);
        vec_prod(tmp_x,tmp_y,tmp_z,l->tau_x,l->tau_y,l->tau_z, l->u2x,l->u2y,l->u2z);
        double J_n_fic= xic/info->m_c/l->tau*scalar_prod(info->csx,info->csy,info->csz,tmp_x,tmp_y,tmp_z);

        vec_prod(tmp_x,tmp_y,tmp_z,l->tau_x,l->tau_y,l->tau_z, l->u3x,l->u3y,l->u3z);
        double J_v_fia= xia/info->m_a/l->tau*scalar_prod(info->asx,info->asy,info->asz,tmp_x,tmp_y,tmp_z);
        vec_prod(tmp_x,tmp_y,tmp_z,l->tau_x,l->tau_y,l->tau_z, l->u3x,l->u3y,l->u3z);
        double J_v_fib= xib/info->m_b/l->tau*scalar_prod(info->bsx,info->bsy,info->bsz,tmp_x,tmp_y,tmp_z);
        vec_prod(tmp_x,tmp_y,tmp_z,l->tau_x,l->tau_y,l->tau_z, l->u3x,l->u3y,l->u3z);
        double J_v_fic= xic/info->m_c/l->tau*scalar_prod(info->csx,info->csy,info->csz,tmp_x,tmp_y,tmp_z);

        /*with the jacobian we can compute the sigmas in terms of the orthogonal vectors u2 and u3*/
        sig2=sig_fi_a*fabs(J_v_fia) + sig_fi_b*fabs(J_v_fib) + sig_fi_c*fabs(J_v_fic);
        sig3=sig_fi_a*fabs(J_n_fia) + sig_fi_b*fabs(J_n_fib) + sig_fi_c*fabs(J_n_fic);
      } else if (SC_mosaic_AB[0]!=0 && SC_mosaic_AB[1]!=0){
        if ( (SC_mosaic_AB[2]==0 && SC_mosaic_AB[3]==0 && SC_mosaic_AB[4]==0) || (SC_mosaic_AB[5]==0 && SC_mosaic_AB[6]==0 && SC_mosaic_AB[7]==0) ){
          fprintf(stderr,"Single_crystal: Error: in-plane mosaics are specified but one (or both)\n"
              "  in-plane reciprocal vector is the zero vector\n");
          return(0);
        }
        fprintf(stderr,"Single_crystal: Warning: you are using an experimental feature: \n"
              "  \"in-plane\" anistropic mosaicity. Please examine your data carefully.\n");

        /*for given reflection in list - compute linear comb of tau_a and tau_b*/
        /*check for not in plane - f.i. check if (tau_a X tau_b).tau_i)==0*/
        struct hkl_data *l =&(list[i]);
        double det,c1,c2,sig_tau_c;
        double em_x,em_y,em_z, tmp_x,tmp_y,tmp_z;
        double tau_a[3],tau_b[3];
        /*convert Miller indices to taus*/
        if(info->m_a==0) info->m_a=sqrt(scalar_prod( info->m_ax,info->m_ay,info->m_az,info->m_ax,info->m_ay,info->m_az));
        if(info->m_b==0) info->m_b=sqrt(scalar_prod( info->m_bx,info->m_by,info->m_bz,info->m_bx,info->m_by,info->m_bz));
        if(info->m_c==0) info->m_c=sqrt(scalar_prod( info->m_cx,info->m_cy,info->m_cz,info->m_cx,info->m_cy,info->m_cz));
        tau_a[0]=M_2_PI*( (SC_mosaic_AB[2]/info->m_a)*info->asx + (SC_mosaic_AB[3]/info->m_b)*info->bsx + (SC_mosaic_AB[4]/info->m_c)*info->csx );
        tau_a[1]=M_2_PI*( (SC_mosaic_AB[2]/info->m_a)*info->asy + (SC_mosaic_AB[3]/info->m_b)*info->bsy + (SC_mosaic_AB[4]/info->m_c)*info->csy );
        tau_a[2]=M_2_PI*( (SC_mosaic_AB[2]/info->m_a)*info->asz + (SC_mosaic_AB[3]/info->m_b)*info->bsz + (SC_mosaic_AB[4]/info->m_c)*info->csz );
        tau_b[0]=M_2_PI*( (SC_mosaic_AB[5]/info->m_a)*info->asx + (SC_mosaic_AB[6]/info->m_b)*info->bsx + (SC_mosaic_AB[7]/info->m_c)*info->csx );
        tau_b[1]=M_2_PI*( (SC_mosaic_AB[5]/info->m_a)*info->asy + (SC_mosaic_AB[6]/info->m_b)*info->bsy + (SC_mosaic_AB[7]/info->m_c)*info->csy );
        tau_b[2]=M_2_PI*( (SC_mosaic_AB[5]/info->m_a)*info->asz + (SC_mosaic_AB[6]/info->m_b)*info->bsz + (SC_mosaic_AB[7]/info->m_c)*info->csz );

        /*check determinants to see how we should compute the linear combination of a and b (to match c)*/
        if ((det=tau_a[0]*tau_b[1]-tau_a[1]*tau_b[0])!=0){
          c1= (l->tau_x*tau_b[1] - l->tau_y*tau_b[0])/det;
          c2= (tau_a[0]*l->tau_y - tau_a[1]*l->tau_x)/det;
        }else if ((det=tau_a[1]*tau_b[2]-tau_a[2]*tau_b[1])!=0){
          c1= (l->tau_y*tau_b[2] - l->tau_z*tau_b[1])/det;
          c2= (tau_a[1]*l->tau_z - tau_a[2]*l->tau_y)/det;
        }else if ((det=tau_a[0]*tau_b[2]-tau_a[2]*tau_b[0])!=0){
          c1= (l->tau_x*tau_b[2] - l->tau_z*tau_b[0])/det;
          c2= (tau_a[0]*l->tau_z - tau_a[2]*l->tau_x)/det;
        }
        if ((c1==0) && (c2==0)){
          fprintf(stderr,"Single_crystal: Warning: reflection tau[%i]=(%g %g %g) "
          "has no component in defined mosaic plane\n",
          i, l->tau_x,l->tau_y,l->tau_z);
        }
        /*compute linear combination => sig_tau_i = | c1*sig_tau_a + c2*sig_tau_b |  - also add in the minute to radian scaling factor*/;
        sig_tau_c = MIN2RAD*sqrt(c1*SC_mosaic_AB[0]*c1*SC_mosaic_AB[0] + c2*SC_mosaic_AB[1]*c2*SC_mosaic_AB[1]);
        l->u2x = b1[0]; l->u2y = b1[1]; l->u2z = b1[2];
        l->u3x = b2[0]; l->u3y = b2[1]; l->u3z = b2[2];

        /*so now let's compute the rotation around planenormal tau_a X tau_b*/
        /*g_bar (unit normal of rotation plane) = tau_a X tau_b / norm(tau_a X tau_b)*/
        vec_prod(tmp_x,tmp_y,tmp_z, tau_a[0],tau_a[1],tau_a[2],tau_b[0],tau_b[1],tau_b[2]);
        vec_prod(em_x,em_y,em_z, l->tau_x, l->tau_y, l->tau_z, tmp_x,tmp_y,tmp_z);
        NORM(em_x,em_y,em_z);
        sig2 = l->tau*sig_tau_c*fabs(scalar_prod(em_x,em_y,em_z, l->u2x,l->u2y,l->u2z));
        sig3 = l->tau*sig_tau_c*fabs(scalar_prod(em_x,em_y,em_z, l->u3x,l->u3y,l->u3z));
        /*protect against collapsing gaussians. These seem to be sensible values.*/
        if (sig2<1e-5) sig2=1e-5;
        if (sig3<1e-5) sig3=1e-5;
      }
      else {
        fprintf(stderr,
                "Single_crystal: Error: EITHER mosaic OR (mosaic_a, mosaic_b, mosaic_c)\n"
                "  must be given and be >0.\n");
        return(0);
      }
      list[i].sig123 = sig1*sig2*sig3;
      list[i].m1 = 1/(2*sig1*sig1);
      list[i].m2 = 1/(2*sig2*sig2);
      list[i].m3 = 1/(2*sig3*sig3);
      /* Set Gauss cutoff to 5 times the maximal sigma. */
      if(sig1 > sig2)
        if(sig1 > sig3)
          list[i].cutoff = 5*sig1;
        else
          list[i].cutoff = 5*sig3;
      else
        if(sig2 > sig3)
          list[i].cutoff = 5*sig2;
        else
          list[i].cutoff = 5*sig3;
    }
    Table_Free(&sTable);

    /* sort the list with increasing tau */
    qsort(list, i, sizeof(struct hkl_data),  SX_list_compare);

    info->list = list;
    info->count = i;
    info->tau_list = malloc(i*sizeof(*info->tau_list));
    if(!info->tau_list)
    {
      fprintf(stderr, "Single_crystal: Error: Out of memory!\n");
      return(0);
    }
    return(info->count);
  } /* read_hkl_data */

  /* ------------------------------------------------------------------------ */
  /* hkl_search
    search the HKL reflections which are on the Ewald sphere
    input:
      L,T,count,V0: constants for all calls
      kix,kiy,kiz: may be different for each call
    this function returns:
      tau_count (return), coh_refl, coh_xsect, T (updated elements in the array up to [j])
   */
  int hkl_search(struct hkl_data *L, struct tau_data *T, int count, double V0,
    double kix, double kiy, double kiz, double tau_max,
    double *coh_refl, double *coh_xsect)
  {
    double rho, rho_x, rho_y, rho_z;
    double diff;
    int    i,j;
    double ox,oy,oz;
    double b1x,b1y,b1z, b2x,b2y,b2z, kx, ky, kz, nx, ny, nz;
    double n11, n22, n12, det_N, inv_n11, inv_n22, inv_n12, l11, l22, l12,  det_L;
    double Bt_D_O_x, Bt_D_O_y, y0x, y0y, alpha;

    double ki = sqrt(kix*kix+kiy*kiy+kiz*kiz);

    /* Common factor in coherent cross-section */
    double xsect_factor = pow(2*PI, 5.0/2.0)/(V0*ki*ki);

    for(i = j = 0; i < count; i++)
      {
    /* Assuming reflections are sorted, stop search when max tau exceeded. */
        if(L[i].tau > tau_max)
          break;
        /* Check if this reciprocal lattice point is close enough to the
           Ewald sphere to make scattering possible. */
        rho_x = kix - L[i].tau_x;
        rho_y = kiy - L[i].tau_y;
        rho_z = kiz - L[i].tau_z;
        rho = sqrt(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z);
        diff = fabs(rho - ki);

        /* Check if scattering is possible (cutoff of Gaussian tails). */
        if(diff <= L[i].cutoff)
        {
          /* Store reflection. */
          T[j].index = i;
          /* Get ki vector in local coordinates. */
          kx = kix*L[i].u1x + kiy*L[i].u1y + kiz*L[i].u1z;
          ky = kix*L[i].u2x + kiy*L[i].u2y + kiz*L[i].u2z;
          kz = kix*L[i].u3x + kiy*L[i].u3y + kiz*L[i].u3z;
          T[j].rho_x = kx - L[i].tau;
          T[j].rho_y = ky;
          T[j].rho_z = kz;
          T[j].rho = rho;
          /* Compute the tangent plane of the Ewald sphere. */
          nx = T[j].rho_x/T[j].rho;
          ny = T[j].rho_y/T[j].rho;
          nz = T[j].rho_z/T[j].rho;
          ox = (ki - T[j].rho)*nx;
          oy = (ki - T[j].rho)*ny;
          oz = (ki - T[j].rho)*nz;
          T[j].ox = ox;
          T[j].oy = oy;
          T[j].oz = oz;
          /* Compute unit vectors b1 and b2 that span the tangent plane. */
          normal_vec(b1x, b1y, b1z, nx, ny, nz);
          vec_prod(b2x, b2y, b2z, nx, ny, nz, b1x, b1y, b1z);
          T[j].b1x = b1x;
          T[j].b1y = b1y;
          T[j].b1z = b1z;
          T[j].b2x = b2x;
          T[j].b2y = b2y;
          T[j].b2z = b2z;
          /* Compute the 2D projection of the 3D Gauss of the reflection. */
          /* The symmetric 2x2 matrix N describing the 2D gauss. */
          n11 = L[i].m1*b1x*b1x + L[i].m2*b1y*b1y + L[i].m3*b1z*b1z;
          n12 = L[i].m1*b1x*b2x + L[i].m2*b1y*b2y + L[i].m3*b1z*b2z;
          n22 = L[i].m1*b2x*b2x + L[i].m2*b2y*b2y + L[i].m3*b2z*b2z;
          /* The (symmetric) inverse matrix of N. */
          det_N = n11*n22 - n12*n12;
          inv_n11 = n22/det_N;
          inv_n12 = -n12/det_N;
          inv_n22 = n11/det_N;
          /* The Cholesky decomposition of 1/2*inv_n (lower triangular L). */
          l11 = sqrt(inv_n11/2);
          l12 = inv_n12/(2*l11);
          l22 = sqrt(inv_n22/2 - l12*l12);
          T[j].l11 = l11;
          T[j].l12 = l12;
          T[j].l22 = l22;
          det_L = l11*l22;
          /* The product B^T D o. */
          Bt_D_O_x = b1x*L[i].m1*ox + b1y*L[i].m2*oy + b1z*L[i].m3*oz;
          Bt_D_O_y = b2x*L[i].m1*ox + b2y*L[i].m2*oy + b2z*L[i].m3*oz;
          /* Center of 2D Gauss in plane coordinates. */
          y0x = -(Bt_D_O_x*inv_n11 + Bt_D_O_y*inv_n12);
          y0y = -(Bt_D_O_x*inv_n12 + Bt_D_O_y*inv_n22);
          T[j].y0x = y0x;
          T[j].y0y = y0y;
          /* Factor alpha for the distance of the 2D Gauss from the origin. */
          alpha = L[i].m1*ox*ox + L[i].m2*oy*oy + L[i].m3*oz*oz -
                       (y0x*y0x*n11 + y0y*y0y*n22 + 2*y0x*y0y*n12);
          T[j].refl = xsect_factor*det_L*exp(-alpha)/L[i].sig123; /* intensity of that Bragg */
          *coh_refl += T[j].refl;                                  /* total scatterable intensity */
          T[j].xsect = T[j].refl*L[i].F2;
          *coh_xsect += T[j].xsect;
          j++;
        }

      } /* end for */
        return (j); // this is 'tau_count', i.e. number of reachable reflections
    } /* end hkl_search */

    int hkl_select(struct tau_data *T, int tau_count, double coh_refl, double *sum) {
      int j;
      double r = rand0max(coh_refl);
      *sum = 0;
      for(j = 0; j < tau_count; j++)
      {
        *sum += T[j].refl;
        if(*sum > r) break;
      }
      return j;
    }

    /* Functions for "reorientation", powder and PG modes */
    /* Powder, forward */
    void randrotate(double *nx, double *ny, double *nz, double a, double b) {
      double nvx, nvy, nvz;
      rotate(nvx,nvy,nvz, *nx, *ny, *nz, a, 1, 0, 0);
      rotate(*nx,*ny,*nz, nvx,nvy,nvz, b, 0, 1, 0);
    }
    /* Powder, back */
    void randderotate(double *nx, double *ny, double *nz, double a, double b) {
      double nvx, nvy, nvz;
      rotate(nvx,nvy,nvz,*nx,*ny,*nz, -b, 0, 1, 0);
      rotate(*nx, *ny, *nz, nvx,nvy,nvz, -a, 1, 0, 0);
    }
    /* PG, forward */
    void PGrotate(double *nx, double *ny, double *nz, double a, double csx, double csy, double csz) {
      /* Currently assumes c-axis along 'x', ought to be generalized... */
      double nvx, nvy, nvz;
      rotate(nvx,nvy,nvz, *nx, *ny, *nz, a, csx, csy, csz);
      *nx = nvx; *ny = nvy; *nz = nvz;
    }
    /* PG, back */
    void PGderotate(double *nx, double *ny, double *nz, double a, double csx, double csy, double csz) {
      /* Currently assumes c-axis along 'x', ought to be generalized... */
      double nvx, nvy, nvz;
      rotate(nvx,nvy,nvz, *nx, *ny, *nz, -a, csx, csy, csz);
      *nx = nvx; *ny = nvy; *nz = nvz;
    }



    /* rotate vector counterclockwise */
    void vec_rotate_2d(double* x, double* y, double angle) {
        double c, s;
        double newx, newy;

        c = cos(angle);
        s = sin(angle);

        newx = *x*c - *y*s;
        newy = *x*s + *y*c;

        *x = newx;
        *y = newy;
    }


#endif /* !SINGLE_CRYSTAL_DECL */
#line 11003 "RITA-II.c"

/* Shared user declarations for all components 'Phonon_simple'. */
#line 73 "/usr/share/mcstas/2.5/samples/Phonon_simple.comp"
#ifndef PHONON_SIMPLE
#define PHONON_SIMPLE $Revision$
#define T2E (1/11.605)   /* Kelvin to meV */

double nbose(double omega, double T)  /* Other name ?? */
  {
    double nb;

    nb= (omega>0) ? 1+1/(exp(omega/(T*T2E))-1) : 1/(exp(-omega/(T*T2E))-1);
    return nb;
  }
#undef T2E
/* Routine types from Numerical Recipies book */
#define UNUSED (-1.11e30)
#define MAXRIDD 60

void fatalerror(char *s)
  {
     fprintf(stderr,"%s \n",s);
     exit(1);
  }

double zridd(double (*func)(double*), double x1, double x2, double *parms, double xacc)
    {
      int j;
      double ans, fh, fl, fm, fnew, s, xh, xl, xm, xnew;

/*      printf("zridd called with brackets %g %g acceptance %g \n",x1,x2,xacc);
      printf("and %i parameters %g %g %g %g %g \n",Nparms,parms[0],parms[1],parms[2],parms[3], parms[4]); */
      parms[0]=x1;
      fl=(*func)(parms);
      parms[0]=x2;
      fh=(*func)(parms);
/*      printf("Function values: %g %g \n",fl,fh); */
      if (fl*fh >= 0)
      {
        if (fl==0) return x1;
        if (fh==0) return x2;
        return UNUSED;
      }
      else
      {
        xl=x1;
        xh=x2;
        ans=UNUSED;
        for (j=1; j<MAXRIDD; j++)
        {
          xm=0.5*(xl+xh);
          parms[0]=xm;
          fm=(*func)(parms);
          s=sqrt(fm*fm-fl*fh);
          if (s == 0.0)
            return ans;
          xnew=xm+(xm-xl)*((fl >= fh ? 1.0 : -1.0)*fm/s);
          if (fabs(xnew-ans) <= xacc)
            return ans;
          ans=xnew;
          parms[0]=ans;
          fnew=(*func)(parms);
          if (fnew == 0.0) return ans;
          if (fabs(fm)*SIGN(fnew) != fm)
          {
            xl=xm;
            fl=fm;
            xh=ans;
            fh=fnew;
          }
          else
            if (fabs(fl)*SIGN(fnew) != fl)
            {
              xh=ans;
              fh=fnew;
            }
            else
              if(fabs(fh)*SIGN(fnew) != fh)
              {
                xl=ans;
                fl=fnew;
              }
              else
                fatalerror("never get here in zridd");
          if (fabs(xh-xl) <= xacc)
            return ans;
        }
        fatalerror("zridd exceeded maximum iterations");
      }
      return 0.0;  /* Never get here */
    }

#define ROOTACC 1e-8
  int findroots(double brack_low, double brack_mid, double brack_high, double *list, int* index, double (*f)(double*), double *parms)
    {
      double root,range=brack_mid-brack_low;
      int i, steps=100;

     for (i=0; i<steps; i++)
     {
      root = zridd(f, brack_low+range*i/(int)steps,
                   brack_low+range*(i+1)/(int)steps,
                   (double *)parms, ROOTACC);
      if (root != UNUSED)
      {
        list[(*index)++]=root;
/*        printf("findroots found a  low root: %g \n",root); */
      }
     }
      root = zridd(f, brack_mid, brack_high, (double *)parms, ROOTACC);
      if (root != UNUSED)
      {
        list[(*index)++]=root;
/*        printf("findroots found a high root: %g \n",root); */
      }
    }

  double omega_q(double* parms)
    {
      /* dispersion in units of meV  */
      double vi, vf, vv_x, vv_y, vv_z, vi_x, vi_y, vi_z;
      double q, qx, qy, qz, Jq, res_phonon, res_neutron;
      double ah, a, c, gap;

      vf=parms[0];
      vi=parms[1];
      vv_x=parms[2];
      vv_y=parms[3];
      vv_z=parms[4];
      vi_x=parms[5];
      vi_y=parms[6];
      vi_z=parms[7];
      a   =parms[8];
      c   =parms[9];
      gap =parms[10];
      ah=a/2.0;

/*    printf("omega_q called with parameters vf= %g, vi=%g (%g %g %g) vv=(%g, %g, %g) \n",vf,vi,vi_x,vi_y,vi_z,vv_x,vv_y,vv_z); */
      qx=V2K*(vi_x-vf*vv_x);
      qy=V2K*(vi_y-vf*vv_y);
      qz=V2K*(vi_z-vf*vv_z);
      q=sqrt(qx*qx+qy*qy+qz*qz);
      Jq=2*(cos(ah*(qx+qy))+cos(ah*(qx-qy))+cos(ah*(qx+qz))+cos(ah*(qx-qz))
             +cos(ah*(qy+qz))+cos(ah*(qy-qz)) );
      if (gap>0) {
	res_phonon=sqrt(gap*gap+(12-Jq)*(c*c)/(a*a));
      } else {
        res_phonon=c/a*sqrt(12-Jq);
      }
      res_neutron = fabs(VS2E*(vi*vi-vf*vf));
/*      if (fabs(res_phonon-res_neutron)<1e-3)
       printf("in omega_q: q=(%g %g %g), omega_phonon=%g, omega_neutron=%g\n ",
             qx,qy,qz,res_phonon,res_neutron); */
/*      printf("omega_q returning %g - %g\n",res_phonon,res_neutron); */

      return (res_phonon - res_neutron);
    }
#undef UNUSED
#undef MAXRIDD
#endif
#line 11164 "RITA-II.c"

/* Shared user declarations for all components 'Monochromator_flat'. */
#line 71 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
#ifndef GAUSS
/* Define these arrays only once for all instances. */
/* Values for Gauss quadrature. Taken from Brice Carnahan, H. A. Luther and
James O Wilkes, "Applied numerical methods", Wiley, 1969, page 103.
This reference is available from the Copenhagen UB2 library */
double Gauss_X[] = {-0.987992518020485, -0.937273392400706, -0.848206583410427,
-0.724417731360170, -0.570972172608539, -0.394151347077563,
-0.201194093997435, 0, 0.201194093997435,
0.394151347077563, 0.570972172608539, 0.724417731360170,
0.848206583410427, 0.937273392400706, 0.987992518020485};
double Gauss_W[] = {0.030753241996117, 0.070366047488108, 0.107159220467172,
0.139570677926154, 0.166269205816994, 0.186161000115562,
0.198431485327111, 0.202578241925561, 0.198431485327111,
0.186161000115562, 0.166269205816994, 0.139570677926154,
0.107159220467172, 0.070366047488108, 0.030753241996117};


#define GAUSS(x,mean,rms) \
  (exp(-((x)-(mean))*((x)-(mean))/(2*(rms)*(rms)))/(sqrt(2*PI)*(rms)))
#endif
#line 11188 "RITA-II.c"

/* Instrument parameters. */
MCNUM mcipITAR;
MCNUM mcipL0;
MCNUM mcipBPL;
MCNUM mcipBPH;
MCNUM mcipMONO_N;
MCNUM mcipMONOFORCE;
MCNUM mcipMONO_MOS_H;
MCNUM mcipMONO_MOS_V;
MCNUM mcipEI;
MCNUM mcipEF;
MCNUM mcipEN;
MCNUM mcipSM;
MCNUM mcipSS;
MCNUM mcipSA;
MCNUM mcipQH;
MCNUM mcipQK;
MCNUM mcipQL;
MCNUM mcipQM;
MCNUM mcipAS;
MCNUM mcipBS;
MCNUM mcipCS;
MCNUM mcipAA;
MCNUM mcipBB;
MCNUM mcipCC;
MCNUM mcipAH;
MCNUM mcipAK;
MCNUM mcipAL;
MCNUM mcipBH;
MCNUM mcipBK;
MCNUM mcipBL;
MCNUM mcipINFILTER;
char* mcipINFILTERFILE;
MCNUM mcipCOLL_MS;
MCNUM mcipMST;
MCNUM mcipMSB;
MCNUM mcipMSL;
MCNUM mcipMSR;
MCNUM mcipPTHICK;
MCNUM mcipPERSPEX;
MCNUM mcipSAMPLE;
char* mcipSAMPLEFILE;
MCNUM mcipMOS;
MCNUM mcipDD_D;
MCNUM mcipSAMPLESIZE;
MCNUM mcipBARNS;
MCNUM mcipAAX;
MCNUM mcipAAY;
MCNUM mcipAAZ;
MCNUM mcipBBX;
MCNUM mcipBBY;
MCNUM mcipBBZ;
MCNUM mcipCCX;
MCNUM mcipCCY;
MCNUM mcipCCZ;
MCNUM mcipA1;
MCNUM mcipA2;
MCNUM mcipA3;
MCNUM mcipA4;
MCNUM mcipAA5;
MCNUM mcipA6;
MCNUM mcipTILT;
MCNUM mcipSST;
MCNUM mcipSSB;
MCNUM mcipSSL;
MCNUM mcipSSR;
MCNUM mcipOUTFILTER;
char* mcipOUTFILTERFILE;
MCNUM mcipANAFORCE;
MCNUM mcipC1;
MCNUM mcipC2;
MCNUM mcipC3;
MCNUM mcipC4;
MCNUM mcipC5;
MCNUM mcipC6;
MCNUM mcipC7;
MCNUM mcipC8;
MCNUM mcipC9;
MCNUM mcipCOARSE;
MCNUM mcipLC;
MCNUM mcipRC;
MCNUM mcipREP;
MCNUM mcipVIRTUALOUT;
MCNUM mcipVIRTUALIN;
char* mcipSOURCEFILE;
MCNUM mcipverbose;

#define mcNUMIPAR 85
int mcnumipar = 85;
struct mcinputtable_struct mcinputtable[mcNUMIPAR+1] = {
  "ITAR", &mcipITAR, instr_type_double, "1.0", 
  "L0", &mcipL0, instr_type_double, "4.045", 
  "BPL", &mcipBPL, instr_type_double, "0.97", 
  "BPH", &mcipBPH, instr_type_double, "1.03", 
  "MONO_N", &mcipMONO_N, instr_type_double, "1", 
  "MONOFORCE", &mcipMONOFORCE, instr_type_double, "0", 
  "MONO_MOS_H", &mcipMONO_MOS_H, instr_type_double, "37", 
  "MONO_MOS_V", &mcipMONO_MOS_V, instr_type_double, "37", 
  "EI", &mcipEI, instr_type_double, "0", 
  "EF", &mcipEF, instr_type_double, "0", 
  "EN", &mcipEN, instr_type_double, "0", 
  "SM", &mcipSM, instr_type_double, "1", 
  "SS", &mcipSS, instr_type_double, "-1", 
  "SA", &mcipSA, instr_type_double, "1", 
  "QH", &mcipQH, instr_type_double, "0", 
  "QK", &mcipQK, instr_type_double, "0", 
  "QL", &mcipQL, instr_type_double, "0", 
  "QM", &mcipQM, instr_type_double, "1.8051", 
  "AS", &mcipAS, instr_type_double, "4.95", 
  "BS", &mcipBS, instr_type_double, "4.95", 
  "CS", &mcipCS, instr_type_double, "4.95", 
  "AA", &mcipAA, instr_type_double, "90", 
  "BB", &mcipBB, instr_type_double, "90", 
  "CC", &mcipCC, instr_type_double, "90", 
  "AH", &mcipAH, instr_type_double, "0", 
  "AK", &mcipAK, instr_type_double, "1", 
  "AL", &mcipAL, instr_type_double, "0", 
  "BH", &mcipBH, instr_type_double, "1", 
  "BK", &mcipBK, instr_type_double, "0", 
  "BL", &mcipBL, instr_type_double, "0", 
  "INFILTER", &mcipINFILTER, instr_type_double, "0", 
  "INFILTERFILE", &mcipINFILTERFILE, instr_type_string, "Be.trm", 
  "COLL_MS", &mcipCOLL_MS, instr_type_double, "80", 
  "MST", &mcipMST, instr_type_double, "40", 
  "MSB", &mcipMSB, instr_type_double, "40", 
  "MSL", &mcipMSL, instr_type_double, "40", 
  "MSR", &mcipMSR, instr_type_double, "40", 
  "PTHICK", &mcipPTHICK, instr_type_double, "1e-3", 
  "PERSPEX", &mcipPERSPEX, instr_type_double, "0", 
  "SAMPLE", &mcipSAMPLE, instr_type_double, "1", 
  "SAMPLEFILE", &mcipSAMPLEFILE, instr_type_string, "default", 
  "MOS", &mcipMOS, instr_type_double, "100", 
  "DD_D", &mcipDD_D, instr_type_double, "1e-3", 
  "SAMPLESIZE", &mcipSAMPLESIZE, instr_type_double, "0.01", 
  "BARNS", &mcipBARNS, instr_type_double, "1", 
  "AAX", &mcipAAX, instr_type_double, "-4.95", 
  "AAY", &mcipAAY, instr_type_double, "0", 
  "AAZ", &mcipAAZ, instr_type_double, "0", 
  "BBX", &mcipBBX, instr_type_double, "0", 
  "BBY", &mcipBBY, instr_type_double, "0", 
  "BBZ", &mcipBBZ, instr_type_double, "4.95", 
  "CCX", &mcipCCX, instr_type_double, "0", 
  "CCY", &mcipCCY, instr_type_double, "4.95", 
  "CCZ", &mcipCCZ, instr_type_double, "0", 
  "A1", &mcipA1, instr_type_double, "0", 
  "A2", &mcipA2, instr_type_double, "0", 
  "A3", &mcipA3, instr_type_double, "0", 
  "A4", &mcipA4, instr_type_double, "0", 
  "AA5", &mcipAA5, instr_type_double, "0", 
  "A6", &mcipA6, instr_type_double, "0", 
  "TILT", &mcipTILT, instr_type_double, "0", 
  "SST", &mcipSST, instr_type_double, "100", 
  "SSB", &mcipSSB, instr_type_double, "100", 
  "SSL", &mcipSSL, instr_type_double, "100", 
  "SSR", &mcipSSR, instr_type_double, "100", 
  "OUTFILTER", &mcipOUTFILTER, instr_type_double, "1", 
  "OUTFILTERFILE", &mcipOUTFILTERFILE, instr_type_string, "Be.trm", 
  "ANAFORCE", &mcipANAFORCE, instr_type_double, "0", 
  "C1", &mcipC1, instr_type_double, "0", 
  "C2", &mcipC2, instr_type_double, "0", 
  "C3", &mcipC3, instr_type_double, "0", 
  "C4", &mcipC4, instr_type_double, "0", 
  "C5", &mcipC5, instr_type_double, "0", 
  "C6", &mcipC6, instr_type_double, "0", 
  "C7", &mcipC7, instr_type_double, "0", 
  "C8", &mcipC8, instr_type_double, "0", 
  "C9", &mcipC9, instr_type_double, "0", 
  "COARSE", &mcipCOARSE, instr_type_double, "1", 
  "LC", &mcipLC, instr_type_double, "4", 
  "RC", &mcipRC, instr_type_double, "3", 
  "REP", &mcipREP, instr_type_double, "1", 
  "VIRTUALOUT", &mcipVIRTUALOUT, instr_type_double, "0", 
  "VIRTUALIN", &mcipVIRTUALIN, instr_type_double, "0", 
  "SOURCEFILE", &mcipSOURCEFILE, instr_type_string, "Vin_default.dat", 
  "verbose", &mcipverbose, instr_type_double, "1", 
  NULL, NULL, instr_type_double, ""
};

/* User declarations from instrument definition. */
#define mccompcurname  RITA_II
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaRITA_II coords_set(0,0,0)
#define ITAR mcipITAR
#define L0 mcipL0
#define BPL mcipBPL
#define BPH mcipBPH
#define MONO_N mcipMONO_N
#define MONOFORCE mcipMONOFORCE
#define MONO_MOS_H mcipMONO_MOS_H
#define MONO_MOS_V mcipMONO_MOS_V
#define EI mcipEI
#define EF mcipEF
#define EN mcipEN
#define SM mcipSM
#define SS mcipSS
#define SA mcipSA
#define QH mcipQH
#define QK mcipQK
#define QL mcipQL
#define QM mcipQM
#define AS mcipAS
#define BS mcipBS
#define CS mcipCS
#define AA mcipAA
#define BB mcipBB
#define CC mcipCC
#define AH mcipAH
#define AK mcipAK
#define AL mcipAL
#define BH mcipBH
#define BK mcipBK
#define BL mcipBL
#define INFILTER mcipINFILTER
#define INFILTERFILE mcipINFILTERFILE
#define COLL_MS mcipCOLL_MS
#define MST mcipMST
#define MSB mcipMSB
#define MSL mcipMSL
#define MSR mcipMSR
#define PTHICK mcipPTHICK
#define PERSPEX mcipPERSPEX
#define SAMPLE mcipSAMPLE
#define SAMPLEFILE mcipSAMPLEFILE
#define MOS mcipMOS
#define DD_D mcipDD_D
#define SAMPLESIZE mcipSAMPLESIZE
#define BARNS mcipBARNS
#define AAX mcipAAX
#define AAY mcipAAY
#define AAZ mcipAAZ
#define BBX mcipBBX
#define BBY mcipBBY
#define BBZ mcipBBZ
#define CCX mcipCCX
#define CCY mcipCCY
#define CCZ mcipCCZ
#define A1 mcipA1
#define A2 mcipA2
#define A3 mcipA3
#define A4 mcipA4
#define AA5 mcipAA5
#define A6 mcipA6
#define TILT mcipTILT
#define SST mcipSST
#define SSB mcipSSB
#define SSL mcipSSL
#define SSR mcipSSR
#define OUTFILTER mcipOUTFILTER
#define OUTFILTERFILE mcipOUTFILTERFILE
#define ANAFORCE mcipANAFORCE
#define C1 mcipC1
#define C2 mcipC2
#define C3 mcipC3
#define C4 mcipC4
#define C5 mcipC5
#define C6 mcipC6
#define C7 mcipC7
#define C8 mcipC8
#define C9 mcipC9
#define COARSE mcipCOARSE
#define LC mcipLC
#define RC mcipRC
#define REP mcipREP
#define VIRTUALOUT mcipVIRTUALOUT
#define VIRTUALIN mcipVIRTUALIN
#define SOURCEFILE mcipSOURCEFILE
#define verbose mcipverbose
#line 162 "RITA-II.instr"
/* The following is from RITA2front, Kim Lefmann / Linda Udby */


/* Static values... */
double l0,lmin,lmax;
double emini,emaxi;
double eminf,emaxf;
double nefchan;
double neichan;
double lI,KI,KF;

/* Internal variable for SPLIT repetitions */
int SPLITREP;
int SPLITMREP;
int SPLITAREP;

/* Guide element parameters*/
double angleGuideCurved;
double R = 0.88;
double R0 = 0.995;
double Qc = 0.0217;
double W = 0;
double  M= 2.15;
double ALPHA;

/* Monochromator material parameters */
double mono_q = 1.87325;
double mono_r0 = 0.8;
double DM;      /*d-spacing monochromator*/
double mono_mosaic_h;
double mono_mosaic_v;
/* Monochromator curvature parmeters */
//double u,v;
double dms;  /* Target vector for focusing */
double tx,tz;    /* Target vector for focusing */
double sintm,sinta;
double rv; /* Mono focusing parameter */
/* Monochromator geometrical parameters */
/* Size of monochromator blades are hard-coded in the component*/
double mono_d = 0.026;  /* Distance between mono blades. From drawings */
double dmc; /* Distance monochromator to front of collimator. Was 0.32 from Stine */
double rmh = 0.58; /* Radius of monohousing. Measured 2008/11/05 */
double lc = 0.198; /*Length of monocollimator. Measured 2008/11/05*/
/* Order of scattering from the monochromator */
int Mono_order;     

/* RITA Monitor efficiency 1.7e-5 */
double EFF = 1.7e-5; 


/* Sample parameters */
double d_sample_slit = 0.35; /* Measured 2008/11/05, was 25 cm from Stine */
double d_sample_filter = 0.51; /*To centre of filter. Measured 2008/11/05, was to filter front 25 cm from Stine */
double dsa = 1.195;  /* distance sample-analyzer (m). Was 1.256 from Stine */
double dsb ; /*distance sample to blade, depends on analyser rack postion*/
double dmv = 1.00; /* distance monochromator to virtual out */
//double dvs = 0.67; /* distance virtual in to sample. dmv+dvs=1.67=rmh+1.09. Ma15 setting */
double dvs = 0.54; /* distance virtual in to sample. dmv+dvs=1.54 */
double is_incoh;/* Random number pr. neutron event for incoherent V scattering */
/* Filenames for the sample comps: */
char *PowderFile;
char *SingleXFile;

/* Analyser material parameters*/
double ana_mosaic_h;
double ana_mosaic_v;
double ana_q = 1.87325;
double ana_r0 = 0.8; 
double DA;    /* d-spacing analyser*/
/*Analyser geometrical parameters */
double ana_d = 0.025;  /* Width of analyser blades. From drawings */
double ana_h = 0.15;   /* Height of analyser blades. From drawings */
double dad = 0.338;  /* distance analyzer to detector front (m) */
double dadw = 0.3595; //= 0.3595;  /* distance analyzer to detector wire (m) */
double wan = 0.024;  /* width of analyzer blades , by ruler (m) */
double RR; //  = 0.3008; /* ratio of dadw and dsa*/
//double DA4; /*angle between blades*/
double A5; /* scattering angle for flat analyser*/
/* Declarations for 'Coarse Collimator' at the PSD detector surface */
int EntrySlit;
int ExitSlit;
int AnaBlade;
double BladeThickness = 0.007;// detector coll after 2006, from drawings
double WindowSize = 0.025;
double BladeLength = 0.179;// detector coll after 2006, from drawings
double BladeHeight = 0.272;// detector coll after 2006, from drawings
//double BladeThickness = 0.002;// detector coll before 2006
//double BladeLength = 0.180;// detector coll before 2006
//double BladeHeight = 0.250;// detector coll before 2006
double FirstWindowSizeL;
double FirstWindowSizeR;
double deltaL;
int coarse;

/* Detector parameters */
//double det_width = 0.2735;/* was 0.3 from Stine*/
double det_width = 0.275;
double det_height =0.5;
double PSF = 0.0074/2.35;// FWHM=0.0074m, measured by C. Bahl NIMB 246, 452.
/* Electronic Window positions in the PSD */
int XwinMin[9];
int YwinMin[9];
int XwinMax[9];
int YwinMax[9];
int BinX;
int BinY;





/* BEGIN declaring stuff for the HKL calculator adapted from templateTAS */
  struct sample_struct {
    double as, bs, cs; // Lattice parameters
    double aa, bb, cc; // Lattice angles
    double ax, ay, az; // First scattering plane vector
    double bx, by, bz; // Second scattering plane vector
  } sample;

  struct machine_hkl_struct {
    double dm, da;     // Mono and ana d-spacings
    double sm, ss, sa; // Mono, sample, ana angle signs
    double ki, kf, ei, ef; // Initial and Final wavevectors and energies
    double qh, qk, ql, en; // Momentum transfer and energy transfer in sample
  } machine_hkl;

  struct machine_real_struct {
    double a1,a2,a3,a4,a5,a6;
    double da4,aa5;
    double c1,c2,c3,c4,c5,c6,c7,c8,c9;
    double rmh, rmv, rah, rav;
    double qm, qs, qt[3];
    char   message[256];
  } machine_real;

  struct machine_real_struct qhkl2angles(
    struct sample_struct      sample,
    struct machine_hkl_struct machine_hkl,
    struct machine_real_struct machine_real) {

      /* code from TASMAD/t_rlp.F:SETRLP */
      double qhkl[3];
      double alpha[3];
      double a[3];
      double aspv[3][2];
      double cosa[3], sina[3];
      double cosb[3], sinb[3];
      double b[3], c[3], s[4][4];
      double vv[3][3], bb[3][3];
      double arg, cc;
      int i,j,k,l,m,n;
      char liquid_case=1;
      /* transfered parameters to local arrays */
      qhkl[0]   = machine_hkl.qh; /* HKL target */
      qhkl[1]   = machine_hkl.qk;
      qhkl[2]   = machine_hkl.ql;
      alpha[0]  = sample.aa; /* cell angles */
      alpha[1]  = sample.bb;
      alpha[2]  = sample.cc;
      a[0]      = sample.as; /* cell parameters */
      a[1]      = sample.bs;
      a[2]      = sample.cs;
      aspv[0][0]= sample.ax; /* cell axis A */
      aspv[1][0]= sample.ay;
      aspv[2][0]= sample.az;
      aspv[0][1]= sample.bx; /* cell axis B */
      aspv[1][1]= sample.by;
      aspv[2][1]= sample.bz;

      /* default return values */
      strcpy(machine_real.message, "");
      machine_real.a3 = machine_real.a4 = 0;
      machine_real.a1 = machine_real.a5 = 0;

      /* if using HKL positioning in crystal (QM = 0) */
      if (machine_real.qm <= 0) {
        liquid_case = 0;
        /* compute reciprocal cell */
        for (i=0; i< 3; i++)
          if (a[i] <=0) sprintf(machine_real.message, "Lattice parameters a[%i]=%g", i, a[i]);
          else {
            a[i]    /= 2*PI;
            alpha[i]*= DEG2RAD;
            cosa[i]  = cos(alpha[i]);
            sina[i]  = sin(alpha[i]);
          }
        cc = cosa[0]*cosa[0]+cosa[1]*cosa[1]+cosa[2]*cosa[2]; /* nprm */
        cc = 1 + 2*cosa[0]*cosa[1]*cosa[2] - cc;
        if (cc <= 0) sprintf(machine_real.message, "Lattice angles (AA,BB,CC) cc=%g", cc);
        else cc = sqrt(cc);

        if (strlen(machine_real.message)) return machine_real;

        /* compute bb */
        j=1; k=2;
        for (i=0; i<3; i++) {
          b[i] = sina[i]/(a[i]*cc);
          cosb[i] = (cosa[j]*cosa[k] - cosa[i])/(sina[j]*sina[k]);
          sinb[i] = sqrt(1 - cosb[i]*cosb[i]);
          j=k; k=i;
        }

        bb[0][0] = b[0];
        bb[1][0] = 0;
        bb[2][0] = 0;
        bb[0][1] = b[1]*cosb[2];
        bb[1][1] = b[1]*sinb[2];
        bb[2][1] = 0;
        bb[0][2] = b[2]*cosb[1];
        bb[1][2] =-b[2]*sinb[1]*cosa[0];
        bb[2][2] = 1/a[2];

        /* compute vv */
        for (k=0; k< 3; k++)
          for (i=0; i< 3; i++) vv[k][i] = 0;

        for (k=0; k< 2; k++)
          for (i=0; i< 3; i++)
            for (j=0; j< 3; j++)
              vv[k][i] += bb[i][j]*aspv[j][k];

        for (m=2; m>=1; m--)
          for (n=0; n<3; n++) {
            i = (int)fmod(m+1,3); j= (int)fmod(m+2,3);
            k = (int)fmod(n+1,3); l= (int)fmod(n+2,3);
            vv[m][n]=vv[i][k]*vv[j][l]-vv[i][l]*vv[j][k];
          }

        for (i=0; i< 3; i++) { /* compute norm(vv) */
          c[i]=0;
          for (j=0; j< 3; j++)
            c[i] += vv[i][j]*vv[i][j];
          if (c[i]>0) c[i] =  sqrt(c[i]);
          else {
            sprintf(machine_real.message, "Vectors A and B, c[%i]=%g", i, c[i]);
            return machine_real;
          }
        }

        for (i=0; i< 3; i++) /* normalize vv */
          for (j=0; j< 3; j++)
            vv[j][i] /= c[j];

        for (i=0; i< 3; i++) /* compute S */
          for (j=0; j< 3; j++) {
            s[i][j] = 0;
            for (k=0; k< 3; k++)
              s[i][j] += vv[i][k]*bb[k][j];
          }
        s[3][3]=1;
        for (i=0;  i< 3;  i++)  s[3][i]=s[i][3]=0;

        /* compute q modulus and transverse component */
        machine_real.qs = 0;
        for (i=0; i< 3; i++) {
          machine_real.qt[i] = 0;
          for (j=0; j< 3; j++) machine_real.qt[i] += qhkl[j]*s[i][j];
          machine_real.qs += machine_real.qt[i]*machine_real.qt[i];
        }
        if (machine_real.qs > 0) machine_real.qm = sqrt(machine_real.qs);
        else sprintf(machine_real.message, "Q modulus too small QM^2=%g", machine_real.qs);
      } else {
        machine_real.qs = machine_real.qm*machine_real.qm;
      }
      /* end if  qm <= 0 ********************************************* */

      /* positioning of monochromator and analyser */
      arg = PI/machine_hkl.dm/machine_hkl.ki;
      if (fabs(arg > 1))
        sprintf(machine_real.message, "Monochromator can not reach this KI. arg=%g", arg);
      else {
        if (machine_hkl.dm <= 0 || machine_hkl.ki <= 0)
          strcpy(machine_real.message, "Monochromator DM=0 or KI=0.");
        else
          machine_real.a1 = asin(arg)*RAD2DEG;
        machine_real.a1 *= machine_hkl.sm;
      }
      machine_real.a2=2*machine_real.a1;

      arg = PI/machine_hkl.da/machine_hkl.kf;
      if (fabs(arg > 1))
        sprintf(machine_real.message, "Analyzer can not reach this KF. arg=%g",arg);
      else {
        if (machine_hkl.da <= 0 || machine_hkl.kf <= 0)
          strcpy(machine_real.message, "Analyzer DA=0 or KF=0.");
        else
          machine_real.a5 = asin(arg)*RAD2DEG;
        machine_real.a5 *= machine_hkl.sa;
      }
      machine_real.a6=2*machine_real.a5;
      if (strlen(machine_real.message)) return machine_real;


      /* code from TASMAD/t_conv.F:SAM_CASE */
      arg = (machine_hkl.ki*machine_hkl.ki + machine_hkl.kf*machine_hkl.kf - machine_real.qs)
          / (2*machine_hkl.ki*machine_hkl.kf);
      if (fabs(arg) < 1)
        machine_real.a4 = RAD2DEG*acos(arg);
      else
        sprintf(machine_real.message, "Q modulus too big. Can not close triangle. arg=%g", arg);
      machine_real.a4 *= machine_hkl.ss;

      if (!liquid_case) { /* compute a3 in crystals */
        machine_real.a3 =
            -atan2(machine_real.qt[1],machine_real.qt[0])
            -acos( (machine_hkl.kf*machine_hkl.kf-machine_real.qs-machine_hkl.ki*machine_hkl.ki)
                  /(-2*machine_real.qm*machine_hkl.ki) );
        machine_real.a3 *= RAD2DEG*(machine_real.a4 > 0 ? 1 : -1 );  
  //machine_real.a3 = machine_real.a3 -90;// Add by PW & LU


      }

/* Analyser angles */
/* Angle of the analyser rack aa5 */
RR = dadw/dsa;
machine_real.aa5 = -RAD2DEG*(acos((sin(DEG2RAD*machine_real.a6)-(cos(DEG2RAD*machine_real.a6)+RR)*sqrt(RR*RR+2*RR*cos(DEG2RAD*machine_real.a6)))/(1+RR*RR+2*RR*cos(DEG2RAD*machine_real.a6)))); // From Bahl et al. , NIMB 226 (2004)
/*printf("(RITA Analyzer Rack Angle: AA5=%.4g[deg])\n", machine_real.aa5);*/
/*A4 angle between blades */
dsb = sqrt(dsa*dsa + ana_d*ana_d - 2*dsa*ana_d*cos(DEG2RAD*machine_real.aa5));
 machine_real.da4 = RAD2DEG*asin(ana_d*sin(DEG2RAD*abs(machine_real.aa5))/dsb);
//machine_real.da4 = RAD2DEG*atan(ana_d*cos(DEG2RAD*machine_real.aa5)/dsa);
printf("(RITA Analyzer Angle between blades: DA4=%.4g[deg])\n", machine_real.da4);
/*Blade angle rotation */
 machine_real.c1= -machine_real.aa5+machine_real.a5-(1-5)*machine_real.da4;
 machine_real.c2= -machine_real.aa5+machine_real.a5-(2-5)*machine_real.da4;
 machine_real.c3= -machine_real.aa5+machine_real.a5-(3-5)*machine_real.da4;
 machine_real.c4= -machine_real.aa5+machine_real.a5-(4-5)*machine_real.da4;
 machine_real.c5= -machine_real.aa5+machine_real.a5-(5-5)*machine_real.da4;
 machine_real.c6= -machine_real.aa5+machine_real.a5-(6-5)*machine_real.da4;
 machine_real.c7= -machine_real.aa5+machine_real.a5-(7-5)*machine_real.da4;
 machine_real.c8= -machine_real.aa5+machine_real.a5-(8-5)*machine_real.da4;
 machine_real.c9= -machine_real.aa5+machine_real.a5-(9-5)*machine_real.da4;

    return machine_real;  
  }
/* END declaring stuff for the HKL calculator adapted from templateTAS */


 
#line 11799 "RITA-II.c"
#undef verbose
#undef SOURCEFILE
#undef VIRTUALIN
#undef VIRTUALOUT
#undef REP
#undef RC
#undef LC
#undef COARSE
#undef C9
#undef C8
#undef C7
#undef C6
#undef C5
#undef C4
#undef C3
#undef C2
#undef C1
#undef ANAFORCE
#undef OUTFILTERFILE
#undef OUTFILTER
#undef SSR
#undef SSL
#undef SSB
#undef SST
#undef TILT
#undef A6
#undef AA5
#undef A4
#undef A3
#undef A2
#undef A1
#undef CCZ
#undef CCY
#undef CCX
#undef BBZ
#undef BBY
#undef BBX
#undef AAZ
#undef AAY
#undef AAX
#undef BARNS
#undef SAMPLESIZE
#undef DD_D
#undef MOS
#undef SAMPLEFILE
#undef SAMPLE
#undef PERSPEX
#undef PTHICK
#undef MSR
#undef MSL
#undef MSB
#undef MST
#undef COLL_MS
#undef INFILTERFILE
#undef INFILTER
#undef BL
#undef BK
#undef BH
#undef AL
#undef AK
#undef AH
#undef CC
#undef BB
#undef AA
#undef CS
#undef BS
#undef AS
#undef QM
#undef QL
#undef QK
#undef QH
#undef SA
#undef SS
#undef SM
#undef EN
#undef EF
#undef EI
#undef MONO_MOS_V
#undef MONO_MOS_H
#undef MONOFORCE
#undef MONO_N
#undef BPH
#undef BPL
#undef L0
#undef ITAR
#undef mcposaRITA_II
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname

/* neutron state table at each component input (local coords) */
/* [x, y, z, vx, vy, vz, t, sx, sy, sz, p] */
MCNUM mccomp_storein[11*154];
/* Components position table (absolute and relative coords) */
Coords mccomp_posa[154];
Coords mccomp_posr[154];
/* Counter for each comp to check for inactive ones */
MCNUM  mcNCounter[154];
MCNUM  mcPCounter[154];
MCNUM  mcP2Counter[154];
#define mcNUMCOMP 153 /* number of components */
/* Counter for PROP ABSORB */
MCNUM  mcAbsorbProp[154];
/* Flag true when previous component acted on the neutron (SCATTER) */
MCNUM mcScattered=0;
/* Flag true when neutron should be restored (RESTORE) */
MCNUM mcRestore=0;
/* Declarations of component definition and setting parameters. */

/* Setting parameters for component 'armSource' [1]. */
char mccarmSource_profile[16384];
MCNUM mccarmSource_percent;
MCNUM mccarmSource_flag_save;
MCNUM mccarmSource_minutes;

/* Definition parameters for component 'source' [2]. */
#define mccsource_flux_file 0 /* declared as a string. May produce warnings at compile */
#define mccsource_xdiv_file 0 /* declared as a string. May produce warnings at compile */
#define mccsource_ydiv_file 0 /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'source' [2]. */
MCNUM mccsource_radius;
MCNUM mccsource_dist;
MCNUM mccsource_xw;
MCNUM mccsource_yh;
MCNUM mccsource_E0;
MCNUM mccsource_dE;
MCNUM mccsource_Lambda0;
MCNUM mccsource_dLambda;
MCNUM mccsource_I1;
MCNUM mccsource_h;
MCNUM mccsource_w;
MCNUM mccsource_gaussian;
MCNUM mccsource_verbose;
MCNUM mccsource_T1;
MCNUM mccsource_flux_file_perAA;
MCNUM mccsource_flux_file_log;
MCNUM mccsource_Lmin;
MCNUM mccsource_Lmax;
MCNUM mccsource_Emin;
MCNUM mccsource_Emax;
MCNUM mccsource_T2;
MCNUM mccsource_I2;
MCNUM mccsource_T3;
MCNUM mccsource_I3;
MCNUM mccsource_length;
MCNUM mccsource_phi_init;
MCNUM mccsource_theta_init;
MCNUM mccsource_HEtailA;
MCNUM mccsource_HEtailL0;

/* Setting parameters for component 'slitGuideBegin' [3]. */
MCNUM mccslitGuideBegin_xmin;
MCNUM mccslitGuideBegin_xmax;
MCNUM mccslitGuideBegin_ymin;
MCNUM mccslitGuideBegin_ymax;
MCNUM mccslitGuideBegin_radius;
MCNUM mccslitGuideBegin_xwidth;
MCNUM mccslitGuideBegin_yheight;

/* Definition parameters for component 'lmon_guide_start' [4]. */
#define mcclmon_guide_start_nL 100
/* Setting parameters for component 'lmon_guide_start' [4]. */
char mcclmon_guide_start_filename[16384];
MCNUM mcclmon_guide_start_xmin;
MCNUM mcclmon_guide_start_xmax;
MCNUM mcclmon_guide_start_ymin;
MCNUM mcclmon_guide_start_ymax;
MCNUM mcclmon_guide_start_xwidth;
MCNUM mcclmon_guide_start_yheight;
MCNUM mcclmon_guide_start_Lmin;
MCNUM mcclmon_guide_start_Lmax;
MCNUM mcclmon_guide_start_restore_neutron;
int mcclmon_guide_start_nowritefile;

/* Setting parameters for component 'guideStraight' [5]. */
char mccguideStraight_reflect[16384];
MCNUM mccguideStraight_w1;
MCNUM mccguideStraight_h1;
MCNUM mccguideStraight_w2;
MCNUM mccguideStraight_h2;
MCNUM mccguideStraight_l;
MCNUM mccguideStraight_R0;
MCNUM mccguideStraight_Qc;
MCNUM mccguideStraight_alpha;
MCNUM mccguideStraight_m;
MCNUM mccguideStraight_W;

/* Setting parameters for component 'guideCurved1' [6]. */
char mccguideCurved1_reflect[16384];
MCNUM mccguideCurved1_w1;
MCNUM mccguideCurved1_h1;
MCNUM mccguideCurved1_w2;
MCNUM mccguideCurved1_h2;
MCNUM mccguideCurved1_l;
MCNUM mccguideCurved1_R0;
MCNUM mccguideCurved1_Qc;
MCNUM mccguideCurved1_alpha;
MCNUM mccguideCurved1_m;
MCNUM mccguideCurved1_W;

/* Setting parameters for component 'guideCurved2' [7]. */
char mccguideCurved2_reflect[16384];
MCNUM mccguideCurved2_w1;
MCNUM mccguideCurved2_h1;
MCNUM mccguideCurved2_w2;
MCNUM mccguideCurved2_h2;
MCNUM mccguideCurved2_l;
MCNUM mccguideCurved2_R0;
MCNUM mccguideCurved2_Qc;
MCNUM mccguideCurved2_alpha;
MCNUM mccguideCurved2_m;
MCNUM mccguideCurved2_W;

/* Setting parameters for component 'guideCurved3' [8]. */
char mccguideCurved3_reflect[16384];
MCNUM mccguideCurved3_w1;
MCNUM mccguideCurved3_h1;
MCNUM mccguideCurved3_w2;
MCNUM mccguideCurved3_h2;
MCNUM mccguideCurved3_l;
MCNUM mccguideCurved3_R0;
MCNUM mccguideCurved3_Qc;
MCNUM mccguideCurved3_alpha;
MCNUM mccguideCurved3_m;
MCNUM mccguideCurved3_W;

/* Setting parameters for component 'guideCurved4' [9]. */
char mccguideCurved4_reflect[16384];
MCNUM mccguideCurved4_w1;
MCNUM mccguideCurved4_h1;
MCNUM mccguideCurved4_w2;
MCNUM mccguideCurved4_h2;
MCNUM mccguideCurved4_l;
MCNUM mccguideCurved4_R0;
MCNUM mccguideCurved4_Qc;
MCNUM mccguideCurved4_alpha;
MCNUM mccguideCurved4_m;
MCNUM mccguideCurved4_W;

/* Setting parameters for component 'guideCurved5' [10]. */
char mccguideCurved5_reflect[16384];
MCNUM mccguideCurved5_w1;
MCNUM mccguideCurved5_h1;
MCNUM mccguideCurved5_w2;
MCNUM mccguideCurved5_h2;
MCNUM mccguideCurved5_l;
MCNUM mccguideCurved5_R0;
MCNUM mccguideCurved5_Qc;
MCNUM mccguideCurved5_alpha;
MCNUM mccguideCurved5_m;
MCNUM mccguideCurved5_W;

/* Setting parameters for component 'guideCurved6' [11]. */
char mccguideCurved6_reflect[16384];
MCNUM mccguideCurved6_w1;
MCNUM mccguideCurved6_h1;
MCNUM mccguideCurved6_w2;
MCNUM mccguideCurved6_h2;
MCNUM mccguideCurved6_l;
MCNUM mccguideCurved6_R0;
MCNUM mccguideCurved6_Qc;
MCNUM mccguideCurved6_alpha;
MCNUM mccguideCurved6_m;
MCNUM mccguideCurved6_W;

/* Setting parameters for component 'guideCurved7' [12]. */
char mccguideCurved7_reflect[16384];
MCNUM mccguideCurved7_w1;
MCNUM mccguideCurved7_h1;
MCNUM mccguideCurved7_w2;
MCNUM mccguideCurved7_h2;
MCNUM mccguideCurved7_l;
MCNUM mccguideCurved7_R0;
MCNUM mccguideCurved7_Qc;
MCNUM mccguideCurved7_alpha;
MCNUM mccguideCurved7_m;
MCNUM mccguideCurved7_W;

/* Setting parameters for component 'guideCurved8' [13]. */
char mccguideCurved8_reflect[16384];
MCNUM mccguideCurved8_w1;
MCNUM mccguideCurved8_h1;
MCNUM mccguideCurved8_w2;
MCNUM mccguideCurved8_h2;
MCNUM mccguideCurved8_l;
MCNUM mccguideCurved8_R0;
MCNUM mccguideCurved8_Qc;
MCNUM mccguideCurved8_alpha;
MCNUM mccguideCurved8_m;
MCNUM mccguideCurved8_W;

/* Setting parameters for component 'guideCurved9' [14]. */
char mccguideCurved9_reflect[16384];
MCNUM mccguideCurved9_w1;
MCNUM mccguideCurved9_h1;
MCNUM mccguideCurved9_w2;
MCNUM mccguideCurved9_h2;
MCNUM mccguideCurved9_l;
MCNUM mccguideCurved9_R0;
MCNUM mccguideCurved9_Qc;
MCNUM mccguideCurved9_alpha;
MCNUM mccguideCurved9_m;
MCNUM mccguideCurved9_W;

/* Setting parameters for component 'guideCurved10' [15]. */
char mccguideCurved10_reflect[16384];
MCNUM mccguideCurved10_w1;
MCNUM mccguideCurved10_h1;
MCNUM mccguideCurved10_w2;
MCNUM mccguideCurved10_h2;
MCNUM mccguideCurved10_l;
MCNUM mccguideCurved10_R0;
MCNUM mccguideCurved10_Qc;
MCNUM mccguideCurved10_alpha;
MCNUM mccguideCurved10_m;
MCNUM mccguideCurved10_W;

/* Setting parameters for component 'guideCurved11' [16]. */
char mccguideCurved11_reflect[16384];
MCNUM mccguideCurved11_w1;
MCNUM mccguideCurved11_h1;
MCNUM mccguideCurved11_w2;
MCNUM mccguideCurved11_h2;
MCNUM mccguideCurved11_l;
MCNUM mccguideCurved11_R0;
MCNUM mccguideCurved11_Qc;
MCNUM mccguideCurved11_alpha;
MCNUM mccguideCurved11_m;
MCNUM mccguideCurved11_W;

/* Setting parameters for component 'guideCurved12' [17]. */
char mccguideCurved12_reflect[16384];
MCNUM mccguideCurved12_w1;
MCNUM mccguideCurved12_h1;
MCNUM mccguideCurved12_w2;
MCNUM mccguideCurved12_h2;
MCNUM mccguideCurved12_l;
MCNUM mccguideCurved12_R0;
MCNUM mccguideCurved12_Qc;
MCNUM mccguideCurved12_alpha;
MCNUM mccguideCurved12_m;
MCNUM mccguideCurved12_W;

/* Setting parameters for component 'guideCurved13' [18]. */
char mccguideCurved13_reflect[16384];
MCNUM mccguideCurved13_w1;
MCNUM mccguideCurved13_h1;
MCNUM mccguideCurved13_w2;
MCNUM mccguideCurved13_h2;
MCNUM mccguideCurved13_l;
MCNUM mccguideCurved13_R0;
MCNUM mccguideCurved13_Qc;
MCNUM mccguideCurved13_alpha;
MCNUM mccguideCurved13_m;
MCNUM mccguideCurved13_W;

/* Setting parameters for component 'guideCurved14' [19]. */
char mccguideCurved14_reflect[16384];
MCNUM mccguideCurved14_w1;
MCNUM mccguideCurved14_h1;
MCNUM mccguideCurved14_w2;
MCNUM mccguideCurved14_h2;
MCNUM mccguideCurved14_l;
MCNUM mccguideCurved14_R0;
MCNUM mccguideCurved14_Qc;
MCNUM mccguideCurved14_alpha;
MCNUM mccguideCurved14_m;
MCNUM mccguideCurved14_W;

/* Setting parameters for component 'guideCurved15' [20]. */
char mccguideCurved15_reflect[16384];
MCNUM mccguideCurved15_w1;
MCNUM mccguideCurved15_h1;
MCNUM mccguideCurved15_w2;
MCNUM mccguideCurved15_h2;
MCNUM mccguideCurved15_l;
MCNUM mccguideCurved15_R0;
MCNUM mccguideCurved15_Qc;
MCNUM mccguideCurved15_alpha;
MCNUM mccguideCurved15_m;
MCNUM mccguideCurved15_W;

/* Setting parameters for component 'guideCurved16' [21]. */
char mccguideCurved16_reflect[16384];
MCNUM mccguideCurved16_w1;
MCNUM mccguideCurved16_h1;
MCNUM mccguideCurved16_w2;
MCNUM mccguideCurved16_h2;
MCNUM mccguideCurved16_l;
MCNUM mccguideCurved16_R0;
MCNUM mccguideCurved16_Qc;
MCNUM mccguideCurved16_alpha;
MCNUM mccguideCurved16_m;
MCNUM mccguideCurved16_W;

/* Setting parameters for component 'guideCurved17' [22]. */
char mccguideCurved17_reflect[16384];
MCNUM mccguideCurved17_w1;
MCNUM mccguideCurved17_h1;
MCNUM mccguideCurved17_w2;
MCNUM mccguideCurved17_h2;
MCNUM mccguideCurved17_l;
MCNUM mccguideCurved17_R0;
MCNUM mccguideCurved17_Qc;
MCNUM mccguideCurved17_alpha;
MCNUM mccguideCurved17_m;
MCNUM mccguideCurved17_W;

/* Setting parameters for component 'guideCurved18' [23]. */
char mccguideCurved18_reflect[16384];
MCNUM mccguideCurved18_w1;
MCNUM mccguideCurved18_h1;
MCNUM mccguideCurved18_w2;
MCNUM mccguideCurved18_h2;
MCNUM mccguideCurved18_l;
MCNUM mccguideCurved18_R0;
MCNUM mccguideCurved18_Qc;
MCNUM mccguideCurved18_alpha;
MCNUM mccguideCurved18_m;
MCNUM mccguideCurved18_W;

/* Setting parameters for component 'guideCurved19' [24]. */
char mccguideCurved19_reflect[16384];
MCNUM mccguideCurved19_w1;
MCNUM mccguideCurved19_h1;
MCNUM mccguideCurved19_w2;
MCNUM mccguideCurved19_h2;
MCNUM mccguideCurved19_l;
MCNUM mccguideCurved19_R0;
MCNUM mccguideCurved19_Qc;
MCNUM mccguideCurved19_alpha;
MCNUM mccguideCurved19_m;
MCNUM mccguideCurved19_W;

/* Setting parameters for component 'guideCurved20' [25]. */
char mccguideCurved20_reflect[16384];
MCNUM mccguideCurved20_w1;
MCNUM mccguideCurved20_h1;
MCNUM mccguideCurved20_w2;
MCNUM mccguideCurved20_h2;
MCNUM mccguideCurved20_l;
MCNUM mccguideCurved20_R0;
MCNUM mccguideCurved20_Qc;
MCNUM mccguideCurved20_alpha;
MCNUM mccguideCurved20_m;
MCNUM mccguideCurved20_W;

/* Setting parameters for component 'guideCurved21' [26]. */
char mccguideCurved21_reflect[16384];
MCNUM mccguideCurved21_w1;
MCNUM mccguideCurved21_h1;
MCNUM mccguideCurved21_w2;
MCNUM mccguideCurved21_h2;
MCNUM mccguideCurved21_l;
MCNUM mccguideCurved21_R0;
MCNUM mccguideCurved21_Qc;
MCNUM mccguideCurved21_alpha;
MCNUM mccguideCurved21_m;
MCNUM mccguideCurved21_W;

/* Setting parameters for component 'guideCurved22' [27]. */
char mccguideCurved22_reflect[16384];
MCNUM mccguideCurved22_w1;
MCNUM mccguideCurved22_h1;
MCNUM mccguideCurved22_w2;
MCNUM mccguideCurved22_h2;
MCNUM mccguideCurved22_l;
MCNUM mccguideCurved22_R0;
MCNUM mccguideCurved22_Qc;
MCNUM mccguideCurved22_alpha;
MCNUM mccguideCurved22_m;
MCNUM mccguideCurved22_W;

/* Setting parameters for component 'guideCurved23' [28]. */
char mccguideCurved23_reflect[16384];
MCNUM mccguideCurved23_w1;
MCNUM mccguideCurved23_h1;
MCNUM mccguideCurved23_w2;
MCNUM mccguideCurved23_h2;
MCNUM mccguideCurved23_l;
MCNUM mccguideCurved23_R0;
MCNUM mccguideCurved23_Qc;
MCNUM mccguideCurved23_alpha;
MCNUM mccguideCurved23_m;
MCNUM mccguideCurved23_W;

/* Setting parameters for component 'guideCurved24' [29]. */
char mccguideCurved24_reflect[16384];
MCNUM mccguideCurved24_w1;
MCNUM mccguideCurved24_h1;
MCNUM mccguideCurved24_w2;
MCNUM mccguideCurved24_h2;
MCNUM mccguideCurved24_l;
MCNUM mccguideCurved24_R0;
MCNUM mccguideCurved24_Qc;
MCNUM mccguideCurved24_alpha;
MCNUM mccguideCurved24_m;
MCNUM mccguideCurved24_W;

/* Setting parameters for component 'guideCurved25' [30]. */
char mccguideCurved25_reflect[16384];
MCNUM mccguideCurved25_w1;
MCNUM mccguideCurved25_h1;
MCNUM mccguideCurved25_w2;
MCNUM mccguideCurved25_h2;
MCNUM mccguideCurved25_l;
MCNUM mccguideCurved25_R0;
MCNUM mccguideCurved25_Qc;
MCNUM mccguideCurved25_alpha;
MCNUM mccguideCurved25_m;
MCNUM mccguideCurved25_W;

/* Setting parameters for component 'guideCurved26' [31]. */
char mccguideCurved26_reflect[16384];
MCNUM mccguideCurved26_w1;
MCNUM mccguideCurved26_h1;
MCNUM mccguideCurved26_w2;
MCNUM mccguideCurved26_h2;
MCNUM mccguideCurved26_l;
MCNUM mccguideCurved26_R0;
MCNUM mccguideCurved26_Qc;
MCNUM mccguideCurved26_alpha;
MCNUM mccguideCurved26_m;
MCNUM mccguideCurved26_W;

/* Setting parameters for component 'guideCurved27' [32]. */
char mccguideCurved27_reflect[16384];
MCNUM mccguideCurved27_w1;
MCNUM mccguideCurved27_h1;
MCNUM mccguideCurved27_w2;
MCNUM mccguideCurved27_h2;
MCNUM mccguideCurved27_l;
MCNUM mccguideCurved27_R0;
MCNUM mccguideCurved27_Qc;
MCNUM mccguideCurved27_alpha;
MCNUM mccguideCurved27_m;
MCNUM mccguideCurved27_W;

/* Setting parameters for component 'guideCurved28' [33]. */
char mccguideCurved28_reflect[16384];
MCNUM mccguideCurved28_w1;
MCNUM mccguideCurved28_h1;
MCNUM mccguideCurved28_w2;
MCNUM mccguideCurved28_h2;
MCNUM mccguideCurved28_l;
MCNUM mccguideCurved28_R0;
MCNUM mccguideCurved28_Qc;
MCNUM mccguideCurved28_alpha;
MCNUM mccguideCurved28_m;
MCNUM mccguideCurved28_W;

/* Setting parameters for component 'guideCurved29' [34]. */
char mccguideCurved29_reflect[16384];
MCNUM mccguideCurved29_w1;
MCNUM mccguideCurved29_h1;
MCNUM mccguideCurved29_w2;
MCNUM mccguideCurved29_h2;
MCNUM mccguideCurved29_l;
MCNUM mccguideCurved29_R0;
MCNUM mccguideCurved29_Qc;
MCNUM mccguideCurved29_alpha;
MCNUM mccguideCurved29_m;
MCNUM mccguideCurved29_W;

/* Setting parameters for component 'guideCurved30' [35]. */
char mccguideCurved30_reflect[16384];
MCNUM mccguideCurved30_w1;
MCNUM mccguideCurved30_h1;
MCNUM mccguideCurved30_w2;
MCNUM mccguideCurved30_h2;
MCNUM mccguideCurved30_l;
MCNUM mccguideCurved30_R0;
MCNUM mccguideCurved30_Qc;
MCNUM mccguideCurved30_alpha;
MCNUM mccguideCurved30_m;
MCNUM mccguideCurved30_W;

/* Setting parameters for component 'guideCurved31' [36]. */
char mccguideCurved31_reflect[16384];
MCNUM mccguideCurved31_w1;
MCNUM mccguideCurved31_h1;
MCNUM mccguideCurved31_w2;
MCNUM mccguideCurved31_h2;
MCNUM mccguideCurved31_l;
MCNUM mccguideCurved31_R0;
MCNUM mccguideCurved31_Qc;
MCNUM mccguideCurved31_alpha;
MCNUM mccguideCurved31_m;
MCNUM mccguideCurved31_W;

/* Setting parameters for component 'guideCurved32' [37]. */
char mccguideCurved32_reflect[16384];
MCNUM mccguideCurved32_w1;
MCNUM mccguideCurved32_h1;
MCNUM mccguideCurved32_w2;
MCNUM mccguideCurved32_h2;
MCNUM mccguideCurved32_l;
MCNUM mccguideCurved32_R0;
MCNUM mccguideCurved32_Qc;
MCNUM mccguideCurved32_alpha;
MCNUM mccguideCurved32_m;
MCNUM mccguideCurved32_W;

/* Setting parameters for component 'guideCurved33' [38]. */
char mccguideCurved33_reflect[16384];
MCNUM mccguideCurved33_w1;
MCNUM mccguideCurved33_h1;
MCNUM mccguideCurved33_w2;
MCNUM mccguideCurved33_h2;
MCNUM mccguideCurved33_l;
MCNUM mccguideCurved33_R0;
MCNUM mccguideCurved33_Qc;
MCNUM mccguideCurved33_alpha;
MCNUM mccguideCurved33_m;
MCNUM mccguideCurved33_W;

/* Setting parameters for component 'guideCurved34' [39]. */
char mccguideCurved34_reflect[16384];
MCNUM mccguideCurved34_w1;
MCNUM mccguideCurved34_h1;
MCNUM mccguideCurved34_w2;
MCNUM mccguideCurved34_h2;
MCNUM mccguideCurved34_l;
MCNUM mccguideCurved34_R0;
MCNUM mccguideCurved34_Qc;
MCNUM mccguideCurved34_alpha;
MCNUM mccguideCurved34_m;
MCNUM mccguideCurved34_W;

/* Setting parameters for component 'guideCurved35' [40]. */
char mccguideCurved35_reflect[16384];
MCNUM mccguideCurved35_w1;
MCNUM mccguideCurved35_h1;
MCNUM mccguideCurved35_w2;
MCNUM mccguideCurved35_h2;
MCNUM mccguideCurved35_l;
MCNUM mccguideCurved35_R0;
MCNUM mccguideCurved35_Qc;
MCNUM mccguideCurved35_alpha;
MCNUM mccguideCurved35_m;
MCNUM mccguideCurved35_W;

/* Setting parameters for component 'guideCurved36' [41]. */
char mccguideCurved36_reflect[16384];
MCNUM mccguideCurved36_w1;
MCNUM mccguideCurved36_h1;
MCNUM mccguideCurved36_w2;
MCNUM mccguideCurved36_h2;
MCNUM mccguideCurved36_l;
MCNUM mccguideCurved36_R0;
MCNUM mccguideCurved36_Qc;
MCNUM mccguideCurved36_alpha;
MCNUM mccguideCurved36_m;
MCNUM mccguideCurved36_W;

/* Setting parameters for component 'guideCurved37' [42]. */
char mccguideCurved37_reflect[16384];
MCNUM mccguideCurved37_w1;
MCNUM mccguideCurved37_h1;
MCNUM mccguideCurved37_w2;
MCNUM mccguideCurved37_h2;
MCNUM mccguideCurved37_l;
MCNUM mccguideCurved37_R0;
MCNUM mccguideCurved37_Qc;
MCNUM mccguideCurved37_alpha;
MCNUM mccguideCurved37_m;
MCNUM mccguideCurved37_W;

/* Setting parameters for component 'guideCurved38' [43]. */
char mccguideCurved38_reflect[16384];
MCNUM mccguideCurved38_w1;
MCNUM mccguideCurved38_h1;
MCNUM mccguideCurved38_w2;
MCNUM mccguideCurved38_h2;
MCNUM mccguideCurved38_l;
MCNUM mccguideCurved38_R0;
MCNUM mccguideCurved38_Qc;
MCNUM mccguideCurved38_alpha;
MCNUM mccguideCurved38_m;
MCNUM mccguideCurved38_W;

/* Setting parameters for component 'guideCurved39' [44]. */
char mccguideCurved39_reflect[16384];
MCNUM mccguideCurved39_w1;
MCNUM mccguideCurved39_h1;
MCNUM mccguideCurved39_w2;
MCNUM mccguideCurved39_h2;
MCNUM mccguideCurved39_l;
MCNUM mccguideCurved39_R0;
MCNUM mccguideCurved39_Qc;
MCNUM mccguideCurved39_alpha;
MCNUM mccguideCurved39_m;
MCNUM mccguideCurved39_W;

/* Setting parameters for component 'guideCurved40' [45]. */
char mccguideCurved40_reflect[16384];
MCNUM mccguideCurved40_w1;
MCNUM mccguideCurved40_h1;
MCNUM mccguideCurved40_w2;
MCNUM mccguideCurved40_h2;
MCNUM mccguideCurved40_l;
MCNUM mccguideCurved40_R0;
MCNUM mccguideCurved40_Qc;
MCNUM mccguideCurved40_alpha;
MCNUM mccguideCurved40_m;
MCNUM mccguideCurved40_W;

/* Setting parameters for component 'bunker' [46]. */
char mccbunker_reflect[16384];
MCNUM mccbunker_w1;
MCNUM mccbunker_h1;
MCNUM mccbunker_w2;
MCNUM mccbunker_h2;
MCNUM mccbunker_l;
MCNUM mccbunker_R0;
MCNUM mccbunker_Qc;
MCNUM mccbunker_alpha;
MCNUM mccbunker_m;
MCNUM mccbunker_W;

/* Setting parameters for component 'guide3' [47]. */
char mccguide3_reflect[16384];
MCNUM mccguide3_w1;
MCNUM mccguide3_h1;
MCNUM mccguide3_w2;
MCNUM mccguide3_h2;
MCNUM mccguide3_l;
MCNUM mccguide3_R0;
MCNUM mccguide3_Qc;
MCNUM mccguide3_alpha;
MCNUM mccguide3_m;
MCNUM mccguide3_W;

/* Setting parameters for component 'slitGuideEnd' [48]. */
MCNUM mccslitGuideEnd_xmin;
MCNUM mccslitGuideEnd_xmax;
MCNUM mccslitGuideEnd_ymin;
MCNUM mccslitGuideEnd_ymax;
MCNUM mccslitGuideEnd_radius;
MCNUM mccslitGuideEnd_xwidth;
MCNUM mccslitGuideEnd_yheight;

/* Definition parameters for component 'psd_guide_end' [49]. */
#define mccpsd_guide_end_nx 64
#define mccpsd_guide_end_ny 64
/* Setting parameters for component 'psd_guide_end' [49]. */
char mccpsd_guide_end_filename[16384];
MCNUM mccpsd_guide_end_xmin;
MCNUM mccpsd_guide_end_xmax;
MCNUM mccpsd_guide_end_ymin;
MCNUM mccpsd_guide_end_ymax;
MCNUM mccpsd_guide_end_xwidth;
MCNUM mccpsd_guide_end_yheight;
MCNUM mccpsd_guide_end_restore_neutron;
int mccpsd_guide_end_nowritefile;

/* Definition parameters for component 'emon_guide_end' [50]. */
#define mccemon_guide_end_nE 100
/* Setting parameters for component 'emon_guide_end' [50]. */
char mccemon_guide_end_filename[16384];
MCNUM mccemon_guide_end_xmin;
MCNUM mccemon_guide_end_xmax;
MCNUM mccemon_guide_end_ymin;
MCNUM mccemon_guide_end_ymax;
MCNUM mccemon_guide_end_xwidth;
MCNUM mccemon_guide_end_yheight;
MCNUM mccemon_guide_end_Emin;
MCNUM mccemon_guide_end_Emax;
MCNUM mccemon_guide_end_restore_neutron;
int mccemon_guide_end_nowritefile;

/* Definition parameters for component 'lmon_guide_end' [51]. */
#define mcclmon_guide_end_nL 100
/* Setting parameters for component 'lmon_guide_end' [51]. */
char mcclmon_guide_end_filename[16384];
MCNUM mcclmon_guide_end_xmin;
MCNUM mcclmon_guide_end_xmax;
MCNUM mcclmon_guide_end_ymin;
MCNUM mcclmon_guide_end_ymax;
MCNUM mcclmon_guide_end_xwidth;
MCNUM mcclmon_guide_end_yheight;
MCNUM mcclmon_guide_end_Lmin;
MCNUM mcclmon_guide_end_Lmax;
MCNUM mcclmon_guide_end_restore_neutron;
int mcclmon_guide_end_nowritefile;

/* Definition parameters for component 'divmon_guide_end' [52]. */
#define mccdivmon_guide_end_nh 128
#define mccdivmon_guide_end_nv 128
/* Setting parameters for component 'divmon_guide_end' [52]. */
char mccdivmon_guide_end_filename[16384];
MCNUM mccdivmon_guide_end_xmin;
MCNUM mccdivmon_guide_end_xmax;
MCNUM mccdivmon_guide_end_ymin;
MCNUM mccdivmon_guide_end_ymax;
MCNUM mccdivmon_guide_end_xwidth;
MCNUM mccdivmon_guide_end_yheight;
MCNUM mccdivmon_guide_end_maxdiv_h;
MCNUM mccdivmon_guide_end_maxdiv_v;
MCNUM mccdivmon_guide_end_restore_neutron;
MCNUM mccdivmon_guide_end_nx;
MCNUM mccdivmon_guide_end_ny;
MCNUM mccdivmon_guide_end_nz;
int mccdivmon_guide_end_nowritefile;

/* Setting parameters for component 'monochromator_curved' [54]. */
char mccmonochromator_curved_reflect[16384];
char mccmonochromator_curved_transmit[16384];
MCNUM mccmonochromator_curved_zwidth;
MCNUM mccmonochromator_curved_yheight;
MCNUM mccmonochromator_curved_gap;
MCNUM mccmonochromator_curved_NH;
MCNUM mccmonochromator_curved_NV;
MCNUM mccmonochromator_curved_mosaich;
MCNUM mccmonochromator_curved_mosaicv;
MCNUM mccmonochromator_curved_r0;
MCNUM mccmonochromator_curved_t0;
MCNUM mccmonochromator_curved_Q;
MCNUM mccmonochromator_curved_RV;
MCNUM mccmonochromator_curved_RH;
MCNUM mccmonochromator_curved_DM;
MCNUM mccmonochromator_curved_mosaic;
MCNUM mccmonochromator_curved_width;
MCNUM mccmonochromator_curved_height;
MCNUM mccmonochromator_curved_verbose;
MCNUM mccmonochromator_curved_order;

/* Setting parameters for component 'slitShutter' [56]. */
MCNUM mccslitShutter_xmin;
MCNUM mccslitShutter_xmax;
MCNUM mccslitShutter_ymin;
MCNUM mccslitShutter_ymax;
MCNUM mccslitShutter_radius;
MCNUM mccslitShutter_xwidth;
MCNUM mccslitShutter_yheight;

/* Setting parameters for component 'MSCollimator' [57]. */
MCNUM mccMSCollimator_xmin;
MCNUM mccMSCollimator_xmax;
MCNUM mccMSCollimator_ymin;
MCNUM mccMSCollimator_ymax;
MCNUM mccMSCollimator_xwidth;
MCNUM mccMSCollimator_yheight;
MCNUM mccMSCollimator_length;
MCNUM mccMSCollimator_divergence;
MCNUM mccMSCollimator_transmission;
MCNUM mccMSCollimator_divergenceV;

/* Setting parameters for component 'infilter' [58]. */
char mccinfilter_filename[16384];
char mccinfilter_options[16384];
MCNUM mccinfilter_xmin;
MCNUM mccinfilter_xmax;
MCNUM mccinfilter_ymin;
MCNUM mccinfilter_ymax;
MCNUM mccinfilter_xwidth;
MCNUM mccinfilter_yheight;
MCNUM mccinfilter_thickness;
MCNUM mccinfilter_scaling;
MCNUM mccinfilter_verbose;

/* Definition parameters for component 'psd_virt' [59]. */
#define mccpsd_virt_nx 128
#define mccpsd_virt_ny 128
/* Setting parameters for component 'psd_virt' [59]. */
char mccpsd_virt_filename[16384];
MCNUM mccpsd_virt_xmin;
MCNUM mccpsd_virt_xmax;
MCNUM mccpsd_virt_ymin;
MCNUM mccpsd_virt_ymax;
MCNUM mccpsd_virt_xwidth;
MCNUM mccpsd_virt_yheight;
MCNUM mccpsd_virt_restore_neutron;
int mccpsd_virt_nowritefile;

/* Definition parameters for component 'lmon_virt' [60]. */
#define mcclmon_virt_nL 100
/* Setting parameters for component 'lmon_virt' [60]. */
char mcclmon_virt_filename[16384];
MCNUM mcclmon_virt_xmin;
MCNUM mcclmon_virt_xmax;
MCNUM mcclmon_virt_ymin;
MCNUM mcclmon_virt_ymax;
MCNUM mcclmon_virt_xwidth;
MCNUM mcclmon_virt_yheight;
MCNUM mcclmon_virt_Lmin;
MCNUM mcclmon_virt_Lmax;
MCNUM mcclmon_virt_restore_neutron;
int mcclmon_virt_nowritefile;

/* Setting parameters for component 'virtualout' [62]. */
char mccvirtualout_filename[16384];
MCNUM mccvirtualout_bufsize;

/* Setting parameters for component 'virtualsource' [63]. */
char mccvirtualsource_filename[16384];
MCNUM mccvirtualsource_verbose;
MCNUM mccvirtualsource_repeat_count;
MCNUM mccvirtualsource_smooth;
MCNUM mccvirtualsource_display;

/* Definition parameters for component 'OrderMon' [64]. */
#define mccOrderMon_user1 Mono_order
#define mccOrderMon_user2 FLT_MAX
#define mccOrderMon_user3 FLT_MAX
/* Setting parameters for component 'OrderMon' [64]. */
MCNUM mccOrderMon_xwidth;
MCNUM mccOrderMon_yheight;
MCNUM mccOrderMon_zdepth;
MCNUM mccOrderMon_xmin;
MCNUM mccOrderMon_xmax;
MCNUM mccOrderMon_ymin;
MCNUM mccOrderMon_ymax;
MCNUM mccOrderMon_zmin;
MCNUM mccOrderMon_zmax;
MCNUM mccOrderMon_bins;
MCNUM mccOrderMon_min;
MCNUM mccOrderMon_max;
MCNUM mccOrderMon_restore_neutron;
MCNUM mccOrderMon_radius;
char mccOrderMon_options[16384];
char mccOrderMon_filename[16384];
char mccOrderMon_geometry[16384];
char mccOrderMon_username1[16384];
char mccOrderMon_username2[16384];
char mccOrderMon_username3[16384];
int mccOrderMon_nowritefile;

/* Definition parameters for component 'kMoni' [65]. */
#define mcckMoni_nx 90
#define mcckMoni_ny 90
#define mcckMoni_filename "kMoni.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'kMoni' [65]. */
MCNUM mcckMoni_xmin;
MCNUM mcckMoni_xmax;
MCNUM mcckMoni_ymin;
MCNUM mcckMoni_ymax;
MCNUM mcckMoni_xwidth;
MCNUM mcckMoni_yheight;
MCNUM mcckMoni_psf;
MCNUM mcckMoni_k0;
MCNUM mcckMoni_eff;
MCNUM mcckMoni_restore_neutron;
int mcckMoni_nowritefile;

/* Definition parameters for component 'kMoni1st' [66]. */
#define mcckMoni1st_nx 90
#define mcckMoni1st_ny 90
#define mcckMoni1st_filename "kMoni1st.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'kMoni1st' [66]. */
MCNUM mcckMoni1st_xmin;
MCNUM mcckMoni1st_xmax;
MCNUM mcckMoni1st_ymin;
MCNUM mcckMoni1st_ymax;
MCNUM mcckMoni1st_xwidth;
MCNUM mcckMoni1st_yheight;
MCNUM mcckMoni1st_psf;
MCNUM mcckMoni1st_k0;
MCNUM mcckMoni1st_eff;
MCNUM mcckMoni1st_restore_neutron;
int mcckMoni1st_nowritefile;

/* Definition parameters for component 'kMoni2nd' [67]. */
#define mcckMoni2nd_nx 90
#define mcckMoni2nd_ny 90
#define mcckMoni2nd_filename "kMoni2nd.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'kMoni2nd' [67]. */
MCNUM mcckMoni2nd_xmin;
MCNUM mcckMoni2nd_xmax;
MCNUM mcckMoni2nd_ymin;
MCNUM mcckMoni2nd_ymax;
MCNUM mcckMoni2nd_xwidth;
MCNUM mcckMoni2nd_yheight;
MCNUM mcckMoni2nd_psf;
MCNUM mcckMoni2nd_k0;
MCNUM mcckMoni2nd_eff;
MCNUM mcckMoni2nd_restore_neutron;
int mcckMoni2nd_nowritefile;

/* Definition parameters for component 'kMoni3rd' [68]. */
#define mcckMoni3rd_nx 90
#define mcckMoni3rd_ny 90
#define mcckMoni3rd_filename "kMoni3rd.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'kMoni3rd' [68]. */
MCNUM mcckMoni3rd_xmin;
MCNUM mcckMoni3rd_xmax;
MCNUM mcckMoni3rd_ymin;
MCNUM mcckMoni3rd_ymax;
MCNUM mcckMoni3rd_xwidth;
MCNUM mcckMoni3rd_yheight;
MCNUM mcckMoni3rd_psf;
MCNUM mcckMoni3rd_k0;
MCNUM mcckMoni3rd_eff;
MCNUM mcckMoni3rd_restore_neutron;
int mcckMoni3rd_nowritefile;

/* Setting parameters for component 'slitMonochromator' [69]. */
MCNUM mccslitMonochromator_xmin;
MCNUM mccslitMonochromator_xmax;
MCNUM mccslitMonochromator_ymin;
MCNUM mccslitMonochromator_ymax;
MCNUM mccslitMonochromator_radius;
MCNUM mccslitMonochromator_xwidth;
MCNUM mccslitMonochromator_yheight;

/* Setting parameters for component 'Perspex' [70]. */
char mccPerspex_geometry[16384];
MCNUM mccPerspex_radius;
MCNUM mccPerspex_xwidth;
MCNUM mccPerspex_yheight;
MCNUM mccPerspex_zdepth;
MCNUM mccPerspex_thickness;
MCNUM mccPerspex_target_x;
MCNUM mccPerspex_target_y;
MCNUM mccPerspex_target_z;
MCNUM mccPerspex_focus_r;
MCNUM mccPerspex_focus_xw;
MCNUM mccPerspex_focus_yh;
MCNUM mccPerspex_focus_aw;
MCNUM mccPerspex_focus_ah;
int mccPerspex_target_index;
MCNUM mccPerspex_pack;
MCNUM mccPerspex_p_interact;
MCNUM mccPerspex_f_QE;
MCNUM mccPerspex_gamma;
MCNUM mccPerspex_Etrans;
MCNUM mccPerspex_deltaE;
MCNUM mccPerspex_sigma_abs;
MCNUM mccPerspex_sigma_inc;
MCNUM mccPerspex_Vc;
MCNUM mccPerspex_concentric;
MCNUM mccPerspex_order;

/* Definition parameters for component 'psd_samplepos_1cm2' [71]. */
#define mccpsd_samplepos_1cm2_nx 90
#define mccpsd_samplepos_1cm2_ny 90
/* Setting parameters for component 'psd_samplepos_1cm2' [71]. */
char mccpsd_samplepos_1cm2_filename[16384];
MCNUM mccpsd_samplepos_1cm2_xmin;
MCNUM mccpsd_samplepos_1cm2_xmax;
MCNUM mccpsd_samplepos_1cm2_ymin;
MCNUM mccpsd_samplepos_1cm2_ymax;
MCNUM mccpsd_samplepos_1cm2_xwidth;
MCNUM mccpsd_samplepos_1cm2_yheight;
MCNUM mccpsd_samplepos_1cm2_restore_neutron;
int mccpsd_samplepos_1cm2_nowritefile;

/* Definition parameters for component 'emon_samplepos_1cm2' [72]. */
#define mccemon_samplepos_1cm2_nE 100
/* Setting parameters for component 'emon_samplepos_1cm2' [72]. */
char mccemon_samplepos_1cm2_filename[16384];
MCNUM mccemon_samplepos_1cm2_xmin;
MCNUM mccemon_samplepos_1cm2_xmax;
MCNUM mccemon_samplepos_1cm2_ymin;
MCNUM mccemon_samplepos_1cm2_ymax;
MCNUM mccemon_samplepos_1cm2_xwidth;
MCNUM mccemon_samplepos_1cm2_yheight;
MCNUM mccemon_samplepos_1cm2_Emin;
MCNUM mccemon_samplepos_1cm2_Emax;
MCNUM mccemon_samplepos_1cm2_restore_neutron;
int mccemon_samplepos_1cm2_nowritefile;

/* Definition parameters for component 'divmon_samplepos_1cm2' [73]. */
#define mccdivmon_samplepos_1cm2_nh 128
#define mccdivmon_samplepos_1cm2_nv 128
/* Setting parameters for component 'divmon_samplepos_1cm2' [73]. */
char mccdivmon_samplepos_1cm2_filename[16384];
MCNUM mccdivmon_samplepos_1cm2_xmin;
MCNUM mccdivmon_samplepos_1cm2_xmax;
MCNUM mccdivmon_samplepos_1cm2_ymin;
MCNUM mccdivmon_samplepos_1cm2_ymax;
MCNUM mccdivmon_samplepos_1cm2_xwidth;
MCNUM mccdivmon_samplepos_1cm2_yheight;
MCNUM mccdivmon_samplepos_1cm2_maxdiv_h;
MCNUM mccdivmon_samplepos_1cm2_maxdiv_v;
MCNUM mccdivmon_samplepos_1cm2_restore_neutron;
MCNUM mccdivmon_samplepos_1cm2_nx;
MCNUM mccdivmon_samplepos_1cm2_ny;
MCNUM mccdivmon_samplepos_1cm2_nz;
int mccdivmon_samplepos_1cm2_nowritefile;

/* Definition parameters for component 'psd_samplepos_large' [74]. */
#define mccpsd_samplepos_large_nx 90
#define mccpsd_samplepos_large_ny 90
/* Setting parameters for component 'psd_samplepos_large' [74]. */
char mccpsd_samplepos_large_filename[16384];
MCNUM mccpsd_samplepos_large_xmin;
MCNUM mccpsd_samplepos_large_xmax;
MCNUM mccpsd_samplepos_large_ymin;
MCNUM mccpsd_samplepos_large_ymax;
MCNUM mccpsd_samplepos_large_xwidth;
MCNUM mccpsd_samplepos_large_yheight;
MCNUM mccpsd_samplepos_large_restore_neutron;
int mccpsd_samplepos_large_nowritefile;

/* Setting parameters for component 'incohSample' [77]. */
char mccincohSample_geometry[16384];
MCNUM mccincohSample_radius;
MCNUM mccincohSample_xwidth;
MCNUM mccincohSample_yheight;
MCNUM mccincohSample_zdepth;
MCNUM mccincohSample_thickness;
MCNUM mccincohSample_target_x;
MCNUM mccincohSample_target_y;
MCNUM mccincohSample_target_z;
MCNUM mccincohSample_focus_r;
MCNUM mccincohSample_focus_xw;
MCNUM mccincohSample_focus_yh;
MCNUM mccincohSample_focus_aw;
MCNUM mccincohSample_focus_ah;
int mccincohSample_target_index;
MCNUM mccincohSample_pack;
MCNUM mccincohSample_p_interact;
MCNUM mccincohSample_f_QE;
MCNUM mccincohSample_gamma;
MCNUM mccincohSample_Etrans;
MCNUM mccincohSample_deltaE;
MCNUM mccincohSample_sigma_abs;
MCNUM mccincohSample_sigma_inc;
MCNUM mccincohSample_Vc;
MCNUM mccincohSample_concentric;
MCNUM mccincohSample_order;

/* Definition parameters for component 'powderSample' [78]. */
#define mccpowderSample_format Undefined
/* Setting parameters for component 'powderSample' [78]. */
char mccpowderSample_reflections[16384];
char mccpowderSample_geometry[16384];
MCNUM mccpowderSample_radius;
MCNUM mccpowderSample_yheight;
MCNUM mccpowderSample_xwidth;
MCNUM mccpowderSample_zdepth;
MCNUM mccpowderSample_thickness;
MCNUM mccpowderSample_pack;
MCNUM mccpowderSample_Vc;
MCNUM mccpowderSample_sigma_abs;
MCNUM mccpowderSample_sigma_inc;
MCNUM mccpowderSample_delta_d_d;
MCNUM mccpowderSample_p_inc;
MCNUM mccpowderSample_p_transmit;
MCNUM mccpowderSample_DW;
MCNUM mccpowderSample_nb_atoms;
MCNUM mccpowderSample_d_omega;
MCNUM mccpowderSample_d_phi;
MCNUM mccpowderSample_tth_sign;
MCNUM mccpowderSample_p_interact;
MCNUM mccpowderSample_concentric;
MCNUM mccpowderSample_density;
MCNUM mccpowderSample_weight;
MCNUM mccpowderSample_barns;
MCNUM mccpowderSample_Strain;
MCNUM mccpowderSample_focus_flip;
int mccpowderSample_target_index;

/* Definition parameters for component 'crystalSample' [79]. */
#define mcccrystalSample_mosaic_AB Mosaic_AB_Undefined
/* Setting parameters for component 'crystalSample' [79]. */
char mcccrystalSample_reflections[16384];
char mcccrystalSample_geometry[16384];
MCNUM mcccrystalSample_xwidth;
MCNUM mcccrystalSample_yheight;
MCNUM mcccrystalSample_zdepth;
MCNUM mcccrystalSample_radius;
MCNUM mcccrystalSample_delta_d_d;
MCNUM mcccrystalSample_mosaic;
MCNUM mcccrystalSample_mosaic_a;
MCNUM mcccrystalSample_mosaic_b;
MCNUM mcccrystalSample_mosaic_c;
MCNUM mcccrystalSample_recip_cell;
MCNUM mcccrystalSample_barns;
MCNUM mcccrystalSample_ax;
MCNUM mcccrystalSample_ay;
MCNUM mcccrystalSample_az;
MCNUM mcccrystalSample_bx;
MCNUM mcccrystalSample_by;
MCNUM mcccrystalSample_bz;
MCNUM mcccrystalSample_cx;
MCNUM mcccrystalSample_cy;
MCNUM mcccrystalSample_cz;
MCNUM mcccrystalSample_p_transmit;
MCNUM mcccrystalSample_sigma_abs;
MCNUM mcccrystalSample_sigma_inc;
MCNUM mcccrystalSample_aa;
MCNUM mcccrystalSample_bb;
MCNUM mcccrystalSample_cc;
MCNUM mcccrystalSample_order;
MCNUM mcccrystalSample_RX;
MCNUM mcccrystalSample_RY;
MCNUM mcccrystalSample_powder;
MCNUM mcccrystalSample_PG;
MCNUM mcccrystalSample_deltak;

/* Setting parameters for component 'phononSample' [80]. */
MCNUM mccphononSample_radius;
MCNUM mccphononSample_yheight;
MCNUM mccphononSample_sigma_abs;
MCNUM mccphononSample_sigma_inc;
MCNUM mccphononSample_a;
MCNUM mccphononSample_b;
MCNUM mccphononSample_M;
MCNUM mccphononSample_c;
MCNUM mccphononSample_DW;
MCNUM mccphononSample_T;
MCNUM mccphononSample_target_x;
MCNUM mccphononSample_target_y;
MCNUM mccphononSample_target_z;
int mccphononSample_target_index;
MCNUM mccphononSample_focus_r;
MCNUM mccphononSample_focus_xw;
MCNUM mccphononSample_focus_yh;
MCNUM mccphononSample_focus_aw;
MCNUM mccphononSample_focus_ah;
MCNUM mccphononSample_gap;

/* Definition parameters for component 'psd_4pi' [81]. */
#define mccpsd_4pi_nx 1000
#define mccpsd_4pi_ny 1000
/* Setting parameters for component 'psd_4pi' [81]. */
char mccpsd_4pi_filename[16384];
MCNUM mccpsd_4pi_radius;
MCNUM mccpsd_4pi_restore_neutron;
int mccpsd_4pi_nowritefile;

/* Setting parameters for component 'slitSample' [83]. */
MCNUM mccslitSample_xmin;
MCNUM mccslitSample_xmax;
MCNUM mccslitSample_ymin;
MCNUM mccslitSample_ymax;
MCNUM mccslitSample_radius;
MCNUM mccslitSample_xwidth;
MCNUM mccslitSample_yheight;

/* Setting parameters for component 'filter_coll' [84]. */
MCNUM mccfilter_coll_theta_min;
MCNUM mccfilter_coll_theta_max;
MCNUM mccfilter_coll_nslit;
MCNUM mccfilter_coll_radius;
MCNUM mccfilter_coll_length;
MCNUM mccfilter_coll_h_in;
MCNUM mccfilter_coll_h_out;
MCNUM mccfilter_coll_d;
MCNUM mccfilter_coll_verbose;

/* Setting parameters for component 'filter' [85]. */
char mccfilter_filename[16384];
char mccfilter_options[16384];
MCNUM mccfilter_xmin;
MCNUM mccfilter_xmax;
MCNUM mccfilter_ymin;
MCNUM mccfilter_ymax;
MCNUM mccfilter_xwidth;
MCNUM mccfilter_yheight;
MCNUM mccfilter_thickness;
MCNUM mccfilter_scaling;
MCNUM mccfilter_verbose;

/* Setting parameters for component 'ana_slit1' [86]. */
MCNUM mccana_slit1_xmin;
MCNUM mccana_slit1_xmax;
MCNUM mccana_slit1_ymin;
MCNUM mccana_slit1_ymax;
MCNUM mccana_slit1_radius;
MCNUM mccana_slit1_xwidth;
MCNUM mccana_slit1_yheight;

/* Setting parameters for component 'ana_slit2' [87]. */
MCNUM mccana_slit2_xmin;
MCNUM mccana_slit2_xmax;
MCNUM mccana_slit2_ymin;
MCNUM mccana_slit2_ymax;
MCNUM mccana_slit2_radius;
MCNUM mccana_slit2_xwidth;
MCNUM mccana_slit2_yheight;

/* Definition parameters for component 'emon_before_ana' [88]. */
#define mccemon_before_ana_nE 100
/* Setting parameters for component 'emon_before_ana' [88]. */
char mccemon_before_ana_filename[16384];
MCNUM mccemon_before_ana_xmin;
MCNUM mccemon_before_ana_xmax;
MCNUM mccemon_before_ana_ymin;
MCNUM mccemon_before_ana_ymax;
MCNUM mccemon_before_ana_xwidth;
MCNUM mccemon_before_ana_yheight;
MCNUM mccemon_before_ana_Emin;
MCNUM mccemon_before_ana_Emax;
MCNUM mccemon_before_ana_restore_neutron;
int mccemon_before_ana_nowritefile;

/* Definition parameters for component 'psd_before_ana' [89]. */
#define mccpsd_before_ana_nx 128
#define mccpsd_before_ana_ny 128
/* Setting parameters for component 'psd_before_ana' [89]. */
char mccpsd_before_ana_filename[16384];
MCNUM mccpsd_before_ana_xmin;
MCNUM mccpsd_before_ana_xmax;
MCNUM mccpsd_before_ana_ymin;
MCNUM mccpsd_before_ana_ymax;
MCNUM mccpsd_before_ana_xwidth;
MCNUM mccpsd_before_ana_yheight;
MCNUM mccpsd_before_ana_restore_neutron;
int mccpsd_before_ana_nowritefile;

/* Definition parameters for component 'divmon_before_ana' [90]. */
#define mccdivmon_before_ana_nh 128
#define mccdivmon_before_ana_nv 128
/* Setting parameters for component 'divmon_before_ana' [90]. */
char mccdivmon_before_ana_filename[16384];
MCNUM mccdivmon_before_ana_xmin;
MCNUM mccdivmon_before_ana_xmax;
MCNUM mccdivmon_before_ana_ymin;
MCNUM mccdivmon_before_ana_ymax;
MCNUM mccdivmon_before_ana_xwidth;
MCNUM mccdivmon_before_ana_yheight;
MCNUM mccdivmon_before_ana_maxdiv_h;
MCNUM mccdivmon_before_ana_maxdiv_v;
MCNUM mccdivmon_before_ana_restore_neutron;
MCNUM mccdivmon_before_ana_nx;
MCNUM mccdivmon_before_ana_ny;
MCNUM mccdivmon_before_ana_nz;
int mccdivmon_before_ana_nowritefile;

/* Setting parameters for component 'an1l' [92]. */
MCNUM mccan1l_zmin;
MCNUM mccan1l_zmax;
MCNUM mccan1l_ymin;
MCNUM mccan1l_ymax;
MCNUM mccan1l_zwidth;
MCNUM mccan1l_yheight;
MCNUM mccan1l_mosaich;
MCNUM mccan1l_mosaicv;
MCNUM mccan1l_r0;
MCNUM mccan1l_Q;
MCNUM mccan1l_DM;

/* Setting parameters for component 'an1u' [93]. */
MCNUM mccan1u_zmin;
MCNUM mccan1u_zmax;
MCNUM mccan1u_ymin;
MCNUM mccan1u_ymax;
MCNUM mccan1u_zwidth;
MCNUM mccan1u_yheight;
MCNUM mccan1u_mosaich;
MCNUM mccan1u_mosaicv;
MCNUM mccan1u_r0;
MCNUM mccan1u_Q;
MCNUM mccan1u_DM;

/* Setting parameters for component 'an2l' [94]. */
MCNUM mccan2l_zmin;
MCNUM mccan2l_zmax;
MCNUM mccan2l_ymin;
MCNUM mccan2l_ymax;
MCNUM mccan2l_zwidth;
MCNUM mccan2l_yheight;
MCNUM mccan2l_mosaich;
MCNUM mccan2l_mosaicv;
MCNUM mccan2l_r0;
MCNUM mccan2l_Q;
MCNUM mccan2l_DM;

/* Setting parameters for component 'an2u' [95]. */
MCNUM mccan2u_zmin;
MCNUM mccan2u_zmax;
MCNUM mccan2u_ymin;
MCNUM mccan2u_ymax;
MCNUM mccan2u_zwidth;
MCNUM mccan2u_yheight;
MCNUM mccan2u_mosaich;
MCNUM mccan2u_mosaicv;
MCNUM mccan2u_r0;
MCNUM mccan2u_Q;
MCNUM mccan2u_DM;

/* Setting parameters for component 'an3l' [96]. */
MCNUM mccan3l_zmin;
MCNUM mccan3l_zmax;
MCNUM mccan3l_ymin;
MCNUM mccan3l_ymax;
MCNUM mccan3l_zwidth;
MCNUM mccan3l_yheight;
MCNUM mccan3l_mosaich;
MCNUM mccan3l_mosaicv;
MCNUM mccan3l_r0;
MCNUM mccan3l_Q;
MCNUM mccan3l_DM;

/* Setting parameters for component 'an3u' [97]. */
MCNUM mccan3u_zmin;
MCNUM mccan3u_zmax;
MCNUM mccan3u_ymin;
MCNUM mccan3u_ymax;
MCNUM mccan3u_zwidth;
MCNUM mccan3u_yheight;
MCNUM mccan3u_mosaich;
MCNUM mccan3u_mosaicv;
MCNUM mccan3u_r0;
MCNUM mccan3u_Q;
MCNUM mccan3u_DM;

/* Setting parameters for component 'an4l' [98]. */
MCNUM mccan4l_zmin;
MCNUM mccan4l_zmax;
MCNUM mccan4l_ymin;
MCNUM mccan4l_ymax;
MCNUM mccan4l_zwidth;
MCNUM mccan4l_yheight;
MCNUM mccan4l_mosaich;
MCNUM mccan4l_mosaicv;
MCNUM mccan4l_r0;
MCNUM mccan4l_Q;
MCNUM mccan4l_DM;

/* Setting parameters for component 'an4u' [99]. */
MCNUM mccan4u_zmin;
MCNUM mccan4u_zmax;
MCNUM mccan4u_ymin;
MCNUM mccan4u_ymax;
MCNUM mccan4u_zwidth;
MCNUM mccan4u_yheight;
MCNUM mccan4u_mosaich;
MCNUM mccan4u_mosaicv;
MCNUM mccan4u_r0;
MCNUM mccan4u_Q;
MCNUM mccan4u_DM;

/* Setting parameters for component 'an5l' [100]. */
MCNUM mccan5l_zmin;
MCNUM mccan5l_zmax;
MCNUM mccan5l_ymin;
MCNUM mccan5l_ymax;
MCNUM mccan5l_zwidth;
MCNUM mccan5l_yheight;
MCNUM mccan5l_mosaich;
MCNUM mccan5l_mosaicv;
MCNUM mccan5l_r0;
MCNUM mccan5l_Q;
MCNUM mccan5l_DM;

/* Setting parameters for component 'an5u' [101]. */
MCNUM mccan5u_zmin;
MCNUM mccan5u_zmax;
MCNUM mccan5u_ymin;
MCNUM mccan5u_ymax;
MCNUM mccan5u_zwidth;
MCNUM mccan5u_yheight;
MCNUM mccan5u_mosaich;
MCNUM mccan5u_mosaicv;
MCNUM mccan5u_r0;
MCNUM mccan5u_Q;
MCNUM mccan5u_DM;

/* Setting parameters for component 'an6l' [102]. */
MCNUM mccan6l_zmin;
MCNUM mccan6l_zmax;
MCNUM mccan6l_ymin;
MCNUM mccan6l_ymax;
MCNUM mccan6l_zwidth;
MCNUM mccan6l_yheight;
MCNUM mccan6l_mosaich;
MCNUM mccan6l_mosaicv;
MCNUM mccan6l_r0;
MCNUM mccan6l_Q;
MCNUM mccan6l_DM;

/* Setting parameters for component 'an6u' [103]. */
MCNUM mccan6u_zmin;
MCNUM mccan6u_zmax;
MCNUM mccan6u_ymin;
MCNUM mccan6u_ymax;
MCNUM mccan6u_zwidth;
MCNUM mccan6u_yheight;
MCNUM mccan6u_mosaich;
MCNUM mccan6u_mosaicv;
MCNUM mccan6u_r0;
MCNUM mccan6u_Q;
MCNUM mccan6u_DM;

/* Setting parameters for component 'an7l' [104]. */
MCNUM mccan7l_zmin;
MCNUM mccan7l_zmax;
MCNUM mccan7l_ymin;
MCNUM mccan7l_ymax;
MCNUM mccan7l_zwidth;
MCNUM mccan7l_yheight;
MCNUM mccan7l_mosaich;
MCNUM mccan7l_mosaicv;
MCNUM mccan7l_r0;
MCNUM mccan7l_Q;
MCNUM mccan7l_DM;

/* Setting parameters for component 'an7u' [105]. */
MCNUM mccan7u_zmin;
MCNUM mccan7u_zmax;
MCNUM mccan7u_ymin;
MCNUM mccan7u_ymax;
MCNUM mccan7u_zwidth;
MCNUM mccan7u_yheight;
MCNUM mccan7u_mosaich;
MCNUM mccan7u_mosaicv;
MCNUM mccan7u_r0;
MCNUM mccan7u_Q;
MCNUM mccan7u_DM;

/* Setting parameters for component 'an8l' [106]. */
MCNUM mccan8l_zmin;
MCNUM mccan8l_zmax;
MCNUM mccan8l_ymin;
MCNUM mccan8l_ymax;
MCNUM mccan8l_zwidth;
MCNUM mccan8l_yheight;
MCNUM mccan8l_mosaich;
MCNUM mccan8l_mosaicv;
MCNUM mccan8l_r0;
MCNUM mccan8l_Q;
MCNUM mccan8l_DM;

/* Setting parameters for component 'an8u' [107]. */
MCNUM mccan8u_zmin;
MCNUM mccan8u_zmax;
MCNUM mccan8u_ymin;
MCNUM mccan8u_ymax;
MCNUM mccan8u_zwidth;
MCNUM mccan8u_yheight;
MCNUM mccan8u_mosaich;
MCNUM mccan8u_mosaicv;
MCNUM mccan8u_r0;
MCNUM mccan8u_Q;
MCNUM mccan8u_DM;

/* Setting parameters for component 'an9l' [108]. */
MCNUM mccan9l_zmin;
MCNUM mccan9l_zmax;
MCNUM mccan9l_ymin;
MCNUM mccan9l_ymax;
MCNUM mccan9l_zwidth;
MCNUM mccan9l_yheight;
MCNUM mccan9l_mosaich;
MCNUM mccan9l_mosaicv;
MCNUM mccan9l_r0;
MCNUM mccan9l_Q;
MCNUM mccan9l_DM;

/* Setting parameters for component 'an9u' [109]. */
MCNUM mccan9u_zmin;
MCNUM mccan9u_zmax;
MCNUM mccan9u_ymin;
MCNUM mccan9u_ymax;
MCNUM mccan9u_zwidth;
MCNUM mccan9u_yheight;
MCNUM mccan9u_mosaich;
MCNUM mccan9u_mosaicv;
MCNUM mccan9u_r0;
MCNUM mccan9u_Q;
MCNUM mccan9u_DM;

/* Definition parameters for component 'emon_before_coarse' [111]. */
#define mccemon_before_coarse_nE 100
/* Setting parameters for component 'emon_before_coarse' [111]. */
char mccemon_before_coarse_filename[16384];
MCNUM mccemon_before_coarse_xmin;
MCNUM mccemon_before_coarse_xmax;
MCNUM mccemon_before_coarse_ymin;
MCNUM mccemon_before_coarse_ymax;
MCNUM mccemon_before_coarse_xwidth;
MCNUM mccemon_before_coarse_yheight;
MCNUM mccemon_before_coarse_Emin;
MCNUM mccemon_before_coarse_Emax;
MCNUM mccemon_before_coarse_restore_neutron;
int mccemon_before_coarse_nowritefile;

/* Definition parameters for component 'psd_before_coarse' [112]. */
#define mccpsd_before_coarse_nx 128
#define mccpsd_before_coarse_ny 128
/* Setting parameters for component 'psd_before_coarse' [112]. */
char mccpsd_before_coarse_filename[16384];
MCNUM mccpsd_before_coarse_xmin;
MCNUM mccpsd_before_coarse_xmax;
MCNUM mccpsd_before_coarse_ymin;
MCNUM mccpsd_before_coarse_ymax;
MCNUM mccpsd_before_coarse_xwidth;
MCNUM mccpsd_before_coarse_yheight;
MCNUM mccpsd_before_coarse_restore_neutron;
int mccpsd_before_coarse_nowritefile;

/* Setting parameters for component 'BladeR1' [114]. */
MCNUM mccBladeR1_xmin;
MCNUM mccBladeR1_xmax;
MCNUM mccBladeR1_ymin;
MCNUM mccBladeR1_ymax;
MCNUM mccBladeR1_zmin;
MCNUM mccBladeR1_zmax;

/* Setting parameters for component 'BladeR2' [116]. */
MCNUM mccBladeR2_xmin;
MCNUM mccBladeR2_xmax;
MCNUM mccBladeR2_ymin;
MCNUM mccBladeR2_ymax;
MCNUM mccBladeR2_zmin;
MCNUM mccBladeR2_zmax;

/* Setting parameters for component 'BladeR3' [118]. */
MCNUM mccBladeR3_xmin;
MCNUM mccBladeR3_xmax;
MCNUM mccBladeR3_ymin;
MCNUM mccBladeR3_ymax;
MCNUM mccBladeR3_zmin;
MCNUM mccBladeR3_zmax;

/* Setting parameters for component 'BladeR4' [120]. */
MCNUM mccBladeR4_xmin;
MCNUM mccBladeR4_xmax;
MCNUM mccBladeR4_ymin;
MCNUM mccBladeR4_ymax;
MCNUM mccBladeR4_zmin;
MCNUM mccBladeR4_zmax;

/* Setting parameters for component 'BladeR5' [122]. */
MCNUM mccBladeR5_xmin;
MCNUM mccBladeR5_xmax;
MCNUM mccBladeR5_ymin;
MCNUM mccBladeR5_ymax;
MCNUM mccBladeR5_zmin;
MCNUM mccBladeR5_zmax;

/* Setting parameters for component 'BladeL1' [124]. */
MCNUM mccBladeL1_xmin;
MCNUM mccBladeL1_xmax;
MCNUM mccBladeL1_ymin;
MCNUM mccBladeL1_ymax;
MCNUM mccBladeL1_zmin;
MCNUM mccBladeL1_zmax;

/* Setting parameters for component 'BladeL2' [126]. */
MCNUM mccBladeL2_xmin;
MCNUM mccBladeL2_xmax;
MCNUM mccBladeL2_ymin;
MCNUM mccBladeL2_ymax;
MCNUM mccBladeL2_zmin;
MCNUM mccBladeL2_zmax;

/* Setting parameters for component 'BladeL3' [128]. */
MCNUM mccBladeL3_xmin;
MCNUM mccBladeL3_xmax;
MCNUM mccBladeL3_ymin;
MCNUM mccBladeL3_ymax;
MCNUM mccBladeL3_zmin;
MCNUM mccBladeL3_zmax;

/* Setting parameters for component 'BladeL4' [130]. */
MCNUM mccBladeL4_xmin;
MCNUM mccBladeL4_xmax;
MCNUM mccBladeL4_ymin;
MCNUM mccBladeL4_ymax;
MCNUM mccBladeL4_zmin;
MCNUM mccBladeL4_zmax;

/* Setting parameters for component 'BladeL5' [132]. */
MCNUM mccBladeL5_xmin;
MCNUM mccBladeL5_xmax;
MCNUM mccBladeL5_ymin;
MCNUM mccBladeL5_ymax;
MCNUM mccBladeL5_zmin;
MCNUM mccBladeL5_zmax;

/* Definition parameters for component 'psd_detector' [133]. */
#define mccpsd_detector_nx 128
#define mccpsd_detector_ny 128
#define mccpsd_detector_filename "psd_detector.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_detector' [133]. */
MCNUM mccpsd_detector_xmin;
MCNUM mccpsd_detector_xmax;
MCNUM mccpsd_detector_ymin;
MCNUM mccpsd_detector_ymax;
MCNUM mccpsd_detector_xwidth;
MCNUM mccpsd_detector_yheight;
MCNUM mccpsd_detector_psf;
MCNUM mccpsd_detector_k0;
MCNUM mccpsd_detector_eff;
MCNUM mccpsd_detector_restore_neutron;
int mccpsd_detector_nowritefile;

/* Definition parameters for component 'emon_detector' [134]. */
#define mccemon_detector_nE 100
/* Setting parameters for component 'emon_detector' [134]. */
char mccemon_detector_filename[16384];
MCNUM mccemon_detector_xmin;
MCNUM mccemon_detector_xmax;
MCNUM mccemon_detector_ymin;
MCNUM mccemon_detector_ymax;
MCNUM mccemon_detector_xwidth;
MCNUM mccemon_detector_yheight;
MCNUM mccemon_detector_Emin;
MCNUM mccemon_detector_Emax;
MCNUM mccemon_detector_restore_neutron;
int mccemon_detector_nowritefile;

/* Definition parameters for component 'psd_window1' [135]. */
#define mccpsd_window1_nx 128
#define mccpsd_window1_ny 128
#define mccpsd_window1_filename "psd_window1.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window1' [135]. */
MCNUM mccpsd_window1_xmin;
MCNUM mccpsd_window1_xmax;
MCNUM mccpsd_window1_ymin;
MCNUM mccpsd_window1_ymax;
MCNUM mccpsd_window1_xwidth;
MCNUM mccpsd_window1_yheight;
MCNUM mccpsd_window1_psf;
MCNUM mccpsd_window1_k0;
MCNUM mccpsd_window1_eff;
MCNUM mccpsd_window1_restore_neutron;
int mccpsd_window1_nowritefile;

/* Definition parameters for component 'emon_window1' [136]. */
#define mccemon_window1_nE 100
/* Setting parameters for component 'emon_window1' [136]. */
char mccemon_window1_filename[16384];
MCNUM mccemon_window1_xmin;
MCNUM mccemon_window1_xmax;
MCNUM mccemon_window1_ymin;
MCNUM mccemon_window1_ymax;
MCNUM mccemon_window1_xwidth;
MCNUM mccemon_window1_yheight;
MCNUM mccemon_window1_Emin;
MCNUM mccemon_window1_Emax;
MCNUM mccemon_window1_restore_neutron;
int mccemon_window1_nowritefile;

/* Definition parameters for component 'psd_window2' [137]. */
#define mccpsd_window2_nx 128
#define mccpsd_window2_ny 128
#define mccpsd_window2_filename "psd_window2.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window2' [137]. */
MCNUM mccpsd_window2_xmin;
MCNUM mccpsd_window2_xmax;
MCNUM mccpsd_window2_ymin;
MCNUM mccpsd_window2_ymax;
MCNUM mccpsd_window2_xwidth;
MCNUM mccpsd_window2_yheight;
MCNUM mccpsd_window2_psf;
MCNUM mccpsd_window2_k0;
MCNUM mccpsd_window2_eff;
MCNUM mccpsd_window2_restore_neutron;
int mccpsd_window2_nowritefile;

/* Definition parameters for component 'emon_window2' [138]. */
#define mccemon_window2_nE 100
/* Setting parameters for component 'emon_window2' [138]. */
char mccemon_window2_filename[16384];
MCNUM mccemon_window2_xmin;
MCNUM mccemon_window2_xmax;
MCNUM mccemon_window2_ymin;
MCNUM mccemon_window2_ymax;
MCNUM mccemon_window2_xwidth;
MCNUM mccemon_window2_yheight;
MCNUM mccemon_window2_Emin;
MCNUM mccemon_window2_Emax;
MCNUM mccemon_window2_restore_neutron;
int mccemon_window2_nowritefile;

/* Definition parameters for component 'psd_window3' [139]. */
#define mccpsd_window3_nx 128
#define mccpsd_window3_ny 128
#define mccpsd_window3_filename "psd_window3.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window3' [139]. */
MCNUM mccpsd_window3_xmin;
MCNUM mccpsd_window3_xmax;
MCNUM mccpsd_window3_ymin;
MCNUM mccpsd_window3_ymax;
MCNUM mccpsd_window3_xwidth;
MCNUM mccpsd_window3_yheight;
MCNUM mccpsd_window3_psf;
MCNUM mccpsd_window3_k0;
MCNUM mccpsd_window3_eff;
MCNUM mccpsd_window3_restore_neutron;
int mccpsd_window3_nowritefile;

/* Definition parameters for component 'emon_window3' [140]. */
#define mccemon_window3_nE 100
/* Setting parameters for component 'emon_window3' [140]. */
char mccemon_window3_filename[16384];
MCNUM mccemon_window3_xmin;
MCNUM mccemon_window3_xmax;
MCNUM mccemon_window3_ymin;
MCNUM mccemon_window3_ymax;
MCNUM mccemon_window3_xwidth;
MCNUM mccemon_window3_yheight;
MCNUM mccemon_window3_Emin;
MCNUM mccemon_window3_Emax;
MCNUM mccemon_window3_restore_neutron;
int mccemon_window3_nowritefile;

/* Definition parameters for component 'psd_window4' [141]. */
#define mccpsd_window4_nx 128
#define mccpsd_window4_ny 128
#define mccpsd_window4_filename "psd_window4.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window4' [141]. */
MCNUM mccpsd_window4_xmin;
MCNUM mccpsd_window4_xmax;
MCNUM mccpsd_window4_ymin;
MCNUM mccpsd_window4_ymax;
MCNUM mccpsd_window4_xwidth;
MCNUM mccpsd_window4_yheight;
MCNUM mccpsd_window4_psf;
MCNUM mccpsd_window4_k0;
MCNUM mccpsd_window4_eff;
MCNUM mccpsd_window4_restore_neutron;
int mccpsd_window4_nowritefile;

/* Definition parameters for component 'emon_window4' [142]. */
#define mccemon_window4_nE 100
/* Setting parameters for component 'emon_window4' [142]. */
char mccemon_window4_filename[16384];
MCNUM mccemon_window4_xmin;
MCNUM mccemon_window4_xmax;
MCNUM mccemon_window4_ymin;
MCNUM mccemon_window4_ymax;
MCNUM mccemon_window4_xwidth;
MCNUM mccemon_window4_yheight;
MCNUM mccemon_window4_Emin;
MCNUM mccemon_window4_Emax;
MCNUM mccemon_window4_restore_neutron;
int mccemon_window4_nowritefile;

/* Definition parameters for component 'psd_window5' [143]. */
#define mccpsd_window5_nx 128
#define mccpsd_window5_ny 128
#define mccpsd_window5_filename "psd_window5.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window5' [143]. */
MCNUM mccpsd_window5_xmin;
MCNUM mccpsd_window5_xmax;
MCNUM mccpsd_window5_ymin;
MCNUM mccpsd_window5_ymax;
MCNUM mccpsd_window5_xwidth;
MCNUM mccpsd_window5_yheight;
MCNUM mccpsd_window5_psf;
MCNUM mccpsd_window5_k0;
MCNUM mccpsd_window5_eff;
MCNUM mccpsd_window5_restore_neutron;
int mccpsd_window5_nowritefile;

/* Definition parameters for component 'emon_window5' [144]. */
#define mccemon_window5_nE 100
/* Setting parameters for component 'emon_window5' [144]. */
char mccemon_window5_filename[16384];
MCNUM mccemon_window5_xmin;
MCNUM mccemon_window5_xmax;
MCNUM mccemon_window5_ymin;
MCNUM mccemon_window5_ymax;
MCNUM mccemon_window5_xwidth;
MCNUM mccemon_window5_yheight;
MCNUM mccemon_window5_Emin;
MCNUM mccemon_window5_Emax;
MCNUM mccemon_window5_restore_neutron;
int mccemon_window5_nowritefile;

/* Definition parameters for component 'psd_window6' [145]. */
#define mccpsd_window6_nx 128
#define mccpsd_window6_ny 128
#define mccpsd_window6_filename "psd_window6.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window6' [145]. */
MCNUM mccpsd_window6_xmin;
MCNUM mccpsd_window6_xmax;
MCNUM mccpsd_window6_ymin;
MCNUM mccpsd_window6_ymax;
MCNUM mccpsd_window6_xwidth;
MCNUM mccpsd_window6_yheight;
MCNUM mccpsd_window6_psf;
MCNUM mccpsd_window6_k0;
MCNUM mccpsd_window6_eff;
MCNUM mccpsd_window6_restore_neutron;
int mccpsd_window6_nowritefile;

/* Definition parameters for component 'emon_window6' [146]. */
#define mccemon_window6_nE 100
/* Setting parameters for component 'emon_window6' [146]. */
char mccemon_window6_filename[16384];
MCNUM mccemon_window6_xmin;
MCNUM mccemon_window6_xmax;
MCNUM mccemon_window6_ymin;
MCNUM mccemon_window6_ymax;
MCNUM mccemon_window6_xwidth;
MCNUM mccemon_window6_yheight;
MCNUM mccemon_window6_Emin;
MCNUM mccemon_window6_Emax;
MCNUM mccemon_window6_restore_neutron;
int mccemon_window6_nowritefile;

/* Definition parameters for component 'psd_window7' [147]. */
#define mccpsd_window7_nx 128
#define mccpsd_window7_ny 128
#define mccpsd_window7_filename "psd_window7.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window7' [147]. */
MCNUM mccpsd_window7_xmin;
MCNUM mccpsd_window7_xmax;
MCNUM mccpsd_window7_ymin;
MCNUM mccpsd_window7_ymax;
MCNUM mccpsd_window7_xwidth;
MCNUM mccpsd_window7_yheight;
MCNUM mccpsd_window7_psf;
MCNUM mccpsd_window7_k0;
MCNUM mccpsd_window7_eff;
MCNUM mccpsd_window7_restore_neutron;
int mccpsd_window7_nowritefile;

/* Definition parameters for component 'emon_window7' [148]. */
#define mccemon_window7_nE 100
/* Setting parameters for component 'emon_window7' [148]. */
char mccemon_window7_filename[16384];
MCNUM mccemon_window7_xmin;
MCNUM mccemon_window7_xmax;
MCNUM mccemon_window7_ymin;
MCNUM mccemon_window7_ymax;
MCNUM mccemon_window7_xwidth;
MCNUM mccemon_window7_yheight;
MCNUM mccemon_window7_Emin;
MCNUM mccemon_window7_Emax;
MCNUM mccemon_window7_restore_neutron;
int mccemon_window7_nowritefile;

/* Definition parameters for component 'psd_window8' [149]. */
#define mccpsd_window8_nx 128
#define mccpsd_window8_ny 128
#define mccpsd_window8_filename "psd_window8.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window8' [149]. */
MCNUM mccpsd_window8_xmin;
MCNUM mccpsd_window8_xmax;
MCNUM mccpsd_window8_ymin;
MCNUM mccpsd_window8_ymax;
MCNUM mccpsd_window8_xwidth;
MCNUM mccpsd_window8_yheight;
MCNUM mccpsd_window8_psf;
MCNUM mccpsd_window8_k0;
MCNUM mccpsd_window8_eff;
MCNUM mccpsd_window8_restore_neutron;
int mccpsd_window8_nowritefile;

/* Definition parameters for component 'emon_window8' [150]. */
#define mccemon_window8_nE 100
/* Setting parameters for component 'emon_window8' [150]. */
char mccemon_window8_filename[16384];
MCNUM mccemon_window8_xmin;
MCNUM mccemon_window8_xmax;
MCNUM mccemon_window8_ymin;
MCNUM mccemon_window8_ymax;
MCNUM mccemon_window8_xwidth;
MCNUM mccemon_window8_yheight;
MCNUM mccemon_window8_Emin;
MCNUM mccemon_window8_Emax;
MCNUM mccemon_window8_restore_neutron;
int mccemon_window8_nowritefile;

/* Definition parameters for component 'psd_window9' [151]. */
#define mccpsd_window9_nx 128
#define mccpsd_window9_ny 128
#define mccpsd_window9_filename "psd_window9.dat" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'psd_window9' [151]. */
MCNUM mccpsd_window9_xmin;
MCNUM mccpsd_window9_xmax;
MCNUM mccpsd_window9_ymin;
MCNUM mccpsd_window9_ymax;
MCNUM mccpsd_window9_xwidth;
MCNUM mccpsd_window9_yheight;
MCNUM mccpsd_window9_psf;
MCNUM mccpsd_window9_k0;
MCNUM mccpsd_window9_eff;
MCNUM mccpsd_window9_restore_neutron;
int mccpsd_window9_nowritefile;

/* Definition parameters for component 'emon_window9' [152]. */
#define mccemon_window9_nE 128
/* Setting parameters for component 'emon_window9' [152]. */
char mccemon_window9_filename[16384];
MCNUM mccemon_window9_xmin;
MCNUM mccemon_window9_xmax;
MCNUM mccemon_window9_ymin;
MCNUM mccemon_window9_ymax;
MCNUM mccemon_window9_xwidth;
MCNUM mccemon_window9_yheight;
MCNUM mccemon_window9_Emin;
MCNUM mccemon_window9_Emax;
MCNUM mccemon_window9_restore_neutron;
int mccemon_window9_nowritefile;

/* User component declarations. */

/* User declarations for component 'armSource' [1]. */
#define mccompcurname  armSource
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccarmSource_IntermediateCnts
#define StartTime mccarmSource_StartTime
#define EndTime mccarmSource_EndTime
#define CurrentTime mccarmSource_CurrentTime
#define profile mccarmSource_profile
#define percent mccarmSource_percent
#define flag_save mccarmSource_flag_save
#define minutes mccarmSource_minutes
#line 44 "/usr/share/mcstas/2.5/misc/Progress_bar.comp"
#ifndef PROGRESS_BAR
#define PROGRESS_BAR
#else
#error Only one Progress_bar component may be used in an instrument definition.
#endif

double IntermediateCnts;
time_t StartTime;
time_t EndTime;
time_t CurrentTime;
#line 13810 "RITA-II.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'source' [2]. */
#define mccompcurname  source
#define mccompcurtype  Source_gen4
#define mccompcurindex 2
#define flux_file mccsource_flux_file
#define xdiv_file mccsource_xdiv_file
#define ydiv_file mccsource_ydiv_file
#define p_in mccsource_p_in
#define lambda0 mccsource_lambda0
#define lambda02 mccsource_lambda02
#define L2P mccsource_L2P
#define lambda0b mccsource_lambda0b
#define lambda02b mccsource_lambda02b
#define L2Pb mccsource_L2Pb
#define lambda0c mccsource_lambda0c
#define lambda02c mccsource_lambda02c
#define L2Pc mccsource_L2Pc
#define pTable mccsource_pTable
#define pTable_x mccsource_pTable_x
#define pTable_y mccsource_pTable_y
#define radius mccsource_radius
#define dist mccsource_dist
#define xw mccsource_xw
#define yh mccsource_yh
#define E0 mccsource_E0
#define dE mccsource_dE
#define Lambda0 mccsource_Lambda0
#define dLambda mccsource_dLambda
#define I1 mccsource_I1
#define h mccsource_h
#define w mccsource_w
#define gaussian mccsource_gaussian
#define verbose mccsource_verbose
#define T1 mccsource_T1
#define flux_file_perAA mccsource_flux_file_perAA
#define flux_file_log mccsource_flux_file_log
#define Lmin mccsource_Lmin
#define Lmax mccsource_Lmax
#define Emin mccsource_Emin
#define Emax mccsource_Emax
#define T2 mccsource_T2
#define I2 mccsource_I2
#define T3 mccsource_T3
#define I3 mccsource_I3
#define length mccsource_length
#define phi_init mccsource_phi_init
#define theta_init mccsource_theta_init
#define HEtailA mccsource_HEtailA
#define HEtailL0 mccsource_HEtailL0
#line 187 "/usr/share/mcstas/2.5/contrib/Source_gen4.comp"
  double p_in;
  double Lambda0;
  double lambda0, lambda02, L2P;     /* first Maxwellian source */
  double lambda0b, lambda02b, L2Pb;  /* second Maxwellian source */
  double lambda0c, lambda02c, L2Pc;  /* third Maxwellian source */
  t_Table pTable;
  t_Table pTable_x;
  t_Table pTable_y;
  double  pTable_xmin;
  double  pTable_xmax;
  double  pTable_xsum=0;
  double  pTable_ymin;
  double  pTable_ymax;
  double  pTable_ysum=0;
  double  pTable_dxmin;
  double  pTable_dxmax;
  double  pTable_dymin;
  double  pTable_dymax;
#line 13891 "RITA-II.c"
#undef HEtailL0
#undef HEtailA
#undef theta_init
#undef phi_init
#undef length
#undef I3
#undef T3
#undef I2
#undef T2
#undef Emax
#undef Emin
#undef Lmax
#undef Lmin
#undef flux_file_log
#undef flux_file_perAA
#undef T1
#undef verbose
#undef gaussian
#undef w
#undef h
#undef I1
#undef dLambda
#undef Lambda0
#undef dE
#undef E0
#undef yh
#undef xw
#undef dist
#undef radius
#undef pTable_y
#undef pTable_x
#undef pTable
#undef L2Pc
#undef lambda02c
#undef lambda0c
#undef L2Pb
#undef lambda02b
#undef lambda0b
#undef L2P
#undef lambda02
#undef lambda0
#undef p_in
#undef ydiv_file
#undef xdiv_file
#undef flux_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'slitGuideBegin' [3]. */
#define mccompcurname  slitGuideBegin
#define mccompcurtype  Slit
#define mccompcurindex 3
#define xmin mccslitGuideBegin_xmin
#define xmax mccslitGuideBegin_xmax
#define ymin mccslitGuideBegin_ymin
#define ymax mccslitGuideBegin_ymax
#define radius mccslitGuideBegin_radius
#define xwidth mccslitGuideBegin_xwidth
#define yheight mccslitGuideBegin_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'lmon_guide_start' [4]. */
#define mccompcurname  lmon_guide_start
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mcclmon_guide_start_nL
#define L_N mcclmon_guide_start_L_N
#define L_p mcclmon_guide_start_L_p
#define L_p2 mcclmon_guide_start_L_p2
#define filename mcclmon_guide_start_filename
#define xmin mcclmon_guide_start_xmin
#define xmax mcclmon_guide_start_xmax
#define ymin mcclmon_guide_start_ymin
#define ymax mcclmon_guide_start_ymax
#define xwidth mcclmon_guide_start_xwidth
#define yheight mcclmon_guide_start_yheight
#define Lmin mcclmon_guide_start_Lmin
#define Lmax mcclmon_guide_start_Lmax
#define restore_neutron mcclmon_guide_start_restore_neutron
#define nowritefile mcclmon_guide_start_nowritefile
#line 57 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 13985 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideStraight' [5]. */
#define mccompcurname  guideStraight
#define mccompcurtype  Guide
#define mccompcurindex 5
#define pTable mccguideStraight_pTable
#define reflect mccguideStraight_reflect
#define w1 mccguideStraight_w1
#define h1 mccguideStraight_h1
#define w2 mccguideStraight_w2
#define h2 mccguideStraight_h2
#define l mccguideStraight_l
#define R0 mccguideStraight_R0
#define Qc mccguideStraight_Qc
#define alpha mccguideStraight_alpha
#define m mccguideStraight_m
#define W mccguideStraight_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14023 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved1' [6]. */
#define mccompcurname  guideCurved1
#define mccompcurtype  Guide
#define mccompcurindex 6
#define pTable mccguideCurved1_pTable
#define reflect mccguideCurved1_reflect
#define w1 mccguideCurved1_w1
#define h1 mccguideCurved1_h1
#define w2 mccguideCurved1_w2
#define h2 mccguideCurved1_h2
#define l mccguideCurved1_l
#define R0 mccguideCurved1_R0
#define Qc mccguideCurved1_Qc
#define alpha mccguideCurved1_alpha
#define m mccguideCurved1_m
#define W mccguideCurved1_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14058 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved2' [7]. */
#define mccompcurname  guideCurved2
#define mccompcurtype  Guide
#define mccompcurindex 7
#define pTable mccguideCurved2_pTable
#define reflect mccguideCurved2_reflect
#define w1 mccguideCurved2_w1
#define h1 mccguideCurved2_h1
#define w2 mccguideCurved2_w2
#define h2 mccguideCurved2_h2
#define l mccguideCurved2_l
#define R0 mccguideCurved2_R0
#define Qc mccguideCurved2_Qc
#define alpha mccguideCurved2_alpha
#define m mccguideCurved2_m
#define W mccguideCurved2_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14093 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved3' [8]. */
#define mccompcurname  guideCurved3
#define mccompcurtype  Guide
#define mccompcurindex 8
#define pTable mccguideCurved3_pTable
#define reflect mccguideCurved3_reflect
#define w1 mccguideCurved3_w1
#define h1 mccguideCurved3_h1
#define w2 mccguideCurved3_w2
#define h2 mccguideCurved3_h2
#define l mccguideCurved3_l
#define R0 mccguideCurved3_R0
#define Qc mccguideCurved3_Qc
#define alpha mccguideCurved3_alpha
#define m mccguideCurved3_m
#define W mccguideCurved3_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14128 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved4' [9]. */
#define mccompcurname  guideCurved4
#define mccompcurtype  Guide
#define mccompcurindex 9
#define pTable mccguideCurved4_pTable
#define reflect mccguideCurved4_reflect
#define w1 mccguideCurved4_w1
#define h1 mccguideCurved4_h1
#define w2 mccguideCurved4_w2
#define h2 mccguideCurved4_h2
#define l mccguideCurved4_l
#define R0 mccguideCurved4_R0
#define Qc mccguideCurved4_Qc
#define alpha mccguideCurved4_alpha
#define m mccguideCurved4_m
#define W mccguideCurved4_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14163 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved5' [10]. */
#define mccompcurname  guideCurved5
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccguideCurved5_pTable
#define reflect mccguideCurved5_reflect
#define w1 mccguideCurved5_w1
#define h1 mccguideCurved5_h1
#define w2 mccguideCurved5_w2
#define h2 mccguideCurved5_h2
#define l mccguideCurved5_l
#define R0 mccguideCurved5_R0
#define Qc mccguideCurved5_Qc
#define alpha mccguideCurved5_alpha
#define m mccguideCurved5_m
#define W mccguideCurved5_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14198 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved6' [11]. */
#define mccompcurname  guideCurved6
#define mccompcurtype  Guide
#define mccompcurindex 11
#define pTable mccguideCurved6_pTable
#define reflect mccguideCurved6_reflect
#define w1 mccguideCurved6_w1
#define h1 mccguideCurved6_h1
#define w2 mccguideCurved6_w2
#define h2 mccguideCurved6_h2
#define l mccguideCurved6_l
#define R0 mccguideCurved6_R0
#define Qc mccguideCurved6_Qc
#define alpha mccguideCurved6_alpha
#define m mccguideCurved6_m
#define W mccguideCurved6_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14233 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved7' [12]. */
#define mccompcurname  guideCurved7
#define mccompcurtype  Guide
#define mccompcurindex 12
#define pTable mccguideCurved7_pTable
#define reflect mccguideCurved7_reflect
#define w1 mccguideCurved7_w1
#define h1 mccguideCurved7_h1
#define w2 mccguideCurved7_w2
#define h2 mccguideCurved7_h2
#define l mccguideCurved7_l
#define R0 mccguideCurved7_R0
#define Qc mccguideCurved7_Qc
#define alpha mccguideCurved7_alpha
#define m mccguideCurved7_m
#define W mccguideCurved7_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14268 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved8' [13]. */
#define mccompcurname  guideCurved8
#define mccompcurtype  Guide
#define mccompcurindex 13
#define pTable mccguideCurved8_pTable
#define reflect mccguideCurved8_reflect
#define w1 mccguideCurved8_w1
#define h1 mccguideCurved8_h1
#define w2 mccguideCurved8_w2
#define h2 mccguideCurved8_h2
#define l mccguideCurved8_l
#define R0 mccguideCurved8_R0
#define Qc mccguideCurved8_Qc
#define alpha mccguideCurved8_alpha
#define m mccguideCurved8_m
#define W mccguideCurved8_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14303 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved9' [14]. */
#define mccompcurname  guideCurved9
#define mccompcurtype  Guide
#define mccompcurindex 14
#define pTable mccguideCurved9_pTable
#define reflect mccguideCurved9_reflect
#define w1 mccguideCurved9_w1
#define h1 mccguideCurved9_h1
#define w2 mccguideCurved9_w2
#define h2 mccguideCurved9_h2
#define l mccguideCurved9_l
#define R0 mccguideCurved9_R0
#define Qc mccguideCurved9_Qc
#define alpha mccguideCurved9_alpha
#define m mccguideCurved9_m
#define W mccguideCurved9_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14338 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved10' [15]. */
#define mccompcurname  guideCurved10
#define mccompcurtype  Guide
#define mccompcurindex 15
#define pTable mccguideCurved10_pTable
#define reflect mccguideCurved10_reflect
#define w1 mccguideCurved10_w1
#define h1 mccguideCurved10_h1
#define w2 mccguideCurved10_w2
#define h2 mccguideCurved10_h2
#define l mccguideCurved10_l
#define R0 mccguideCurved10_R0
#define Qc mccguideCurved10_Qc
#define alpha mccguideCurved10_alpha
#define m mccguideCurved10_m
#define W mccguideCurved10_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14373 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved11' [16]. */
#define mccompcurname  guideCurved11
#define mccompcurtype  Guide
#define mccompcurindex 16
#define pTable mccguideCurved11_pTable
#define reflect mccguideCurved11_reflect
#define w1 mccguideCurved11_w1
#define h1 mccguideCurved11_h1
#define w2 mccguideCurved11_w2
#define h2 mccguideCurved11_h2
#define l mccguideCurved11_l
#define R0 mccguideCurved11_R0
#define Qc mccguideCurved11_Qc
#define alpha mccguideCurved11_alpha
#define m mccguideCurved11_m
#define W mccguideCurved11_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14408 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved12' [17]. */
#define mccompcurname  guideCurved12
#define mccompcurtype  Guide
#define mccompcurindex 17
#define pTable mccguideCurved12_pTable
#define reflect mccguideCurved12_reflect
#define w1 mccguideCurved12_w1
#define h1 mccguideCurved12_h1
#define w2 mccguideCurved12_w2
#define h2 mccguideCurved12_h2
#define l mccguideCurved12_l
#define R0 mccguideCurved12_R0
#define Qc mccguideCurved12_Qc
#define alpha mccguideCurved12_alpha
#define m mccguideCurved12_m
#define W mccguideCurved12_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14443 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved13' [18]. */
#define mccompcurname  guideCurved13
#define mccompcurtype  Guide
#define mccompcurindex 18
#define pTable mccguideCurved13_pTable
#define reflect mccguideCurved13_reflect
#define w1 mccguideCurved13_w1
#define h1 mccguideCurved13_h1
#define w2 mccguideCurved13_w2
#define h2 mccguideCurved13_h2
#define l mccguideCurved13_l
#define R0 mccguideCurved13_R0
#define Qc mccguideCurved13_Qc
#define alpha mccguideCurved13_alpha
#define m mccguideCurved13_m
#define W mccguideCurved13_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14478 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved14' [19]. */
#define mccompcurname  guideCurved14
#define mccompcurtype  Guide
#define mccompcurindex 19
#define pTable mccguideCurved14_pTable
#define reflect mccguideCurved14_reflect
#define w1 mccguideCurved14_w1
#define h1 mccguideCurved14_h1
#define w2 mccguideCurved14_w2
#define h2 mccguideCurved14_h2
#define l mccguideCurved14_l
#define R0 mccguideCurved14_R0
#define Qc mccguideCurved14_Qc
#define alpha mccguideCurved14_alpha
#define m mccguideCurved14_m
#define W mccguideCurved14_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14513 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved15' [20]. */
#define mccompcurname  guideCurved15
#define mccompcurtype  Guide
#define mccompcurindex 20
#define pTable mccguideCurved15_pTable
#define reflect mccguideCurved15_reflect
#define w1 mccguideCurved15_w1
#define h1 mccguideCurved15_h1
#define w2 mccguideCurved15_w2
#define h2 mccguideCurved15_h2
#define l mccguideCurved15_l
#define R0 mccguideCurved15_R0
#define Qc mccguideCurved15_Qc
#define alpha mccguideCurved15_alpha
#define m mccguideCurved15_m
#define W mccguideCurved15_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14548 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved16' [21]. */
#define mccompcurname  guideCurved16
#define mccompcurtype  Guide
#define mccompcurindex 21
#define pTable mccguideCurved16_pTable
#define reflect mccguideCurved16_reflect
#define w1 mccguideCurved16_w1
#define h1 mccguideCurved16_h1
#define w2 mccguideCurved16_w2
#define h2 mccguideCurved16_h2
#define l mccguideCurved16_l
#define R0 mccguideCurved16_R0
#define Qc mccguideCurved16_Qc
#define alpha mccguideCurved16_alpha
#define m mccguideCurved16_m
#define W mccguideCurved16_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14583 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved17' [22]. */
#define mccompcurname  guideCurved17
#define mccompcurtype  Guide
#define mccompcurindex 22
#define pTable mccguideCurved17_pTable
#define reflect mccguideCurved17_reflect
#define w1 mccguideCurved17_w1
#define h1 mccguideCurved17_h1
#define w2 mccguideCurved17_w2
#define h2 mccguideCurved17_h2
#define l mccguideCurved17_l
#define R0 mccguideCurved17_R0
#define Qc mccguideCurved17_Qc
#define alpha mccguideCurved17_alpha
#define m mccguideCurved17_m
#define W mccguideCurved17_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14618 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved18' [23]. */
#define mccompcurname  guideCurved18
#define mccompcurtype  Guide
#define mccompcurindex 23
#define pTable mccguideCurved18_pTable
#define reflect mccguideCurved18_reflect
#define w1 mccguideCurved18_w1
#define h1 mccguideCurved18_h1
#define w2 mccguideCurved18_w2
#define h2 mccguideCurved18_h2
#define l mccguideCurved18_l
#define R0 mccguideCurved18_R0
#define Qc mccguideCurved18_Qc
#define alpha mccguideCurved18_alpha
#define m mccguideCurved18_m
#define W mccguideCurved18_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14653 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved19' [24]. */
#define mccompcurname  guideCurved19
#define mccompcurtype  Guide
#define mccompcurindex 24
#define pTable mccguideCurved19_pTable
#define reflect mccguideCurved19_reflect
#define w1 mccguideCurved19_w1
#define h1 mccguideCurved19_h1
#define w2 mccguideCurved19_w2
#define h2 mccguideCurved19_h2
#define l mccguideCurved19_l
#define R0 mccguideCurved19_R0
#define Qc mccguideCurved19_Qc
#define alpha mccguideCurved19_alpha
#define m mccguideCurved19_m
#define W mccguideCurved19_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14688 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved20' [25]. */
#define mccompcurname  guideCurved20
#define mccompcurtype  Guide
#define mccompcurindex 25
#define pTable mccguideCurved20_pTable
#define reflect mccguideCurved20_reflect
#define w1 mccguideCurved20_w1
#define h1 mccguideCurved20_h1
#define w2 mccguideCurved20_w2
#define h2 mccguideCurved20_h2
#define l mccguideCurved20_l
#define R0 mccguideCurved20_R0
#define Qc mccguideCurved20_Qc
#define alpha mccguideCurved20_alpha
#define m mccguideCurved20_m
#define W mccguideCurved20_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14723 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved21' [26]. */
#define mccompcurname  guideCurved21
#define mccompcurtype  Guide
#define mccompcurindex 26
#define pTable mccguideCurved21_pTable
#define reflect mccguideCurved21_reflect
#define w1 mccguideCurved21_w1
#define h1 mccguideCurved21_h1
#define w2 mccguideCurved21_w2
#define h2 mccguideCurved21_h2
#define l mccguideCurved21_l
#define R0 mccguideCurved21_R0
#define Qc mccguideCurved21_Qc
#define alpha mccguideCurved21_alpha
#define m mccguideCurved21_m
#define W mccguideCurved21_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14758 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved22' [27]. */
#define mccompcurname  guideCurved22
#define mccompcurtype  Guide
#define mccompcurindex 27
#define pTable mccguideCurved22_pTable
#define reflect mccguideCurved22_reflect
#define w1 mccguideCurved22_w1
#define h1 mccguideCurved22_h1
#define w2 mccguideCurved22_w2
#define h2 mccguideCurved22_h2
#define l mccguideCurved22_l
#define R0 mccguideCurved22_R0
#define Qc mccguideCurved22_Qc
#define alpha mccguideCurved22_alpha
#define m mccguideCurved22_m
#define W mccguideCurved22_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14793 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved23' [28]. */
#define mccompcurname  guideCurved23
#define mccompcurtype  Guide
#define mccompcurindex 28
#define pTable mccguideCurved23_pTable
#define reflect mccguideCurved23_reflect
#define w1 mccguideCurved23_w1
#define h1 mccguideCurved23_h1
#define w2 mccguideCurved23_w2
#define h2 mccguideCurved23_h2
#define l mccguideCurved23_l
#define R0 mccguideCurved23_R0
#define Qc mccguideCurved23_Qc
#define alpha mccguideCurved23_alpha
#define m mccguideCurved23_m
#define W mccguideCurved23_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14828 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved24' [29]. */
#define mccompcurname  guideCurved24
#define mccompcurtype  Guide
#define mccompcurindex 29
#define pTable mccguideCurved24_pTable
#define reflect mccguideCurved24_reflect
#define w1 mccguideCurved24_w1
#define h1 mccguideCurved24_h1
#define w2 mccguideCurved24_w2
#define h2 mccguideCurved24_h2
#define l mccguideCurved24_l
#define R0 mccguideCurved24_R0
#define Qc mccguideCurved24_Qc
#define alpha mccguideCurved24_alpha
#define m mccguideCurved24_m
#define W mccguideCurved24_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14863 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved25' [30]. */
#define mccompcurname  guideCurved25
#define mccompcurtype  Guide
#define mccompcurindex 30
#define pTable mccguideCurved25_pTable
#define reflect mccguideCurved25_reflect
#define w1 mccguideCurved25_w1
#define h1 mccguideCurved25_h1
#define w2 mccguideCurved25_w2
#define h2 mccguideCurved25_h2
#define l mccguideCurved25_l
#define R0 mccguideCurved25_R0
#define Qc mccguideCurved25_Qc
#define alpha mccguideCurved25_alpha
#define m mccguideCurved25_m
#define W mccguideCurved25_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14898 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved26' [31]. */
#define mccompcurname  guideCurved26
#define mccompcurtype  Guide
#define mccompcurindex 31
#define pTable mccguideCurved26_pTable
#define reflect mccguideCurved26_reflect
#define w1 mccguideCurved26_w1
#define h1 mccguideCurved26_h1
#define w2 mccguideCurved26_w2
#define h2 mccguideCurved26_h2
#define l mccguideCurved26_l
#define R0 mccguideCurved26_R0
#define Qc mccguideCurved26_Qc
#define alpha mccguideCurved26_alpha
#define m mccguideCurved26_m
#define W mccguideCurved26_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14933 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved27' [32]. */
#define mccompcurname  guideCurved27
#define mccompcurtype  Guide
#define mccompcurindex 32
#define pTable mccguideCurved27_pTable
#define reflect mccguideCurved27_reflect
#define w1 mccguideCurved27_w1
#define h1 mccguideCurved27_h1
#define w2 mccguideCurved27_w2
#define h2 mccguideCurved27_h2
#define l mccguideCurved27_l
#define R0 mccguideCurved27_R0
#define Qc mccguideCurved27_Qc
#define alpha mccguideCurved27_alpha
#define m mccguideCurved27_m
#define W mccguideCurved27_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 14968 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved28' [33]. */
#define mccompcurname  guideCurved28
#define mccompcurtype  Guide
#define mccompcurindex 33
#define pTable mccguideCurved28_pTable
#define reflect mccguideCurved28_reflect
#define w1 mccguideCurved28_w1
#define h1 mccguideCurved28_h1
#define w2 mccguideCurved28_w2
#define h2 mccguideCurved28_h2
#define l mccguideCurved28_l
#define R0 mccguideCurved28_R0
#define Qc mccguideCurved28_Qc
#define alpha mccguideCurved28_alpha
#define m mccguideCurved28_m
#define W mccguideCurved28_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15003 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved29' [34]. */
#define mccompcurname  guideCurved29
#define mccompcurtype  Guide
#define mccompcurindex 34
#define pTable mccguideCurved29_pTable
#define reflect mccguideCurved29_reflect
#define w1 mccguideCurved29_w1
#define h1 mccguideCurved29_h1
#define w2 mccguideCurved29_w2
#define h2 mccguideCurved29_h2
#define l mccguideCurved29_l
#define R0 mccguideCurved29_R0
#define Qc mccguideCurved29_Qc
#define alpha mccguideCurved29_alpha
#define m mccguideCurved29_m
#define W mccguideCurved29_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15038 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved30' [35]. */
#define mccompcurname  guideCurved30
#define mccompcurtype  Guide
#define mccompcurindex 35
#define pTable mccguideCurved30_pTable
#define reflect mccguideCurved30_reflect
#define w1 mccguideCurved30_w1
#define h1 mccguideCurved30_h1
#define w2 mccguideCurved30_w2
#define h2 mccguideCurved30_h2
#define l mccguideCurved30_l
#define R0 mccguideCurved30_R0
#define Qc mccguideCurved30_Qc
#define alpha mccguideCurved30_alpha
#define m mccguideCurved30_m
#define W mccguideCurved30_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15073 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved31' [36]. */
#define mccompcurname  guideCurved31
#define mccompcurtype  Guide
#define mccompcurindex 36
#define pTable mccguideCurved31_pTable
#define reflect mccguideCurved31_reflect
#define w1 mccguideCurved31_w1
#define h1 mccguideCurved31_h1
#define w2 mccguideCurved31_w2
#define h2 mccguideCurved31_h2
#define l mccguideCurved31_l
#define R0 mccguideCurved31_R0
#define Qc mccguideCurved31_Qc
#define alpha mccguideCurved31_alpha
#define m mccguideCurved31_m
#define W mccguideCurved31_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15108 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved32' [37]. */
#define mccompcurname  guideCurved32
#define mccompcurtype  Guide
#define mccompcurindex 37
#define pTable mccguideCurved32_pTable
#define reflect mccguideCurved32_reflect
#define w1 mccguideCurved32_w1
#define h1 mccguideCurved32_h1
#define w2 mccguideCurved32_w2
#define h2 mccguideCurved32_h2
#define l mccguideCurved32_l
#define R0 mccguideCurved32_R0
#define Qc mccguideCurved32_Qc
#define alpha mccguideCurved32_alpha
#define m mccguideCurved32_m
#define W mccguideCurved32_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15143 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved33' [38]. */
#define mccompcurname  guideCurved33
#define mccompcurtype  Guide
#define mccompcurindex 38
#define pTable mccguideCurved33_pTable
#define reflect mccguideCurved33_reflect
#define w1 mccguideCurved33_w1
#define h1 mccguideCurved33_h1
#define w2 mccguideCurved33_w2
#define h2 mccguideCurved33_h2
#define l mccguideCurved33_l
#define R0 mccguideCurved33_R0
#define Qc mccguideCurved33_Qc
#define alpha mccguideCurved33_alpha
#define m mccguideCurved33_m
#define W mccguideCurved33_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15178 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved34' [39]. */
#define mccompcurname  guideCurved34
#define mccompcurtype  Guide
#define mccompcurindex 39
#define pTable mccguideCurved34_pTable
#define reflect mccguideCurved34_reflect
#define w1 mccguideCurved34_w1
#define h1 mccguideCurved34_h1
#define w2 mccguideCurved34_w2
#define h2 mccguideCurved34_h2
#define l mccguideCurved34_l
#define R0 mccguideCurved34_R0
#define Qc mccguideCurved34_Qc
#define alpha mccguideCurved34_alpha
#define m mccguideCurved34_m
#define W mccguideCurved34_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15213 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved35' [40]. */
#define mccompcurname  guideCurved35
#define mccompcurtype  Guide
#define mccompcurindex 40
#define pTable mccguideCurved35_pTable
#define reflect mccguideCurved35_reflect
#define w1 mccguideCurved35_w1
#define h1 mccguideCurved35_h1
#define w2 mccguideCurved35_w2
#define h2 mccguideCurved35_h2
#define l mccguideCurved35_l
#define R0 mccguideCurved35_R0
#define Qc mccguideCurved35_Qc
#define alpha mccguideCurved35_alpha
#define m mccguideCurved35_m
#define W mccguideCurved35_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15248 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved36' [41]. */
#define mccompcurname  guideCurved36
#define mccompcurtype  Guide
#define mccompcurindex 41
#define pTable mccguideCurved36_pTable
#define reflect mccguideCurved36_reflect
#define w1 mccguideCurved36_w1
#define h1 mccguideCurved36_h1
#define w2 mccguideCurved36_w2
#define h2 mccguideCurved36_h2
#define l mccguideCurved36_l
#define R0 mccguideCurved36_R0
#define Qc mccguideCurved36_Qc
#define alpha mccguideCurved36_alpha
#define m mccguideCurved36_m
#define W mccguideCurved36_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15283 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved37' [42]. */
#define mccompcurname  guideCurved37
#define mccompcurtype  Guide
#define mccompcurindex 42
#define pTable mccguideCurved37_pTable
#define reflect mccguideCurved37_reflect
#define w1 mccguideCurved37_w1
#define h1 mccguideCurved37_h1
#define w2 mccguideCurved37_w2
#define h2 mccguideCurved37_h2
#define l mccguideCurved37_l
#define R0 mccguideCurved37_R0
#define Qc mccguideCurved37_Qc
#define alpha mccguideCurved37_alpha
#define m mccguideCurved37_m
#define W mccguideCurved37_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15318 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved38' [43]. */
#define mccompcurname  guideCurved38
#define mccompcurtype  Guide
#define mccompcurindex 43
#define pTable mccguideCurved38_pTable
#define reflect mccguideCurved38_reflect
#define w1 mccguideCurved38_w1
#define h1 mccguideCurved38_h1
#define w2 mccguideCurved38_w2
#define h2 mccguideCurved38_h2
#define l mccguideCurved38_l
#define R0 mccguideCurved38_R0
#define Qc mccguideCurved38_Qc
#define alpha mccguideCurved38_alpha
#define m mccguideCurved38_m
#define W mccguideCurved38_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15353 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved39' [44]. */
#define mccompcurname  guideCurved39
#define mccompcurtype  Guide
#define mccompcurindex 44
#define pTable mccguideCurved39_pTable
#define reflect mccguideCurved39_reflect
#define w1 mccguideCurved39_w1
#define h1 mccguideCurved39_h1
#define w2 mccguideCurved39_w2
#define h2 mccguideCurved39_h2
#define l mccguideCurved39_l
#define R0 mccguideCurved39_R0
#define Qc mccguideCurved39_Qc
#define alpha mccguideCurved39_alpha
#define m mccguideCurved39_m
#define W mccguideCurved39_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15388 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guideCurved40' [45]. */
#define mccompcurname  guideCurved40
#define mccompcurtype  Guide
#define mccompcurindex 45
#define pTable mccguideCurved40_pTable
#define reflect mccguideCurved40_reflect
#define w1 mccguideCurved40_w1
#define h1 mccguideCurved40_h1
#define w2 mccguideCurved40_w2
#define h2 mccguideCurved40_h2
#define l mccguideCurved40_l
#define R0 mccguideCurved40_R0
#define Qc mccguideCurved40_Qc
#define alpha mccguideCurved40_alpha
#define m mccguideCurved40_m
#define W mccguideCurved40_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15423 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'bunker' [46]. */
#define mccompcurname  bunker
#define mccompcurtype  Guide
#define mccompcurindex 46
#define pTable mccbunker_pTable
#define reflect mccbunker_reflect
#define w1 mccbunker_w1
#define h1 mccbunker_h1
#define w2 mccbunker_w2
#define h2 mccbunker_h2
#define l mccbunker_l
#define R0 mccbunker_R0
#define Qc mccbunker_Qc
#define alpha mccbunker_alpha
#define m mccbunker_m
#define W mccbunker_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15458 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'guide3' [47]. */
#define mccompcurname  guide3
#define mccompcurtype  Guide
#define mccompcurindex 47
#define pTable mccguide3_pTable
#define reflect mccguide3_reflect
#define w1 mccguide3_w1
#define h1 mccguide3_h1
#define w2 mccguide3_w2
#define h2 mccguide3_h2
#define l mccguide3_l
#define R0 mccguide3_R0
#define Qc mccguide3_Qc
#define alpha mccguide3_alpha
#define m mccguide3_m
#define W mccguide3_W
#line 70 "/usr/share/mcstas/2.5/optics/Guide.comp"
t_Table pTable;
#line 15493 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'slitGuideEnd' [48]. */
#define mccompcurname  slitGuideEnd
#define mccompcurtype  Slit
#define mccompcurindex 48
#define xmin mccslitGuideEnd_xmin
#define xmax mccslitGuideEnd_xmax
#define ymin mccslitGuideEnd_ymin
#define ymax mccslitGuideEnd_ymax
#define radius mccslitGuideEnd_radius
#define xwidth mccslitGuideEnd_xwidth
#define yheight mccslitGuideEnd_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_guide_end' [49]. */
#define mccompcurname  psd_guide_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccpsd_guide_end_nx
#define ny mccpsd_guide_end_ny
#define PSD_N mccpsd_guide_end_PSD_N
#define PSD_p mccpsd_guide_end_PSD_p
#define PSD_p2 mccpsd_guide_end_PSD_p2
#define filename mccpsd_guide_end_filename
#define xmin mccpsd_guide_end_xmin
#define xmax mccpsd_guide_end_xmax
#define ymin mccpsd_guide_end_ymin
#define ymax mccpsd_guide_end_ymax
#define xwidth mccpsd_guide_end_xwidth
#define yheight mccpsd_guide_end_yheight
#define restore_neutron mccpsd_guide_end_restore_neutron
#define nowritefile mccpsd_guide_end_nowritefile
#line 56 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 15554 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_guide_end' [50]. */
#define mccompcurname  emon_guide_end
#define mccompcurtype  E_monitor
#define mccompcurindex 50
#define nE mccemon_guide_end_nE
#define E_N mccemon_guide_end_E_N
#define E_p mccemon_guide_end_E_p
#define E_p2 mccemon_guide_end_E_p2
#define S_p mccemon_guide_end_S_p
#define S_pE mccemon_guide_end_S_pE
#define S_pE2 mccemon_guide_end_S_pE2
#define filename mccemon_guide_end_filename
#define xmin mccemon_guide_end_xmin
#define xmax mccemon_guide_end_xmax
#define ymin mccemon_guide_end_ymin
#define ymax mccemon_guide_end_ymax
#define xwidth mccemon_guide_end_xwidth
#define yheight mccemon_guide_end_yheight
#define Emin mccemon_guide_end_Emin
#define Emax mccemon_guide_end_Emax
#define restore_neutron mccemon_guide_end_restore_neutron
#define nowritefile mccemon_guide_end_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 15599 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'lmon_guide_end' [51]. */
#define mccompcurname  lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mcclmon_guide_end_nL
#define L_N mcclmon_guide_end_L_N
#define L_p mcclmon_guide_end_L_p
#define L_p2 mcclmon_guide_end_L_p2
#define filename mcclmon_guide_end_filename
#define xmin mcclmon_guide_end_xmin
#define xmax mcclmon_guide_end_xmax
#define ymin mcclmon_guide_end_ymin
#define ymax mcclmon_guide_end_ymax
#define xwidth mcclmon_guide_end_xwidth
#define yheight mcclmon_guide_end_yheight
#define Lmin mcclmon_guide_end_Lmin
#define Lmax mcclmon_guide_end_Lmax
#define restore_neutron mcclmon_guide_end_restore_neutron
#define nowritefile mcclmon_guide_end_nowritefile
#line 57 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 15644 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'divmon_guide_end' [52]. */
#define mccompcurname  divmon_guide_end
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 52
#define nh mccdivmon_guide_end_nh
#define nv mccdivmon_guide_end_nv
#define Div_N mccdivmon_guide_end_Div_N
#define Div_p mccdivmon_guide_end_Div_p
#define Div_p2 mccdivmon_guide_end_Div_p2
#define filename mccdivmon_guide_end_filename
#define xmin mccdivmon_guide_end_xmin
#define xmax mccdivmon_guide_end_xmax
#define ymin mccdivmon_guide_end_ymin
#define ymax mccdivmon_guide_end_ymax
#define xwidth mccdivmon_guide_end_xwidth
#define yheight mccdivmon_guide_end_yheight
#define maxdiv_h mccdivmon_guide_end_maxdiv_h
#define maxdiv_v mccdivmon_guide_end_maxdiv_v
#define restore_neutron mccdivmon_guide_end_restore_neutron
#define nx mccdivmon_guide_end_nx
#define ny mccdivmon_guide_end_ny
#define nz mccdivmon_guide_end_nz
#define nowritefile mccdivmon_guide_end_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
double Div_N[nh][nv];
double Div_p[nh][nv];
double Div_p2[nh][nv];
#line 15691 "RITA-II.c"
#undef nowritefile
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'focus_mono' [53]. */
#define mccompcurname  focus_mono
#define mccompcurtype  Arm
#define mccompcurindex 53
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator_curved' [54]. */
#define mccompcurname  monochromator_curved
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 54
#define mos_rms_y mccmonochromator_curved_mos_rms_y
#define mos_rms_z mccmonochromator_curved_mos_rms_z
#define mos_rms_max mccmonochromator_curved_mos_rms_max
#define mono_Q mccmonochromator_curved_mono_Q
#define SlabWidth mccmonochromator_curved_SlabWidth
#define SlabHeight mccmonochromator_curved_SlabHeight
#define rTable mccmonochromator_curved_rTable
#define tTable mccmonochromator_curved_tTable
#define row mccmonochromator_curved_row
#define col mccmonochromator_curved_col
#define tiltH mccmonochromator_curved_tiltH
#define tiltV mccmonochromator_curved_tiltV
#define reflect mccmonochromator_curved_reflect
#define transmit mccmonochromator_curved_transmit
#define zwidth mccmonochromator_curved_zwidth
#define yheight mccmonochromator_curved_yheight
#define gap mccmonochromator_curved_gap
#define NH mccmonochromator_curved_NH
#define NV mccmonochromator_curved_NV
#define mosaich mccmonochromator_curved_mosaich
#define mosaicv mccmonochromator_curved_mosaicv
#define r0 mccmonochromator_curved_r0
#define t0 mccmonochromator_curved_t0
#define Q mccmonochromator_curved_Q
#define RV mccmonochromator_curved_RV
#define RH mccmonochromator_curved_RH
#define DM mccmonochromator_curved_DM
#define mosaic mccmonochromator_curved_mosaic
#define width mccmonochromator_curved_width
#define height mccmonochromator_curved_height
#define verbose mccmonochromator_curved_verbose
#define order mccmonochromator_curved_order
#line 136 "/usr/share/mcstas/2.5/optics/Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 15769 "RITA-II.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'a2' [55]. */
#define mccompcurname  a2
#define mccompcurtype  Arm
#define mccompcurindex 55
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'slitShutter' [56]. */
#define mccompcurname  slitShutter
#define mccompcurtype  Slit
#define mccompcurindex 56
#define xmin mccslitShutter_xmin
#define xmax mccslitShutter_xmax
#define ymin mccslitShutter_ymin
#define ymax mccslitShutter_ymax
#define radius mccslitShutter_radius
#define xwidth mccslitShutter_xwidth
#define yheight mccslitShutter_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'MSCollimator' [57]. */
#define mccompcurname  MSCollimator
#define mccompcurtype  Collimator_linear
#define mccompcurindex 57
#define slope mccMSCollimator_slope
#define slopeV mccMSCollimator_slopeV
#define xmin mccMSCollimator_xmin
#define xmax mccMSCollimator_xmax
#define ymin mccMSCollimator_ymin
#define ymax mccMSCollimator_ymax
#define xwidth mccMSCollimator_xwidth
#define yheight mccMSCollimator_yheight
#define length mccMSCollimator_length
#define divergence mccMSCollimator_divergence
#define transmission mccMSCollimator_transmission
#define divergenceV mccMSCollimator_divergenceV
#line 51 "/usr/share/mcstas/2.5/optics/Collimator_linear.comp"
double slope, slopeV;
#line 15854 "RITA-II.c"
#undef divergenceV
#undef transmission
#undef divergence
#undef length
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef slopeV
#undef slope
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'infilter' [58]. */
#define mccompcurname  infilter
#define mccompcurtype  Filter_gen
#define mccompcurindex 58
#define pTable mccinfilter_pTable
#define Mode_Table mccinfilter_Mode_Table
#define Type_Table mccinfilter_Type_Table
#define filename mccinfilter_filename
#define options mccinfilter_options
#define xmin mccinfilter_xmin
#define xmax mccinfilter_xmax
#define ymin mccinfilter_ymin
#define ymax mccinfilter_ymax
#define xwidth mccinfilter_xwidth
#define yheight mccinfilter_yheight
#define thickness mccinfilter_thickness
#define scaling mccinfilter_scaling
#define verbose mccinfilter_verbose
#line 120 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
  char Mode_Table;
  char Type_Table;
  t_Table pTable;
#line 15893 "RITA-II.c"
#undef verbose
#undef scaling
#undef thickness
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef options
#undef filename
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_virt' [59]. */
#define mccompcurname  psd_virt
#define mccompcurtype  PSD_monitor
#define mccompcurindex 59
#define nx mccpsd_virt_nx
#define ny mccpsd_virt_ny
#define PSD_N mccpsd_virt_PSD_N
#define PSD_p mccpsd_virt_PSD_p
#define PSD_p2 mccpsd_virt_PSD_p2
#define filename mccpsd_virt_filename
#define xmin mccpsd_virt_xmin
#define xmax mccpsd_virt_xmax
#define ymin mccpsd_virt_ymin
#define ymax mccpsd_virt_ymax
#define xwidth mccpsd_virt_xwidth
#define yheight mccpsd_virt_yheight
#define restore_neutron mccpsd_virt_restore_neutron
#define nowritefile mccpsd_virt_nowritefile
#line 56 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 15934 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'lmon_virt' [60]. */
#define mccompcurname  lmon_virt
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mcclmon_virt_nL
#define L_N mcclmon_virt_L_N
#define L_p mcclmon_virt_L_p
#define L_p2 mcclmon_virt_L_p2
#define filename mcclmon_virt_filename
#define xmin mcclmon_virt_xmin
#define xmax mcclmon_virt_xmax
#define ymin mcclmon_virt_ymin
#define ymax mcclmon_virt_ymax
#define xwidth mcclmon_virt_xwidth
#define yheight mcclmon_virt_yheight
#define Lmin mcclmon_virt_Lmin
#define Lmax mcclmon_virt_Lmax
#define restore_neutron mcclmon_virt_restore_neutron
#define nowritefile mcclmon_virt_nowritefile
#line 57 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 15975 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'aa2' [61]. */
#define mccompcurname  aa2
#define mccompcurtype  Arm
#define mccompcurindex 61
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'virtualout' [62]. */
#define mccompcurname  virtualout
#define mccompcurtype  Virtual_output
#define mccompcurindex 62
#define DEFS mccvirtualout_DEFS
#define Vars mccvirtualout_Vars
#define filename mccvirtualout_filename
#define bufsize mccvirtualout_bufsize
#line 72 "/usr/share/mcstas/2.5/sources/Virtual_output.comp"
char type[10];
MonitornD_Defines_type DEFS;
MonitornD_Variables_type Vars;
#line 16015 "RITA-II.c"
#undef bufsize
#undef filename
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'virtualsource' [63]. */
#define mccompcurname  virtualsource
#define mccompcurtype  Virtual_input
#define mccompcurindex 63
#define read_block mccvirtualsource_read_block
#define pos mccvirtualsource_pos
#define nrows mccvirtualsource_nrows
#define Offset mccvirtualsource_Offset
#define rTable mccvirtualsource_rTable
#define repeat_number mccvirtualsource_repeat_number
#define filename_ncount mccvirtualsource_filename_ncount
#define mean_vx mccvirtualsource_mean_vx
#define mean_vy mccvirtualsource_mean_vy
#define mean_vz mccvirtualsource_mean_vz
#define mean_dx mccvirtualsource_mean_dx
#define mean_dy mccvirtualsource_mean_dy
#define mean_dz mccvirtualsource_mean_dz
#define n_neutrons mccvirtualsource_n_neutrons
#define min_x mccvirtualsource_min_x
#define min_y mccvirtualsource_min_y
#define min_z mccvirtualsource_min_z
#define max_x mccvirtualsource_max_x
#define max_y mccvirtualsource_max_y
#define max_z mccvirtualsource_max_z
#define min_vx mccvirtualsource_min_vx
#define min_vy mccvirtualsource_min_vy
#define min_vz mccvirtualsource_min_vz
#define max_vx mccvirtualsource_max_vx
#define max_vy mccvirtualsource_max_vy
#define max_vz mccvirtualsource_max_vz
#define first_block mccvirtualsource_first_block
#define mean_x mccvirtualsource_mean_x
#define mean_y mccvirtualsource_mean_y
#define mean_z mccvirtualsource_mean_z
#define end_reading mccvirtualsource_end_reading
#define n_count_extrapolated mccvirtualsource_n_count_extrapolated
#define repeat_cnt mccvirtualsource_repeat_cnt
#define filename mccvirtualsource_filename
#define verbose mccvirtualsource_verbose
#define repeat_count mccvirtualsource_repeat_count
#define smooth mccvirtualsource_smooth
#define display mccvirtualsource_display
#line 103 "/usr/share/mcstas/2.5/sources/Virtual_input.comp"
  int repeat_number;      /* Neutron repeat of the filename */
  int repeat_cnt;         /* Repeat count, MPI taken into account */
  long pos;               /* current pos in block */
  long nrows;             /* total nrows in block */
  long Offset;            /* offset in filename */
  double filename_ncount; /* total number of neutrons in filename */
  double n_neutrons;
  char read_block;        /* flag to start by reading block */
  char first_block;
  char end_reading;
  t_Table rTable;

  /* statistics on first block */
  double mean_x, mean_y, mean_z;
  double mean_vx, mean_vy, mean_vz;
  double mean_dx, mean_dy, mean_dz;
  double min_x, min_y, min_z;
  double max_x, max_y, max_z;
  double min_vx, min_vy, min_vz;
  double max_vx, max_vy, max_vz;
  double n_count_extrapolated;
  char type[10];
#line 16089 "RITA-II.c"
#undef display
#undef smooth
#undef repeat_count
#undef verbose
#undef filename
#undef repeat_cnt
#undef n_count_extrapolated
#undef end_reading
#undef mean_z
#undef mean_y
#undef mean_x
#undef first_block
#undef max_vz
#undef max_vy
#undef max_vx
#undef min_vz
#undef min_vy
#undef min_vx
#undef max_z
#undef max_y
#undef max_x
#undef min_z
#undef min_y
#undef min_x
#undef n_neutrons
#undef mean_dz
#undef mean_dy
#undef mean_dx
#undef mean_vz
#undef mean_vy
#undef mean_vx
#undef filename_ncount
#undef repeat_number
#undef rTable
#undef Offset
#undef nrows
#undef pos
#undef read_block
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'OrderMon' [64]. */
#define mccompcurname  OrderMon
#define mccompcurtype  Monitor_nD
#define mccompcurindex 64
#define user1 mccOrderMon_user1
#define user2 mccOrderMon_user2
#define user3 mccOrderMon_user3
#define DEFS mccOrderMon_DEFS
#define Vars mccOrderMon_Vars
#define detector mccOrderMon_detector
#define offdata mccOrderMon_offdata
#define xwidth mccOrderMon_xwidth
#define yheight mccOrderMon_yheight
#define zdepth mccOrderMon_zdepth
#define xmin mccOrderMon_xmin
#define xmax mccOrderMon_xmax
#define ymin mccOrderMon_ymin
#define ymax mccOrderMon_ymax
#define zmin mccOrderMon_zmin
#define zmax mccOrderMon_zmax
#define bins mccOrderMon_bins
#define min mccOrderMon_min
#define max mccOrderMon_max
#define restore_neutron mccOrderMon_restore_neutron
#define radius mccOrderMon_radius
#define options mccOrderMon_options
#define filename mccOrderMon_filename
#define geometry mccOrderMon_geometry
#define username1 mccOrderMon_username1
#define username2 mccOrderMon_username2
#define username3 mccOrderMon_username3
#define nowritefile mccOrderMon_nowritefile
#line 223 "/usr/share/mcstas/2.5/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 16169 "RITA-II.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'kMoni' [65]. */
#define mccompcurname  kMoni
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 65
#define nx mcckMoni_nx
#define ny mcckMoni_ny
#define filename mcckMoni_filename
#define PSD_N mcckMoni_PSD_N
#define PSD_p mcckMoni_PSD_p
#define PSD_p2 mcckMoni_PSD_p2
#define weight mcckMoni_weight
#define xmin mcckMoni_xmin
#define xmax mcckMoni_xmax
#define ymin mcckMoni_ymin
#define ymax mcckMoni_ymax
#define xwidth mcckMoni_xwidth
#define yheight mcckMoni_yheight
#define psf mcckMoni_psf
#define k0 mcckMoni_k0
#define eff mcckMoni_eff
#define restore_neutron mcckMoni_restore_neutron
#define nowritefile mcckMoni_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 16229 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'kMoni1st' [66]. */
#define mccompcurname  kMoni1st
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 66
#define nx mcckMoni1st_nx
#define ny mcckMoni1st_ny
#define filename mcckMoni1st_filename
#define PSD_N mcckMoni1st_PSD_N
#define PSD_p mcckMoni1st_PSD_p
#define PSD_p2 mcckMoni1st_PSD_p2
#define weight mcckMoni1st_weight
#define xmin mcckMoni1st_xmin
#define xmax mcckMoni1st_xmax
#define ymin mcckMoni1st_ymin
#define ymax mcckMoni1st_ymax
#define xwidth mcckMoni1st_xwidth
#define yheight mcckMoni1st_yheight
#define psf mcckMoni1st_psf
#define k0 mcckMoni1st_k0
#define eff mcckMoni1st_eff
#define restore_neutron mcckMoni1st_restore_neutron
#define nowritefile mcckMoni1st_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 16279 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'kMoni2nd' [67]. */
#define mccompcurname  kMoni2nd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 67
#define nx mcckMoni2nd_nx
#define ny mcckMoni2nd_ny
#define filename mcckMoni2nd_filename
#define PSD_N mcckMoni2nd_PSD_N
#define PSD_p mcckMoni2nd_PSD_p
#define PSD_p2 mcckMoni2nd_PSD_p2
#define weight mcckMoni2nd_weight
#define xmin mcckMoni2nd_xmin
#define xmax mcckMoni2nd_xmax
#define ymin mcckMoni2nd_ymin
#define ymax mcckMoni2nd_ymax
#define xwidth mcckMoni2nd_xwidth
#define yheight mcckMoni2nd_yheight
#define psf mcckMoni2nd_psf
#define k0 mcckMoni2nd_k0
#define eff mcckMoni2nd_eff
#define restore_neutron mcckMoni2nd_restore_neutron
#define nowritefile mcckMoni2nd_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 16329 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'kMoni3rd' [68]. */
#define mccompcurname  kMoni3rd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 68
#define nx mcckMoni3rd_nx
#define ny mcckMoni3rd_ny
#define filename mcckMoni3rd_filename
#define PSD_N mcckMoni3rd_PSD_N
#define PSD_p mcckMoni3rd_PSD_p
#define PSD_p2 mcckMoni3rd_PSD_p2
#define weight mcckMoni3rd_weight
#define xmin mcckMoni3rd_xmin
#define xmax mcckMoni3rd_xmax
#define ymin mcckMoni3rd_ymin
#define ymax mcckMoni3rd_ymax
#define xwidth mcckMoni3rd_xwidth
#define yheight mcckMoni3rd_yheight
#define psf mcckMoni3rd_psf
#define k0 mcckMoni3rd_k0
#define eff mcckMoni3rd_eff
#define restore_neutron mcckMoni3rd_restore_neutron
#define nowritefile mcckMoni3rd_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 16379 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'slitMonochromator' [69]. */
#define mccompcurname  slitMonochromator
#define mccompcurtype  Slit
#define mccompcurindex 69
#define xmin mccslitMonochromator_xmin
#define xmax mccslitMonochromator_xmax
#define ymin mccslitMonochromator_ymin
#define ymax mccslitMonochromator_ymax
#define radius mccslitMonochromator_radius
#define xwidth mccslitMonochromator_xwidth
#define yheight mccslitMonochromator_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Perspex' [70]. */
#define mccompcurname  Perspex
#define mccompcurtype  Incoherent
#define mccompcurindex 70
#define VarsInc mccPerspex_VarsInc
#define offdata mccPerspex_offdata
#define geometry mccPerspex_geometry
#define radius mccPerspex_radius
#define xwidth mccPerspex_xwidth
#define yheight mccPerspex_yheight
#define zdepth mccPerspex_zdepth
#define thickness mccPerspex_thickness
#define target_x mccPerspex_target_x
#define target_y mccPerspex_target_y
#define target_z mccPerspex_target_z
#define focus_r mccPerspex_focus_r
#define focus_xw mccPerspex_focus_xw
#define focus_yh mccPerspex_focus_yh
#define focus_aw mccPerspex_focus_aw
#define focus_ah mccPerspex_focus_ah
#define target_index mccPerspex_target_index
#define pack mccPerspex_pack
#define p_interact mccPerspex_p_interact
#define f_QE mccPerspex_f_QE
#define gamma mccPerspex_gamma
#define Etrans mccPerspex_Etrans
#define deltaE mccPerspex_deltaE
#define sigma_abs mccPerspex_sigma_abs
#define sigma_inc mccPerspex_sigma_inc
#define Vc mccPerspex_Vc
#define concentric mccPerspex_concentric
#define order mccPerspex_order
#line 149 "/usr/share/mcstas/2.5/samples/Incoherent.comp"

  struct StructVarsInc VarsInc;
  off_struct offdata;

#line 16461 "RITA-II.c"
#undef order
#undef concentric
#undef Vc
#undef sigma_inc
#undef sigma_abs
#undef deltaE
#undef Etrans
#undef gamma
#undef f_QE
#undef p_interact
#undef pack
#undef target_index
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef focus_r
#undef target_z
#undef target_y
#undef target_x
#undef thickness
#undef zdepth
#undef yheight
#undef xwidth
#undef radius
#undef geometry
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_samplepos_1cm2' [71]. */
#define mccompcurname  psd_samplepos_1cm2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 71
#define nx mccpsd_samplepos_1cm2_nx
#define ny mccpsd_samplepos_1cm2_ny
#define PSD_N mccpsd_samplepos_1cm2_PSD_N
#define PSD_p mccpsd_samplepos_1cm2_PSD_p
#define PSD_p2 mccpsd_samplepos_1cm2_PSD_p2
#define filename mccpsd_samplepos_1cm2_filename
#define xmin mccpsd_samplepos_1cm2_xmin
#define xmax mccpsd_samplepos_1cm2_xmax
#define ymin mccpsd_samplepos_1cm2_ymin
#define ymax mccpsd_samplepos_1cm2_ymax
#define xwidth mccpsd_samplepos_1cm2_xwidth
#define yheight mccpsd_samplepos_1cm2_yheight
#define restore_neutron mccpsd_samplepos_1cm2_restore_neutron
#define nowritefile mccpsd_samplepos_1cm2_nowritefile
#line 56 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 16516 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_samplepos_1cm2' [72]. */
#define mccompcurname  emon_samplepos_1cm2
#define mccompcurtype  E_monitor
#define mccompcurindex 72
#define nE mccemon_samplepos_1cm2_nE
#define E_N mccemon_samplepos_1cm2_E_N
#define E_p mccemon_samplepos_1cm2_E_p
#define E_p2 mccemon_samplepos_1cm2_E_p2
#define S_p mccemon_samplepos_1cm2_S_p
#define S_pE mccemon_samplepos_1cm2_S_pE
#define S_pE2 mccemon_samplepos_1cm2_S_pE2
#define filename mccemon_samplepos_1cm2_filename
#define xmin mccemon_samplepos_1cm2_xmin
#define xmax mccemon_samplepos_1cm2_xmax
#define ymin mccemon_samplepos_1cm2_ymin
#define ymax mccemon_samplepos_1cm2_ymax
#define xwidth mccemon_samplepos_1cm2_xwidth
#define yheight mccemon_samplepos_1cm2_yheight
#define Emin mccemon_samplepos_1cm2_Emin
#define Emax mccemon_samplepos_1cm2_Emax
#define restore_neutron mccemon_samplepos_1cm2_restore_neutron
#define nowritefile mccemon_samplepos_1cm2_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 16561 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'divmon_samplepos_1cm2' [73]. */
#define mccompcurname  divmon_samplepos_1cm2
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 73
#define nh mccdivmon_samplepos_1cm2_nh
#define nv mccdivmon_samplepos_1cm2_nv
#define Div_N mccdivmon_samplepos_1cm2_Div_N
#define Div_p mccdivmon_samplepos_1cm2_Div_p
#define Div_p2 mccdivmon_samplepos_1cm2_Div_p2
#define filename mccdivmon_samplepos_1cm2_filename
#define xmin mccdivmon_samplepos_1cm2_xmin
#define xmax mccdivmon_samplepos_1cm2_xmax
#define ymin mccdivmon_samplepos_1cm2_ymin
#define ymax mccdivmon_samplepos_1cm2_ymax
#define xwidth mccdivmon_samplepos_1cm2_xwidth
#define yheight mccdivmon_samplepos_1cm2_yheight
#define maxdiv_h mccdivmon_samplepos_1cm2_maxdiv_h
#define maxdiv_v mccdivmon_samplepos_1cm2_maxdiv_v
#define restore_neutron mccdivmon_samplepos_1cm2_restore_neutron
#define nx mccdivmon_samplepos_1cm2_nx
#define ny mccdivmon_samplepos_1cm2_ny
#define nz mccdivmon_samplepos_1cm2_nz
#define nowritefile mccdivmon_samplepos_1cm2_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
double Div_N[nh][nv];
double Div_p[nh][nv];
double Div_p2[nh][nv];
#line 16611 "RITA-II.c"
#undef nowritefile
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_samplepos_large' [74]. */
#define mccompcurname  psd_samplepos_large
#define mccompcurtype  PSD_monitor
#define mccompcurindex 74
#define nx mccpsd_samplepos_large_nx
#define ny mccpsd_samplepos_large_ny
#define PSD_N mccpsd_samplepos_large_PSD_N
#define PSD_p mccpsd_samplepos_large_PSD_p
#define PSD_p2 mccpsd_samplepos_large_PSD_p2
#define filename mccpsd_samplepos_large_filename
#define xmin mccpsd_samplepos_large_xmin
#define xmax mccpsd_samplepos_large_xmax
#define ymin mccpsd_samplepos_large_ymin
#define ymax mccpsd_samplepos_large_ymax
#define xwidth mccpsd_samplepos_large_xwidth
#define yheight mccpsd_samplepos_large_yheight
#define restore_neutron mccpsd_samplepos_large_restore_neutron
#define nowritefile mccpsd_samplepos_large_nowritefile
#line 56 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 16657 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'a3' [75]. */
#define mccompcurname  a3
#define mccompcurtype  Arm
#define mccompcurindex 75
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'aa3' [76]. */
#define mccompcurname  aa3
#define mccompcurtype  Arm
#define mccompcurindex 76
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'incohSample' [77]. */
#define mccompcurname  incohSample
#define mccompcurtype  Incoherent
#define mccompcurindex 77
#define VarsInc mccincohSample_VarsInc
#define offdata mccincohSample_offdata
#define geometry mccincohSample_geometry
#define radius mccincohSample_radius
#define xwidth mccincohSample_xwidth
#define yheight mccincohSample_yheight
#define zdepth mccincohSample_zdepth
#define thickness mccincohSample_thickness
#define target_x mccincohSample_target_x
#define target_y mccincohSample_target_y
#define target_z mccincohSample_target_z
#define focus_r mccincohSample_focus_r
#define focus_xw mccincohSample_focus_xw
#define focus_yh mccincohSample_focus_yh
#define focus_aw mccincohSample_focus_aw
#define focus_ah mccincohSample_focus_ah
#define target_index mccincohSample_target_index
#define pack mccincohSample_pack
#define p_interact mccincohSample_p_interact
#define f_QE mccincohSample_f_QE
#define gamma mccincohSample_gamma
#define Etrans mccincohSample_Etrans
#define deltaE mccincohSample_deltaE
#define sigma_abs mccincohSample_sigma_abs
#define sigma_inc mccincohSample_sigma_inc
#define Vc mccincohSample_Vc
#define concentric mccincohSample_concentric
#define order mccincohSample_order
#line 149 "/usr/share/mcstas/2.5/samples/Incoherent.comp"

  struct StructVarsInc VarsInc;
  off_struct offdata;

#line 16729 "RITA-II.c"
#undef order
#undef concentric
#undef Vc
#undef sigma_inc
#undef sigma_abs
#undef deltaE
#undef Etrans
#undef gamma
#undef f_QE
#undef p_interact
#undef pack
#undef target_index
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef focus_r
#undef target_z
#undef target_y
#undef target_x
#undef thickness
#undef zdepth
#undef yheight
#undef xwidth
#undef radius
#undef geometry
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'powderSample' [78]. */
#define mccompcurname  powderSample
#define mccompcurtype  PowderN
#define mccompcurindex 78
#define format mccpowderSample_format
#define line_info mccpowderSample_line_info
#define columns mccpowderSample_columns
#define offdata mccpowderSample_offdata
#define reflections mccpowderSample_reflections
#define geometry mccpowderSample_geometry
#define radius mccpowderSample_radius
#define yheight mccpowderSample_yheight
#define xwidth mccpowderSample_xwidth
#define zdepth mccpowderSample_zdepth
#define thickness mccpowderSample_thickness
#define pack mccpowderSample_pack
#define Vc mccpowderSample_Vc
#define sigma_abs mccpowderSample_sigma_abs
#define sigma_inc mccpowderSample_sigma_inc
#define delta_d_d mccpowderSample_delta_d_d
#define p_inc mccpowderSample_p_inc
#define p_transmit mccpowderSample_p_transmit
#define DW mccpowderSample_DW
#define nb_atoms mccpowderSample_nb_atoms
#define d_omega mccpowderSample_d_omega
#define d_phi mccpowderSample_d_phi
#define tth_sign mccpowderSample_tth_sign
#define p_interact mccpowderSample_p_interact
#define concentric mccpowderSample_concentric
#define density mccpowderSample_density
#define weight mccpowderSample_weight
#define barns mccpowderSample_barns
#define Strain mccpowderSample_Strain
#define focus_flip mccpowderSample_focus_flip
#define target_index mccpowderSample_target_index
#line 552 "/usr/share/mcstas/2.5/samples/PowderN.comp"
  struct line_info_struct line_info;
  int *columns;
  off_struct offdata;
  double tgt_x, tgt_y, tgt_z;

#line 16803 "RITA-II.c"
#undef target_index
#undef focus_flip
#undef Strain
#undef barns
#undef weight
#undef density
#undef concentric
#undef p_interact
#undef tth_sign
#undef d_phi
#undef d_omega
#undef nb_atoms
#undef DW
#undef p_transmit
#undef p_inc
#undef delta_d_d
#undef sigma_inc
#undef sigma_abs
#undef Vc
#undef pack
#undef thickness
#undef zdepth
#undef xwidth
#undef yheight
#undef radius
#undef geometry
#undef reflections
#undef offdata
#undef columns
#undef line_info
#undef format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'crystalSample' [79]. */
#define mccompcurname  crystalSample
#define mccompcurtype  Single_crystal
#define mccompcurindex 79
#define mosaic_AB mcccrystalSample_mosaic_AB
#define hkl_info mcccrystalSample_hkl_info
#define offdata mcccrystalSample_offdata
#define reflections mcccrystalSample_reflections
#define geometry mcccrystalSample_geometry
#define xwidth mcccrystalSample_xwidth
#define yheight mcccrystalSample_yheight
#define zdepth mcccrystalSample_zdepth
#define radius mcccrystalSample_radius
#define delta_d_d mcccrystalSample_delta_d_d
#define mosaic mcccrystalSample_mosaic
#define mosaic_a mcccrystalSample_mosaic_a
#define mosaic_b mcccrystalSample_mosaic_b
#define mosaic_c mcccrystalSample_mosaic_c
#define recip_cell mcccrystalSample_recip_cell
#define barns mcccrystalSample_barns
#define ax mcccrystalSample_ax
#define ay mcccrystalSample_ay
#define az mcccrystalSample_az
#define bx mcccrystalSample_bx
#define by mcccrystalSample_by
#define bz mcccrystalSample_bz
#define cx mcccrystalSample_cx
#define cy mcccrystalSample_cy
#define cz mcccrystalSample_cz
#define p_transmit mcccrystalSample_p_transmit
#define sigma_abs mcccrystalSample_sigma_abs
#define sigma_inc mcccrystalSample_sigma_inc
#define aa mcccrystalSample_aa
#define bb mcccrystalSample_bb
#define cc mcccrystalSample_cc
#define order mcccrystalSample_order
#define RX mcccrystalSample_RX
#define RY mcccrystalSample_RY
#define powder mcccrystalSample_powder
#define PG mcccrystalSample_PG
#define deltak mcccrystalSample_deltak
#line 962 "/usr/share/mcstas/2.5/samples/Single_crystal.comp"
  struct hkl_info_struct hkl_info;
  off_struct             offdata;
#line 16883 "RITA-II.c"
#undef deltak
#undef PG
#undef powder
#undef RY
#undef RX
#undef order
#undef cc
#undef bb
#undef aa
#undef sigma_inc
#undef sigma_abs
#undef p_transmit
#undef cz
#undef cy
#undef cx
#undef bz
#undef by
#undef bx
#undef az
#undef ay
#undef ax
#undef barns
#undef recip_cell
#undef mosaic_c
#undef mosaic_b
#undef mosaic_a
#undef mosaic
#undef delta_d_d
#undef radius
#undef zdepth
#undef yheight
#undef xwidth
#undef geometry
#undef reflections
#undef offdata
#undef hkl_info
#undef mosaic_AB
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'phononSample' [80]. */
#define mccompcurname  phononSample
#define mccompcurtype  Phonon_simple
#define mccompcurindex 80
#define V_rho mccphononSample_V_rho
#define V_my_s mccphononSample_V_my_s
#define V_my_a_v mccphononSample_V_my_a_v
#define DV mccphononSample_DV
#define parms mccphononSample_parms
#define radius mccphononSample_radius
#define yheight mccphononSample_yheight
#define sigma_abs mccphononSample_sigma_abs
#define sigma_inc mccphononSample_sigma_inc
#define a mccphononSample_a
#define b mccphononSample_b
#define M mccphononSample_M
#define c mccphononSample_c
#define DW mccphononSample_DW
#define T mccphononSample_T
#define target_x mccphononSample_target_x
#define target_y mccphononSample_target_y
#define target_z mccphononSample_target_z
#define target_index mccphononSample_target_index
#define focus_r mccphononSample_focus_r
#define focus_xw mccphononSample_focus_xw
#define focus_yh mccphononSample_focus_yh
#define focus_aw mccphononSample_focus_aw
#define focus_ah mccphononSample_focus_ah
#define gap mccphononSample_gap
#line 234 "/usr/share/mcstas/2.5/samples/Phonon_simple.comp"
  double V_rho;
  double V_my_s;
  double V_my_a_v;
  double DV;
  double parms[11];
#line 16960 "RITA-II.c"
#undef gap
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef focus_r
#undef target_index
#undef target_z
#undef target_y
#undef target_x
#undef T
#undef DW
#undef c
#undef M
#undef b
#undef a
#undef sigma_inc
#undef sigma_abs
#undef yheight
#undef radius
#undef parms
#undef DV
#undef V_my_a_v
#undef V_my_s
#undef V_rho
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_4pi' [81]. */
#define mccompcurname  psd_4pi
#define mccompcurtype  PSD_monitor_4PI
#define mccompcurindex 81
#define nx mccpsd_4pi_nx
#define ny mccpsd_4pi_ny
#define PSD_N mccpsd_4pi_PSD_N
#define PSD_p mccpsd_4pi_PSD_p
#define PSD_p2 mccpsd_4pi_PSD_p2
#define filename mccpsd_4pi_filename
#define radius mccpsd_4pi_radius
#define restore_neutron mccpsd_4pi_restore_neutron
#define nowritefile mccpsd_4pi_nowritefile
#line 55 "/usr/share/mcstas/2.5/monitors/PSD_monitor_4PI.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 17007 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef radius
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'a4' [82]. */
#define mccompcurname  a4
#define mccompcurtype  Arm
#define mccompcurindex 82
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'slitSample' [83]. */
#define mccompcurname  slitSample
#define mccompcurtype  Slit
#define mccompcurindex 83
#define xmin mccslitSample_xmin
#define xmax mccslitSample_xmax
#define ymin mccslitSample_ymin
#define ymax mccslitSample_ymax
#define radius mccslitSample_radius
#define xwidth mccslitSample_xwidth
#define yheight mccslitSample_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'filter_coll' [84]. */
#define mccompcurname  filter_coll
#define mccompcurtype  Exact_radial_coll
#define mccompcurindex 84
#define alpha_in mccfilter_coll_alpha_in
#define alpha_out mccfilter_coll_alpha_out
#define out_radius mccfilter_coll_out_radius
#define beta_in mccfilter_coll_beta_in
#define beta_out mccfilter_coll_beta_out
#define iw mccfilter_coll_iw
#define ow mccfilter_coll_ow
#define divergence mccfilter_coll_divergence
#define theta mccfilter_coll_theta
#define theta_min mccfilter_coll_theta_min
#define theta_max mccfilter_coll_theta_max
#define nslit mccfilter_coll_nslit
#define radius mccfilter_coll_radius
#define length mccfilter_coll_length
#define h_in mccfilter_coll_h_in
#define h_out mccfilter_coll_h_out
#define d mccfilter_coll_d
#define verbose mccfilter_coll_verbose
#line 58 "/usr/share/mcstas/2.5/contrib/Exact_radial_coll.comp"
double alpha_in, alpha_out, beta_in, beta_out, theta;
double out_radius, iw, ow, divergence;
#line 17076 "RITA-II.c"
#undef verbose
#undef d
#undef h_out
#undef h_in
#undef length
#undef radius
#undef nslit
#undef theta_max
#undef theta_min
#undef theta
#undef divergence
#undef ow
#undef iw
#undef beta_out
#undef beta_in
#undef out_radius
#undef alpha_out
#undef alpha_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'filter' [85]. */
#define mccompcurname  filter
#define mccompcurtype  Filter_gen
#define mccompcurindex 85
#define pTable mccfilter_pTable
#define Mode_Table mccfilter_Mode_Table
#define Type_Table mccfilter_Type_Table
#define filename mccfilter_filename
#define options mccfilter_options
#define xmin mccfilter_xmin
#define xmax mccfilter_xmax
#define ymin mccfilter_ymin
#define ymax mccfilter_ymax
#define xwidth mccfilter_xwidth
#define yheight mccfilter_yheight
#define thickness mccfilter_thickness
#define scaling mccfilter_scaling
#define verbose mccfilter_verbose
#line 120 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
  char Mode_Table;
  char Type_Table;
  t_Table pTable;
#line 17121 "RITA-II.c"
#undef verbose
#undef scaling
#undef thickness
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef options
#undef filename
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ana_slit1' [86]. */
#define mccompcurname  ana_slit1
#define mccompcurtype  Slit
#define mccompcurindex 86
#define xmin mccana_slit1_xmin
#define xmax mccana_slit1_xmax
#define ymin mccana_slit1_ymin
#define ymax mccana_slit1_ymax
#define radius mccana_slit1_radius
#define xwidth mccana_slit1_xwidth
#define yheight mccana_slit1_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ana_slit2' [87]. */
#define mccompcurname  ana_slit2
#define mccompcurtype  Slit
#define mccompcurindex 87
#define xmin mccana_slit2_xmin
#define xmax mccana_slit2_xmax
#define ymin mccana_slit2_ymin
#define ymax mccana_slit2_ymax
#define radius mccana_slit2_radius
#define xwidth mccana_slit2_xwidth
#define yheight mccana_slit2_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_before_ana' [88]. */
#define mccompcurname  emon_before_ana
#define mccompcurtype  E_monitor
#define mccompcurindex 88
#define nE mccemon_before_ana_nE
#define E_N mccemon_before_ana_E_N
#define E_p mccemon_before_ana_E_p
#define E_p2 mccemon_before_ana_E_p2
#define S_p mccemon_before_ana_S_p
#define S_pE mccemon_before_ana_S_pE
#define S_pE2 mccemon_before_ana_S_pE2
#define filename mccemon_before_ana_filename
#define xmin mccemon_before_ana_xmin
#define xmax mccemon_before_ana_xmax
#define ymin mccemon_before_ana_ymin
#define ymax mccemon_before_ana_ymax
#define xwidth mccemon_before_ana_xwidth
#define yheight mccemon_before_ana_yheight
#define Emin mccemon_before_ana_Emin
#define Emax mccemon_before_ana_Emax
#define restore_neutron mccemon_before_ana_restore_neutron
#define nowritefile mccemon_before_ana_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 17210 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_before_ana' [89]. */
#define mccompcurname  psd_before_ana
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define nx mccpsd_before_ana_nx
#define ny mccpsd_before_ana_ny
#define PSD_N mccpsd_before_ana_PSD_N
#define PSD_p mccpsd_before_ana_PSD_p
#define PSD_p2 mccpsd_before_ana_PSD_p2
#define filename mccpsd_before_ana_filename
#define xmin mccpsd_before_ana_xmin
#define xmax mccpsd_before_ana_xmax
#define ymin mccpsd_before_ana_ymin
#define ymax mccpsd_before_ana_ymax
#define xwidth mccpsd_before_ana_xwidth
#define yheight mccpsd_before_ana_yheight
#define restore_neutron mccpsd_before_ana_restore_neutron
#define nowritefile mccpsd_before_ana_nowritefile
#line 56 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 17255 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'divmon_before_ana' [90]. */
#define mccompcurname  divmon_before_ana
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 90
#define nh mccdivmon_before_ana_nh
#define nv mccdivmon_before_ana_nv
#define Div_N mccdivmon_before_ana_Div_N
#define Div_p mccdivmon_before_ana_Div_p
#define Div_p2 mccdivmon_before_ana_Div_p2
#define filename mccdivmon_before_ana_filename
#define xmin mccdivmon_before_ana_xmin
#define xmax mccdivmon_before_ana_xmax
#define ymin mccdivmon_before_ana_ymin
#define ymax mccdivmon_before_ana_ymax
#define xwidth mccdivmon_before_ana_xwidth
#define yheight mccdivmon_before_ana_yheight
#define maxdiv_h mccdivmon_before_ana_maxdiv_h
#define maxdiv_v mccdivmon_before_ana_maxdiv_v
#define restore_neutron mccdivmon_before_ana_restore_neutron
#define nx mccdivmon_before_ana_nx
#define ny mccdivmon_before_ana_ny
#define nz mccdivmon_before_ana_nz
#define nowritefile mccdivmon_before_ana_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
double Div_N[nh][nv];
double Div_p[nh][nv];
double Div_p2[nh][nv];
#line 17301 "RITA-II.c"
#undef nowritefile
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'focus_ana' [91]. */
#define mccompcurname  focus_ana
#define mccompcurtype  Arm
#define mccompcurindex 91
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an1l' [92]. */
#define mccompcurname  an1l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 92
#define mos_rms_y mccan1l_mos_rms_y
#define mos_rms_z mccan1l_mos_rms_z
#define mos_rms_max mccan1l_mos_rms_max
#define mono_Q mccan1l_mono_Q
#define zmin mccan1l_zmin
#define zmax mccan1l_zmax
#define ymin mccan1l_ymin
#define ymax mccan1l_ymax
#define zwidth mccan1l_zwidth
#define yheight mccan1l_yheight
#define mosaich mccan1l_mosaich
#define mosaicv mccan1l_mosaicv
#define r0 mccan1l_r0
#define Q mccan1l_Q
#define DM mccan1l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17357 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an1u' [93]. */
#define mccompcurname  an1u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 93
#define mos_rms_y mccan1u_mos_rms_y
#define mos_rms_z mccan1u_mos_rms_z
#define mos_rms_max mccan1u_mos_rms_max
#define mono_Q mccan1u_mono_Q
#define zmin mccan1u_zmin
#define zmax mccan1u_zmax
#define ymin mccan1u_ymin
#define ymax mccan1u_ymax
#define zwidth mccan1u_zwidth
#define yheight mccan1u_yheight
#define mosaich mccan1u_mosaich
#define mosaicv mccan1u_mosaicv
#define r0 mccan1u_r0
#define Q mccan1u_Q
#define DM mccan1u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17401 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an2l' [94]. */
#define mccompcurname  an2l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 94
#define mos_rms_y mccan2l_mos_rms_y
#define mos_rms_z mccan2l_mos_rms_z
#define mos_rms_max mccan2l_mos_rms_max
#define mono_Q mccan2l_mono_Q
#define zmin mccan2l_zmin
#define zmax mccan2l_zmax
#define ymin mccan2l_ymin
#define ymax mccan2l_ymax
#define zwidth mccan2l_zwidth
#define yheight mccan2l_yheight
#define mosaich mccan2l_mosaich
#define mosaicv mccan2l_mosaicv
#define r0 mccan2l_r0
#define Q mccan2l_Q
#define DM mccan2l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17445 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an2u' [95]. */
#define mccompcurname  an2u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 95
#define mos_rms_y mccan2u_mos_rms_y
#define mos_rms_z mccan2u_mos_rms_z
#define mos_rms_max mccan2u_mos_rms_max
#define mono_Q mccan2u_mono_Q
#define zmin mccan2u_zmin
#define zmax mccan2u_zmax
#define ymin mccan2u_ymin
#define ymax mccan2u_ymax
#define zwidth mccan2u_zwidth
#define yheight mccan2u_yheight
#define mosaich mccan2u_mosaich
#define mosaicv mccan2u_mosaicv
#define r0 mccan2u_r0
#define Q mccan2u_Q
#define DM mccan2u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17489 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an3l' [96]. */
#define mccompcurname  an3l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 96
#define mos_rms_y mccan3l_mos_rms_y
#define mos_rms_z mccan3l_mos_rms_z
#define mos_rms_max mccan3l_mos_rms_max
#define mono_Q mccan3l_mono_Q
#define zmin mccan3l_zmin
#define zmax mccan3l_zmax
#define ymin mccan3l_ymin
#define ymax mccan3l_ymax
#define zwidth mccan3l_zwidth
#define yheight mccan3l_yheight
#define mosaich mccan3l_mosaich
#define mosaicv mccan3l_mosaicv
#define r0 mccan3l_r0
#define Q mccan3l_Q
#define DM mccan3l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17533 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an3u' [97]. */
#define mccompcurname  an3u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 97
#define mos_rms_y mccan3u_mos_rms_y
#define mos_rms_z mccan3u_mos_rms_z
#define mos_rms_max mccan3u_mos_rms_max
#define mono_Q mccan3u_mono_Q
#define zmin mccan3u_zmin
#define zmax mccan3u_zmax
#define ymin mccan3u_ymin
#define ymax mccan3u_ymax
#define zwidth mccan3u_zwidth
#define yheight mccan3u_yheight
#define mosaich mccan3u_mosaich
#define mosaicv mccan3u_mosaicv
#define r0 mccan3u_r0
#define Q mccan3u_Q
#define DM mccan3u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17577 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an4l' [98]. */
#define mccompcurname  an4l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 98
#define mos_rms_y mccan4l_mos_rms_y
#define mos_rms_z mccan4l_mos_rms_z
#define mos_rms_max mccan4l_mos_rms_max
#define mono_Q mccan4l_mono_Q
#define zmin mccan4l_zmin
#define zmax mccan4l_zmax
#define ymin mccan4l_ymin
#define ymax mccan4l_ymax
#define zwidth mccan4l_zwidth
#define yheight mccan4l_yheight
#define mosaich mccan4l_mosaich
#define mosaicv mccan4l_mosaicv
#define r0 mccan4l_r0
#define Q mccan4l_Q
#define DM mccan4l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17621 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an4u' [99]. */
#define mccompcurname  an4u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 99
#define mos_rms_y mccan4u_mos_rms_y
#define mos_rms_z mccan4u_mos_rms_z
#define mos_rms_max mccan4u_mos_rms_max
#define mono_Q mccan4u_mono_Q
#define zmin mccan4u_zmin
#define zmax mccan4u_zmax
#define ymin mccan4u_ymin
#define ymax mccan4u_ymax
#define zwidth mccan4u_zwidth
#define yheight mccan4u_yheight
#define mosaich mccan4u_mosaich
#define mosaicv mccan4u_mosaicv
#define r0 mccan4u_r0
#define Q mccan4u_Q
#define DM mccan4u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17665 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an5l' [100]. */
#define mccompcurname  an5l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 100
#define mos_rms_y mccan5l_mos_rms_y
#define mos_rms_z mccan5l_mos_rms_z
#define mos_rms_max mccan5l_mos_rms_max
#define mono_Q mccan5l_mono_Q
#define zmin mccan5l_zmin
#define zmax mccan5l_zmax
#define ymin mccan5l_ymin
#define ymax mccan5l_ymax
#define zwidth mccan5l_zwidth
#define yheight mccan5l_yheight
#define mosaich mccan5l_mosaich
#define mosaicv mccan5l_mosaicv
#define r0 mccan5l_r0
#define Q mccan5l_Q
#define DM mccan5l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17709 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an5u' [101]. */
#define mccompcurname  an5u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 101
#define mos_rms_y mccan5u_mos_rms_y
#define mos_rms_z mccan5u_mos_rms_z
#define mos_rms_max mccan5u_mos_rms_max
#define mono_Q mccan5u_mono_Q
#define zmin mccan5u_zmin
#define zmax mccan5u_zmax
#define ymin mccan5u_ymin
#define ymax mccan5u_ymax
#define zwidth mccan5u_zwidth
#define yheight mccan5u_yheight
#define mosaich mccan5u_mosaich
#define mosaicv mccan5u_mosaicv
#define r0 mccan5u_r0
#define Q mccan5u_Q
#define DM mccan5u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17753 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an6l' [102]. */
#define mccompcurname  an6l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 102
#define mos_rms_y mccan6l_mos_rms_y
#define mos_rms_z mccan6l_mos_rms_z
#define mos_rms_max mccan6l_mos_rms_max
#define mono_Q mccan6l_mono_Q
#define zmin mccan6l_zmin
#define zmax mccan6l_zmax
#define ymin mccan6l_ymin
#define ymax mccan6l_ymax
#define zwidth mccan6l_zwidth
#define yheight mccan6l_yheight
#define mosaich mccan6l_mosaich
#define mosaicv mccan6l_mosaicv
#define r0 mccan6l_r0
#define Q mccan6l_Q
#define DM mccan6l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17797 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an6u' [103]. */
#define mccompcurname  an6u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 103
#define mos_rms_y mccan6u_mos_rms_y
#define mos_rms_z mccan6u_mos_rms_z
#define mos_rms_max mccan6u_mos_rms_max
#define mono_Q mccan6u_mono_Q
#define zmin mccan6u_zmin
#define zmax mccan6u_zmax
#define ymin mccan6u_ymin
#define ymax mccan6u_ymax
#define zwidth mccan6u_zwidth
#define yheight mccan6u_yheight
#define mosaich mccan6u_mosaich
#define mosaicv mccan6u_mosaicv
#define r0 mccan6u_r0
#define Q mccan6u_Q
#define DM mccan6u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17841 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an7l' [104]. */
#define mccompcurname  an7l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 104
#define mos_rms_y mccan7l_mos_rms_y
#define mos_rms_z mccan7l_mos_rms_z
#define mos_rms_max mccan7l_mos_rms_max
#define mono_Q mccan7l_mono_Q
#define zmin mccan7l_zmin
#define zmax mccan7l_zmax
#define ymin mccan7l_ymin
#define ymax mccan7l_ymax
#define zwidth mccan7l_zwidth
#define yheight mccan7l_yheight
#define mosaich mccan7l_mosaich
#define mosaicv mccan7l_mosaicv
#define r0 mccan7l_r0
#define Q mccan7l_Q
#define DM mccan7l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17885 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an7u' [105]. */
#define mccompcurname  an7u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 105
#define mos_rms_y mccan7u_mos_rms_y
#define mos_rms_z mccan7u_mos_rms_z
#define mos_rms_max mccan7u_mos_rms_max
#define mono_Q mccan7u_mono_Q
#define zmin mccan7u_zmin
#define zmax mccan7u_zmax
#define ymin mccan7u_ymin
#define ymax mccan7u_ymax
#define zwidth mccan7u_zwidth
#define yheight mccan7u_yheight
#define mosaich mccan7u_mosaich
#define mosaicv mccan7u_mosaicv
#define r0 mccan7u_r0
#define Q mccan7u_Q
#define DM mccan7u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17929 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an8l' [106]. */
#define mccompcurname  an8l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 106
#define mos_rms_y mccan8l_mos_rms_y
#define mos_rms_z mccan8l_mos_rms_z
#define mos_rms_max mccan8l_mos_rms_max
#define mono_Q mccan8l_mono_Q
#define zmin mccan8l_zmin
#define zmax mccan8l_zmax
#define ymin mccan8l_ymin
#define ymax mccan8l_ymax
#define zwidth mccan8l_zwidth
#define yheight mccan8l_yheight
#define mosaich mccan8l_mosaich
#define mosaicv mccan8l_mosaicv
#define r0 mccan8l_r0
#define Q mccan8l_Q
#define DM mccan8l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 17973 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an8u' [107]. */
#define mccompcurname  an8u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 107
#define mos_rms_y mccan8u_mos_rms_y
#define mos_rms_z mccan8u_mos_rms_z
#define mos_rms_max mccan8u_mos_rms_max
#define mono_Q mccan8u_mono_Q
#define zmin mccan8u_zmin
#define zmax mccan8u_zmax
#define ymin mccan8u_ymin
#define ymax mccan8u_ymax
#define zwidth mccan8u_zwidth
#define yheight mccan8u_yheight
#define mosaich mccan8u_mosaich
#define mosaicv mccan8u_mosaicv
#define r0 mccan8u_r0
#define Q mccan8u_Q
#define DM mccan8u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 18017 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an9l' [108]. */
#define mccompcurname  an9l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 108
#define mos_rms_y mccan9l_mos_rms_y
#define mos_rms_z mccan9l_mos_rms_z
#define mos_rms_max mccan9l_mos_rms_max
#define mono_Q mccan9l_mono_Q
#define zmin mccan9l_zmin
#define zmax mccan9l_zmax
#define ymin mccan9l_ymin
#define ymax mccan9l_ymax
#define zwidth mccan9l_zwidth
#define yheight mccan9l_yheight
#define mosaich mccan9l_mosaich
#define mosaicv mccan9l_mosaicv
#define r0 mccan9l_r0
#define Q mccan9l_Q
#define DM mccan9l_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 18061 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'an9u' [109]. */
#define mccompcurname  an9u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 109
#define mos_rms_y mccan9u_mos_rms_y
#define mos_rms_z mccan9u_mos_rms_z
#define mos_rms_max mccan9u_mos_rms_max
#define mono_Q mccan9u_mono_Q
#define zmin mccan9u_zmin
#define zmax mccan9u_zmax
#define ymin mccan9u_ymin
#define ymax mccan9u_ymax
#define zwidth mccan9u_zwidth
#define yheight mccan9u_yheight
#define mosaich mccan9u_mosaich
#define mosaicv mccan9u_mosaicv
#define r0 mccan9u_r0
#define Q mccan9u_Q
#define DM mccan9u_DM
#line 95 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
#line 18105 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'a6' [110]. */
#define mccompcurname  a6
#define mccompcurtype  Arm
#define mccompcurindex 110
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_before_coarse' [111]. */
#define mccompcurname  emon_before_coarse
#define mccompcurtype  E_monitor
#define mccompcurindex 111
#define nE mccemon_before_coarse_nE
#define E_N mccemon_before_coarse_E_N
#define E_p mccemon_before_coarse_E_p
#define E_p2 mccemon_before_coarse_E_p2
#define S_p mccemon_before_coarse_S_p
#define S_pE mccemon_before_coarse_S_pE
#define S_pE2 mccemon_before_coarse_S_pE2
#define filename mccemon_before_coarse_filename
#define xmin mccemon_before_coarse_xmin
#define xmax mccemon_before_coarse_xmax
#define ymin mccemon_before_coarse_ymin
#define ymax mccemon_before_coarse_ymax
#define xwidth mccemon_before_coarse_xwidth
#define yheight mccemon_before_coarse_yheight
#define Emin mccemon_before_coarse_Emin
#define Emax mccemon_before_coarse_Emax
#define restore_neutron mccemon_before_coarse_restore_neutron
#define nowritefile mccemon_before_coarse_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 18159 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_before_coarse' [112]. */
#define mccompcurname  psd_before_coarse
#define mccompcurtype  PSD_monitor
#define mccompcurindex 112
#define nx mccpsd_before_coarse_nx
#define ny mccpsd_before_coarse_ny
#define PSD_N mccpsd_before_coarse_PSD_N
#define PSD_p mccpsd_before_coarse_PSD_p
#define PSD_p2 mccpsd_before_coarse_PSD_p2
#define filename mccpsd_before_coarse_filename
#define xmin mccpsd_before_coarse_xmin
#define xmax mccpsd_before_coarse_xmax
#define ymin mccpsd_before_coarse_ymin
#define ymax mccpsd_before_coarse_ymax
#define xwidth mccpsd_before_coarse_xwidth
#define yheight mccpsd_before_coarse_yheight
#define restore_neutron mccpsd_before_coarse_restore_neutron
#define nowritefile mccpsd_before_coarse_nowritefile
#line 56 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 18204 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmR1' [113]. */
#define mccompcurname  ArmR1
#define mccompcurtype  Arm
#define mccompcurindex 113
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeR1' [114]. */
#define mccompcurname  BladeR1
#define mccompcurtype  Absorber
#define mccompcurindex 114
#define xw mccBladeR1_xw
#define yh mccBladeR1_yh
#define zt mccBladeR1_zt
#define xm mccBladeR1_xm
#define ym mccBladeR1_ym
#define zm mccBladeR1_zm
#define xmin mccBladeR1_xmin
#define xmax mccBladeR1_xmax
#define ymin mccBladeR1_ymin
#define ymax mccBladeR1_ymax
#define zmin mccBladeR1_zmin
#define zmax mccBladeR1_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18249 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmR2' [115]. */
#define mccompcurname  ArmR2
#define mccompcurtype  Arm
#define mccompcurindex 115
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeR2' [116]. */
#define mccompcurname  BladeR2
#define mccompcurtype  Absorber
#define mccompcurindex 116
#define xw mccBladeR2_xw
#define yh mccBladeR2_yh
#define zt mccBladeR2_zt
#define xm mccBladeR2_xm
#define ym mccBladeR2_ym
#define zm mccBladeR2_zm
#define xmin mccBladeR2_xmin
#define xmax mccBladeR2_xmax
#define ymin mccBladeR2_ymin
#define ymax mccBladeR2_ymax
#define zmin mccBladeR2_zmin
#define zmax mccBladeR2_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18292 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmR3' [117]. */
#define mccompcurname  ArmR3
#define mccompcurtype  Arm
#define mccompcurindex 117
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeR3' [118]. */
#define mccompcurname  BladeR3
#define mccompcurtype  Absorber
#define mccompcurindex 118
#define xw mccBladeR3_xw
#define yh mccBladeR3_yh
#define zt mccBladeR3_zt
#define xm mccBladeR3_xm
#define ym mccBladeR3_ym
#define zm mccBladeR3_zm
#define xmin mccBladeR3_xmin
#define xmax mccBladeR3_xmax
#define ymin mccBladeR3_ymin
#define ymax mccBladeR3_ymax
#define zmin mccBladeR3_zmin
#define zmax mccBladeR3_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18335 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmR4' [119]. */
#define mccompcurname  ArmR4
#define mccompcurtype  Arm
#define mccompcurindex 119
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeR4' [120]. */
#define mccompcurname  BladeR4
#define mccompcurtype  Absorber
#define mccompcurindex 120
#define xw mccBladeR4_xw
#define yh mccBladeR4_yh
#define zt mccBladeR4_zt
#define xm mccBladeR4_xm
#define ym mccBladeR4_ym
#define zm mccBladeR4_zm
#define xmin mccBladeR4_xmin
#define xmax mccBladeR4_xmax
#define ymin mccBladeR4_ymin
#define ymax mccBladeR4_ymax
#define zmin mccBladeR4_zmin
#define zmax mccBladeR4_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18378 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmR5' [121]. */
#define mccompcurname  ArmR5
#define mccompcurtype  Arm
#define mccompcurindex 121
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeR5' [122]. */
#define mccompcurname  BladeR5
#define mccompcurtype  Absorber
#define mccompcurindex 122
#define xw mccBladeR5_xw
#define yh mccBladeR5_yh
#define zt mccBladeR5_zt
#define xm mccBladeR5_xm
#define ym mccBladeR5_ym
#define zm mccBladeR5_zm
#define xmin mccBladeR5_xmin
#define xmax mccBladeR5_xmax
#define ymin mccBladeR5_ymin
#define ymax mccBladeR5_ymax
#define zmin mccBladeR5_zmin
#define zmax mccBladeR5_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18421 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmL1' [123]. */
#define mccompcurname  ArmL1
#define mccompcurtype  Arm
#define mccompcurindex 123
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeL1' [124]. */
#define mccompcurname  BladeL1
#define mccompcurtype  Absorber
#define mccompcurindex 124
#define xw mccBladeL1_xw
#define yh mccBladeL1_yh
#define zt mccBladeL1_zt
#define xm mccBladeL1_xm
#define ym mccBladeL1_ym
#define zm mccBladeL1_zm
#define xmin mccBladeL1_xmin
#define xmax mccBladeL1_xmax
#define ymin mccBladeL1_ymin
#define ymax mccBladeL1_ymax
#define zmin mccBladeL1_zmin
#define zmax mccBladeL1_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18464 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmL2' [125]. */
#define mccompcurname  ArmL2
#define mccompcurtype  Arm
#define mccompcurindex 125
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeL2' [126]. */
#define mccompcurname  BladeL2
#define mccompcurtype  Absorber
#define mccompcurindex 126
#define xw mccBladeL2_xw
#define yh mccBladeL2_yh
#define zt mccBladeL2_zt
#define xm mccBladeL2_xm
#define ym mccBladeL2_ym
#define zm mccBladeL2_zm
#define xmin mccBladeL2_xmin
#define xmax mccBladeL2_xmax
#define ymin mccBladeL2_ymin
#define ymax mccBladeL2_ymax
#define zmin mccBladeL2_zmin
#define zmax mccBladeL2_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18507 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmL3' [127]. */
#define mccompcurname  ArmL3
#define mccompcurtype  Arm
#define mccompcurindex 127
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeL3' [128]. */
#define mccompcurname  BladeL3
#define mccompcurtype  Absorber
#define mccompcurindex 128
#define xw mccBladeL3_xw
#define yh mccBladeL3_yh
#define zt mccBladeL3_zt
#define xm mccBladeL3_xm
#define ym mccBladeL3_ym
#define zm mccBladeL3_zm
#define xmin mccBladeL3_xmin
#define xmax mccBladeL3_xmax
#define ymin mccBladeL3_ymin
#define ymax mccBladeL3_ymax
#define zmin mccBladeL3_zmin
#define zmax mccBladeL3_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18550 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmL4' [129]. */
#define mccompcurname  ArmL4
#define mccompcurtype  Arm
#define mccompcurindex 129
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeL4' [130]. */
#define mccompcurname  BladeL4
#define mccompcurtype  Absorber
#define mccompcurindex 130
#define xw mccBladeL4_xw
#define yh mccBladeL4_yh
#define zt mccBladeL4_zt
#define xm mccBladeL4_xm
#define ym mccBladeL4_ym
#define zm mccBladeL4_zm
#define xmin mccBladeL4_xmin
#define xmax mccBladeL4_xmax
#define ymin mccBladeL4_ymin
#define ymax mccBladeL4_ymax
#define zmin mccBladeL4_zmin
#define zmax mccBladeL4_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18593 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmL5' [131]. */
#define mccompcurname  ArmL5
#define mccompcurtype  Arm
#define mccompcurindex 131
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BladeL5' [132]. */
#define mccompcurname  BladeL5
#define mccompcurtype  Absorber
#define mccompcurindex 132
#define xw mccBladeL5_xw
#define yh mccBladeL5_yh
#define zt mccBladeL5_zt
#define xm mccBladeL5_xm
#define ym mccBladeL5_ym
#define zm mccBladeL5_zm
#define xmin mccBladeL5_xmin
#define xmax mccBladeL5_xmax
#define ymin mccBladeL5_ymin
#define ymax mccBladeL5_ymax
#define zmin mccBladeL5_zmin
#define zmax mccBladeL5_zmax
#line 43 "/usr/share/mcstas/2.5/optics/Absorber.comp"
double t0,t1,xp,yp,zp,xm,ym,zm,xw, yh, zt;
#line 18636 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_detector' [133]. */
#define mccompcurname  psd_detector
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 133
#define nx mccpsd_detector_nx
#define ny mccpsd_detector_ny
#define filename mccpsd_detector_filename
#define PSD_N mccpsd_detector_PSD_N
#define PSD_p mccpsd_detector_PSD_p
#define PSD_p2 mccpsd_detector_PSD_p2
#define weight mccpsd_detector_weight
#define xmin mccpsd_detector_xmin
#define xmax mccpsd_detector_xmax
#define ymin mccpsd_detector_ymin
#define ymax mccpsd_detector_ymax
#define xwidth mccpsd_detector_xwidth
#define yheight mccpsd_detector_yheight
#define psf mccpsd_detector_psf
#define k0 mccpsd_detector_k0
#define eff mccpsd_detector_eff
#define restore_neutron mccpsd_detector_restore_neutron
#define nowritefile mccpsd_detector_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 18680 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_detector' [134]. */
#define mccompcurname  emon_detector
#define mccompcurtype  E_monitor
#define mccompcurindex 134
#define nE mccemon_detector_nE
#define E_N mccemon_detector_E_N
#define E_p mccemon_detector_E_p
#define E_p2 mccemon_detector_E_p2
#define S_p mccemon_detector_S_p
#define S_pE mccemon_detector_S_pE
#define S_pE2 mccemon_detector_S_pE2
#define filename mccemon_detector_filename
#define xmin mccemon_detector_xmin
#define xmax mccemon_detector_xmax
#define ymin mccemon_detector_ymin
#define ymax mccemon_detector_ymax
#define xwidth mccemon_detector_xwidth
#define yheight mccemon_detector_yheight
#define Emin mccemon_detector_Emin
#define Emax mccemon_detector_Emax
#define restore_neutron mccemon_detector_restore_neutron
#define nowritefile mccemon_detector_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 18729 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window1' [135]. */
#define mccompcurname  psd_window1
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 135
#define nx mccpsd_window1_nx
#define ny mccpsd_window1_ny
#define filename mccpsd_window1_filename
#define PSD_N mccpsd_window1_PSD_N
#define PSD_p mccpsd_window1_PSD_p
#define PSD_p2 mccpsd_window1_PSD_p2
#define weight mccpsd_window1_weight
#define xmin mccpsd_window1_xmin
#define xmax mccpsd_window1_xmax
#define ymin mccpsd_window1_ymin
#define ymax mccpsd_window1_ymax
#define xwidth mccpsd_window1_xwidth
#define yheight mccpsd_window1_yheight
#define psf mccpsd_window1_psf
#define k0 mccpsd_window1_k0
#define eff mccpsd_window1_eff
#define restore_neutron mccpsd_window1_restore_neutron
#define nowritefile mccpsd_window1_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 18779 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window1' [136]. */
#define mccompcurname  emon_window1
#define mccompcurtype  E_monitor
#define mccompcurindex 136
#define nE mccemon_window1_nE
#define E_N mccemon_window1_E_N
#define E_p mccemon_window1_E_p
#define E_p2 mccemon_window1_E_p2
#define S_p mccemon_window1_S_p
#define S_pE mccemon_window1_S_pE
#define S_pE2 mccemon_window1_S_pE2
#define filename mccemon_window1_filename
#define xmin mccemon_window1_xmin
#define xmax mccemon_window1_xmax
#define ymin mccemon_window1_ymin
#define ymax mccemon_window1_ymax
#define xwidth mccemon_window1_xwidth
#define yheight mccemon_window1_yheight
#define Emin mccemon_window1_Emin
#define Emax mccemon_window1_Emax
#define restore_neutron mccemon_window1_restore_neutron
#define nowritefile mccemon_window1_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 18828 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window2' [137]. */
#define mccompcurname  psd_window2
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 137
#define nx mccpsd_window2_nx
#define ny mccpsd_window2_ny
#define filename mccpsd_window2_filename
#define PSD_N mccpsd_window2_PSD_N
#define PSD_p mccpsd_window2_PSD_p
#define PSD_p2 mccpsd_window2_PSD_p2
#define weight mccpsd_window2_weight
#define xmin mccpsd_window2_xmin
#define xmax mccpsd_window2_xmax
#define ymin mccpsd_window2_ymin
#define ymax mccpsd_window2_ymax
#define xwidth mccpsd_window2_xwidth
#define yheight mccpsd_window2_yheight
#define psf mccpsd_window2_psf
#define k0 mccpsd_window2_k0
#define eff mccpsd_window2_eff
#define restore_neutron mccpsd_window2_restore_neutron
#define nowritefile mccpsd_window2_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 18878 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window2' [138]. */
#define mccompcurname  emon_window2
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccemon_window2_nE
#define E_N mccemon_window2_E_N
#define E_p mccemon_window2_E_p
#define E_p2 mccemon_window2_E_p2
#define S_p mccemon_window2_S_p
#define S_pE mccemon_window2_S_pE
#define S_pE2 mccemon_window2_S_pE2
#define filename mccemon_window2_filename
#define xmin mccemon_window2_xmin
#define xmax mccemon_window2_xmax
#define ymin mccemon_window2_ymin
#define ymax mccemon_window2_ymax
#define xwidth mccemon_window2_xwidth
#define yheight mccemon_window2_yheight
#define Emin mccemon_window2_Emin
#define Emax mccemon_window2_Emax
#define restore_neutron mccemon_window2_restore_neutron
#define nowritefile mccemon_window2_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 18927 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window3' [139]. */
#define mccompcurname  psd_window3
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 139
#define nx mccpsd_window3_nx
#define ny mccpsd_window3_ny
#define filename mccpsd_window3_filename
#define PSD_N mccpsd_window3_PSD_N
#define PSD_p mccpsd_window3_PSD_p
#define PSD_p2 mccpsd_window3_PSD_p2
#define weight mccpsd_window3_weight
#define xmin mccpsd_window3_xmin
#define xmax mccpsd_window3_xmax
#define ymin mccpsd_window3_ymin
#define ymax mccpsd_window3_ymax
#define xwidth mccpsd_window3_xwidth
#define yheight mccpsd_window3_yheight
#define psf mccpsd_window3_psf
#define k0 mccpsd_window3_k0
#define eff mccpsd_window3_eff
#define restore_neutron mccpsd_window3_restore_neutron
#define nowritefile mccpsd_window3_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 18977 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window3' [140]. */
#define mccompcurname  emon_window3
#define mccompcurtype  E_monitor
#define mccompcurindex 140
#define nE mccemon_window3_nE
#define E_N mccemon_window3_E_N
#define E_p mccemon_window3_E_p
#define E_p2 mccemon_window3_E_p2
#define S_p mccemon_window3_S_p
#define S_pE mccemon_window3_S_pE
#define S_pE2 mccemon_window3_S_pE2
#define filename mccemon_window3_filename
#define xmin mccemon_window3_xmin
#define xmax mccemon_window3_xmax
#define ymin mccemon_window3_ymin
#define ymax mccemon_window3_ymax
#define xwidth mccemon_window3_xwidth
#define yheight mccemon_window3_yheight
#define Emin mccemon_window3_Emin
#define Emax mccemon_window3_Emax
#define restore_neutron mccemon_window3_restore_neutron
#define nowritefile mccemon_window3_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 19026 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window4' [141]. */
#define mccompcurname  psd_window4
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 141
#define nx mccpsd_window4_nx
#define ny mccpsd_window4_ny
#define filename mccpsd_window4_filename
#define PSD_N mccpsd_window4_PSD_N
#define PSD_p mccpsd_window4_PSD_p
#define PSD_p2 mccpsd_window4_PSD_p2
#define weight mccpsd_window4_weight
#define xmin mccpsd_window4_xmin
#define xmax mccpsd_window4_xmax
#define ymin mccpsd_window4_ymin
#define ymax mccpsd_window4_ymax
#define xwidth mccpsd_window4_xwidth
#define yheight mccpsd_window4_yheight
#define psf mccpsd_window4_psf
#define k0 mccpsd_window4_k0
#define eff mccpsd_window4_eff
#define restore_neutron mccpsd_window4_restore_neutron
#define nowritefile mccpsd_window4_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 19076 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window4' [142]. */
#define mccompcurname  emon_window4
#define mccompcurtype  E_monitor
#define mccompcurindex 142
#define nE mccemon_window4_nE
#define E_N mccemon_window4_E_N
#define E_p mccemon_window4_E_p
#define E_p2 mccemon_window4_E_p2
#define S_p mccemon_window4_S_p
#define S_pE mccemon_window4_S_pE
#define S_pE2 mccemon_window4_S_pE2
#define filename mccemon_window4_filename
#define xmin mccemon_window4_xmin
#define xmax mccemon_window4_xmax
#define ymin mccemon_window4_ymin
#define ymax mccemon_window4_ymax
#define xwidth mccemon_window4_xwidth
#define yheight mccemon_window4_yheight
#define Emin mccemon_window4_Emin
#define Emax mccemon_window4_Emax
#define restore_neutron mccemon_window4_restore_neutron
#define nowritefile mccemon_window4_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 19125 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window5' [143]. */
#define mccompcurname  psd_window5
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 143
#define nx mccpsd_window5_nx
#define ny mccpsd_window5_ny
#define filename mccpsd_window5_filename
#define PSD_N mccpsd_window5_PSD_N
#define PSD_p mccpsd_window5_PSD_p
#define PSD_p2 mccpsd_window5_PSD_p2
#define weight mccpsd_window5_weight
#define xmin mccpsd_window5_xmin
#define xmax mccpsd_window5_xmax
#define ymin mccpsd_window5_ymin
#define ymax mccpsd_window5_ymax
#define xwidth mccpsd_window5_xwidth
#define yheight mccpsd_window5_yheight
#define psf mccpsd_window5_psf
#define k0 mccpsd_window5_k0
#define eff mccpsd_window5_eff
#define restore_neutron mccpsd_window5_restore_neutron
#define nowritefile mccpsd_window5_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 19175 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window5' [144]. */
#define mccompcurname  emon_window5
#define mccompcurtype  E_monitor
#define mccompcurindex 144
#define nE mccemon_window5_nE
#define E_N mccemon_window5_E_N
#define E_p mccemon_window5_E_p
#define E_p2 mccemon_window5_E_p2
#define S_p mccemon_window5_S_p
#define S_pE mccemon_window5_S_pE
#define S_pE2 mccemon_window5_S_pE2
#define filename mccemon_window5_filename
#define xmin mccemon_window5_xmin
#define xmax mccemon_window5_xmax
#define ymin mccemon_window5_ymin
#define ymax mccemon_window5_ymax
#define xwidth mccemon_window5_xwidth
#define yheight mccemon_window5_yheight
#define Emin mccemon_window5_Emin
#define Emax mccemon_window5_Emax
#define restore_neutron mccemon_window5_restore_neutron
#define nowritefile mccemon_window5_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 19224 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window6' [145]. */
#define mccompcurname  psd_window6
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 145
#define nx mccpsd_window6_nx
#define ny mccpsd_window6_ny
#define filename mccpsd_window6_filename
#define PSD_N mccpsd_window6_PSD_N
#define PSD_p mccpsd_window6_PSD_p
#define PSD_p2 mccpsd_window6_PSD_p2
#define weight mccpsd_window6_weight
#define xmin mccpsd_window6_xmin
#define xmax mccpsd_window6_xmax
#define ymin mccpsd_window6_ymin
#define ymax mccpsd_window6_ymax
#define xwidth mccpsd_window6_xwidth
#define yheight mccpsd_window6_yheight
#define psf mccpsd_window6_psf
#define k0 mccpsd_window6_k0
#define eff mccpsd_window6_eff
#define restore_neutron mccpsd_window6_restore_neutron
#define nowritefile mccpsd_window6_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 19274 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window6' [146]. */
#define mccompcurname  emon_window6
#define mccompcurtype  E_monitor
#define mccompcurindex 146
#define nE mccemon_window6_nE
#define E_N mccemon_window6_E_N
#define E_p mccemon_window6_E_p
#define E_p2 mccemon_window6_E_p2
#define S_p mccemon_window6_S_p
#define S_pE mccemon_window6_S_pE
#define S_pE2 mccemon_window6_S_pE2
#define filename mccemon_window6_filename
#define xmin mccemon_window6_xmin
#define xmax mccemon_window6_xmax
#define ymin mccemon_window6_ymin
#define ymax mccemon_window6_ymax
#define xwidth mccemon_window6_xwidth
#define yheight mccemon_window6_yheight
#define Emin mccemon_window6_Emin
#define Emax mccemon_window6_Emax
#define restore_neutron mccemon_window6_restore_neutron
#define nowritefile mccemon_window6_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 19323 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window7' [147]. */
#define mccompcurname  psd_window7
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 147
#define nx mccpsd_window7_nx
#define ny mccpsd_window7_ny
#define filename mccpsd_window7_filename
#define PSD_N mccpsd_window7_PSD_N
#define PSD_p mccpsd_window7_PSD_p
#define PSD_p2 mccpsd_window7_PSD_p2
#define weight mccpsd_window7_weight
#define xmin mccpsd_window7_xmin
#define xmax mccpsd_window7_xmax
#define ymin mccpsd_window7_ymin
#define ymax mccpsd_window7_ymax
#define xwidth mccpsd_window7_xwidth
#define yheight mccpsd_window7_yheight
#define psf mccpsd_window7_psf
#define k0 mccpsd_window7_k0
#define eff mccpsd_window7_eff
#define restore_neutron mccpsd_window7_restore_neutron
#define nowritefile mccpsd_window7_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 19373 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window7' [148]. */
#define mccompcurname  emon_window7
#define mccompcurtype  E_monitor
#define mccompcurindex 148
#define nE mccemon_window7_nE
#define E_N mccemon_window7_E_N
#define E_p mccemon_window7_E_p
#define E_p2 mccemon_window7_E_p2
#define S_p mccemon_window7_S_p
#define S_pE mccemon_window7_S_pE
#define S_pE2 mccemon_window7_S_pE2
#define filename mccemon_window7_filename
#define xmin mccemon_window7_xmin
#define xmax mccemon_window7_xmax
#define ymin mccemon_window7_ymin
#define ymax mccemon_window7_ymax
#define xwidth mccemon_window7_xwidth
#define yheight mccemon_window7_yheight
#define Emin mccemon_window7_Emin
#define Emax mccemon_window7_Emax
#define restore_neutron mccemon_window7_restore_neutron
#define nowritefile mccemon_window7_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 19422 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window8' [149]. */
#define mccompcurname  psd_window8
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 149
#define nx mccpsd_window8_nx
#define ny mccpsd_window8_ny
#define filename mccpsd_window8_filename
#define PSD_N mccpsd_window8_PSD_N
#define PSD_p mccpsd_window8_PSD_p
#define PSD_p2 mccpsd_window8_PSD_p2
#define weight mccpsd_window8_weight
#define xmin mccpsd_window8_xmin
#define xmax mccpsd_window8_xmax
#define ymin mccpsd_window8_ymin
#define ymax mccpsd_window8_ymax
#define xwidth mccpsd_window8_xwidth
#define yheight mccpsd_window8_yheight
#define psf mccpsd_window8_psf
#define k0 mccpsd_window8_k0
#define eff mccpsd_window8_eff
#define restore_neutron mccpsd_window8_restore_neutron
#define nowritefile mccpsd_window8_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 19472 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window8' [150]. */
#define mccompcurname  emon_window8
#define mccompcurtype  E_monitor
#define mccompcurindex 150
#define nE mccemon_window8_nE
#define E_N mccemon_window8_E_N
#define E_p mccemon_window8_E_p
#define E_p2 mccemon_window8_E_p2
#define S_p mccemon_window8_S_p
#define S_pE mccemon_window8_S_pE
#define S_pE2 mccemon_window8_S_pE2
#define filename mccemon_window8_filename
#define xmin mccemon_window8_xmin
#define xmax mccemon_window8_xmax
#define ymin mccemon_window8_ymin
#define ymax mccemon_window8_ymax
#define xwidth mccemon_window8_xwidth
#define yheight mccemon_window8_yheight
#define Emin mccemon_window8_Emin
#define Emax mccemon_window8_Emax
#define restore_neutron mccemon_window8_restore_neutron
#define nowritefile mccemon_window8_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 19521 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_window9' [151]. */
#define mccompcurname  psd_window9
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 151
#define nx mccpsd_window9_nx
#define ny mccpsd_window9_ny
#define filename mccpsd_window9_filename
#define PSD_N mccpsd_window9_PSD_N
#define PSD_p mccpsd_window9_PSD_p
#define PSD_p2 mccpsd_window9_PSD_p2
#define weight mccpsd_window9_weight
#define xmin mccpsd_window9_xmin
#define xmax mccpsd_window9_xmax
#define ymin mccpsd_window9_ymin
#define ymax mccpsd_window9_ymax
#define xwidth mccpsd_window9_xwidth
#define yheight mccpsd_window9_yheight
#define psf mccpsd_window9_psf
#define k0 mccpsd_window9_k0
#define eff mccpsd_window9_eff
#define restore_neutron mccpsd_window9_restore_neutron
#define nowritefile mccpsd_window9_nowritefile
#line 59 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
double weight;
#line 19571 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'emon_window9' [152]. */
#define mccompcurname  emon_window9
#define mccompcurtype  E_monitor
#define mccompcurindex 152
#define nE mccemon_window9_nE
#define E_N mccemon_window9_E_N
#define E_p mccemon_window9_E_p
#define E_p2 mccemon_window9_E_p2
#define S_p mccemon_window9_S_p
#define S_pE mccemon_window9_S_pE
#define S_pE2 mccemon_window9_S_pE2
#define filename mccemon_window9_filename
#define xmin mccemon_window9_xmin
#define xmax mccemon_window9_xmax
#define ymin mccemon_window9_ymin
#define ymax mccemon_window9_ymax
#define xwidth mccemon_window9_xwidth
#define yheight mccemon_window9_yheight
#define Emin mccemon_window9_Emin
#define Emax mccemon_window9_Emax
#define restore_neutron mccemon_window9_restore_neutron
#define nowritefile mccemon_window9_nowritefile
#line 60 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 19620 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

Coords mcposaarmSource, mcposrarmSource;
Rotation mcrotaarmSource, mcrotrarmSource;
Coords mcposasource, mcposrsource;
Rotation mcrotasource, mcrotrsource;
Coords mcposaslitGuideBegin, mcposrslitGuideBegin;
Rotation mcrotaslitGuideBegin, mcrotrslitGuideBegin;
Coords mcposalmon_guide_start, mcposrlmon_guide_start;
Rotation mcrotalmon_guide_start, mcrotrlmon_guide_start;
Coords mcposaguideStraight, mcposrguideStraight;
Rotation mcrotaguideStraight, mcrotrguideStraight;
Coords mcposaguideCurved1, mcposrguideCurved1;
Rotation mcrotaguideCurved1, mcrotrguideCurved1;
Coords mcposaguideCurved2, mcposrguideCurved2;
Rotation mcrotaguideCurved2, mcrotrguideCurved2;
Coords mcposaguideCurved3, mcposrguideCurved3;
Rotation mcrotaguideCurved3, mcrotrguideCurved3;
Coords mcposaguideCurved4, mcposrguideCurved4;
Rotation mcrotaguideCurved4, mcrotrguideCurved4;
Coords mcposaguideCurved5, mcposrguideCurved5;
Rotation mcrotaguideCurved5, mcrotrguideCurved5;
Coords mcposaguideCurved6, mcposrguideCurved6;
Rotation mcrotaguideCurved6, mcrotrguideCurved6;
Coords mcposaguideCurved7, mcposrguideCurved7;
Rotation mcrotaguideCurved7, mcrotrguideCurved7;
Coords mcposaguideCurved8, mcposrguideCurved8;
Rotation mcrotaguideCurved8, mcrotrguideCurved8;
Coords mcposaguideCurved9, mcposrguideCurved9;
Rotation mcrotaguideCurved9, mcrotrguideCurved9;
Coords mcposaguideCurved10, mcposrguideCurved10;
Rotation mcrotaguideCurved10, mcrotrguideCurved10;
Coords mcposaguideCurved11, mcposrguideCurved11;
Rotation mcrotaguideCurved11, mcrotrguideCurved11;
Coords mcposaguideCurved12, mcposrguideCurved12;
Rotation mcrotaguideCurved12, mcrotrguideCurved12;
Coords mcposaguideCurved13, mcposrguideCurved13;
Rotation mcrotaguideCurved13, mcrotrguideCurved13;
Coords mcposaguideCurved14, mcposrguideCurved14;
Rotation mcrotaguideCurved14, mcrotrguideCurved14;
Coords mcposaguideCurved15, mcposrguideCurved15;
Rotation mcrotaguideCurved15, mcrotrguideCurved15;
Coords mcposaguideCurved16, mcposrguideCurved16;
Rotation mcrotaguideCurved16, mcrotrguideCurved16;
Coords mcposaguideCurved17, mcposrguideCurved17;
Rotation mcrotaguideCurved17, mcrotrguideCurved17;
Coords mcposaguideCurved18, mcposrguideCurved18;
Rotation mcrotaguideCurved18, mcrotrguideCurved18;
Coords mcposaguideCurved19, mcposrguideCurved19;
Rotation mcrotaguideCurved19, mcrotrguideCurved19;
Coords mcposaguideCurved20, mcposrguideCurved20;
Rotation mcrotaguideCurved20, mcrotrguideCurved20;
Coords mcposaguideCurved21, mcposrguideCurved21;
Rotation mcrotaguideCurved21, mcrotrguideCurved21;
Coords mcposaguideCurved22, mcposrguideCurved22;
Rotation mcrotaguideCurved22, mcrotrguideCurved22;
Coords mcposaguideCurved23, mcposrguideCurved23;
Rotation mcrotaguideCurved23, mcrotrguideCurved23;
Coords mcposaguideCurved24, mcposrguideCurved24;
Rotation mcrotaguideCurved24, mcrotrguideCurved24;
Coords mcposaguideCurved25, mcposrguideCurved25;
Rotation mcrotaguideCurved25, mcrotrguideCurved25;
Coords mcposaguideCurved26, mcposrguideCurved26;
Rotation mcrotaguideCurved26, mcrotrguideCurved26;
Coords mcposaguideCurved27, mcposrguideCurved27;
Rotation mcrotaguideCurved27, mcrotrguideCurved27;
Coords mcposaguideCurved28, mcposrguideCurved28;
Rotation mcrotaguideCurved28, mcrotrguideCurved28;
Coords mcposaguideCurved29, mcposrguideCurved29;
Rotation mcrotaguideCurved29, mcrotrguideCurved29;
Coords mcposaguideCurved30, mcposrguideCurved30;
Rotation mcrotaguideCurved30, mcrotrguideCurved30;
Coords mcposaguideCurved31, mcposrguideCurved31;
Rotation mcrotaguideCurved31, mcrotrguideCurved31;
Coords mcposaguideCurved32, mcposrguideCurved32;
Rotation mcrotaguideCurved32, mcrotrguideCurved32;
Coords mcposaguideCurved33, mcposrguideCurved33;
Rotation mcrotaguideCurved33, mcrotrguideCurved33;
Coords mcposaguideCurved34, mcposrguideCurved34;
Rotation mcrotaguideCurved34, mcrotrguideCurved34;
Coords mcposaguideCurved35, mcposrguideCurved35;
Rotation mcrotaguideCurved35, mcrotrguideCurved35;
Coords mcposaguideCurved36, mcposrguideCurved36;
Rotation mcrotaguideCurved36, mcrotrguideCurved36;
Coords mcposaguideCurved37, mcposrguideCurved37;
Rotation mcrotaguideCurved37, mcrotrguideCurved37;
Coords mcposaguideCurved38, mcposrguideCurved38;
Rotation mcrotaguideCurved38, mcrotrguideCurved38;
Coords mcposaguideCurved39, mcposrguideCurved39;
Rotation mcrotaguideCurved39, mcrotrguideCurved39;
Coords mcposaguideCurved40, mcposrguideCurved40;
Rotation mcrotaguideCurved40, mcrotrguideCurved40;
Coords mcposabunker, mcposrbunker;
Rotation mcrotabunker, mcrotrbunker;
Coords mcposaguide3, mcposrguide3;
Rotation mcrotaguide3, mcrotrguide3;
Coords mcposaslitGuideEnd, mcposrslitGuideEnd;
Rotation mcrotaslitGuideEnd, mcrotrslitGuideEnd;
Coords mcposapsd_guide_end, mcposrpsd_guide_end;
Rotation mcrotapsd_guide_end, mcrotrpsd_guide_end;
Coords mcposaemon_guide_end, mcposremon_guide_end;
Rotation mcrotaemon_guide_end, mcrotremon_guide_end;
Coords mcposalmon_guide_end, mcposrlmon_guide_end;
Rotation mcrotalmon_guide_end, mcrotrlmon_guide_end;
Coords mcposadivmon_guide_end, mcposrdivmon_guide_end;
Rotation mcrotadivmon_guide_end, mcrotrdivmon_guide_end;
Coords mcposafocus_mono, mcposrfocus_mono;
Rotation mcrotafocus_mono, mcrotrfocus_mono;
Coords mcposamonochromator_curved, mcposrmonochromator_curved;
Rotation mcrotamonochromator_curved, mcrotrmonochromator_curved;
Coords mcposaa2, mcposra2;
Rotation mcrotaa2, mcrotra2;
Coords mcposaslitShutter, mcposrslitShutter;
Rotation mcrotaslitShutter, mcrotrslitShutter;
Coords mcposaMSCollimator, mcposrMSCollimator;
Rotation mcrotaMSCollimator, mcrotrMSCollimator;
Coords mcposainfilter, mcposrinfilter;
Rotation mcrotainfilter, mcrotrinfilter;
Coords mcposapsd_virt, mcposrpsd_virt;
Rotation mcrotapsd_virt, mcrotrpsd_virt;
Coords mcposalmon_virt, mcposrlmon_virt;
Rotation mcrotalmon_virt, mcrotrlmon_virt;
Coords mcposaaa2, mcposraa2;
Rotation mcrotaaa2, mcrotraa2;
Coords mcposavirtualout, mcposrvirtualout;
Rotation mcrotavirtualout, mcrotrvirtualout;
Coords mcposavirtualsource, mcposrvirtualsource;
Rotation mcrotavirtualsource, mcrotrvirtualsource;
Coords mcposaOrderMon, mcposrOrderMon;
Rotation mcrotaOrderMon, mcrotrOrderMon;
Coords mcposakMoni, mcposrkMoni;
Rotation mcrotakMoni, mcrotrkMoni;
Coords mcposakMoni1st, mcposrkMoni1st;
Rotation mcrotakMoni1st, mcrotrkMoni1st;
Coords mcposakMoni2nd, mcposrkMoni2nd;
Rotation mcrotakMoni2nd, mcrotrkMoni2nd;
Coords mcposakMoni3rd, mcposrkMoni3rd;
Rotation mcrotakMoni3rd, mcrotrkMoni3rd;
Coords mcposaslitMonochromator, mcposrslitMonochromator;
Rotation mcrotaslitMonochromator, mcrotrslitMonochromator;
Coords mcposaPerspex, mcposrPerspex;
Rotation mcrotaPerspex, mcrotrPerspex;
Coords mcposapsd_samplepos_1cm2, mcposrpsd_samplepos_1cm2;
Rotation mcrotapsd_samplepos_1cm2, mcrotrpsd_samplepos_1cm2;
Coords mcposaemon_samplepos_1cm2, mcposremon_samplepos_1cm2;
Rotation mcrotaemon_samplepos_1cm2, mcrotremon_samplepos_1cm2;
Coords mcposadivmon_samplepos_1cm2, mcposrdivmon_samplepos_1cm2;
Rotation mcrotadivmon_samplepos_1cm2, mcrotrdivmon_samplepos_1cm2;
Coords mcposapsd_samplepos_large, mcposrpsd_samplepos_large;
Rotation mcrotapsd_samplepos_large, mcrotrpsd_samplepos_large;
Coords mcposaa3, mcposra3;
Rotation mcrotaa3, mcrotra3;
Coords mcposaaa3, mcposraa3;
Rotation mcrotaaa3, mcrotraa3;
Coords mcposaincohSample, mcposrincohSample;
Rotation mcrotaincohSample, mcrotrincohSample;
Coords mcposapowderSample, mcposrpowderSample;
Rotation mcrotapowderSample, mcrotrpowderSample;
Coords mcposacrystalSample, mcposrcrystalSample;
Rotation mcrotacrystalSample, mcrotrcrystalSample;
Coords mcposaphononSample, mcposrphononSample;
Rotation mcrotaphononSample, mcrotrphononSample;
Coords mcposapsd_4pi, mcposrpsd_4pi;
Rotation mcrotapsd_4pi, mcrotrpsd_4pi;
Coords mcposaa4, mcposra4;
Rotation mcrotaa4, mcrotra4;
Coords mcposaslitSample, mcposrslitSample;
Rotation mcrotaslitSample, mcrotrslitSample;
Coords mcposafilter_coll, mcposrfilter_coll;
Rotation mcrotafilter_coll, mcrotrfilter_coll;
Coords mcposafilter, mcposrfilter;
Rotation mcrotafilter, mcrotrfilter;
Coords mcposaana_slit1, mcposrana_slit1;
Rotation mcrotaana_slit1, mcrotrana_slit1;
Coords mcposaana_slit2, mcposrana_slit2;
Rotation mcrotaana_slit2, mcrotrana_slit2;
Coords mcposaemon_before_ana, mcposremon_before_ana;
Rotation mcrotaemon_before_ana, mcrotremon_before_ana;
Coords mcposapsd_before_ana, mcposrpsd_before_ana;
Rotation mcrotapsd_before_ana, mcrotrpsd_before_ana;
Coords mcposadivmon_before_ana, mcposrdivmon_before_ana;
Rotation mcrotadivmon_before_ana, mcrotrdivmon_before_ana;
Coords mcposafocus_ana, mcposrfocus_ana;
Rotation mcrotafocus_ana, mcrotrfocus_ana;
Coords mcposaan1l, mcposran1l;
Rotation mcrotaan1l, mcrotran1l;
Coords mcposaan1u, mcposran1u;
Rotation mcrotaan1u, mcrotran1u;
Coords mcposaan2l, mcposran2l;
Rotation mcrotaan2l, mcrotran2l;
Coords mcposaan2u, mcposran2u;
Rotation mcrotaan2u, mcrotran2u;
Coords mcposaan3l, mcposran3l;
Rotation mcrotaan3l, mcrotran3l;
Coords mcposaan3u, mcposran3u;
Rotation mcrotaan3u, mcrotran3u;
Coords mcposaan4l, mcposran4l;
Rotation mcrotaan4l, mcrotran4l;
Coords mcposaan4u, mcposran4u;
Rotation mcrotaan4u, mcrotran4u;
Coords mcposaan5l, mcposran5l;
Rotation mcrotaan5l, mcrotran5l;
Coords mcposaan5u, mcposran5u;
Rotation mcrotaan5u, mcrotran5u;
Coords mcposaan6l, mcposran6l;
Rotation mcrotaan6l, mcrotran6l;
Coords mcposaan6u, mcposran6u;
Rotation mcrotaan6u, mcrotran6u;
Coords mcposaan7l, mcposran7l;
Rotation mcrotaan7l, mcrotran7l;
Coords mcposaan7u, mcposran7u;
Rotation mcrotaan7u, mcrotran7u;
Coords mcposaan8l, mcposran8l;
Rotation mcrotaan8l, mcrotran8l;
Coords mcposaan8u, mcposran8u;
Rotation mcrotaan8u, mcrotran8u;
Coords mcposaan9l, mcposran9l;
Rotation mcrotaan9l, mcrotran9l;
Coords mcposaan9u, mcposran9u;
Rotation mcrotaan9u, mcrotran9u;
Coords mcposaa6, mcposra6;
Rotation mcrotaa6, mcrotra6;
Coords mcposaemon_before_coarse, mcposremon_before_coarse;
Rotation mcrotaemon_before_coarse, mcrotremon_before_coarse;
Coords mcposapsd_before_coarse, mcposrpsd_before_coarse;
Rotation mcrotapsd_before_coarse, mcrotrpsd_before_coarse;
Coords mcposaArmR1, mcposrArmR1;
Rotation mcrotaArmR1, mcrotrArmR1;
Coords mcposaBladeR1, mcposrBladeR1;
Rotation mcrotaBladeR1, mcrotrBladeR1;
Coords mcposaArmR2, mcposrArmR2;
Rotation mcrotaArmR2, mcrotrArmR2;
Coords mcposaBladeR2, mcposrBladeR2;
Rotation mcrotaBladeR2, mcrotrBladeR2;
Coords mcposaArmR3, mcposrArmR3;
Rotation mcrotaArmR3, mcrotrArmR3;
Coords mcposaBladeR3, mcposrBladeR3;
Rotation mcrotaBladeR3, mcrotrBladeR3;
Coords mcposaArmR4, mcposrArmR4;
Rotation mcrotaArmR4, mcrotrArmR4;
Coords mcposaBladeR4, mcposrBladeR4;
Rotation mcrotaBladeR4, mcrotrBladeR4;
Coords mcposaArmR5, mcposrArmR5;
Rotation mcrotaArmR5, mcrotrArmR5;
Coords mcposaBladeR5, mcposrBladeR5;
Rotation mcrotaBladeR5, mcrotrBladeR5;
Coords mcposaArmL1, mcposrArmL1;
Rotation mcrotaArmL1, mcrotrArmL1;
Coords mcposaBladeL1, mcposrBladeL1;
Rotation mcrotaBladeL1, mcrotrBladeL1;
Coords mcposaArmL2, mcposrArmL2;
Rotation mcrotaArmL2, mcrotrArmL2;
Coords mcposaBladeL2, mcposrBladeL2;
Rotation mcrotaBladeL2, mcrotrBladeL2;
Coords mcposaArmL3, mcposrArmL3;
Rotation mcrotaArmL3, mcrotrArmL3;
Coords mcposaBladeL3, mcposrBladeL3;
Rotation mcrotaBladeL3, mcrotrBladeL3;
Coords mcposaArmL4, mcposrArmL4;
Rotation mcrotaArmL4, mcrotrArmL4;
Coords mcposaBladeL4, mcposrBladeL4;
Rotation mcrotaBladeL4, mcrotrBladeL4;
Coords mcposaArmL5, mcposrArmL5;
Rotation mcrotaArmL5, mcrotrArmL5;
Coords mcposaBladeL5, mcposrBladeL5;
Rotation mcrotaBladeL5, mcrotrBladeL5;
Coords mcposapsd_detector, mcposrpsd_detector;
Rotation mcrotapsd_detector, mcrotrpsd_detector;
Coords mcposaemon_detector, mcposremon_detector;
Rotation mcrotaemon_detector, mcrotremon_detector;
Coords mcposapsd_window1, mcposrpsd_window1;
Rotation mcrotapsd_window1, mcrotrpsd_window1;
Coords mcposaemon_window1, mcposremon_window1;
Rotation mcrotaemon_window1, mcrotremon_window1;
Coords mcposapsd_window2, mcposrpsd_window2;
Rotation mcrotapsd_window2, mcrotrpsd_window2;
Coords mcposaemon_window2, mcposremon_window2;
Rotation mcrotaemon_window2, mcrotremon_window2;
Coords mcposapsd_window3, mcposrpsd_window3;
Rotation mcrotapsd_window3, mcrotrpsd_window3;
Coords mcposaemon_window3, mcposremon_window3;
Rotation mcrotaemon_window3, mcrotremon_window3;
Coords mcposapsd_window4, mcposrpsd_window4;
Rotation mcrotapsd_window4, mcrotrpsd_window4;
Coords mcposaemon_window4, mcposremon_window4;
Rotation mcrotaemon_window4, mcrotremon_window4;
Coords mcposapsd_window5, mcposrpsd_window5;
Rotation mcrotapsd_window5, mcrotrpsd_window5;
Coords mcposaemon_window5, mcposremon_window5;
Rotation mcrotaemon_window5, mcrotremon_window5;
Coords mcposapsd_window6, mcposrpsd_window6;
Rotation mcrotapsd_window6, mcrotrpsd_window6;
Coords mcposaemon_window6, mcposremon_window6;
Rotation mcrotaemon_window6, mcrotremon_window6;
Coords mcposapsd_window7, mcposrpsd_window7;
Rotation mcrotapsd_window7, mcrotrpsd_window7;
Coords mcposaemon_window7, mcposremon_window7;
Rotation mcrotaemon_window7, mcrotremon_window7;
Coords mcposapsd_window8, mcposrpsd_window8;
Rotation mcrotapsd_window8, mcrotrpsd_window8;
Coords mcposaemon_window8, mcposremon_window8;
Rotation mcrotaemon_window8, mcrotremon_window8;
Coords mcposapsd_window9, mcposrpsd_window9;
Rotation mcrotapsd_window9, mcrotrpsd_window9;
Coords mcposaemon_window9, mcposremon_window9;
Rotation mcrotaemon_window9, mcrotremon_window9;

MCNUM mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz, mcnt, mcnsx, mcnsy, mcnsz, mcnp;

/* end declare */

void mcinit(void) {
#define mccompcurname  RITA_II
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaRITA_II coords_set(0,0,0)
#define ITAR mcipITAR
#define L0 mcipL0
#define BPL mcipBPL
#define BPH mcipBPH
#define MONO_N mcipMONO_N
#define MONOFORCE mcipMONOFORCE
#define MONO_MOS_H mcipMONO_MOS_H
#define MONO_MOS_V mcipMONO_MOS_V
#define EI mcipEI
#define EF mcipEF
#define EN mcipEN
#define SM mcipSM
#define SS mcipSS
#define SA mcipSA
#define QH mcipQH
#define QK mcipQK
#define QL mcipQL
#define QM mcipQM
#define AS mcipAS
#define BS mcipBS
#define CS mcipCS
#define AA mcipAA
#define BB mcipBB
#define CC mcipCC
#define AH mcipAH
#define AK mcipAK
#define AL mcipAL
#define BH mcipBH
#define BK mcipBK
#define BL mcipBL
#define INFILTER mcipINFILTER
#define INFILTERFILE mcipINFILTERFILE
#define COLL_MS mcipCOLL_MS
#define MST mcipMST
#define MSB mcipMSB
#define MSL mcipMSL
#define MSR mcipMSR
#define PTHICK mcipPTHICK
#define PERSPEX mcipPERSPEX
#define SAMPLE mcipSAMPLE
#define SAMPLEFILE mcipSAMPLEFILE
#define MOS mcipMOS
#define DD_D mcipDD_D
#define SAMPLESIZE mcipSAMPLESIZE
#define BARNS mcipBARNS
#define AAX mcipAAX
#define AAY mcipAAY
#define AAZ mcipAAZ
#define BBX mcipBBX
#define BBY mcipBBY
#define BBZ mcipBBZ
#define CCX mcipCCX
#define CCY mcipCCY
#define CCZ mcipCCZ
#define A1 mcipA1
#define A2 mcipA2
#define A3 mcipA3
#define A4 mcipA4
#define AA5 mcipAA5
#define A6 mcipA6
#define TILT mcipTILT
#define SST mcipSST
#define SSB mcipSSB
#define SSL mcipSSL
#define SSR mcipSSR
#define OUTFILTER mcipOUTFILTER
#define OUTFILTERFILE mcipOUTFILTERFILE
#define ANAFORCE mcipANAFORCE
#define C1 mcipC1
#define C2 mcipC2
#define C3 mcipC3
#define C4 mcipC4
#define C5 mcipC5
#define C6 mcipC6
#define C7 mcipC7
#define C8 mcipC8
#define C9 mcipC9
#define COARSE mcipCOARSE
#define LC mcipLC
#define RC mcipRC
#define REP mcipREP
#define VIRTUALOUT mcipVIRTUALOUT
#define VIRTUALIN mcipVIRTUALIN
#define SOURCEFILE mcipSOURCEFILE
#define verbose mcipverbose
#line 505 "RITA-II.instr"
{

/* Source parameters */
//l0=9.045/sqrt(EI);
l0=L0;// fix 20100222 by LU since we want source independent of mono
lmin=BPL*l0;/* MONO_N is the order of the reflection */
lmax=BPH*l0;
printf("Source wavelength interval=%.4g - %.4g[Ang] \n",lmin, lmax);
/* Calculate min and max energy for source to use with energy monitors before sample */
emini=(9.045*9.045)/(lmax*lmax);
emaxi=(9.045*9.045)/(lmin*lmin);
//neichan=floor((emaxi-emini)/0.01);
printf("Source energy interval=%.4g - %.4g[meV] \n",emini, emaxi);
/* Calculate min and max energy for the detectors after the sample */
eminf=EF*0.95;
emaxf=EF*1.05;
//nefchan=floor((emaxf-eminf)/0.005);
printf("Detector energy interval=%.4g - %.4g[meV] \n",eminf, emaxf);

/* Only SPLIT if we are not running with VIRTUAL parms */
if (VIRTUALIN || VIRTUALOUT) {
  SPLITREP = 1;
  if (!VIRTUALOUT){
    SPLITMREP = 1;
  }else{
    SPLITMREP = REP;
  }
  if (!VIRTUALIN){
    SPLITAREP = 1;
  }else{
    SPLITAREP = REP;
  }  
 } else {
  SPLITREP = REP;
  SPLITMREP = REP;
  SPLITAREP = REP;
}


/* Guide parameters */
angleGuideCurved=20.0/2408.0;
/* calculate mirror reflectivity slope */
 ALPHA=0;//(R0-R)/(Qc*(M-1));
printf("* GUIDE MIRROR ALPHA=%g [AA]\n", ALPHA);

/* Monochromator parameters */
double Vi, Vf;
double tmp=0;
char Qmode = 0;
DM = 2*PI/mono_q;
DA = 2*PI/ana_q;
mono_mosaic_h = MONO_MOS_H; /* MON_MOSAIC; */
mono_mosaic_v = MONO_MOS_V; /* MON_MOSAIC; */
dms = dmv+dvs;/* Distance between mono and sample*/
dmc = rmh-lc; /*distance monochromator to front of monocollimator*/
/* fix 08/02/2009 by LU */
/* Forcing monochromator to set value */
 if (MONOFORCE) {/* Flat mono */
   rv=0;
   printf("* MONOCHROMATOR IS VERTICALLY FOCUSING: RV=%g \n",rv);
 } 
 else {rv=dms; /* curved mono */
 printf("* MONOCHROMATOR IS FLAT: RV=%g \n", rv);
 }


/* BEGIN HKL calculator adapted from templateTAS */

machine_real.a1 = A1;
machine_real.a2 = A2;
machine_real.a3 = A3;
machine_real.a4 = A4;
machine_real.a5 = A5;
machine_real.a6 = A6;

machine_real.c1 = -C1;
machine_real.c2 = -C2;
machine_real.c3 = -C3;
machine_real.c4 = -C4;
machine_real.c5 = -C5;
machine_real.c6 = -C6;
machine_real.c7 = -C7;
machine_real.c8 = -C8;
machine_real.c9 = -C9;

/* energy conservation */
 if (EI && EF) {
   EN = EI - EF;
   fprintf(stderr,"%s WARNING: EN is now set to %g since you provided both EI=%g (KI) and EF=%g (KF)\n", NAME_CURRENT_COMP, EN, EI, EF);
 } else if (EI && !EF){
   EF = EI - EN;
   fprintf(stderr,"%s WARNING: EF is now set to %g since you provided both EI=%g (KI) and EN=%g\n", NAME_CURRENT_COMP, EF, EI, EN);
   fprintf(stderr,"%s POSSIBLE ERROR: On RITA, EF is normally SET, EI calculated - are you sure about this?\n", NAME_CURRENT_COMP);
 } else if (EF && !EI) {
   EI = EF + EN;
   fprintf(stderr,"%s WARNING: EI is now set to %g since you provided both EF=%g (KF) and EN=%g\n", NAME_CURRENT_COMP, EI, EF, EN);
 } else {
   fprintf(stderr,"%s WARNING: Neither EI, EF nor EN defined: Energies are set from user angle input:\n", NAME_CURRENT_COMP);
   l0 = 2 * DM * sin(DEG2RAD*A2/2)/MONO_N;
   EI = 9.045/l0;
   EI = EI*EI;
   fprintf(stderr,"%s: WARNING: EI has been adjusted to %g[meV]  (A2 = %g[deg])\n", NAME_CURRENT_COMP, EI, A2);
   l0 = 2 * DA * sin(DEG2RAD*A6/2)/MONO_N;
   EF= 9.045/l0;
   EF = EF*EF;
   fprintf(stderr,"%s: WARNING: EF has been adjusted to %g[meV]  (A6 = %g[deg])\n", NAME_CURRENT_COMP, EF, A2);
 }
 /* determine remaining neutron energies */
 Vi = SE2V*sqrt(EI);
 KI = V2K*Vi;
 Vf = SE2V*sqrt(EF);
 KF = V2K*Vf;

/* transfered sample parameters */
sample.aa = AA;
sample.bb = BB;
sample.cc = CC;
sample.as = AS;
sample.bs = BS;
sample.cs = CS;
sample.ax = AH;
sample.ay = AK;
sample.az = AL;
sample.bx = BH;
sample.by = BK;
sample.bz = BL;

/* transfered target parameters */
machine_hkl.ki = KI;
machine_hkl.kf = KF;
machine_hkl.ei = EI;
machine_hkl.ef = EF;
machine_hkl.qh = QH;
machine_hkl.qk = QK;
machine_hkl.ql = QL;
machine_hkl.en = EN;
machine_real.qm = QM;

if (QM || QH || QK || QL) {
  Qmode=1;
  fprintf(stderr,"%s: Running in HKL mode\n", NAME_CURRENT_COMP);
} else {
  fprintf(stderr,"%s: Running in angle mode\n", NAME_CURRENT_COMP);
}

if (verbose && Qmode) {
  printf("%s: Detailed TAS configuration\n", NAME_CURRENT_COMP);
  printf("* Incoming beam: EI=%.4g [meV] KI=%.4g [Angs-1] Vi=%g [m/s]\n", EI, KI, Vi);
  printf("* Outgoing beam: EF=%.4g [meV] KF=%.4g [Angs-1] Vf=%g [m/s]\n", EF, KF, Vf);
}

/* transfered machine parameters */
/* For W configuartion of TAS: */
machine_hkl.sm = SM;
machine_hkl.ss = SS;
machine_hkl.sa = SA;
/* These two are actually constants, see top of INITIALIZE */
machine_hkl.dm = DM;
machine_hkl.da = DA;

if (Qmode) {
  machine_real = qhkl2angles(sample, machine_hkl, machine_real);
  if (strlen(machine_real.message)) {
    exit(fprintf(stderr, "%s: ERROR: %s [qhkl2angles]\n", NAME_CURRENT_COMP, machine_real.message));
  }
}



if (A1 && (machine_real.a1 != A1)) {
   printf("Warning, resetting A1 from calculated %g to user provided %g\n",machine_real.a1,A1);
   machine_real.a1 = A1;
}
if (A2 && (machine_real.a2 != A2)) {
   printf("Warning, resetting A2 from calculated %g to user provided %g\n",machine_real.a2,A2);
   machine_real.a2 = A2;
}
if (A3 && (machine_real.a3 != A3)) {
   printf("Warning, resetting A3 from calculated %g to user provided %g\n",machine_real.a3,A3);
   machine_real.a3 = A3;
}
if (A4 && (machine_real.a4 != A4)) {
   printf("Warning, resetting A4 from calculated %g to user provided %g\n",machine_real.a4,A4);
   machine_real.a4 = A4;
}
if (A5 && (machine_real.a5 != A5)) {
   printf("Warning, resetting A5 from calculated %g to user provided %g\n",machine_real.a5,A5);
   machine_real.a5 = A5;
}
if (A6 && (machine_real.a6 != A6)) {
   printf("Warning, resetting A6 from calculated %g to user provided %g\n",machine_real.a6,A6);
   machine_real.a6 = A6;
}


if (AA5 && (machine_real.aa5 != AA5) && !ANAFORCE) {
   printf("Warning, resetting AA5 from calculated %g to user provided %g\n",machine_real.aa5,AA5);
   machine_real.aa5 = AA5;
   /*A4 angle between blades */
machine_real.da4 = RAD2DEG*atan(ana_d*cos(DEG2RAD*machine_real.aa5)/dsa);
/*Blade angle rotation */
 machine_real.c1= -machine_real.aa5+machine_real.a5-(1-5)*machine_real.da4;
 machine_real.c2= -machine_real.aa5+machine_real.a5-(2-5)*machine_real.da4;
 machine_real.c3= -machine_real.aa5+machine_real.a5-(3-5)*machine_real.da4;
 machine_real.c4= -machine_real.aa5+machine_real.a5-(4-5)*machine_real.da4;
 machine_real.c5= -machine_real.aa5+machine_real.a5-(5-5)*machine_real.da4;
 machine_real.c6= -machine_real.aa5+machine_real.a5-(6-5)*machine_real.da4;
 machine_real.c7= -machine_real.aa5+machine_real.a5-(7-5)*machine_real.da4;
 machine_real.c8= -machine_real.aa5+machine_real.a5-(8-5)*machine_real.da4;
 machine_real.c9= -machine_real.aa5+machine_real.a5-(9-5)*machine_real.da4;
 printf("Warning, recalculating C's to %g %g %g %g %g %g %g %g %g \n",machine_real.c1,machine_real.c2,machine_real.c3,machine_real.c4,machine_real.c5,machine_real.c6,machine_real.c7,machine_real.c8,machine_real.c9);
}


if (C1 && (machine_real.c1 != -C1)) {
   printf("Warning, resetting C1 from calculated %g to user provided %g\n",machine_real.c1,-C1);
   machine_real.c1 = -C1;
}
if (C2 && (machine_real.c2 != -C2)) {
   printf("Warning, resetting C2 from calculated %g to user provided %g\n",machine_real.c2,-C2);
   machine_real.c2 = -C2;
}
if (C3 && (machine_real.c3 != -C3)) {
   printf("Warning, resetting C3 from calculated %g to user provided %g\n",machine_real.c3,-C3);
   machine_real.c3 = -C3;
}
if (C4 && (machine_real.c4 != -C4)) {
   printf("Warning, resetting C4 from calculated %g to user provided %g\n",machine_real.c4,-C4);
   machine_real.c4 = -C4;
}
if (C5 && (machine_real.c5 != -C5)) {
   printf("Warning, resetting C5 from calculated %g to user provided %g\n",machine_real.c5,-C5);
   machine_real.c5 = -C5;
}
if (C6 && (machine_real.c6 != -C6)) {
   printf("Warning, resetting C6 from calculated %g to user provided %g\n",machine_real.c6,-C6);
   machine_real.c6 = -C6;
}
if (C7 && (machine_real.c7 != -C7)) {
   printf("Warning, resetting C7 from calculated %g to user provided %g\n",machine_real.c7,-C7);
   machine_real.c7 = -C7;
}
if (C8 && (machine_real.c8 != -C8)) {
   printf("Warning, resetting C8 from calculated %g to user provided %g\n",machine_real.c8,-C8);
   machine_real.c8 = -C8;
}
if (C9 && (machine_real.c9 != -C9)) {
   printf("Warning, resetting C9 from calculated %g to user provided %g\n",machine_real.c9,-C9);
   machine_real.c9 = -C9;
}

/* Forcing ana to set value */
 if (ANAFORCE) {/* Flat ana mode */
   if (AA5 && machine_real.a5 != AA5){
     machine_real.aa5=AA5;
     printf("Warning, resetting AA5 from calculated %g to user provided %g\n",machine_real.a5,AA5);
   } else{
     machine_real.aa5=machine_real.a5;
   }
   machine_real.c1=0;
   machine_real.c2=0;
   machine_real.c3=0;
   machine_real.c4=0;
   machine_real.c5=0;
   machine_real.c6=0;
   machine_real.c7=0;
   machine_real.c8=0;
   machine_real.c9=0;
   C1 = machine_real.c1;
   C2 = machine_real.c2;
   C3 = machine_real.c3;
   C4 = machine_real.c4;
   C5 = machine_real.c5;
   C6 = machine_real.c6;
   C7 = machine_real.c7;
   C8 = machine_real.c8;
   C9 = machine_real.c9;
   printf("* ANALYSER IN FLAT MODE \n");
 }
 else {/* else imaging mode ana */
   printf("* ANALYSER IN IMAGING MODE \n");
 }


if (verbose) {
  printf("* Transfered:     EN=%g [meV] QM=%g [Angs-1]\n", EN, machine_real.qm);
  printf("Angles: A1=%.4g A2=%.4g A3=%.4g A4=%.4g A5=%.4g A6=%.4g [deg]\n",
    machine_real.a1, machine_real.a2,
    machine_real.a3, machine_real.a4,
    machine_real.a5, machine_real.a6);
    printf("(RITA Analyzer Angles: AA5=%.4g C1=%.4g C2=%.4g C3=%.4g C4=%.4g C5=%.4g C6=%.4g C7=%.4g C8=%.4g C9=%.4g [deg])\n",
   machine_real.aa5,
   machine_real.c1,machine_real.c2,machine_real.c3,
   machine_real.c4,machine_real.c5,machine_real.c6,
   machine_real.c7,machine_real.c8,machine_real.c9);
}
 
/* END HKL calculator adapted from templateTAS */

 

/* Sample paramaters */
if (SAMPLE == 2){
  /* Powder sample, relevant WHEN at sample position */
  if (!strcmp(SAMPLEFILE,"default")) {
    PowderFile="Al2O3_sapphire.lau";
  } else {
    PowderFile=SAMPLEFILE;
  }
  SingleXFile="";
} else if (SAMPLE == 3) {
  /* Single crystal sample, relevant WHEN at sample position */
  if (!strcmp(SAMPLEFILE,"default")) {
    SingleXFile="Pb.laz";
  } else {
    SingleXFile=SAMPLEFILE;
  }
  PowderFile="";
} else if (SAMPLE==4){
  /* Phonon sample */
 printf("Phonon sample used - no elastic contribution. \n");  
}else {
  /* Purely incoherent scatterer, relevant WHEN at sample position */
  SingleXFile="";
  PowderFile="";
}


/* Coarse collimator */
if (COARSE) {coarse = 1;}
else {coarse = 0;}

/* Opening slits of coarse collimator depends on analyzer settings: */
deltaL = 2 * WindowSize * cos(DEG2RAD*machine_real.a6 + fabs(DEG2RAD*machine_real.a5));
FirstWindowSizeL = WindowSize * (dad-BladeLength-deltaL+BladeLength*sin(DEG2RAD*machine_real.a6 + fabs(DEG2RAD*machine_real.a5)))/(dad-deltaL);
FirstWindowSizeR = WindowSize * (dad-BladeLength+deltaL+BladeLength*sin(DEG2RAD*machine_real.a6 + fabs(DEG2RAD*machine_real.a5)))/(dad+deltaL);

/* Window positions */
XwinMin[0] = 0;
XwinMin[1] = 12;
XwinMin[2] = 24;
XwinMin[3] = 36;
XwinMin[4] = 48;
XwinMin[5] = 60;
XwinMin[6] = 72;
XwinMin[7] = 84;
XwinMin[8] = 95;
XwinMin[9] = 106;

XwinMax[0] = 0;
XwinMax[1] = 21;
XwinMax[2] = 33;
XwinMax[3] = 45;
XwinMax[4] = 57;
XwinMax[5] = 69;
XwinMax[6] = 81;
XwinMax[7] = 93;
XwinMax[8] = 104;
XwinMax[9] = 115;

YwinMin[0] = 0;
YwinMin[1] = 39;
YwinMin[2] = 39;
YwinMin[3] = 39;
YwinMin[4] = 39;
YwinMin[5] = 39;
YwinMin[6] = 39;
YwinMin[7] = 39;
YwinMin[8] = 39;
YwinMin[9] = 39;

YwinMax[0] = 0;
YwinMax[1] = 91;
YwinMax[2] = 91;
YwinMax[3] = 91;
YwinMax[4] = 91;
YwinMax[5] = 91;
YwinMax[6] = 91;
YwinMax[7] = 91;
YwinMax[8] = 91;
YwinMax[9] = 91;


}
#line 20427 "RITA-II.c"
#undef verbose
#undef SOURCEFILE
#undef VIRTUALIN
#undef VIRTUALOUT
#undef REP
#undef RC
#undef LC
#undef COARSE
#undef C9
#undef C8
#undef C7
#undef C6
#undef C5
#undef C4
#undef C3
#undef C2
#undef C1
#undef ANAFORCE
#undef OUTFILTERFILE
#undef OUTFILTER
#undef SSR
#undef SSL
#undef SSB
#undef SST
#undef TILT
#undef A6
#undef AA5
#undef A4
#undef A3
#undef A2
#undef A1
#undef CCZ
#undef CCY
#undef CCX
#undef BBZ
#undef BBY
#undef BBX
#undef AAZ
#undef AAY
#undef AAX
#undef BARNS
#undef SAMPLESIZE
#undef DD_D
#undef MOS
#undef SAMPLEFILE
#undef SAMPLE
#undef PERSPEX
#undef PTHICK
#undef MSR
#undef MSL
#undef MSB
#undef MST
#undef COLL_MS
#undef INFILTERFILE
#undef INFILTER
#undef BL
#undef BK
#undef BH
#undef AL
#undef AK
#undef AH
#undef CC
#undef BB
#undef AA
#undef CS
#undef BS
#undef AS
#undef QM
#undef QL
#undef QK
#undef QH
#undef SA
#undef SS
#undef SM
#undef EN
#undef EF
#undef EI
#undef MONO_MOS_V
#undef MONO_MOS_H
#undef MONOFORCE
#undef MONO_N
#undef BPH
#undef BPL
#undef L0
#undef ITAR
#undef mcposaRITA_II
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname
  /* Computation of coordinate transformations. */
  {
    Coords mctc1, mctc2, mcLastComp;
    Rotation mctr1;
    double mcAccumulatedILength = 0;
    /* Initialize "last" component origin as (0,0,0) */
    mcLastComp = coords_set(0,0,0);

    mcDEBUG_INSTR()
  /* Component initializations. */
    /* Component armSource. */
  /* Setting parameters for component armSource. */
  SIG_MESSAGE("armSource (Init:SetPar)");
#line 39 "RITA-II.instr"
  if("NULL") strncpy(mccarmSource_profile, "NULL" ? "NULL" : "", 16384); else mccarmSource_profile[0]='\0';
#line 39 "RITA-II.instr"
  mccarmSource_percent = 10;
#line 39 "RITA-II.instr"
  mccarmSource_flag_save = 0;
#line 39 "RITA-II.instr"
  mccarmSource_minutes = 0;
#line 20538 "RITA-II.c"

  SIG_MESSAGE("armSource (Init:Place/Rotate)");
  rot_set_rotation(mcrotaarmSource,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20545 "RITA-II.c"
  rot_copy(mcrotrarmSource, mcrotaarmSource);
  mcposaarmSource = coords_set(
#line 896 "RITA-II.instr"
    0,
#line 896 "RITA-II.instr"
    0,
#line 896 "RITA-II.instr"
    0);
#line 20554 "RITA-II.c"
  mctc1 = coords_neg(mcposaarmSource);
  mcposrarmSource = rot_apply(mcrotaarmSource, mctc1);
  mcDEBUG_COMPONENT("armSource", mcposaarmSource, mcrotaarmSource)
  mccomp_posa[1] = mcposaarmSource;
  mccomp_posr[1] = mcposrarmSource;
  mcNCounter[1]  = mcPCounter[1] = mcP2Counter[1] = 0;
  mcAbsorbProp[1]= 0;
    /* Component source. */
  /* Setting parameters for component source. */
  SIG_MESSAGE("source (Init:SetPar)");
#line 138 "RITA-II.instr"
  mccsource_radius = 0.0;
#line 901 "RITA-II.instr"
  mccsource_dist = 1.465;
#line 900 "RITA-II.instr"
  mccsource_xw = 0.03;
#line 900 "RITA-II.instr"
  mccsource_yh = 0.12;
#line 138 "RITA-II.instr"
  mccsource_E0 = 0;
#line 138 "RITA-II.instr"
  mccsource_dE = 0;
#line 138 "RITA-II.instr"
  mccsource_Lambda0 = 0;
#line 138 "RITA-II.instr"
  mccsource_dLambda = 0;
#line 902 "RITA-II.instr"
  mccsource_I1 = mcipITAR * ( 1.27e13 / 4 / PI );
#line 900 "RITA-II.instr"
  mccsource_h = 0.135;
#line 900 "RITA-II.instr"
  mccsource_w = 0.08;
#line 139 "RITA-II.instr"
  mccsource_gaussian = 0;
#line 139 "RITA-II.instr"
  mccsource_verbose = 0;
#line 902 "RITA-II.instr"
  mccsource_T1 = 301.287;
#line 140 "RITA-II.instr"
  mccsource_flux_file_perAA = 0;
#line 140 "RITA-II.instr"
  mccsource_flux_file_log = 0;
#line 901 "RITA-II.instr"
  mccsource_Lmin = lmin;
#line 901 "RITA-II.instr"
  mccsource_Lmax = lmax;
#line 142 "RITA-II.instr"
  mccsource_Emin = 0;
#line 142 "RITA-II.instr"
  mccsource_Emax = 0;
#line 903 "RITA-II.instr"
  mccsource_T2 = 105.655;
#line 903 "RITA-II.instr"
  mccsource_I2 = mcipITAR * ( 3.818e12 / 4 / PI );
#line 904 "RITA-II.instr"
  mccsource_T3 = 25.379;
#line 904 "RITA-II.instr"
  mccsource_I3 = mcipITAR * ( 2.331e12 / 4 / PI );
#line 142 "RITA-II.instr"
  mccsource_length = 0;
#line 142 "RITA-II.instr"
  mccsource_phi_init = 0;
#line 142 "RITA-II.instr"
  mccsource_theta_init = 0;
#line 905 "RITA-II.instr"
  mccsource_HEtailA = mcipITAR * 8.306e11 / 4 / PI;
#line 905 "RITA-II.instr"
  mccsource_HEtailL0 = -0.398;
#line 20623 "RITA-II.c"

  SIG_MESSAGE("source (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 906 "RITA-II.instr"
    (0)*DEG2RAD,
#line 906 "RITA-II.instr"
    (0)*DEG2RAD,
#line 906 "RITA-II.instr"
    (0)*DEG2RAD);
#line 20633 "RITA-II.c"
  rot_mul(mctr1, mcrotaarmSource, mcrotasource);
  rot_transpose(mcrotaarmSource, mctr1);
  rot_mul(mcrotasource, mctr1, mcrotrsource);
  mctc1 = coords_set(
#line 906 "RITA-II.instr"
    0,
#line 906 "RITA-II.instr"
    0,
#line 906 "RITA-II.instr"
    0);
#line 20644 "RITA-II.c"
  rot_transpose(mcrotaarmSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasource = coords_add(mcposaarmSource, mctc2);
  mctc1 = coords_sub(mcposaarmSource, mcposasource);
  mcposrsource = rot_apply(mcrotasource, mctc1);
  mcDEBUG_COMPONENT("source", mcposasource, mcrotasource)
  mccomp_posa[2] = mcposasource;
  mccomp_posr[2] = mcposrsource;
  mcNCounter[2]  = mcPCounter[2] = mcP2Counter[2] = 0;
  mcAbsorbProp[2]= 0;
    /* Component slitGuideBegin. */
  /* Setting parameters for component slitGuideBegin. */
  SIG_MESSAGE("slitGuideBegin (Init:SetPar)");
#line 910 "RITA-II.instr"
  mccslitGuideBegin_xmin = -0.015;
#line 910 "RITA-II.instr"
  mccslitGuideBegin_xmax = 0.015;
#line 911 "RITA-II.instr"
  mccslitGuideBegin_ymin = -0.06;
#line 911 "RITA-II.instr"
  mccslitGuideBegin_ymax = 0.06;
#line 46 "RITA-II.instr"
  mccslitGuideBegin_radius = 0;
#line 46 "RITA-II.instr"
  mccslitGuideBegin_xwidth = 0;
#line 46 "RITA-II.instr"
  mccslitGuideBegin_yheight = 0;
#line 20672 "RITA-II.c"

  SIG_MESSAGE("slitGuideBegin (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20679 "RITA-II.c"
  rot_mul(mctr1, mcrotaarmSource, mcrotaslitGuideBegin);
  rot_transpose(mcrotasource, mctr1);
  rot_mul(mcrotaslitGuideBegin, mctr1, mcrotrslitGuideBegin);
  mctc1 = coords_set(
#line 912 "RITA-II.instr"
    0,
#line 912 "RITA-II.instr"
    0,
#line 912 "RITA-II.instr"
    1.464999);
#line 20690 "RITA-II.c"
  rot_transpose(mcrotaarmSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaslitGuideBegin = coords_add(mcposaarmSource, mctc2);
  mctc1 = coords_sub(mcposasource, mcposaslitGuideBegin);
  mcposrslitGuideBegin = rot_apply(mcrotaslitGuideBegin, mctc1);
  mcDEBUG_COMPONENT("slitGuideBegin", mcposaslitGuideBegin, mcrotaslitGuideBegin)
  mccomp_posa[3] = mcposaslitGuideBegin;
  mccomp_posr[3] = mcposrslitGuideBegin;
  mcNCounter[3]  = mcPCounter[3] = mcP2Counter[3] = 0;
  mcAbsorbProp[3]= 0;
    /* Component lmon_guide_start. */
  /* Setting parameters for component lmon_guide_start. */
  SIG_MESSAGE("lmon_guide_start (Init:SetPar)");
#line 916 "RITA-II.instr"
  if("lmon_guide_start.dat") strncpy(mcclmon_guide_start_filename, "lmon_guide_start.dat" ? "lmon_guide_start.dat" : "", 16384); else mcclmon_guide_start_filename[0]='\0';
#line 916 "RITA-II.instr"
  mcclmon_guide_start_xmin = -0.02;
#line 916 "RITA-II.instr"
  mcclmon_guide_start_xmax = 0.02;
#line 917 "RITA-II.instr"
  mcclmon_guide_start_ymin = -0.075;
#line 917 "RITA-II.instr"
  mcclmon_guide_start_ymax = 0.075;
#line 51 "RITA-II.instr"
  mcclmon_guide_start_xwidth = 0;
#line 51 "RITA-II.instr"
  mcclmon_guide_start_yheight = 0;
#line 917 "RITA-II.instr"
  mcclmon_guide_start_Lmin = lmin;
#line 917 "RITA-II.instr"
  mcclmon_guide_start_Lmax = lmax;
#line 917 "RITA-II.instr"
  mcclmon_guide_start_restore_neutron = 1;
#line 51 "RITA-II.instr"
  mcclmon_guide_start_nowritefile = 0;
#line 20726 "RITA-II.c"

  SIG_MESSAGE("lmon_guide_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20733 "RITA-II.c"
  rot_mul(mctr1, mcrotaarmSource, mcrotalmon_guide_start);
  rot_transpose(mcrotaslitGuideBegin, mctr1);
  rot_mul(mcrotalmon_guide_start, mctr1, mcrotrlmon_guide_start);
  mctc1 = coords_set(
#line 918 "RITA-II.instr"
    0,
#line 918 "RITA-II.instr"
    0,
#line 918 "RITA-II.instr"
    1.4649992);
#line 20744 "RITA-II.c"
  rot_transpose(mcrotaarmSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposalmon_guide_start = coords_add(mcposaarmSource, mctc2);
  mctc1 = coords_sub(mcposaslitGuideBegin, mcposalmon_guide_start);
  mcposrlmon_guide_start = rot_apply(mcrotalmon_guide_start, mctc1);
  mcDEBUG_COMPONENT("lmon_guide_start", mcposalmon_guide_start, mcrotalmon_guide_start)
  mccomp_posa[4] = mcposalmon_guide_start;
  mccomp_posr[4] = mcposrlmon_guide_start;
  mcNCounter[4]  = mcPCounter[4] = mcP2Counter[4] = 0;
  mcAbsorbProp[4]= 0;
    /* Component guideStraight. */
  /* Setting parameters for component guideStraight. */
  SIG_MESSAGE("guideStraight (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideStraight_reflect, 0 ? 0 : "", 16384); else mccguideStraight_reflect[0]='\0';
#line 921 "RITA-II.instr"
  mccguideStraight_w1 = 0.03;
#line 921 "RITA-II.instr"
  mccguideStraight_h1 = 0.12;
#line 921 "RITA-II.instr"
  mccguideStraight_w2 = 0.03;
#line 921 "RITA-II.instr"
  mccguideStraight_h2 = 0.12;
#line 921 "RITA-II.instr"
  mccguideStraight_l = 4.628;
#line 922 "RITA-II.instr"
  mccguideStraight_R0 = R0;
#line 922 "RITA-II.instr"
  mccguideStraight_Qc = Qc;
#line 922 "RITA-II.instr"
  mccguideStraight_alpha = ALPHA;
#line 922 "RITA-II.instr"
  mccguideStraight_m = M;
#line 922 "RITA-II.instr"
  mccguideStraight_W = W;
#line 20780 "RITA-II.c"

  SIG_MESSAGE("guideStraight (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20787 "RITA-II.c"
  rot_mul(mctr1, mcrotaarmSource, mcrotaguideStraight);
  rot_transpose(mcrotalmon_guide_start, mctr1);
  rot_mul(mcrotaguideStraight, mctr1, mcrotrguideStraight);
  mctc1 = coords_set(
#line 923 "RITA-II.instr"
    0,
#line 923 "RITA-II.instr"
    0,
#line 923 "RITA-II.instr"
    1.465);
#line 20798 "RITA-II.c"
  rot_transpose(mcrotaarmSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideStraight = coords_add(mcposaarmSource, mctc2);
  mctc1 = coords_sub(mcposalmon_guide_start, mcposaguideStraight);
  mcposrguideStraight = rot_apply(mcrotaguideStraight, mctc1);
  mcDEBUG_COMPONENT("guideStraight", mcposaguideStraight, mcrotaguideStraight)
  mccomp_posa[5] = mcposaguideStraight;
  mccomp_posr[5] = mcposrguideStraight;
  mcNCounter[5]  = mcPCounter[5] = mcP2Counter[5] = 0;
  mcAbsorbProp[5]= 0;
    /* Component guideCurved1. */
  /* Setting parameters for component guideCurved1. */
  SIG_MESSAGE("guideCurved1 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved1_reflect, 0 ? 0 : "", 16384); else mccguideCurved1_reflect[0]='\0';
#line 928 "RITA-II.instr"
  mccguideCurved1_w1 = 0.03;
#line 928 "RITA-II.instr"
  mccguideCurved1_h1 = 0.12;
#line 928 "RITA-II.instr"
  mccguideCurved1_w2 = 0.03;
#line 928 "RITA-II.instr"
  mccguideCurved1_h2 = 0.12;
#line 928 "RITA-II.instr"
  mccguideCurved1_l = 0.499995;
#line 929 "RITA-II.instr"
  mccguideCurved1_R0 = R0;
#line 929 "RITA-II.instr"
  mccguideCurved1_Qc = Qc;
#line 929 "RITA-II.instr"
  mccguideCurved1_alpha = ALPHA;
#line 929 "RITA-II.instr"
  mccguideCurved1_m = M;
#line 929 "RITA-II.instr"
  mccguideCurved1_W = W;
#line 20834 "RITA-II.c"

  SIG_MESSAGE("guideCurved1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 931 "RITA-II.instr"
    (0)*DEG2RAD,
#line 931 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 931 "RITA-II.instr"
    (0)*DEG2RAD);
#line 20844 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideStraight, mcrotaguideCurved1);
  rot_transpose(mcrotaguideStraight, mctr1);
  rot_mul(mcrotaguideCurved1, mctr1, mcrotrguideCurved1);
  mctc1 = coords_set(
#line 930 "RITA-II.instr"
    0,
#line 930 "RITA-II.instr"
    0,
#line 930 "RITA-II.instr"
    4.663);
#line 20855 "RITA-II.c"
  rot_transpose(mcrotaguideStraight, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved1 = coords_add(mcposaguideStraight, mctc2);
  mctc1 = coords_sub(mcposaguideStraight, mcposaguideCurved1);
  mcposrguideCurved1 = rot_apply(mcrotaguideCurved1, mctc1);
  mcDEBUG_COMPONENT("guideCurved1", mcposaguideCurved1, mcrotaguideCurved1)
  mccomp_posa[6] = mcposaguideCurved1;
  mccomp_posr[6] = mcposrguideCurved1;
  mcNCounter[6]  = mcPCounter[6] = mcP2Counter[6] = 0;
  mcAbsorbProp[6]= 0;
    /* Component guideCurved2. */
  /* Setting parameters for component guideCurved2. */
  SIG_MESSAGE("guideCurved2 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved2_reflect, 0 ? 0 : "", 16384); else mccguideCurved2_reflect[0]='\0';
#line 934 "RITA-II.instr"
  mccguideCurved2_w1 = 0.03;
#line 934 "RITA-II.instr"
  mccguideCurved2_h1 = 0.12;
#line 934 "RITA-II.instr"
  mccguideCurved2_w2 = 0.03;
#line 934 "RITA-II.instr"
  mccguideCurved2_h2 = 0.12;
#line 934 "RITA-II.instr"
  mccguideCurved2_l = 0.499995;
#line 935 "RITA-II.instr"
  mccguideCurved2_R0 = R0;
#line 935 "RITA-II.instr"
  mccguideCurved2_Qc = Qc;
#line 935 "RITA-II.instr"
  mccguideCurved2_alpha = ALPHA;
#line 935 "RITA-II.instr"
  mccguideCurved2_m = M;
#line 935 "RITA-II.instr"
  mccguideCurved2_W = W;
#line 20891 "RITA-II.c"

  SIG_MESSAGE("guideCurved2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 937 "RITA-II.instr"
    (0)*DEG2RAD,
#line 937 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 937 "RITA-II.instr"
    (0)*DEG2RAD);
#line 20901 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved1, mcrotaguideCurved2);
  rot_transpose(mcrotaguideCurved1, mctr1);
  rot_mul(mcrotaguideCurved2, mctr1, mcrotrguideCurved2);
  mctc1 = coords_set(
#line 936 "RITA-II.instr"
    0,
#line 936 "RITA-II.instr"
    0,
#line 936 "RITA-II.instr"
    0.5);
#line 20912 "RITA-II.c"
  rot_transpose(mcrotaguideCurved1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved2 = coords_add(mcposaguideCurved1, mctc2);
  mctc1 = coords_sub(mcposaguideCurved1, mcposaguideCurved2);
  mcposrguideCurved2 = rot_apply(mcrotaguideCurved2, mctc1);
  mcDEBUG_COMPONENT("guideCurved2", mcposaguideCurved2, mcrotaguideCurved2)
  mccomp_posa[7] = mcposaguideCurved2;
  mccomp_posr[7] = mcposrguideCurved2;
  mcNCounter[7]  = mcPCounter[7] = mcP2Counter[7] = 0;
  mcAbsorbProp[7]= 0;
    /* Component guideCurved3. */
  /* Setting parameters for component guideCurved3. */
  SIG_MESSAGE("guideCurved3 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved3_reflect, 0 ? 0 : "", 16384); else mccguideCurved3_reflect[0]='\0';
#line 940 "RITA-II.instr"
  mccguideCurved3_w1 = 0.03;
#line 940 "RITA-II.instr"
  mccguideCurved3_h1 = 0.12;
#line 940 "RITA-II.instr"
  mccguideCurved3_w2 = 0.03;
#line 940 "RITA-II.instr"
  mccguideCurved3_h2 = 0.12;
#line 940 "RITA-II.instr"
  mccguideCurved3_l = 0.499995;
#line 941 "RITA-II.instr"
  mccguideCurved3_R0 = R0;
#line 941 "RITA-II.instr"
  mccguideCurved3_Qc = Qc;
#line 941 "RITA-II.instr"
  mccguideCurved3_alpha = ALPHA;
#line 941 "RITA-II.instr"
  mccguideCurved3_m = M;
#line 941 "RITA-II.instr"
  mccguideCurved3_W = W;
#line 20948 "RITA-II.c"

  SIG_MESSAGE("guideCurved3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 943 "RITA-II.instr"
    (0)*DEG2RAD,
#line 943 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 943 "RITA-II.instr"
    (0)*DEG2RAD);
#line 20958 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved2, mcrotaguideCurved3);
  rot_transpose(mcrotaguideCurved2, mctr1);
  rot_mul(mcrotaguideCurved3, mctr1, mcrotrguideCurved3);
  mctc1 = coords_set(
#line 942 "RITA-II.instr"
    0,
#line 942 "RITA-II.instr"
    0,
#line 942 "RITA-II.instr"
    0.5);
#line 20969 "RITA-II.c"
  rot_transpose(mcrotaguideCurved2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved3 = coords_add(mcposaguideCurved2, mctc2);
  mctc1 = coords_sub(mcposaguideCurved2, mcposaguideCurved3);
  mcposrguideCurved3 = rot_apply(mcrotaguideCurved3, mctc1);
  mcDEBUG_COMPONENT("guideCurved3", mcposaguideCurved3, mcrotaguideCurved3)
  mccomp_posa[8] = mcposaguideCurved3;
  mccomp_posr[8] = mcposrguideCurved3;
  mcNCounter[8]  = mcPCounter[8] = mcP2Counter[8] = 0;
  mcAbsorbProp[8]= 0;
    /* Component guideCurved4. */
  /* Setting parameters for component guideCurved4. */
  SIG_MESSAGE("guideCurved4 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved4_reflect, 0 ? 0 : "", 16384); else mccguideCurved4_reflect[0]='\0';
#line 946 "RITA-II.instr"
  mccguideCurved4_w1 = 0.03;
#line 946 "RITA-II.instr"
  mccguideCurved4_h1 = 0.12;
#line 946 "RITA-II.instr"
  mccguideCurved4_w2 = 0.03;
#line 946 "RITA-II.instr"
  mccguideCurved4_h2 = 0.12;
#line 946 "RITA-II.instr"
  mccguideCurved4_l = 0.499995;
#line 947 "RITA-II.instr"
  mccguideCurved4_R0 = R0;
#line 947 "RITA-II.instr"
  mccguideCurved4_Qc = Qc;
#line 947 "RITA-II.instr"
  mccguideCurved4_alpha = ALPHA;
#line 947 "RITA-II.instr"
  mccguideCurved4_m = M;
#line 947 "RITA-II.instr"
  mccguideCurved4_W = W;
#line 21005 "RITA-II.c"

  SIG_MESSAGE("guideCurved4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 949 "RITA-II.instr"
    (0)*DEG2RAD,
#line 949 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 949 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21015 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved3, mcrotaguideCurved4);
  rot_transpose(mcrotaguideCurved3, mctr1);
  rot_mul(mcrotaguideCurved4, mctr1, mcrotrguideCurved4);
  mctc1 = coords_set(
#line 948 "RITA-II.instr"
    0,
#line 948 "RITA-II.instr"
    0,
#line 948 "RITA-II.instr"
    0.5);
#line 21026 "RITA-II.c"
  rot_transpose(mcrotaguideCurved3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved4 = coords_add(mcposaguideCurved3, mctc2);
  mctc1 = coords_sub(mcposaguideCurved3, mcposaguideCurved4);
  mcposrguideCurved4 = rot_apply(mcrotaguideCurved4, mctc1);
  mcDEBUG_COMPONENT("guideCurved4", mcposaguideCurved4, mcrotaguideCurved4)
  mccomp_posa[9] = mcposaguideCurved4;
  mccomp_posr[9] = mcposrguideCurved4;
  mcNCounter[9]  = mcPCounter[9] = mcP2Counter[9] = 0;
  mcAbsorbProp[9]= 0;
    /* Component guideCurved5. */
  /* Setting parameters for component guideCurved5. */
  SIG_MESSAGE("guideCurved5 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved5_reflect, 0 ? 0 : "", 16384); else mccguideCurved5_reflect[0]='\0';
#line 952 "RITA-II.instr"
  mccguideCurved5_w1 = 0.03;
#line 952 "RITA-II.instr"
  mccguideCurved5_h1 = 0.12;
#line 952 "RITA-II.instr"
  mccguideCurved5_w2 = 0.03;
#line 952 "RITA-II.instr"
  mccguideCurved5_h2 = 0.12;
#line 952 "RITA-II.instr"
  mccguideCurved5_l = 0.499995;
#line 953 "RITA-II.instr"
  mccguideCurved5_R0 = R0;
#line 953 "RITA-II.instr"
  mccguideCurved5_Qc = Qc;
#line 953 "RITA-II.instr"
  mccguideCurved5_alpha = ALPHA;
#line 953 "RITA-II.instr"
  mccguideCurved5_m = M;
#line 953 "RITA-II.instr"
  mccguideCurved5_W = W;
#line 21062 "RITA-II.c"

  SIG_MESSAGE("guideCurved5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 955 "RITA-II.instr"
    (0)*DEG2RAD,
#line 955 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 955 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21072 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved4, mcrotaguideCurved5);
  rot_transpose(mcrotaguideCurved4, mctr1);
  rot_mul(mcrotaguideCurved5, mctr1, mcrotrguideCurved5);
  mctc1 = coords_set(
#line 954 "RITA-II.instr"
    0,
#line 954 "RITA-II.instr"
    0,
#line 954 "RITA-II.instr"
    0.5);
#line 21083 "RITA-II.c"
  rot_transpose(mcrotaguideCurved4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved5 = coords_add(mcposaguideCurved4, mctc2);
  mctc1 = coords_sub(mcposaguideCurved4, mcposaguideCurved5);
  mcposrguideCurved5 = rot_apply(mcrotaguideCurved5, mctc1);
  mcDEBUG_COMPONENT("guideCurved5", mcposaguideCurved5, mcrotaguideCurved5)
  mccomp_posa[10] = mcposaguideCurved5;
  mccomp_posr[10] = mcposrguideCurved5;
  mcNCounter[10]  = mcPCounter[10] = mcP2Counter[10] = 0;
  mcAbsorbProp[10]= 0;
    /* Component guideCurved6. */
  /* Setting parameters for component guideCurved6. */
  SIG_MESSAGE("guideCurved6 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved6_reflect, 0 ? 0 : "", 16384); else mccguideCurved6_reflect[0]='\0';
#line 958 "RITA-II.instr"
  mccguideCurved6_w1 = 0.03;
#line 958 "RITA-II.instr"
  mccguideCurved6_h1 = 0.12;
#line 958 "RITA-II.instr"
  mccguideCurved6_w2 = 0.03;
#line 958 "RITA-II.instr"
  mccguideCurved6_h2 = 0.12;
#line 958 "RITA-II.instr"
  mccguideCurved6_l = 0.499995;
#line 959 "RITA-II.instr"
  mccguideCurved6_R0 = R0;
#line 959 "RITA-II.instr"
  mccguideCurved6_Qc = Qc;
#line 959 "RITA-II.instr"
  mccguideCurved6_alpha = ALPHA;
#line 959 "RITA-II.instr"
  mccguideCurved6_m = M;
#line 959 "RITA-II.instr"
  mccguideCurved6_W = W;
#line 21119 "RITA-II.c"

  SIG_MESSAGE("guideCurved6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 961 "RITA-II.instr"
    (0)*DEG2RAD,
#line 961 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 961 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21129 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved5, mcrotaguideCurved6);
  rot_transpose(mcrotaguideCurved5, mctr1);
  rot_mul(mcrotaguideCurved6, mctr1, mcrotrguideCurved6);
  mctc1 = coords_set(
#line 960 "RITA-II.instr"
    0,
#line 960 "RITA-II.instr"
    0,
#line 960 "RITA-II.instr"
    0.5);
#line 21140 "RITA-II.c"
  rot_transpose(mcrotaguideCurved5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved6 = coords_add(mcposaguideCurved5, mctc2);
  mctc1 = coords_sub(mcposaguideCurved5, mcposaguideCurved6);
  mcposrguideCurved6 = rot_apply(mcrotaguideCurved6, mctc1);
  mcDEBUG_COMPONENT("guideCurved6", mcposaguideCurved6, mcrotaguideCurved6)
  mccomp_posa[11] = mcposaguideCurved6;
  mccomp_posr[11] = mcposrguideCurved6;
  mcNCounter[11]  = mcPCounter[11] = mcP2Counter[11] = 0;
  mcAbsorbProp[11]= 0;
    /* Component guideCurved7. */
  /* Setting parameters for component guideCurved7. */
  SIG_MESSAGE("guideCurved7 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved7_reflect, 0 ? 0 : "", 16384); else mccguideCurved7_reflect[0]='\0';
#line 964 "RITA-II.instr"
  mccguideCurved7_w1 = 0.03;
#line 964 "RITA-II.instr"
  mccguideCurved7_h1 = 0.12;
#line 964 "RITA-II.instr"
  mccguideCurved7_w2 = 0.03;
#line 964 "RITA-II.instr"
  mccguideCurved7_h2 = 0.12;
#line 964 "RITA-II.instr"
  mccguideCurved7_l = 0.499995;
#line 965 "RITA-II.instr"
  mccguideCurved7_R0 = R0;
#line 965 "RITA-II.instr"
  mccguideCurved7_Qc = Qc;
#line 965 "RITA-II.instr"
  mccguideCurved7_alpha = ALPHA;
#line 965 "RITA-II.instr"
  mccguideCurved7_m = M;
#line 965 "RITA-II.instr"
  mccguideCurved7_W = W;
#line 21176 "RITA-II.c"

  SIG_MESSAGE("guideCurved7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 967 "RITA-II.instr"
    (0)*DEG2RAD,
#line 967 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 967 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21186 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved6, mcrotaguideCurved7);
  rot_transpose(mcrotaguideCurved6, mctr1);
  rot_mul(mcrotaguideCurved7, mctr1, mcrotrguideCurved7);
  mctc1 = coords_set(
#line 966 "RITA-II.instr"
    0,
#line 966 "RITA-II.instr"
    0,
#line 966 "RITA-II.instr"
    0.5);
#line 21197 "RITA-II.c"
  rot_transpose(mcrotaguideCurved6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved7 = coords_add(mcposaguideCurved6, mctc2);
  mctc1 = coords_sub(mcposaguideCurved6, mcposaguideCurved7);
  mcposrguideCurved7 = rot_apply(mcrotaguideCurved7, mctc1);
  mcDEBUG_COMPONENT("guideCurved7", mcposaguideCurved7, mcrotaguideCurved7)
  mccomp_posa[12] = mcposaguideCurved7;
  mccomp_posr[12] = mcposrguideCurved7;
  mcNCounter[12]  = mcPCounter[12] = mcP2Counter[12] = 0;
  mcAbsorbProp[12]= 0;
    /* Component guideCurved8. */
  /* Setting parameters for component guideCurved8. */
  SIG_MESSAGE("guideCurved8 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved8_reflect, 0 ? 0 : "", 16384); else mccguideCurved8_reflect[0]='\0';
#line 970 "RITA-II.instr"
  mccguideCurved8_w1 = 0.03;
#line 970 "RITA-II.instr"
  mccguideCurved8_h1 = 0.12;
#line 970 "RITA-II.instr"
  mccguideCurved8_w2 = 0.03;
#line 970 "RITA-II.instr"
  mccguideCurved8_h2 = 0.12;
#line 970 "RITA-II.instr"
  mccguideCurved8_l = 0.499995;
#line 971 "RITA-II.instr"
  mccguideCurved8_R0 = R0;
#line 971 "RITA-II.instr"
  mccguideCurved8_Qc = Qc;
#line 971 "RITA-II.instr"
  mccguideCurved8_alpha = ALPHA;
#line 971 "RITA-II.instr"
  mccguideCurved8_m = M;
#line 971 "RITA-II.instr"
  mccguideCurved8_W = W;
#line 21233 "RITA-II.c"

  SIG_MESSAGE("guideCurved8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 973 "RITA-II.instr"
    (0)*DEG2RAD,
#line 973 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 973 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21243 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved7, mcrotaguideCurved8);
  rot_transpose(mcrotaguideCurved7, mctr1);
  rot_mul(mcrotaguideCurved8, mctr1, mcrotrguideCurved8);
  mctc1 = coords_set(
#line 972 "RITA-II.instr"
    0,
#line 972 "RITA-II.instr"
    0,
#line 972 "RITA-II.instr"
    0.5);
#line 21254 "RITA-II.c"
  rot_transpose(mcrotaguideCurved7, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved8 = coords_add(mcposaguideCurved7, mctc2);
  mctc1 = coords_sub(mcposaguideCurved7, mcposaguideCurved8);
  mcposrguideCurved8 = rot_apply(mcrotaguideCurved8, mctc1);
  mcDEBUG_COMPONENT("guideCurved8", mcposaguideCurved8, mcrotaguideCurved8)
  mccomp_posa[13] = mcposaguideCurved8;
  mccomp_posr[13] = mcposrguideCurved8;
  mcNCounter[13]  = mcPCounter[13] = mcP2Counter[13] = 0;
  mcAbsorbProp[13]= 0;
    /* Component guideCurved9. */
  /* Setting parameters for component guideCurved9. */
  SIG_MESSAGE("guideCurved9 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved9_reflect, 0 ? 0 : "", 16384); else mccguideCurved9_reflect[0]='\0';
#line 976 "RITA-II.instr"
  mccguideCurved9_w1 = 0.03;
#line 976 "RITA-II.instr"
  mccguideCurved9_h1 = 0.12;
#line 976 "RITA-II.instr"
  mccguideCurved9_w2 = 0.03;
#line 976 "RITA-II.instr"
  mccguideCurved9_h2 = 0.12;
#line 976 "RITA-II.instr"
  mccguideCurved9_l = 0.499995;
#line 977 "RITA-II.instr"
  mccguideCurved9_R0 = R0;
#line 977 "RITA-II.instr"
  mccguideCurved9_Qc = Qc;
#line 977 "RITA-II.instr"
  mccguideCurved9_alpha = ALPHA;
#line 977 "RITA-II.instr"
  mccguideCurved9_m = M;
#line 977 "RITA-II.instr"
  mccguideCurved9_W = W;
#line 21290 "RITA-II.c"

  SIG_MESSAGE("guideCurved9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 979 "RITA-II.instr"
    (0)*DEG2RAD,
#line 979 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 979 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21300 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved8, mcrotaguideCurved9);
  rot_transpose(mcrotaguideCurved8, mctr1);
  rot_mul(mcrotaguideCurved9, mctr1, mcrotrguideCurved9);
  mctc1 = coords_set(
#line 978 "RITA-II.instr"
    0,
#line 978 "RITA-II.instr"
    0,
#line 978 "RITA-II.instr"
    0.5);
#line 21311 "RITA-II.c"
  rot_transpose(mcrotaguideCurved8, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved9 = coords_add(mcposaguideCurved8, mctc2);
  mctc1 = coords_sub(mcposaguideCurved8, mcposaguideCurved9);
  mcposrguideCurved9 = rot_apply(mcrotaguideCurved9, mctc1);
  mcDEBUG_COMPONENT("guideCurved9", mcposaguideCurved9, mcrotaguideCurved9)
  mccomp_posa[14] = mcposaguideCurved9;
  mccomp_posr[14] = mcposrguideCurved9;
  mcNCounter[14]  = mcPCounter[14] = mcP2Counter[14] = 0;
  mcAbsorbProp[14]= 0;
    /* Component guideCurved10. */
  /* Setting parameters for component guideCurved10. */
  SIG_MESSAGE("guideCurved10 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved10_reflect, 0 ? 0 : "", 16384); else mccguideCurved10_reflect[0]='\0';
#line 982 "RITA-II.instr"
  mccguideCurved10_w1 = 0.03;
#line 982 "RITA-II.instr"
  mccguideCurved10_h1 = 0.12;
#line 982 "RITA-II.instr"
  mccguideCurved10_w2 = 0.03;
#line 982 "RITA-II.instr"
  mccguideCurved10_h2 = 0.12;
#line 982 "RITA-II.instr"
  mccguideCurved10_l = 0.499995;
#line 983 "RITA-II.instr"
  mccguideCurved10_R0 = R0;
#line 983 "RITA-II.instr"
  mccguideCurved10_Qc = Qc;
#line 983 "RITA-II.instr"
  mccguideCurved10_alpha = ALPHA;
#line 983 "RITA-II.instr"
  mccguideCurved10_m = M;
#line 983 "RITA-II.instr"
  mccguideCurved10_W = W;
#line 21347 "RITA-II.c"

  SIG_MESSAGE("guideCurved10 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 985 "RITA-II.instr"
    (0)*DEG2RAD,
#line 985 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 985 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21357 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved9, mcrotaguideCurved10);
  rot_transpose(mcrotaguideCurved9, mctr1);
  rot_mul(mcrotaguideCurved10, mctr1, mcrotrguideCurved10);
  mctc1 = coords_set(
#line 984 "RITA-II.instr"
    0,
#line 984 "RITA-II.instr"
    0,
#line 984 "RITA-II.instr"
    0.5);
#line 21368 "RITA-II.c"
  rot_transpose(mcrotaguideCurved9, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved10 = coords_add(mcposaguideCurved9, mctc2);
  mctc1 = coords_sub(mcposaguideCurved9, mcposaguideCurved10);
  mcposrguideCurved10 = rot_apply(mcrotaguideCurved10, mctc1);
  mcDEBUG_COMPONENT("guideCurved10", mcposaguideCurved10, mcrotaguideCurved10)
  mccomp_posa[15] = mcposaguideCurved10;
  mccomp_posr[15] = mcposrguideCurved10;
  mcNCounter[15]  = mcPCounter[15] = mcP2Counter[15] = 0;
  mcAbsorbProp[15]= 0;
    /* Component guideCurved11. */
  /* Setting parameters for component guideCurved11. */
  SIG_MESSAGE("guideCurved11 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved11_reflect, 0 ? 0 : "", 16384); else mccguideCurved11_reflect[0]='\0';
#line 988 "RITA-II.instr"
  mccguideCurved11_w1 = 0.03;
#line 988 "RITA-II.instr"
  mccguideCurved11_h1 = 0.12;
#line 988 "RITA-II.instr"
  mccguideCurved11_w2 = 0.03;
#line 988 "RITA-II.instr"
  mccguideCurved11_h2 = 0.12;
#line 988 "RITA-II.instr"
  mccguideCurved11_l = 0.499995;
#line 989 "RITA-II.instr"
  mccguideCurved11_R0 = R0;
#line 989 "RITA-II.instr"
  mccguideCurved11_Qc = Qc;
#line 989 "RITA-II.instr"
  mccguideCurved11_alpha = ALPHA;
#line 989 "RITA-II.instr"
  mccguideCurved11_m = M;
#line 989 "RITA-II.instr"
  mccguideCurved11_W = W;
#line 21404 "RITA-II.c"

  SIG_MESSAGE("guideCurved11 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 991 "RITA-II.instr"
    (0)*DEG2RAD,
#line 991 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 991 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21414 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved10, mcrotaguideCurved11);
  rot_transpose(mcrotaguideCurved10, mctr1);
  rot_mul(mcrotaguideCurved11, mctr1, mcrotrguideCurved11);
  mctc1 = coords_set(
#line 990 "RITA-II.instr"
    0,
#line 990 "RITA-II.instr"
    0,
#line 990 "RITA-II.instr"
    0.5);
#line 21425 "RITA-II.c"
  rot_transpose(mcrotaguideCurved10, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved11 = coords_add(mcposaguideCurved10, mctc2);
  mctc1 = coords_sub(mcposaguideCurved10, mcposaguideCurved11);
  mcposrguideCurved11 = rot_apply(mcrotaguideCurved11, mctc1);
  mcDEBUG_COMPONENT("guideCurved11", mcposaguideCurved11, mcrotaguideCurved11)
  mccomp_posa[16] = mcposaguideCurved11;
  mccomp_posr[16] = mcposrguideCurved11;
  mcNCounter[16]  = mcPCounter[16] = mcP2Counter[16] = 0;
  mcAbsorbProp[16]= 0;
    /* Component guideCurved12. */
  /* Setting parameters for component guideCurved12. */
  SIG_MESSAGE("guideCurved12 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved12_reflect, 0 ? 0 : "", 16384); else mccguideCurved12_reflect[0]='\0';
#line 994 "RITA-II.instr"
  mccguideCurved12_w1 = 0.03;
#line 994 "RITA-II.instr"
  mccguideCurved12_h1 = 0.12;
#line 994 "RITA-II.instr"
  mccguideCurved12_w2 = 0.03;
#line 994 "RITA-II.instr"
  mccguideCurved12_h2 = 0.12;
#line 994 "RITA-II.instr"
  mccguideCurved12_l = 0.499995;
#line 995 "RITA-II.instr"
  mccguideCurved12_R0 = R0;
#line 995 "RITA-II.instr"
  mccguideCurved12_Qc = Qc;
#line 995 "RITA-II.instr"
  mccguideCurved12_alpha = ALPHA;
#line 995 "RITA-II.instr"
  mccguideCurved12_m = M;
#line 995 "RITA-II.instr"
  mccguideCurved12_W = W;
#line 21461 "RITA-II.c"

  SIG_MESSAGE("guideCurved12 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 997 "RITA-II.instr"
    (0)*DEG2RAD,
#line 997 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 997 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21471 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved11, mcrotaguideCurved12);
  rot_transpose(mcrotaguideCurved11, mctr1);
  rot_mul(mcrotaguideCurved12, mctr1, mcrotrguideCurved12);
  mctc1 = coords_set(
#line 996 "RITA-II.instr"
    0,
#line 996 "RITA-II.instr"
    0,
#line 996 "RITA-II.instr"
    0.5);
#line 21482 "RITA-II.c"
  rot_transpose(mcrotaguideCurved11, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved12 = coords_add(mcposaguideCurved11, mctc2);
  mctc1 = coords_sub(mcposaguideCurved11, mcposaguideCurved12);
  mcposrguideCurved12 = rot_apply(mcrotaguideCurved12, mctc1);
  mcDEBUG_COMPONENT("guideCurved12", mcposaguideCurved12, mcrotaguideCurved12)
  mccomp_posa[17] = mcposaguideCurved12;
  mccomp_posr[17] = mcposrguideCurved12;
  mcNCounter[17]  = mcPCounter[17] = mcP2Counter[17] = 0;
  mcAbsorbProp[17]= 0;
    /* Component guideCurved13. */
  /* Setting parameters for component guideCurved13. */
  SIG_MESSAGE("guideCurved13 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved13_reflect, 0 ? 0 : "", 16384); else mccguideCurved13_reflect[0]='\0';
#line 1000 "RITA-II.instr"
  mccguideCurved13_w1 = 0.03;
#line 1000 "RITA-II.instr"
  mccguideCurved13_h1 = 0.12;
#line 1000 "RITA-II.instr"
  mccguideCurved13_w2 = 0.03;
#line 1000 "RITA-II.instr"
  mccguideCurved13_h2 = 0.12;
#line 1000 "RITA-II.instr"
  mccguideCurved13_l = 0.499995;
#line 1001 "RITA-II.instr"
  mccguideCurved13_R0 = R0;
#line 1001 "RITA-II.instr"
  mccguideCurved13_Qc = Qc;
#line 1001 "RITA-II.instr"
  mccguideCurved13_alpha = ALPHA;
#line 1001 "RITA-II.instr"
  mccguideCurved13_m = M;
#line 1001 "RITA-II.instr"
  mccguideCurved13_W = W;
#line 21518 "RITA-II.c"

  SIG_MESSAGE("guideCurved13 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1003 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1003 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1003 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21528 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved12, mcrotaguideCurved13);
  rot_transpose(mcrotaguideCurved12, mctr1);
  rot_mul(mcrotaguideCurved13, mctr1, mcrotrguideCurved13);
  mctc1 = coords_set(
#line 1002 "RITA-II.instr"
    0,
#line 1002 "RITA-II.instr"
    0,
#line 1002 "RITA-II.instr"
    0.5);
#line 21539 "RITA-II.c"
  rot_transpose(mcrotaguideCurved12, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved13 = coords_add(mcposaguideCurved12, mctc2);
  mctc1 = coords_sub(mcposaguideCurved12, mcposaguideCurved13);
  mcposrguideCurved13 = rot_apply(mcrotaguideCurved13, mctc1);
  mcDEBUG_COMPONENT("guideCurved13", mcposaguideCurved13, mcrotaguideCurved13)
  mccomp_posa[18] = mcposaguideCurved13;
  mccomp_posr[18] = mcposrguideCurved13;
  mcNCounter[18]  = mcPCounter[18] = mcP2Counter[18] = 0;
  mcAbsorbProp[18]= 0;
    /* Component guideCurved14. */
  /* Setting parameters for component guideCurved14. */
  SIG_MESSAGE("guideCurved14 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved14_reflect, 0 ? 0 : "", 16384); else mccguideCurved14_reflect[0]='\0';
#line 1006 "RITA-II.instr"
  mccguideCurved14_w1 = 0.03;
#line 1006 "RITA-II.instr"
  mccguideCurved14_h1 = 0.12;
#line 1006 "RITA-II.instr"
  mccguideCurved14_w2 = 0.03;
#line 1006 "RITA-II.instr"
  mccguideCurved14_h2 = 0.12;
#line 1006 "RITA-II.instr"
  mccguideCurved14_l = 0.499995;
#line 1007 "RITA-II.instr"
  mccguideCurved14_R0 = R0;
#line 1007 "RITA-II.instr"
  mccguideCurved14_Qc = Qc;
#line 1007 "RITA-II.instr"
  mccguideCurved14_alpha = ALPHA;
#line 1007 "RITA-II.instr"
  mccguideCurved14_m = M;
#line 1007 "RITA-II.instr"
  mccguideCurved14_W = W;
#line 21575 "RITA-II.c"

  SIG_MESSAGE("guideCurved14 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1009 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1009 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1009 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21585 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved13, mcrotaguideCurved14);
  rot_transpose(mcrotaguideCurved13, mctr1);
  rot_mul(mcrotaguideCurved14, mctr1, mcrotrguideCurved14);
  mctc1 = coords_set(
#line 1008 "RITA-II.instr"
    0,
#line 1008 "RITA-II.instr"
    0,
#line 1008 "RITA-II.instr"
    0.5);
#line 21596 "RITA-II.c"
  rot_transpose(mcrotaguideCurved13, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved14 = coords_add(mcposaguideCurved13, mctc2);
  mctc1 = coords_sub(mcposaguideCurved13, mcposaguideCurved14);
  mcposrguideCurved14 = rot_apply(mcrotaguideCurved14, mctc1);
  mcDEBUG_COMPONENT("guideCurved14", mcposaguideCurved14, mcrotaguideCurved14)
  mccomp_posa[19] = mcposaguideCurved14;
  mccomp_posr[19] = mcposrguideCurved14;
  mcNCounter[19]  = mcPCounter[19] = mcP2Counter[19] = 0;
  mcAbsorbProp[19]= 0;
    /* Component guideCurved15. */
  /* Setting parameters for component guideCurved15. */
  SIG_MESSAGE("guideCurved15 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved15_reflect, 0 ? 0 : "", 16384); else mccguideCurved15_reflect[0]='\0';
#line 1012 "RITA-II.instr"
  mccguideCurved15_w1 = 0.03;
#line 1012 "RITA-II.instr"
  mccguideCurved15_h1 = 0.12;
#line 1012 "RITA-II.instr"
  mccguideCurved15_w2 = 0.03;
#line 1012 "RITA-II.instr"
  mccguideCurved15_h2 = 0.12;
#line 1012 "RITA-II.instr"
  mccguideCurved15_l = 0.499995;
#line 1013 "RITA-II.instr"
  mccguideCurved15_R0 = R0;
#line 1013 "RITA-II.instr"
  mccguideCurved15_Qc = Qc;
#line 1013 "RITA-II.instr"
  mccguideCurved15_alpha = ALPHA;
#line 1013 "RITA-II.instr"
  mccguideCurved15_m = M;
#line 1013 "RITA-II.instr"
  mccguideCurved15_W = W;
#line 21632 "RITA-II.c"

  SIG_MESSAGE("guideCurved15 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1015 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1015 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1015 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21642 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved14, mcrotaguideCurved15);
  rot_transpose(mcrotaguideCurved14, mctr1);
  rot_mul(mcrotaguideCurved15, mctr1, mcrotrguideCurved15);
  mctc1 = coords_set(
#line 1014 "RITA-II.instr"
    0,
#line 1014 "RITA-II.instr"
    0,
#line 1014 "RITA-II.instr"
    0.5);
#line 21653 "RITA-II.c"
  rot_transpose(mcrotaguideCurved14, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved15 = coords_add(mcposaguideCurved14, mctc2);
  mctc1 = coords_sub(mcposaguideCurved14, mcposaguideCurved15);
  mcposrguideCurved15 = rot_apply(mcrotaguideCurved15, mctc1);
  mcDEBUG_COMPONENT("guideCurved15", mcposaguideCurved15, mcrotaguideCurved15)
  mccomp_posa[20] = mcposaguideCurved15;
  mccomp_posr[20] = mcposrguideCurved15;
  mcNCounter[20]  = mcPCounter[20] = mcP2Counter[20] = 0;
  mcAbsorbProp[20]= 0;
    /* Component guideCurved16. */
  /* Setting parameters for component guideCurved16. */
  SIG_MESSAGE("guideCurved16 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved16_reflect, 0 ? 0 : "", 16384); else mccguideCurved16_reflect[0]='\0';
#line 1018 "RITA-II.instr"
  mccguideCurved16_w1 = 0.03;
#line 1018 "RITA-II.instr"
  mccguideCurved16_h1 = 0.12;
#line 1018 "RITA-II.instr"
  mccguideCurved16_w2 = 0.03;
#line 1018 "RITA-II.instr"
  mccguideCurved16_h2 = 0.12;
#line 1018 "RITA-II.instr"
  mccguideCurved16_l = 0.499995;
#line 1019 "RITA-II.instr"
  mccguideCurved16_R0 = R0;
#line 1019 "RITA-II.instr"
  mccguideCurved16_Qc = Qc;
#line 1019 "RITA-II.instr"
  mccguideCurved16_alpha = ALPHA;
#line 1019 "RITA-II.instr"
  mccguideCurved16_m = M;
#line 1019 "RITA-II.instr"
  mccguideCurved16_W = W;
#line 21689 "RITA-II.c"

  SIG_MESSAGE("guideCurved16 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1021 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1021 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1021 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21699 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved15, mcrotaguideCurved16);
  rot_transpose(mcrotaguideCurved15, mctr1);
  rot_mul(mcrotaguideCurved16, mctr1, mcrotrguideCurved16);
  mctc1 = coords_set(
#line 1020 "RITA-II.instr"
    0,
#line 1020 "RITA-II.instr"
    0,
#line 1020 "RITA-II.instr"
    0.5);
#line 21710 "RITA-II.c"
  rot_transpose(mcrotaguideCurved15, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved16 = coords_add(mcposaguideCurved15, mctc2);
  mctc1 = coords_sub(mcposaguideCurved15, mcposaguideCurved16);
  mcposrguideCurved16 = rot_apply(mcrotaguideCurved16, mctc1);
  mcDEBUG_COMPONENT("guideCurved16", mcposaguideCurved16, mcrotaguideCurved16)
  mccomp_posa[21] = mcposaguideCurved16;
  mccomp_posr[21] = mcposrguideCurved16;
  mcNCounter[21]  = mcPCounter[21] = mcP2Counter[21] = 0;
  mcAbsorbProp[21]= 0;
    /* Component guideCurved17. */
  /* Setting parameters for component guideCurved17. */
  SIG_MESSAGE("guideCurved17 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved17_reflect, 0 ? 0 : "", 16384); else mccguideCurved17_reflect[0]='\0';
#line 1024 "RITA-II.instr"
  mccguideCurved17_w1 = 0.03;
#line 1024 "RITA-II.instr"
  mccguideCurved17_h1 = 0.12;
#line 1024 "RITA-II.instr"
  mccguideCurved17_w2 = 0.03;
#line 1024 "RITA-II.instr"
  mccguideCurved17_h2 = 0.12;
#line 1024 "RITA-II.instr"
  mccguideCurved17_l = 0.499995;
#line 1025 "RITA-II.instr"
  mccguideCurved17_R0 = R0;
#line 1025 "RITA-II.instr"
  mccguideCurved17_Qc = Qc;
#line 1025 "RITA-II.instr"
  mccguideCurved17_alpha = ALPHA;
#line 1025 "RITA-II.instr"
  mccguideCurved17_m = M;
#line 1025 "RITA-II.instr"
  mccguideCurved17_W = W;
#line 21746 "RITA-II.c"

  SIG_MESSAGE("guideCurved17 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1027 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1027 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1027 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21756 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved16, mcrotaguideCurved17);
  rot_transpose(mcrotaguideCurved16, mctr1);
  rot_mul(mcrotaguideCurved17, mctr1, mcrotrguideCurved17);
  mctc1 = coords_set(
#line 1026 "RITA-II.instr"
    0,
#line 1026 "RITA-II.instr"
    0,
#line 1026 "RITA-II.instr"
    0.5);
#line 21767 "RITA-II.c"
  rot_transpose(mcrotaguideCurved16, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved17 = coords_add(mcposaguideCurved16, mctc2);
  mctc1 = coords_sub(mcposaguideCurved16, mcposaguideCurved17);
  mcposrguideCurved17 = rot_apply(mcrotaguideCurved17, mctc1);
  mcDEBUG_COMPONENT("guideCurved17", mcposaguideCurved17, mcrotaguideCurved17)
  mccomp_posa[22] = mcposaguideCurved17;
  mccomp_posr[22] = mcposrguideCurved17;
  mcNCounter[22]  = mcPCounter[22] = mcP2Counter[22] = 0;
  mcAbsorbProp[22]= 0;
    /* Component guideCurved18. */
  /* Setting parameters for component guideCurved18. */
  SIG_MESSAGE("guideCurved18 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved18_reflect, 0 ? 0 : "", 16384); else mccguideCurved18_reflect[0]='\0';
#line 1030 "RITA-II.instr"
  mccguideCurved18_w1 = 0.03;
#line 1030 "RITA-II.instr"
  mccguideCurved18_h1 = 0.12;
#line 1030 "RITA-II.instr"
  mccguideCurved18_w2 = 0.03;
#line 1030 "RITA-II.instr"
  mccguideCurved18_h2 = 0.12;
#line 1030 "RITA-II.instr"
  mccguideCurved18_l = 0.499995;
#line 1031 "RITA-II.instr"
  mccguideCurved18_R0 = R0;
#line 1031 "RITA-II.instr"
  mccguideCurved18_Qc = Qc;
#line 1031 "RITA-II.instr"
  mccguideCurved18_alpha = ALPHA;
#line 1031 "RITA-II.instr"
  mccguideCurved18_m = M;
#line 1031 "RITA-II.instr"
  mccguideCurved18_W = W;
#line 21803 "RITA-II.c"

  SIG_MESSAGE("guideCurved18 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1033 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1033 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1033 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21813 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved17, mcrotaguideCurved18);
  rot_transpose(mcrotaguideCurved17, mctr1);
  rot_mul(mcrotaguideCurved18, mctr1, mcrotrguideCurved18);
  mctc1 = coords_set(
#line 1032 "RITA-II.instr"
    0,
#line 1032 "RITA-II.instr"
    0,
#line 1032 "RITA-II.instr"
    0.5);
#line 21824 "RITA-II.c"
  rot_transpose(mcrotaguideCurved17, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved18 = coords_add(mcposaguideCurved17, mctc2);
  mctc1 = coords_sub(mcposaguideCurved17, mcposaguideCurved18);
  mcposrguideCurved18 = rot_apply(mcrotaguideCurved18, mctc1);
  mcDEBUG_COMPONENT("guideCurved18", mcposaguideCurved18, mcrotaguideCurved18)
  mccomp_posa[23] = mcposaguideCurved18;
  mccomp_posr[23] = mcposrguideCurved18;
  mcNCounter[23]  = mcPCounter[23] = mcP2Counter[23] = 0;
  mcAbsorbProp[23]= 0;
    /* Component guideCurved19. */
  /* Setting parameters for component guideCurved19. */
  SIG_MESSAGE("guideCurved19 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved19_reflect, 0 ? 0 : "", 16384); else mccguideCurved19_reflect[0]='\0';
#line 1036 "RITA-II.instr"
  mccguideCurved19_w1 = 0.03;
#line 1036 "RITA-II.instr"
  mccguideCurved19_h1 = 0.12;
#line 1036 "RITA-II.instr"
  mccguideCurved19_w2 = 0.03;
#line 1036 "RITA-II.instr"
  mccguideCurved19_h2 = 0.12;
#line 1036 "RITA-II.instr"
  mccguideCurved19_l = 0.499995;
#line 1037 "RITA-II.instr"
  mccguideCurved19_R0 = R0;
#line 1037 "RITA-II.instr"
  mccguideCurved19_Qc = Qc;
#line 1037 "RITA-II.instr"
  mccguideCurved19_alpha = ALPHA;
#line 1037 "RITA-II.instr"
  mccguideCurved19_m = M;
#line 1037 "RITA-II.instr"
  mccguideCurved19_W = W;
#line 21860 "RITA-II.c"

  SIG_MESSAGE("guideCurved19 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1039 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1039 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1039 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21870 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved18, mcrotaguideCurved19);
  rot_transpose(mcrotaguideCurved18, mctr1);
  rot_mul(mcrotaguideCurved19, mctr1, mcrotrguideCurved19);
  mctc1 = coords_set(
#line 1038 "RITA-II.instr"
    0,
#line 1038 "RITA-II.instr"
    0,
#line 1038 "RITA-II.instr"
    0.5);
#line 21881 "RITA-II.c"
  rot_transpose(mcrotaguideCurved18, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved19 = coords_add(mcposaguideCurved18, mctc2);
  mctc1 = coords_sub(mcposaguideCurved18, mcposaguideCurved19);
  mcposrguideCurved19 = rot_apply(mcrotaguideCurved19, mctc1);
  mcDEBUG_COMPONENT("guideCurved19", mcposaguideCurved19, mcrotaguideCurved19)
  mccomp_posa[24] = mcposaguideCurved19;
  mccomp_posr[24] = mcposrguideCurved19;
  mcNCounter[24]  = mcPCounter[24] = mcP2Counter[24] = 0;
  mcAbsorbProp[24]= 0;
    /* Component guideCurved20. */
  /* Setting parameters for component guideCurved20. */
  SIG_MESSAGE("guideCurved20 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved20_reflect, 0 ? 0 : "", 16384); else mccguideCurved20_reflect[0]='\0';
#line 1042 "RITA-II.instr"
  mccguideCurved20_w1 = 0.03;
#line 1042 "RITA-II.instr"
  mccguideCurved20_h1 = 0.12;
#line 1042 "RITA-II.instr"
  mccguideCurved20_w2 = 0.03;
#line 1042 "RITA-II.instr"
  mccguideCurved20_h2 = 0.12;
#line 1042 "RITA-II.instr"
  mccguideCurved20_l = 0.499995;
#line 1043 "RITA-II.instr"
  mccguideCurved20_R0 = R0;
#line 1043 "RITA-II.instr"
  mccguideCurved20_Qc = Qc;
#line 1043 "RITA-II.instr"
  mccguideCurved20_alpha = ALPHA;
#line 1043 "RITA-II.instr"
  mccguideCurved20_m = M;
#line 1043 "RITA-II.instr"
  mccguideCurved20_W = W;
#line 21917 "RITA-II.c"

  SIG_MESSAGE("guideCurved20 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1045 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1045 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1045 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21927 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved19, mcrotaguideCurved20);
  rot_transpose(mcrotaguideCurved19, mctr1);
  rot_mul(mcrotaguideCurved20, mctr1, mcrotrguideCurved20);
  mctc1 = coords_set(
#line 1044 "RITA-II.instr"
    0,
#line 1044 "RITA-II.instr"
    0,
#line 1044 "RITA-II.instr"
    0.5);
#line 21938 "RITA-II.c"
  rot_transpose(mcrotaguideCurved19, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved20 = coords_add(mcposaguideCurved19, mctc2);
  mctc1 = coords_sub(mcposaguideCurved19, mcposaguideCurved20);
  mcposrguideCurved20 = rot_apply(mcrotaguideCurved20, mctc1);
  mcDEBUG_COMPONENT("guideCurved20", mcposaguideCurved20, mcrotaguideCurved20)
  mccomp_posa[25] = mcposaguideCurved20;
  mccomp_posr[25] = mcposrguideCurved20;
  mcNCounter[25]  = mcPCounter[25] = mcP2Counter[25] = 0;
  mcAbsorbProp[25]= 0;
    /* Component guideCurved21. */
  /* Setting parameters for component guideCurved21. */
  SIG_MESSAGE("guideCurved21 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved21_reflect, 0 ? 0 : "", 16384); else mccguideCurved21_reflect[0]='\0';
#line 1048 "RITA-II.instr"
  mccguideCurved21_w1 = 0.03;
#line 1048 "RITA-II.instr"
  mccguideCurved21_h1 = 0.12;
#line 1048 "RITA-II.instr"
  mccguideCurved21_w2 = 0.03;
#line 1048 "RITA-II.instr"
  mccguideCurved21_h2 = 0.12;
#line 1048 "RITA-II.instr"
  mccguideCurved21_l = 0.499995;
#line 1049 "RITA-II.instr"
  mccguideCurved21_R0 = R0;
#line 1049 "RITA-II.instr"
  mccguideCurved21_Qc = Qc;
#line 1049 "RITA-II.instr"
  mccguideCurved21_alpha = ALPHA;
#line 1049 "RITA-II.instr"
  mccguideCurved21_m = M;
#line 1049 "RITA-II.instr"
  mccguideCurved21_W = W;
#line 21974 "RITA-II.c"

  SIG_MESSAGE("guideCurved21 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1051 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1051 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1051 "RITA-II.instr"
    (0)*DEG2RAD);
#line 21984 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved20, mcrotaguideCurved21);
  rot_transpose(mcrotaguideCurved20, mctr1);
  rot_mul(mcrotaguideCurved21, mctr1, mcrotrguideCurved21);
  mctc1 = coords_set(
#line 1050 "RITA-II.instr"
    0,
#line 1050 "RITA-II.instr"
    0,
#line 1050 "RITA-II.instr"
    0.5);
#line 21995 "RITA-II.c"
  rot_transpose(mcrotaguideCurved20, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved21 = coords_add(mcposaguideCurved20, mctc2);
  mctc1 = coords_sub(mcposaguideCurved20, mcposaguideCurved21);
  mcposrguideCurved21 = rot_apply(mcrotaguideCurved21, mctc1);
  mcDEBUG_COMPONENT("guideCurved21", mcposaguideCurved21, mcrotaguideCurved21)
  mccomp_posa[26] = mcposaguideCurved21;
  mccomp_posr[26] = mcposrguideCurved21;
  mcNCounter[26]  = mcPCounter[26] = mcP2Counter[26] = 0;
  mcAbsorbProp[26]= 0;
    /* Component guideCurved22. */
  /* Setting parameters for component guideCurved22. */
  SIG_MESSAGE("guideCurved22 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved22_reflect, 0 ? 0 : "", 16384); else mccguideCurved22_reflect[0]='\0';
#line 1054 "RITA-II.instr"
  mccguideCurved22_w1 = 0.03;
#line 1054 "RITA-II.instr"
  mccguideCurved22_h1 = 0.12;
#line 1054 "RITA-II.instr"
  mccguideCurved22_w2 = 0.03;
#line 1054 "RITA-II.instr"
  mccguideCurved22_h2 = 0.12;
#line 1054 "RITA-II.instr"
  mccguideCurved22_l = 0.499995;
#line 1055 "RITA-II.instr"
  mccguideCurved22_R0 = R0;
#line 1055 "RITA-II.instr"
  mccguideCurved22_Qc = Qc;
#line 1055 "RITA-II.instr"
  mccguideCurved22_alpha = ALPHA;
#line 1055 "RITA-II.instr"
  mccguideCurved22_m = M;
#line 1055 "RITA-II.instr"
  mccguideCurved22_W = W;
#line 22031 "RITA-II.c"

  SIG_MESSAGE("guideCurved22 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1057 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1057 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1057 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22041 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved21, mcrotaguideCurved22);
  rot_transpose(mcrotaguideCurved21, mctr1);
  rot_mul(mcrotaguideCurved22, mctr1, mcrotrguideCurved22);
  mctc1 = coords_set(
#line 1056 "RITA-II.instr"
    0,
#line 1056 "RITA-II.instr"
    0,
#line 1056 "RITA-II.instr"
    0.5);
#line 22052 "RITA-II.c"
  rot_transpose(mcrotaguideCurved21, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved22 = coords_add(mcposaguideCurved21, mctc2);
  mctc1 = coords_sub(mcposaguideCurved21, mcposaguideCurved22);
  mcposrguideCurved22 = rot_apply(mcrotaguideCurved22, mctc1);
  mcDEBUG_COMPONENT("guideCurved22", mcposaguideCurved22, mcrotaguideCurved22)
  mccomp_posa[27] = mcposaguideCurved22;
  mccomp_posr[27] = mcposrguideCurved22;
  mcNCounter[27]  = mcPCounter[27] = mcP2Counter[27] = 0;
  mcAbsorbProp[27]= 0;
    /* Component guideCurved23. */
  /* Setting parameters for component guideCurved23. */
  SIG_MESSAGE("guideCurved23 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved23_reflect, 0 ? 0 : "", 16384); else mccguideCurved23_reflect[0]='\0';
#line 1060 "RITA-II.instr"
  mccguideCurved23_w1 = 0.03;
#line 1060 "RITA-II.instr"
  mccguideCurved23_h1 = 0.12;
#line 1060 "RITA-II.instr"
  mccguideCurved23_w2 = 0.03;
#line 1060 "RITA-II.instr"
  mccguideCurved23_h2 = 0.12;
#line 1060 "RITA-II.instr"
  mccguideCurved23_l = 0.499995;
#line 1061 "RITA-II.instr"
  mccguideCurved23_R0 = R0;
#line 1061 "RITA-II.instr"
  mccguideCurved23_Qc = Qc;
#line 1061 "RITA-II.instr"
  mccguideCurved23_alpha = ALPHA;
#line 1061 "RITA-II.instr"
  mccguideCurved23_m = M;
#line 1061 "RITA-II.instr"
  mccguideCurved23_W = W;
#line 22088 "RITA-II.c"

  SIG_MESSAGE("guideCurved23 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1063 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1063 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1063 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22098 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved22, mcrotaguideCurved23);
  rot_transpose(mcrotaguideCurved22, mctr1);
  rot_mul(mcrotaguideCurved23, mctr1, mcrotrguideCurved23);
  mctc1 = coords_set(
#line 1062 "RITA-II.instr"
    0,
#line 1062 "RITA-II.instr"
    0,
#line 1062 "RITA-II.instr"
    0.5);
#line 22109 "RITA-II.c"
  rot_transpose(mcrotaguideCurved22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved23 = coords_add(mcposaguideCurved22, mctc2);
  mctc1 = coords_sub(mcposaguideCurved22, mcposaguideCurved23);
  mcposrguideCurved23 = rot_apply(mcrotaguideCurved23, mctc1);
  mcDEBUG_COMPONENT("guideCurved23", mcposaguideCurved23, mcrotaguideCurved23)
  mccomp_posa[28] = mcposaguideCurved23;
  mccomp_posr[28] = mcposrguideCurved23;
  mcNCounter[28]  = mcPCounter[28] = mcP2Counter[28] = 0;
  mcAbsorbProp[28]= 0;
    /* Component guideCurved24. */
  /* Setting parameters for component guideCurved24. */
  SIG_MESSAGE("guideCurved24 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved24_reflect, 0 ? 0 : "", 16384); else mccguideCurved24_reflect[0]='\0';
#line 1066 "RITA-II.instr"
  mccguideCurved24_w1 = 0.03;
#line 1066 "RITA-II.instr"
  mccguideCurved24_h1 = 0.12;
#line 1066 "RITA-II.instr"
  mccguideCurved24_w2 = 0.03;
#line 1066 "RITA-II.instr"
  mccguideCurved24_h2 = 0.12;
#line 1066 "RITA-II.instr"
  mccguideCurved24_l = 0.499995;
#line 1067 "RITA-II.instr"
  mccguideCurved24_R0 = R0;
#line 1067 "RITA-II.instr"
  mccguideCurved24_Qc = Qc;
#line 1067 "RITA-II.instr"
  mccguideCurved24_alpha = ALPHA;
#line 1067 "RITA-II.instr"
  mccguideCurved24_m = M;
#line 1067 "RITA-II.instr"
  mccguideCurved24_W = W;
#line 22145 "RITA-II.c"

  SIG_MESSAGE("guideCurved24 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1069 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1069 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1069 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22155 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved23, mcrotaguideCurved24);
  rot_transpose(mcrotaguideCurved23, mctr1);
  rot_mul(mcrotaguideCurved24, mctr1, mcrotrguideCurved24);
  mctc1 = coords_set(
#line 1068 "RITA-II.instr"
    0,
#line 1068 "RITA-II.instr"
    0,
#line 1068 "RITA-II.instr"
    0.5);
#line 22166 "RITA-II.c"
  rot_transpose(mcrotaguideCurved23, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved24 = coords_add(mcposaguideCurved23, mctc2);
  mctc1 = coords_sub(mcposaguideCurved23, mcposaguideCurved24);
  mcposrguideCurved24 = rot_apply(mcrotaguideCurved24, mctc1);
  mcDEBUG_COMPONENT("guideCurved24", mcposaguideCurved24, mcrotaguideCurved24)
  mccomp_posa[29] = mcposaguideCurved24;
  mccomp_posr[29] = mcposrguideCurved24;
  mcNCounter[29]  = mcPCounter[29] = mcP2Counter[29] = 0;
  mcAbsorbProp[29]= 0;
    /* Component guideCurved25. */
  /* Setting parameters for component guideCurved25. */
  SIG_MESSAGE("guideCurved25 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved25_reflect, 0 ? 0 : "", 16384); else mccguideCurved25_reflect[0]='\0';
#line 1072 "RITA-II.instr"
  mccguideCurved25_w1 = 0.03;
#line 1072 "RITA-II.instr"
  mccguideCurved25_h1 = 0.12;
#line 1072 "RITA-II.instr"
  mccguideCurved25_w2 = 0.03;
#line 1072 "RITA-II.instr"
  mccguideCurved25_h2 = 0.12;
#line 1072 "RITA-II.instr"
  mccguideCurved25_l = 0.499995;
#line 1073 "RITA-II.instr"
  mccguideCurved25_R0 = R0;
#line 1073 "RITA-II.instr"
  mccguideCurved25_Qc = Qc;
#line 1073 "RITA-II.instr"
  mccguideCurved25_alpha = ALPHA;
#line 1073 "RITA-II.instr"
  mccguideCurved25_m = M;
#line 1073 "RITA-II.instr"
  mccguideCurved25_W = W;
#line 22202 "RITA-II.c"

  SIG_MESSAGE("guideCurved25 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1075 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1075 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1075 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22212 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved24, mcrotaguideCurved25);
  rot_transpose(mcrotaguideCurved24, mctr1);
  rot_mul(mcrotaguideCurved25, mctr1, mcrotrguideCurved25);
  mctc1 = coords_set(
#line 1074 "RITA-II.instr"
    0,
#line 1074 "RITA-II.instr"
    0,
#line 1074 "RITA-II.instr"
    0.5);
#line 22223 "RITA-II.c"
  rot_transpose(mcrotaguideCurved24, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved25 = coords_add(mcposaguideCurved24, mctc2);
  mctc1 = coords_sub(mcposaguideCurved24, mcposaguideCurved25);
  mcposrguideCurved25 = rot_apply(mcrotaguideCurved25, mctc1);
  mcDEBUG_COMPONENT("guideCurved25", mcposaguideCurved25, mcrotaguideCurved25)
  mccomp_posa[30] = mcposaguideCurved25;
  mccomp_posr[30] = mcposrguideCurved25;
  mcNCounter[30]  = mcPCounter[30] = mcP2Counter[30] = 0;
  mcAbsorbProp[30]= 0;
    /* Component guideCurved26. */
  /* Setting parameters for component guideCurved26. */
  SIG_MESSAGE("guideCurved26 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved26_reflect, 0 ? 0 : "", 16384); else mccguideCurved26_reflect[0]='\0';
#line 1078 "RITA-II.instr"
  mccguideCurved26_w1 = 0.03;
#line 1078 "RITA-II.instr"
  mccguideCurved26_h1 = 0.12;
#line 1078 "RITA-II.instr"
  mccguideCurved26_w2 = 0.03;
#line 1078 "RITA-II.instr"
  mccguideCurved26_h2 = 0.12;
#line 1078 "RITA-II.instr"
  mccguideCurved26_l = 0.499995;
#line 1079 "RITA-II.instr"
  mccguideCurved26_R0 = R0;
#line 1079 "RITA-II.instr"
  mccguideCurved26_Qc = Qc;
#line 1079 "RITA-II.instr"
  mccguideCurved26_alpha = ALPHA;
#line 1079 "RITA-II.instr"
  mccguideCurved26_m = M;
#line 1079 "RITA-II.instr"
  mccguideCurved26_W = W;
#line 22259 "RITA-II.c"

  SIG_MESSAGE("guideCurved26 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1081 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1081 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1081 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22269 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved25, mcrotaguideCurved26);
  rot_transpose(mcrotaguideCurved25, mctr1);
  rot_mul(mcrotaguideCurved26, mctr1, mcrotrguideCurved26);
  mctc1 = coords_set(
#line 1080 "RITA-II.instr"
    0,
#line 1080 "RITA-II.instr"
    0,
#line 1080 "RITA-II.instr"
    0.5);
#line 22280 "RITA-II.c"
  rot_transpose(mcrotaguideCurved25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved26 = coords_add(mcposaguideCurved25, mctc2);
  mctc1 = coords_sub(mcposaguideCurved25, mcposaguideCurved26);
  mcposrguideCurved26 = rot_apply(mcrotaguideCurved26, mctc1);
  mcDEBUG_COMPONENT("guideCurved26", mcposaguideCurved26, mcrotaguideCurved26)
  mccomp_posa[31] = mcposaguideCurved26;
  mccomp_posr[31] = mcposrguideCurved26;
  mcNCounter[31]  = mcPCounter[31] = mcP2Counter[31] = 0;
  mcAbsorbProp[31]= 0;
    /* Component guideCurved27. */
  /* Setting parameters for component guideCurved27. */
  SIG_MESSAGE("guideCurved27 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved27_reflect, 0 ? 0 : "", 16384); else mccguideCurved27_reflect[0]='\0';
#line 1084 "RITA-II.instr"
  mccguideCurved27_w1 = 0.03;
#line 1084 "RITA-II.instr"
  mccguideCurved27_h1 = 0.12;
#line 1084 "RITA-II.instr"
  mccguideCurved27_w2 = 0.03;
#line 1084 "RITA-II.instr"
  mccguideCurved27_h2 = 0.12;
#line 1084 "RITA-II.instr"
  mccguideCurved27_l = 0.499995;
#line 1085 "RITA-II.instr"
  mccguideCurved27_R0 = R0;
#line 1085 "RITA-II.instr"
  mccguideCurved27_Qc = Qc;
#line 1085 "RITA-II.instr"
  mccguideCurved27_alpha = ALPHA;
#line 1085 "RITA-II.instr"
  mccguideCurved27_m = M;
#line 1085 "RITA-II.instr"
  mccguideCurved27_W = W;
#line 22316 "RITA-II.c"

  SIG_MESSAGE("guideCurved27 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1087 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1087 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1087 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22326 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved26, mcrotaguideCurved27);
  rot_transpose(mcrotaguideCurved26, mctr1);
  rot_mul(mcrotaguideCurved27, mctr1, mcrotrguideCurved27);
  mctc1 = coords_set(
#line 1086 "RITA-II.instr"
    0,
#line 1086 "RITA-II.instr"
    0,
#line 1086 "RITA-II.instr"
    0.5);
#line 22337 "RITA-II.c"
  rot_transpose(mcrotaguideCurved26, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved27 = coords_add(mcposaguideCurved26, mctc2);
  mctc1 = coords_sub(mcposaguideCurved26, mcposaguideCurved27);
  mcposrguideCurved27 = rot_apply(mcrotaguideCurved27, mctc1);
  mcDEBUG_COMPONENT("guideCurved27", mcposaguideCurved27, mcrotaguideCurved27)
  mccomp_posa[32] = mcposaguideCurved27;
  mccomp_posr[32] = mcposrguideCurved27;
  mcNCounter[32]  = mcPCounter[32] = mcP2Counter[32] = 0;
  mcAbsorbProp[32]= 0;
    /* Component guideCurved28. */
  /* Setting parameters for component guideCurved28. */
  SIG_MESSAGE("guideCurved28 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved28_reflect, 0 ? 0 : "", 16384); else mccguideCurved28_reflect[0]='\0';
#line 1090 "RITA-II.instr"
  mccguideCurved28_w1 = 0.03;
#line 1090 "RITA-II.instr"
  mccguideCurved28_h1 = 0.12;
#line 1090 "RITA-II.instr"
  mccguideCurved28_w2 = 0.03;
#line 1090 "RITA-II.instr"
  mccguideCurved28_h2 = 0.12;
#line 1090 "RITA-II.instr"
  mccguideCurved28_l = 0.499995;
#line 1091 "RITA-II.instr"
  mccguideCurved28_R0 = R0;
#line 1091 "RITA-II.instr"
  mccguideCurved28_Qc = Qc;
#line 1091 "RITA-II.instr"
  mccguideCurved28_alpha = ALPHA;
#line 1091 "RITA-II.instr"
  mccguideCurved28_m = M;
#line 1091 "RITA-II.instr"
  mccguideCurved28_W = W;
#line 22373 "RITA-II.c"

  SIG_MESSAGE("guideCurved28 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1093 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1093 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1093 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22383 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved27, mcrotaguideCurved28);
  rot_transpose(mcrotaguideCurved27, mctr1);
  rot_mul(mcrotaguideCurved28, mctr1, mcrotrguideCurved28);
  mctc1 = coords_set(
#line 1092 "RITA-II.instr"
    0,
#line 1092 "RITA-II.instr"
    0,
#line 1092 "RITA-II.instr"
    0.5);
#line 22394 "RITA-II.c"
  rot_transpose(mcrotaguideCurved27, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved28 = coords_add(mcposaguideCurved27, mctc2);
  mctc1 = coords_sub(mcposaguideCurved27, mcposaguideCurved28);
  mcposrguideCurved28 = rot_apply(mcrotaguideCurved28, mctc1);
  mcDEBUG_COMPONENT("guideCurved28", mcposaguideCurved28, mcrotaguideCurved28)
  mccomp_posa[33] = mcposaguideCurved28;
  mccomp_posr[33] = mcposrguideCurved28;
  mcNCounter[33]  = mcPCounter[33] = mcP2Counter[33] = 0;
  mcAbsorbProp[33]= 0;
    /* Component guideCurved29. */
  /* Setting parameters for component guideCurved29. */
  SIG_MESSAGE("guideCurved29 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved29_reflect, 0 ? 0 : "", 16384); else mccguideCurved29_reflect[0]='\0';
#line 1096 "RITA-II.instr"
  mccguideCurved29_w1 = 0.03;
#line 1096 "RITA-II.instr"
  mccguideCurved29_h1 = 0.12;
#line 1096 "RITA-II.instr"
  mccguideCurved29_w2 = 0.03;
#line 1096 "RITA-II.instr"
  mccguideCurved29_h2 = 0.12;
#line 1096 "RITA-II.instr"
  mccguideCurved29_l = 0.499995;
#line 1097 "RITA-II.instr"
  mccguideCurved29_R0 = R0;
#line 1097 "RITA-II.instr"
  mccguideCurved29_Qc = Qc;
#line 1097 "RITA-II.instr"
  mccguideCurved29_alpha = ALPHA;
#line 1097 "RITA-II.instr"
  mccguideCurved29_m = M;
#line 1097 "RITA-II.instr"
  mccguideCurved29_W = W;
#line 22430 "RITA-II.c"

  SIG_MESSAGE("guideCurved29 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1099 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1099 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1099 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22440 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved28, mcrotaguideCurved29);
  rot_transpose(mcrotaguideCurved28, mctr1);
  rot_mul(mcrotaguideCurved29, mctr1, mcrotrguideCurved29);
  mctc1 = coords_set(
#line 1098 "RITA-II.instr"
    0,
#line 1098 "RITA-II.instr"
    0,
#line 1098 "RITA-II.instr"
    0.5);
#line 22451 "RITA-II.c"
  rot_transpose(mcrotaguideCurved28, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved29 = coords_add(mcposaguideCurved28, mctc2);
  mctc1 = coords_sub(mcposaguideCurved28, mcposaguideCurved29);
  mcposrguideCurved29 = rot_apply(mcrotaguideCurved29, mctc1);
  mcDEBUG_COMPONENT("guideCurved29", mcposaguideCurved29, mcrotaguideCurved29)
  mccomp_posa[34] = mcposaguideCurved29;
  mccomp_posr[34] = mcposrguideCurved29;
  mcNCounter[34]  = mcPCounter[34] = mcP2Counter[34] = 0;
  mcAbsorbProp[34]= 0;
    /* Component guideCurved30. */
  /* Setting parameters for component guideCurved30. */
  SIG_MESSAGE("guideCurved30 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved30_reflect, 0 ? 0 : "", 16384); else mccguideCurved30_reflect[0]='\0';
#line 1102 "RITA-II.instr"
  mccguideCurved30_w1 = 0.03;
#line 1102 "RITA-II.instr"
  mccguideCurved30_h1 = 0.12;
#line 1102 "RITA-II.instr"
  mccguideCurved30_w2 = 0.03;
#line 1102 "RITA-II.instr"
  mccguideCurved30_h2 = 0.12;
#line 1102 "RITA-II.instr"
  mccguideCurved30_l = 0.499995;
#line 1103 "RITA-II.instr"
  mccguideCurved30_R0 = R0;
#line 1103 "RITA-II.instr"
  mccguideCurved30_Qc = Qc;
#line 1103 "RITA-II.instr"
  mccguideCurved30_alpha = ALPHA;
#line 1103 "RITA-II.instr"
  mccguideCurved30_m = M;
#line 1103 "RITA-II.instr"
  mccguideCurved30_W = W;
#line 22487 "RITA-II.c"

  SIG_MESSAGE("guideCurved30 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1105 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1105 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1105 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22497 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved29, mcrotaguideCurved30);
  rot_transpose(mcrotaguideCurved29, mctr1);
  rot_mul(mcrotaguideCurved30, mctr1, mcrotrguideCurved30);
  mctc1 = coords_set(
#line 1104 "RITA-II.instr"
    0,
#line 1104 "RITA-II.instr"
    0,
#line 1104 "RITA-II.instr"
    0.5);
#line 22508 "RITA-II.c"
  rot_transpose(mcrotaguideCurved29, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved30 = coords_add(mcposaguideCurved29, mctc2);
  mctc1 = coords_sub(mcposaguideCurved29, mcposaguideCurved30);
  mcposrguideCurved30 = rot_apply(mcrotaguideCurved30, mctc1);
  mcDEBUG_COMPONENT("guideCurved30", mcposaguideCurved30, mcrotaguideCurved30)
  mccomp_posa[35] = mcposaguideCurved30;
  mccomp_posr[35] = mcposrguideCurved30;
  mcNCounter[35]  = mcPCounter[35] = mcP2Counter[35] = 0;
  mcAbsorbProp[35]= 0;
    /* Component guideCurved31. */
  /* Setting parameters for component guideCurved31. */
  SIG_MESSAGE("guideCurved31 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved31_reflect, 0 ? 0 : "", 16384); else mccguideCurved31_reflect[0]='\0';
#line 1108 "RITA-II.instr"
  mccguideCurved31_w1 = 0.03;
#line 1108 "RITA-II.instr"
  mccguideCurved31_h1 = 0.12;
#line 1108 "RITA-II.instr"
  mccguideCurved31_w2 = 0.03;
#line 1108 "RITA-II.instr"
  mccguideCurved31_h2 = 0.12;
#line 1108 "RITA-II.instr"
  mccguideCurved31_l = 0.499995;
#line 1109 "RITA-II.instr"
  mccguideCurved31_R0 = R0;
#line 1109 "RITA-II.instr"
  mccguideCurved31_Qc = Qc;
#line 1109 "RITA-II.instr"
  mccguideCurved31_alpha = ALPHA;
#line 1109 "RITA-II.instr"
  mccguideCurved31_m = M;
#line 1109 "RITA-II.instr"
  mccguideCurved31_W = W;
#line 22544 "RITA-II.c"

  SIG_MESSAGE("guideCurved31 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1111 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1111 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1111 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22554 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved30, mcrotaguideCurved31);
  rot_transpose(mcrotaguideCurved30, mctr1);
  rot_mul(mcrotaguideCurved31, mctr1, mcrotrguideCurved31);
  mctc1 = coords_set(
#line 1110 "RITA-II.instr"
    0,
#line 1110 "RITA-II.instr"
    0,
#line 1110 "RITA-II.instr"
    0.5);
#line 22565 "RITA-II.c"
  rot_transpose(mcrotaguideCurved30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved31 = coords_add(mcposaguideCurved30, mctc2);
  mctc1 = coords_sub(mcposaguideCurved30, mcposaguideCurved31);
  mcposrguideCurved31 = rot_apply(mcrotaguideCurved31, mctc1);
  mcDEBUG_COMPONENT("guideCurved31", mcposaguideCurved31, mcrotaguideCurved31)
  mccomp_posa[36] = mcposaguideCurved31;
  mccomp_posr[36] = mcposrguideCurved31;
  mcNCounter[36]  = mcPCounter[36] = mcP2Counter[36] = 0;
  mcAbsorbProp[36]= 0;
    /* Component guideCurved32. */
  /* Setting parameters for component guideCurved32. */
  SIG_MESSAGE("guideCurved32 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved32_reflect, 0 ? 0 : "", 16384); else mccguideCurved32_reflect[0]='\0';
#line 1114 "RITA-II.instr"
  mccguideCurved32_w1 = 0.03;
#line 1114 "RITA-II.instr"
  mccguideCurved32_h1 = 0.12;
#line 1114 "RITA-II.instr"
  mccguideCurved32_w2 = 0.03;
#line 1114 "RITA-II.instr"
  mccguideCurved32_h2 = 0.12;
#line 1114 "RITA-II.instr"
  mccguideCurved32_l = 0.499995;
#line 1115 "RITA-II.instr"
  mccguideCurved32_R0 = R0;
#line 1115 "RITA-II.instr"
  mccguideCurved32_Qc = Qc;
#line 1115 "RITA-II.instr"
  mccguideCurved32_alpha = ALPHA;
#line 1115 "RITA-II.instr"
  mccguideCurved32_m = M;
#line 1115 "RITA-II.instr"
  mccguideCurved32_W = W;
#line 22601 "RITA-II.c"

  SIG_MESSAGE("guideCurved32 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1117 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1117 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1117 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22611 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved31, mcrotaguideCurved32);
  rot_transpose(mcrotaguideCurved31, mctr1);
  rot_mul(mcrotaguideCurved32, mctr1, mcrotrguideCurved32);
  mctc1 = coords_set(
#line 1116 "RITA-II.instr"
    0,
#line 1116 "RITA-II.instr"
    0,
#line 1116 "RITA-II.instr"
    0.5);
#line 22622 "RITA-II.c"
  rot_transpose(mcrotaguideCurved31, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved32 = coords_add(mcposaguideCurved31, mctc2);
  mctc1 = coords_sub(mcposaguideCurved31, mcposaguideCurved32);
  mcposrguideCurved32 = rot_apply(mcrotaguideCurved32, mctc1);
  mcDEBUG_COMPONENT("guideCurved32", mcposaguideCurved32, mcrotaguideCurved32)
  mccomp_posa[37] = mcposaguideCurved32;
  mccomp_posr[37] = mcposrguideCurved32;
  mcNCounter[37]  = mcPCounter[37] = mcP2Counter[37] = 0;
  mcAbsorbProp[37]= 0;
    /* Component guideCurved33. */
  /* Setting parameters for component guideCurved33. */
  SIG_MESSAGE("guideCurved33 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved33_reflect, 0 ? 0 : "", 16384); else mccguideCurved33_reflect[0]='\0';
#line 1120 "RITA-II.instr"
  mccguideCurved33_w1 = 0.03;
#line 1120 "RITA-II.instr"
  mccguideCurved33_h1 = 0.12;
#line 1120 "RITA-II.instr"
  mccguideCurved33_w2 = 0.03;
#line 1120 "RITA-II.instr"
  mccguideCurved33_h2 = 0.12;
#line 1120 "RITA-II.instr"
  mccguideCurved33_l = 0.499995;
#line 1121 "RITA-II.instr"
  mccguideCurved33_R0 = R0;
#line 1121 "RITA-II.instr"
  mccguideCurved33_Qc = Qc;
#line 1121 "RITA-II.instr"
  mccguideCurved33_alpha = ALPHA;
#line 1121 "RITA-II.instr"
  mccguideCurved33_m = M;
#line 1121 "RITA-II.instr"
  mccguideCurved33_W = W;
#line 22658 "RITA-II.c"

  SIG_MESSAGE("guideCurved33 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1123 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1123 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1123 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22668 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved32, mcrotaguideCurved33);
  rot_transpose(mcrotaguideCurved32, mctr1);
  rot_mul(mcrotaguideCurved33, mctr1, mcrotrguideCurved33);
  mctc1 = coords_set(
#line 1122 "RITA-II.instr"
    0,
#line 1122 "RITA-II.instr"
    0,
#line 1122 "RITA-II.instr"
    0.5);
#line 22679 "RITA-II.c"
  rot_transpose(mcrotaguideCurved32, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved33 = coords_add(mcposaguideCurved32, mctc2);
  mctc1 = coords_sub(mcposaguideCurved32, mcposaguideCurved33);
  mcposrguideCurved33 = rot_apply(mcrotaguideCurved33, mctc1);
  mcDEBUG_COMPONENT("guideCurved33", mcposaguideCurved33, mcrotaguideCurved33)
  mccomp_posa[38] = mcposaguideCurved33;
  mccomp_posr[38] = mcposrguideCurved33;
  mcNCounter[38]  = mcPCounter[38] = mcP2Counter[38] = 0;
  mcAbsorbProp[38]= 0;
    /* Component guideCurved34. */
  /* Setting parameters for component guideCurved34. */
  SIG_MESSAGE("guideCurved34 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved34_reflect, 0 ? 0 : "", 16384); else mccguideCurved34_reflect[0]='\0';
#line 1126 "RITA-II.instr"
  mccguideCurved34_w1 = 0.03;
#line 1126 "RITA-II.instr"
  mccguideCurved34_h1 = 0.12;
#line 1126 "RITA-II.instr"
  mccguideCurved34_w2 = 0.03;
#line 1126 "RITA-II.instr"
  mccguideCurved34_h2 = 0.12;
#line 1126 "RITA-II.instr"
  mccguideCurved34_l = 0.499995;
#line 1127 "RITA-II.instr"
  mccguideCurved34_R0 = R0;
#line 1127 "RITA-II.instr"
  mccguideCurved34_Qc = Qc;
#line 1127 "RITA-II.instr"
  mccguideCurved34_alpha = ALPHA;
#line 1127 "RITA-II.instr"
  mccguideCurved34_m = M;
#line 1127 "RITA-II.instr"
  mccguideCurved34_W = W;
#line 22715 "RITA-II.c"

  SIG_MESSAGE("guideCurved34 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1129 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1129 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1129 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22725 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved33, mcrotaguideCurved34);
  rot_transpose(mcrotaguideCurved33, mctr1);
  rot_mul(mcrotaguideCurved34, mctr1, mcrotrguideCurved34);
  mctc1 = coords_set(
#line 1128 "RITA-II.instr"
    0,
#line 1128 "RITA-II.instr"
    0,
#line 1128 "RITA-II.instr"
    0.5);
#line 22736 "RITA-II.c"
  rot_transpose(mcrotaguideCurved33, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved34 = coords_add(mcposaguideCurved33, mctc2);
  mctc1 = coords_sub(mcposaguideCurved33, mcposaguideCurved34);
  mcposrguideCurved34 = rot_apply(mcrotaguideCurved34, mctc1);
  mcDEBUG_COMPONENT("guideCurved34", mcposaguideCurved34, mcrotaguideCurved34)
  mccomp_posa[39] = mcposaguideCurved34;
  mccomp_posr[39] = mcposrguideCurved34;
  mcNCounter[39]  = mcPCounter[39] = mcP2Counter[39] = 0;
  mcAbsorbProp[39]= 0;
    /* Component guideCurved35. */
  /* Setting parameters for component guideCurved35. */
  SIG_MESSAGE("guideCurved35 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved35_reflect, 0 ? 0 : "", 16384); else mccguideCurved35_reflect[0]='\0';
#line 1132 "RITA-II.instr"
  mccguideCurved35_w1 = 0.03;
#line 1132 "RITA-II.instr"
  mccguideCurved35_h1 = 0.12;
#line 1132 "RITA-II.instr"
  mccguideCurved35_w2 = 0.03;
#line 1132 "RITA-II.instr"
  mccguideCurved35_h2 = 0.12;
#line 1132 "RITA-II.instr"
  mccguideCurved35_l = 0.499995;
#line 1133 "RITA-II.instr"
  mccguideCurved35_R0 = R0;
#line 1133 "RITA-II.instr"
  mccguideCurved35_Qc = Qc;
#line 1133 "RITA-II.instr"
  mccguideCurved35_alpha = ALPHA;
#line 1133 "RITA-II.instr"
  mccguideCurved35_m = M;
#line 1133 "RITA-II.instr"
  mccguideCurved35_W = W;
#line 22772 "RITA-II.c"

  SIG_MESSAGE("guideCurved35 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1135 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1135 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1135 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22782 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved34, mcrotaguideCurved35);
  rot_transpose(mcrotaguideCurved34, mctr1);
  rot_mul(mcrotaguideCurved35, mctr1, mcrotrguideCurved35);
  mctc1 = coords_set(
#line 1134 "RITA-II.instr"
    0,
#line 1134 "RITA-II.instr"
    0,
#line 1134 "RITA-II.instr"
    0.5);
#line 22793 "RITA-II.c"
  rot_transpose(mcrotaguideCurved34, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved35 = coords_add(mcposaguideCurved34, mctc2);
  mctc1 = coords_sub(mcposaguideCurved34, mcposaguideCurved35);
  mcposrguideCurved35 = rot_apply(mcrotaguideCurved35, mctc1);
  mcDEBUG_COMPONENT("guideCurved35", mcposaguideCurved35, mcrotaguideCurved35)
  mccomp_posa[40] = mcposaguideCurved35;
  mccomp_posr[40] = mcposrguideCurved35;
  mcNCounter[40]  = mcPCounter[40] = mcP2Counter[40] = 0;
  mcAbsorbProp[40]= 0;
    /* Component guideCurved36. */
  /* Setting parameters for component guideCurved36. */
  SIG_MESSAGE("guideCurved36 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved36_reflect, 0 ? 0 : "", 16384); else mccguideCurved36_reflect[0]='\0';
#line 1138 "RITA-II.instr"
  mccguideCurved36_w1 = 0.03;
#line 1138 "RITA-II.instr"
  mccguideCurved36_h1 = 0.12;
#line 1138 "RITA-II.instr"
  mccguideCurved36_w2 = 0.03;
#line 1138 "RITA-II.instr"
  mccguideCurved36_h2 = 0.12;
#line 1138 "RITA-II.instr"
  mccguideCurved36_l = 0.499995;
#line 1139 "RITA-II.instr"
  mccguideCurved36_R0 = R0;
#line 1139 "RITA-II.instr"
  mccguideCurved36_Qc = Qc;
#line 1139 "RITA-II.instr"
  mccguideCurved36_alpha = ALPHA;
#line 1139 "RITA-II.instr"
  mccguideCurved36_m = M;
#line 1139 "RITA-II.instr"
  mccguideCurved36_W = W;
#line 22829 "RITA-II.c"

  SIG_MESSAGE("guideCurved36 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1141 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1141 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1141 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22839 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved35, mcrotaguideCurved36);
  rot_transpose(mcrotaguideCurved35, mctr1);
  rot_mul(mcrotaguideCurved36, mctr1, mcrotrguideCurved36);
  mctc1 = coords_set(
#line 1140 "RITA-II.instr"
    0,
#line 1140 "RITA-II.instr"
    0,
#line 1140 "RITA-II.instr"
    0.5);
#line 22850 "RITA-II.c"
  rot_transpose(mcrotaguideCurved35, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved36 = coords_add(mcposaguideCurved35, mctc2);
  mctc1 = coords_sub(mcposaguideCurved35, mcposaguideCurved36);
  mcposrguideCurved36 = rot_apply(mcrotaguideCurved36, mctc1);
  mcDEBUG_COMPONENT("guideCurved36", mcposaguideCurved36, mcrotaguideCurved36)
  mccomp_posa[41] = mcposaguideCurved36;
  mccomp_posr[41] = mcposrguideCurved36;
  mcNCounter[41]  = mcPCounter[41] = mcP2Counter[41] = 0;
  mcAbsorbProp[41]= 0;
    /* Component guideCurved37. */
  /* Setting parameters for component guideCurved37. */
  SIG_MESSAGE("guideCurved37 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved37_reflect, 0 ? 0 : "", 16384); else mccguideCurved37_reflect[0]='\0';
#line 1144 "RITA-II.instr"
  mccguideCurved37_w1 = 0.03;
#line 1144 "RITA-II.instr"
  mccguideCurved37_h1 = 0.12;
#line 1144 "RITA-II.instr"
  mccguideCurved37_w2 = 0.03;
#line 1144 "RITA-II.instr"
  mccguideCurved37_h2 = 0.12;
#line 1144 "RITA-II.instr"
  mccguideCurved37_l = 0.499995;
#line 1145 "RITA-II.instr"
  mccguideCurved37_R0 = R0;
#line 1145 "RITA-II.instr"
  mccguideCurved37_Qc = Qc;
#line 1145 "RITA-II.instr"
  mccguideCurved37_alpha = ALPHA;
#line 1145 "RITA-II.instr"
  mccguideCurved37_m = M;
#line 1145 "RITA-II.instr"
  mccguideCurved37_W = W;
#line 22886 "RITA-II.c"

  SIG_MESSAGE("guideCurved37 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1147 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1147 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1147 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22896 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved36, mcrotaguideCurved37);
  rot_transpose(mcrotaguideCurved36, mctr1);
  rot_mul(mcrotaguideCurved37, mctr1, mcrotrguideCurved37);
  mctc1 = coords_set(
#line 1146 "RITA-II.instr"
    0,
#line 1146 "RITA-II.instr"
    0,
#line 1146 "RITA-II.instr"
    0.5);
#line 22907 "RITA-II.c"
  rot_transpose(mcrotaguideCurved36, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved37 = coords_add(mcposaguideCurved36, mctc2);
  mctc1 = coords_sub(mcposaguideCurved36, mcposaguideCurved37);
  mcposrguideCurved37 = rot_apply(mcrotaguideCurved37, mctc1);
  mcDEBUG_COMPONENT("guideCurved37", mcposaguideCurved37, mcrotaguideCurved37)
  mccomp_posa[42] = mcposaguideCurved37;
  mccomp_posr[42] = mcposrguideCurved37;
  mcNCounter[42]  = mcPCounter[42] = mcP2Counter[42] = 0;
  mcAbsorbProp[42]= 0;
    /* Component guideCurved38. */
  /* Setting parameters for component guideCurved38. */
  SIG_MESSAGE("guideCurved38 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved38_reflect, 0 ? 0 : "", 16384); else mccguideCurved38_reflect[0]='\0';
#line 1150 "RITA-II.instr"
  mccguideCurved38_w1 = 0.03;
#line 1150 "RITA-II.instr"
  mccguideCurved38_h1 = 0.12;
#line 1150 "RITA-II.instr"
  mccguideCurved38_w2 = 0.03;
#line 1150 "RITA-II.instr"
  mccguideCurved38_h2 = 0.12;
#line 1150 "RITA-II.instr"
  mccguideCurved38_l = 0.499995;
#line 1151 "RITA-II.instr"
  mccguideCurved38_R0 = R0;
#line 1151 "RITA-II.instr"
  mccguideCurved38_Qc = Qc;
#line 1151 "RITA-II.instr"
  mccguideCurved38_alpha = ALPHA;
#line 1151 "RITA-II.instr"
  mccguideCurved38_m = M;
#line 1151 "RITA-II.instr"
  mccguideCurved38_W = W;
#line 22943 "RITA-II.c"

  SIG_MESSAGE("guideCurved38 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1153 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1153 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1153 "RITA-II.instr"
    (0)*DEG2RAD);
#line 22953 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved37, mcrotaguideCurved38);
  rot_transpose(mcrotaguideCurved37, mctr1);
  rot_mul(mcrotaguideCurved38, mctr1, mcrotrguideCurved38);
  mctc1 = coords_set(
#line 1152 "RITA-II.instr"
    0,
#line 1152 "RITA-II.instr"
    0,
#line 1152 "RITA-II.instr"
    0.5);
#line 22964 "RITA-II.c"
  rot_transpose(mcrotaguideCurved37, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved38 = coords_add(mcposaguideCurved37, mctc2);
  mctc1 = coords_sub(mcposaguideCurved37, mcposaguideCurved38);
  mcposrguideCurved38 = rot_apply(mcrotaguideCurved38, mctc1);
  mcDEBUG_COMPONENT("guideCurved38", mcposaguideCurved38, mcrotaguideCurved38)
  mccomp_posa[43] = mcposaguideCurved38;
  mccomp_posr[43] = mcposrguideCurved38;
  mcNCounter[43]  = mcPCounter[43] = mcP2Counter[43] = 0;
  mcAbsorbProp[43]= 0;
    /* Component guideCurved39. */
  /* Setting parameters for component guideCurved39. */
  SIG_MESSAGE("guideCurved39 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved39_reflect, 0 ? 0 : "", 16384); else mccguideCurved39_reflect[0]='\0';
#line 1156 "RITA-II.instr"
  mccguideCurved39_w1 = 0.03;
#line 1156 "RITA-II.instr"
  mccguideCurved39_h1 = 0.12;
#line 1156 "RITA-II.instr"
  mccguideCurved39_w2 = 0.03;
#line 1156 "RITA-II.instr"
  mccguideCurved39_h2 = 0.12;
#line 1156 "RITA-II.instr"
  mccguideCurved39_l = 0.499995;
#line 1157 "RITA-II.instr"
  mccguideCurved39_R0 = R0;
#line 1157 "RITA-II.instr"
  mccguideCurved39_Qc = Qc;
#line 1157 "RITA-II.instr"
  mccguideCurved39_alpha = ALPHA;
#line 1157 "RITA-II.instr"
  mccguideCurved39_m = M;
#line 1157 "RITA-II.instr"
  mccguideCurved39_W = W;
#line 23000 "RITA-II.c"

  SIG_MESSAGE("guideCurved39 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1159 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1159 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1159 "RITA-II.instr"
    (0)*DEG2RAD);
#line 23010 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved38, mcrotaguideCurved39);
  rot_transpose(mcrotaguideCurved38, mctr1);
  rot_mul(mcrotaguideCurved39, mctr1, mcrotrguideCurved39);
  mctc1 = coords_set(
#line 1158 "RITA-II.instr"
    0,
#line 1158 "RITA-II.instr"
    0,
#line 1158 "RITA-II.instr"
    0.5);
#line 23021 "RITA-II.c"
  rot_transpose(mcrotaguideCurved38, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved39 = coords_add(mcposaguideCurved38, mctc2);
  mctc1 = coords_sub(mcposaguideCurved38, mcposaguideCurved39);
  mcposrguideCurved39 = rot_apply(mcrotaguideCurved39, mctc1);
  mcDEBUG_COMPONENT("guideCurved39", mcposaguideCurved39, mcrotaguideCurved39)
  mccomp_posa[44] = mcposaguideCurved39;
  mccomp_posr[44] = mcposrguideCurved39;
  mcNCounter[44]  = mcPCounter[44] = mcP2Counter[44] = 0;
  mcAbsorbProp[44]= 0;
    /* Component guideCurved40. */
  /* Setting parameters for component guideCurved40. */
  SIG_MESSAGE("guideCurved40 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguideCurved40_reflect, 0 ? 0 : "", 16384); else mccguideCurved40_reflect[0]='\0';
#line 1162 "RITA-II.instr"
  mccguideCurved40_w1 = 0.03;
#line 1162 "RITA-II.instr"
  mccguideCurved40_h1 = 0.12;
#line 1162 "RITA-II.instr"
  mccguideCurved40_w2 = 0.03;
#line 1162 "RITA-II.instr"
  mccguideCurved40_h2 = 0.12;
#line 1162 "RITA-II.instr"
  mccguideCurved40_l = 0.499995;
#line 1163 "RITA-II.instr"
  mccguideCurved40_R0 = R0;
#line 1163 "RITA-II.instr"
  mccguideCurved40_Qc = Qc;
#line 1163 "RITA-II.instr"
  mccguideCurved40_alpha = ALPHA;
#line 1163 "RITA-II.instr"
  mccguideCurved40_m = M;
#line 1163 "RITA-II.instr"
  mccguideCurved40_W = W;
#line 23057 "RITA-II.c"

  SIG_MESSAGE("guideCurved40 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1165 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1165 "RITA-II.instr"
    (angleGuideCurved)*DEG2RAD,
#line 1165 "RITA-II.instr"
    (0)*DEG2RAD);
#line 23067 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved39, mcrotaguideCurved40);
  rot_transpose(mcrotaguideCurved39, mctr1);
  rot_mul(mcrotaguideCurved40, mctr1, mcrotrguideCurved40);
  mctc1 = coords_set(
#line 1164 "RITA-II.instr"
    0,
#line 1164 "RITA-II.instr"
    0,
#line 1164 "RITA-II.instr"
    0.5);
#line 23078 "RITA-II.c"
  rot_transpose(mcrotaguideCurved39, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguideCurved40 = coords_add(mcposaguideCurved39, mctc2);
  mctc1 = coords_sub(mcposaguideCurved39, mcposaguideCurved40);
  mcposrguideCurved40 = rot_apply(mcrotaguideCurved40, mctc1);
  mcDEBUG_COMPONENT("guideCurved40", mcposaguideCurved40, mcrotaguideCurved40)
  mccomp_posa[45] = mcposaguideCurved40;
  mccomp_posr[45] = mcposrguideCurved40;
  mcNCounter[45]  = mcPCounter[45] = mcP2Counter[45] = 0;
  mcAbsorbProp[45]= 0;
    /* Component bunker. */
  /* Setting parameters for component bunker. */
  SIG_MESSAGE("bunker (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccbunker_reflect, 0 ? 0 : "", 16384); else mccbunker_reflect[0]='\0';
#line 1169 "RITA-II.instr"
  mccbunker_w1 = 0.03;
#line 1169 "RITA-II.instr"
  mccbunker_h1 = 0.12;
#line 1169 "RITA-II.instr"
  mccbunker_w2 = 0.03;
#line 1169 "RITA-II.instr"
  mccbunker_h2 = 0.12;
#line 1170 "RITA-II.instr"
  mccbunker_l = 3.45;
#line 1170 "RITA-II.instr"
  mccbunker_R0 = R0;
#line 1170 "RITA-II.instr"
  mccbunker_Qc = Qc;
#line 1170 "RITA-II.instr"
  mccbunker_alpha = ALPHA;
#line 1170 "RITA-II.instr"
  mccbunker_m = M;
#line 1170 "RITA-II.instr"
  mccbunker_W = W;
#line 23114 "RITA-II.c"

  SIG_MESSAGE("bunker (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23121 "RITA-II.c"
  rot_mul(mctr1, mcrotaguideCurved40, mcrotabunker);
  rot_transpose(mcrotaguideCurved40, mctr1);
  rot_mul(mcrotabunker, mctr1, mcrotrbunker);
  mctc1 = coords_set(
#line 1171 "RITA-II.instr"
    0,
#line 1171 "RITA-II.instr"
    0,
#line 1171 "RITA-II.instr"
    0.5);
#line 23132 "RITA-II.c"
  rot_transpose(mcrotaguideCurved40, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposabunker = coords_add(mcposaguideCurved40, mctc2);
  mctc1 = coords_sub(mcposaguideCurved40, mcposabunker);
  mcposrbunker = rot_apply(mcrotabunker, mctc1);
  mcDEBUG_COMPONENT("bunker", mcposabunker, mcrotabunker)
  mccomp_posa[46] = mcposabunker;
  mccomp_posr[46] = mcposrbunker;
  mcNCounter[46]  = mcPCounter[46] = mcP2Counter[46] = 0;
  mcAbsorbProp[46]= 0;
    /* Component guide3. */
  /* Setting parameters for component guide3. */
  SIG_MESSAGE("guide3 (Init:SetPar)");
#line 58 "RITA-II.instr"
  if(0) strncpy(mccguide3_reflect, 0 ? 0 : "", 16384); else mccguide3_reflect[0]='\0';
#line 1176 "RITA-II.instr"
  mccguide3_w1 = 0.03;
#line 1176 "RITA-II.instr"
  mccguide3_h1 = 0.12;
#line 1176 "RITA-II.instr"
  mccguide3_w2 = 0.03;
#line 1176 "RITA-II.instr"
  mccguide3_h2 = 0.12;
#line 1177 "RITA-II.instr"
  mccguide3_l = 5.2;
#line 1177 "RITA-II.instr"
  mccguide3_R0 = R0;
#line 1177 "RITA-II.instr"
  mccguide3_Qc = Qc;
#line 1177 "RITA-II.instr"
  mccguide3_alpha = ALPHA;
#line 1177 "RITA-II.instr"
  mccguide3_m = M;
#line 1177 "RITA-II.instr"
  mccguide3_W = W;
#line 23168 "RITA-II.c"

  SIG_MESSAGE("guide3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23175 "RITA-II.c"
  rot_mul(mctr1, mcrotabunker, mcrotaguide3);
  rot_transpose(mcrotabunker, mctr1);
  rot_mul(mcrotaguide3, mctr1, mcrotrguide3);
  mctc1 = coords_set(
#line 1178 "RITA-II.instr"
    0,
#line 1178 "RITA-II.instr"
    0,
#line 1178 "RITA-II.instr"
    3.6);
#line 23186 "RITA-II.c"
  rot_transpose(mcrotabunker, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaguide3 = coords_add(mcposabunker, mctc2);
  mctc1 = coords_sub(mcposabunker, mcposaguide3);
  mcposrguide3 = rot_apply(mcrotaguide3, mctc1);
  mcDEBUG_COMPONENT("guide3", mcposaguide3, mcrotaguide3)
  mccomp_posa[47] = mcposaguide3;
  mccomp_posr[47] = mcposrguide3;
  mcNCounter[47]  = mcPCounter[47] = mcP2Counter[47] = 0;
  mcAbsorbProp[47]= 0;
    /* Component slitGuideEnd. */
  /* Setting parameters for component slitGuideEnd. */
  SIG_MESSAGE("slitGuideEnd (Init:SetPar)");
#line 1181 "RITA-II.instr"
  mccslitGuideEnd_xmin = -0.016;
#line 1181 "RITA-II.instr"
  mccslitGuideEnd_xmax = 0.016;
#line 1181 "RITA-II.instr"
  mccslitGuideEnd_ymin = -0.061;
#line 1181 "RITA-II.instr"
  mccslitGuideEnd_ymax = 0.061;
#line 46 "RITA-II.instr"
  mccslitGuideEnd_radius = 0;
#line 46 "RITA-II.instr"
  mccslitGuideEnd_xwidth = 0;
#line 46 "RITA-II.instr"
  mccslitGuideEnd_yheight = 0;
#line 23214 "RITA-II.c"

  SIG_MESSAGE("slitGuideEnd (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23221 "RITA-II.c"
  rot_mul(mctr1, mcrotaguide3, mcrotaslitGuideEnd);
  rot_transpose(mcrotaguide3, mctr1);
  rot_mul(mcrotaslitGuideEnd, mctr1, mcrotrslitGuideEnd);
  mctc1 = coords_set(
#line 1182 "RITA-II.instr"
    0,
#line 1182 "RITA-II.instr"
    0,
#line 1182 "RITA-II.instr"
    5.2001);
#line 23232 "RITA-II.c"
  rot_transpose(mcrotaguide3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaslitGuideEnd = coords_add(mcposaguide3, mctc2);
  mctc1 = coords_sub(mcposaguide3, mcposaslitGuideEnd);
  mcposrslitGuideEnd = rot_apply(mcrotaslitGuideEnd, mctc1);
  mcDEBUG_COMPONENT("slitGuideEnd", mcposaslitGuideEnd, mcrotaslitGuideEnd)
  mccomp_posa[48] = mcposaslitGuideEnd;
  mccomp_posr[48] = mcposrslitGuideEnd;
  mcNCounter[48]  = mcPCounter[48] = mcP2Counter[48] = 0;
  mcAbsorbProp[48]= 0;
    /* Component psd_guide_end. */
  /* Setting parameters for component psd_guide_end. */
  SIG_MESSAGE("psd_guide_end (Init:SetPar)");
#line 1186 "RITA-II.instr"
  if("psd_guide_end.dat") strncpy(mccpsd_guide_end_filename, "psd_guide_end.dat" ? "psd_guide_end.dat" : "", 16384); else mccpsd_guide_end_filename[0]='\0';
#line 50 "RITA-II.instr"
  mccpsd_guide_end_xmin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_guide_end_xmax = 0.05;
#line 50 "RITA-II.instr"
  mccpsd_guide_end_ymin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_guide_end_ymax = 0.05;
#line 1185 "RITA-II.instr"
  mccpsd_guide_end_xwidth = 0.04;
#line 1185 "RITA-II.instr"
  mccpsd_guide_end_yheight = 0.15;
#line 1186 "RITA-II.instr"
  mccpsd_guide_end_restore_neutron = 1;
#line 50 "RITA-II.instr"
  mccpsd_guide_end_nowritefile = 0;
#line 23264 "RITA-II.c"

  SIG_MESSAGE("psd_guide_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23271 "RITA-II.c"
  rot_mul(mctr1, mcrotaslitGuideEnd, mcrotapsd_guide_end);
  rot_transpose(mcrotaslitGuideEnd, mctr1);
  rot_mul(mcrotapsd_guide_end, mctr1, mcrotrpsd_guide_end);
  mctc1 = coords_set(
#line 1187 "RITA-II.instr"
    0,
#line 1187 "RITA-II.instr"
    0,
#line 1187 "RITA-II.instr"
    0.04);
#line 23282 "RITA-II.c"
  rot_transpose(mcrotaslitGuideEnd, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_guide_end = coords_add(mcposaslitGuideEnd, mctc2);
  mctc1 = coords_sub(mcposaslitGuideEnd, mcposapsd_guide_end);
  mcposrpsd_guide_end = rot_apply(mcrotapsd_guide_end, mctc1);
  mcDEBUG_COMPONENT("psd_guide_end", mcposapsd_guide_end, mcrotapsd_guide_end)
  mccomp_posa[49] = mcposapsd_guide_end;
  mccomp_posr[49] = mcposrpsd_guide_end;
  mcNCounter[49]  = mcPCounter[49] = mcP2Counter[49] = 0;
  mcAbsorbProp[49]= 0;
    /* Component emon_guide_end. */
  /* Setting parameters for component emon_guide_end. */
  SIG_MESSAGE("emon_guide_end (Init:SetPar)");
#line 1190 "RITA-II.instr"
  if("emon_guide_end.dat") strncpy(mccemon_guide_end_filename, "emon_guide_end.dat" ? "emon_guide_end.dat" : "", 16384); else mccemon_guide_end_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_guide_end_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_guide_end_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_guide_end_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_guide_end_ymax = 0.05;
#line 1190 "RITA-II.instr"
  mccemon_guide_end_xwidth = 0.04;
#line 1190 "RITA-II.instr"
  mccemon_guide_end_yheight = 0.15;
#line 1190 "RITA-II.instr"
  mccemon_guide_end_Emin = emini;
#line 1190 "RITA-II.instr"
  mccemon_guide_end_Emax = emaxi;
#line 1190 "RITA-II.instr"
  mccemon_guide_end_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_guide_end_nowritefile = 0;
#line 23318 "RITA-II.c"

  SIG_MESSAGE("emon_guide_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23325 "RITA-II.c"
  rot_mul(mctr1, mcrotaslitGuideEnd, mcrotaemon_guide_end);
  rot_transpose(mcrotapsd_guide_end, mctr1);
  rot_mul(mcrotaemon_guide_end, mctr1, mcrotremon_guide_end);
  mctc1 = coords_set(
#line 1191 "RITA-II.instr"
    0,
#line 1191 "RITA-II.instr"
    0,
#line 1191 "RITA-II.instr"
    0.05);
#line 23336 "RITA-II.c"
  rot_transpose(mcrotaslitGuideEnd, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_guide_end = coords_add(mcposaslitGuideEnd, mctc2);
  mctc1 = coords_sub(mcposapsd_guide_end, mcposaemon_guide_end);
  mcposremon_guide_end = rot_apply(mcrotaemon_guide_end, mctc1);
  mcDEBUG_COMPONENT("emon_guide_end", mcposaemon_guide_end, mcrotaemon_guide_end)
  mccomp_posa[50] = mcposaemon_guide_end;
  mccomp_posr[50] = mcposremon_guide_end;
  mcNCounter[50]  = mcPCounter[50] = mcP2Counter[50] = 0;
  mcAbsorbProp[50]= 0;
    /* Component lmon_guide_end. */
  /* Setting parameters for component lmon_guide_end. */
  SIG_MESSAGE("lmon_guide_end (Init:SetPar)");
#line 1194 "RITA-II.instr"
  if("lmon_guide_end.dat") strncpy(mcclmon_guide_end_filename, "lmon_guide_end.dat" ? "lmon_guide_end.dat" : "", 16384); else mcclmon_guide_end_filename[0]='\0';
#line 50 "RITA-II.instr"
  mcclmon_guide_end_xmin = -0.05;
#line 50 "RITA-II.instr"
  mcclmon_guide_end_xmax = 0.05;
#line 50 "RITA-II.instr"
  mcclmon_guide_end_ymin = -0.05;
#line 50 "RITA-II.instr"
  mcclmon_guide_end_ymax = 0.05;
#line 1194 "RITA-II.instr"
  mcclmon_guide_end_xwidth = 0.04;
#line 1194 "RITA-II.instr"
  mcclmon_guide_end_yheight = 0.15;
#line 1194 "RITA-II.instr"
  mcclmon_guide_end_Lmin = lmin;
#line 1194 "RITA-II.instr"
  mcclmon_guide_end_Lmax = lmax;
#line 1194 "RITA-II.instr"
  mcclmon_guide_end_restore_neutron = 1;
#line 51 "RITA-II.instr"
  mcclmon_guide_end_nowritefile = 0;
#line 23372 "RITA-II.c"

  SIG_MESSAGE("lmon_guide_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23379 "RITA-II.c"
  rot_mul(mctr1, mcrotaslitGuideEnd, mcrotalmon_guide_end);
  rot_transpose(mcrotaemon_guide_end, mctr1);
  rot_mul(mcrotalmon_guide_end, mctr1, mcrotrlmon_guide_end);
  mctc1 = coords_set(
#line 1195 "RITA-II.instr"
    0,
#line 1195 "RITA-II.instr"
    0,
#line 1195 "RITA-II.instr"
    0.06);
#line 23390 "RITA-II.c"
  rot_transpose(mcrotaslitGuideEnd, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposalmon_guide_end = coords_add(mcposaslitGuideEnd, mctc2);
  mctc1 = coords_sub(mcposaemon_guide_end, mcposalmon_guide_end);
  mcposrlmon_guide_end = rot_apply(mcrotalmon_guide_end, mctc1);
  mcDEBUG_COMPONENT("lmon_guide_end", mcposalmon_guide_end, mcrotalmon_guide_end)
  mccomp_posa[51] = mcposalmon_guide_end;
  mccomp_posr[51] = mcposrlmon_guide_end;
  mcNCounter[51]  = mcPCounter[51] = mcP2Counter[51] = 0;
  mcAbsorbProp[51]= 0;
    /* Component divmon_guide_end. */
  /* Setting parameters for component divmon_guide_end. */
  SIG_MESSAGE("divmon_guide_end (Init:SetPar)");
#line 1198 "RITA-II.instr"
  if("divmon_guide_end.dat") strncpy(mccdivmon_guide_end_filename, "divmon_guide_end.dat" ? "divmon_guide_end.dat" : "", 16384); else mccdivmon_guide_end_filename[0]='\0';
#line 55 "RITA-II.instr"
  mccdivmon_guide_end_xmin = -0.05;
#line 55 "RITA-II.instr"
  mccdivmon_guide_end_xmax = 0.05;
#line 55 "RITA-II.instr"
  mccdivmon_guide_end_ymin = -0.05;
#line 55 "RITA-II.instr"
  mccdivmon_guide_end_ymax = 0.05;
#line 1199 "RITA-II.instr"
  mccdivmon_guide_end_xwidth = 0.04;
#line 1199 "RITA-II.instr"
  mccdivmon_guide_end_yheight = 0.15;
#line 1200 "RITA-II.instr"
  mccdivmon_guide_end_maxdiv_h = 2;
#line 1200 "RITA-II.instr"
  mccdivmon_guide_end_maxdiv_v = 2;
#line 1199 "RITA-II.instr"
  mccdivmon_guide_end_restore_neutron = 1;
#line 56 "RITA-II.instr"
  mccdivmon_guide_end_nx = 0;
#line 56 "RITA-II.instr"
  mccdivmon_guide_end_ny = 0;
#line 56 "RITA-II.instr"
  mccdivmon_guide_end_nz = 1;
#line 56 "RITA-II.instr"
  mccdivmon_guide_end_nowritefile = 0;
#line 23432 "RITA-II.c"

  SIG_MESSAGE("divmon_guide_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23439 "RITA-II.c"
  rot_mul(mctr1, mcrotaslitGuideEnd, mcrotadivmon_guide_end);
  rot_transpose(mcrotalmon_guide_end, mctr1);
  rot_mul(mcrotadivmon_guide_end, mctr1, mcrotrdivmon_guide_end);
  mctc1 = coords_set(
#line 1201 "RITA-II.instr"
    0,
#line 1201 "RITA-II.instr"
    0,
#line 1201 "RITA-II.instr"
    0.07);
#line 23450 "RITA-II.c"
  rot_transpose(mcrotaslitGuideEnd, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposadivmon_guide_end = coords_add(mcposaslitGuideEnd, mctc2);
  mctc1 = coords_sub(mcposalmon_guide_end, mcposadivmon_guide_end);
  mcposrdivmon_guide_end = rot_apply(mcrotadivmon_guide_end, mctc1);
  mcDEBUG_COMPONENT("divmon_guide_end", mcposadivmon_guide_end, mcrotadivmon_guide_end)
  mccomp_posa[52] = mcposadivmon_guide_end;
  mccomp_posr[52] = mcposrdivmon_guide_end;
  mcNCounter[52]  = mcPCounter[52] = mcP2Counter[52] = 0;
  mcAbsorbProp[52]= 0;
    /* Component focus_mono. */
  /* Setting parameters for component focus_mono. */
  SIG_MESSAGE("focus_mono (Init:SetPar)");

  SIG_MESSAGE("focus_mono (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1206 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1206 "RITA-II.instr"
    (machine_real . a1)*DEG2RAD,
#line 1206 "RITA-II.instr"
    (0)*DEG2RAD);
#line 23473 "RITA-II.c"
  rot_mul(mctr1, mcrotaslitGuideEnd, mcrotafocus_mono);
  rot_transpose(mcrotadivmon_guide_end, mctr1);
  rot_mul(mcrotafocus_mono, mctr1, mcrotrfocus_mono);
  mctc1 = coords_set(
#line 1205 "RITA-II.instr"
    0,
#line 1205 "RITA-II.instr"
    0,
#line 1205 "RITA-II.instr"
    0.15);
#line 23484 "RITA-II.c"
  rot_transpose(mcrotaslitGuideEnd, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposafocus_mono = coords_add(mcposaslitGuideEnd, mctc2);
  mctc1 = coords_sub(mcposadivmon_guide_end, mcposafocus_mono);
  mcposrfocus_mono = rot_apply(mcrotafocus_mono, mctc1);
  mcDEBUG_COMPONENT("focus_mono", mcposafocus_mono, mcrotafocus_mono)
  mccomp_posa[53] = mcposafocus_mono;
  mccomp_posr[53] = mcposrfocus_mono;
  mcNCounter[53]  = mcPCounter[53] = mcP2Counter[53] = 0;
  mcAbsorbProp[53]= 0;
    /* Component monochromator_curved. */
  /* Setting parameters for component monochromator_curved. */
  SIG_MESSAGE("monochromator_curved (Init:SetPar)");
#line 1212 "RITA-II.instr"
  if("HOPG.rfl") strncpy(mccmonochromator_curved_reflect, "HOPG.rfl" ? "HOPG.rfl" : "", 16384); else mccmonochromator_curved_reflect[0]='\0';
#line 99 "RITA-II.instr"
  if("NULL") strncpy(mccmonochromator_curved_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator_curved_transmit[0]='\0';
#line 1212 "RITA-II.instr"
  mccmonochromator_curved_zwidth = 0.15;
#line 1212 "RITA-II.instr"
  mccmonochromator_curved_yheight = 0.025;
#line 1213 "RITA-II.instr"
  mccmonochromator_curved_gap = 0.001;
#line 1213 "RITA-II.instr"
  mccmonochromator_curved_NH = 1;
#line 1213 "RITA-II.instr"
  mccmonochromator_curved_NV = 5;
#line 1213 "RITA-II.instr"
  mccmonochromator_curved_mosaich = mono_mosaic_h;
#line 1214 "RITA-II.instr"
  mccmonochromator_curved_mosaicv = mono_mosaic_v;
#line 1214 "RITA-II.instr"
  mccmonochromator_curved_r0 = 1;
#line 101 "RITA-II.instr"
  mccmonochromator_curved_t0 = 1.0;
#line 1214 "RITA-II.instr"
  mccmonochromator_curved_Q = 1.8734;
#line 1214 "RITA-II.instr"
  mccmonochromator_curved_RV = rv;
#line 1215 "RITA-II.instr"
  mccmonochromator_curved_RH = 0;
#line 102 "RITA-II.instr"
  mccmonochromator_curved_DM = 0;
#line 102 "RITA-II.instr"
  mccmonochromator_curved_mosaic = 0;
#line 102 "RITA-II.instr"
  mccmonochromator_curved_width = 0;
#line 102 "RITA-II.instr"
  mccmonochromator_curved_height = 0;
#line 102 "RITA-II.instr"
  mccmonochromator_curved_verbose = 0;
#line 102 "RITA-II.instr"
  mccmonochromator_curved_order = 0;
#line 23538 "RITA-II.c"

  SIG_MESSAGE("monochromator_curved (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23545 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_mono, mcrotamonochromator_curved);
  rot_transpose(mcrotafocus_mono, mctr1);
  rot_mul(mcrotamonochromator_curved, mctr1, mcrotrmonochromator_curved);
  mctc1 = coords_set(
#line 1216 "RITA-II.instr"
    0,
#line 1216 "RITA-II.instr"
    0,
#line 1216 "RITA-II.instr"
    0);
#line 23556 "RITA-II.c"
  rot_transpose(mcrotafocus_mono, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator_curved = coords_add(mcposafocus_mono, mctc2);
  mctc1 = coords_sub(mcposafocus_mono, mcposamonochromator_curved);
  mcposrmonochromator_curved = rot_apply(mcrotamonochromator_curved, mctc1);
  mcDEBUG_COMPONENT("monochromator_curved", mcposamonochromator_curved, mcrotamonochromator_curved)
  mccomp_posa[54] = mcposamonochromator_curved;
  mccomp_posr[54] = mcposrmonochromator_curved;
  mcNCounter[54]  = mcPCounter[54] = mcP2Counter[54] = 0;
  mcAbsorbProp[54]= 0;
    /* Component a2. */
  /* Setting parameters for component a2. */
  SIG_MESSAGE("a2 (Init:SetPar)");

  SIG_MESSAGE("a2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1223 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1223 "RITA-II.instr"
    (machine_real . a2)*DEG2RAD,
#line 1223 "RITA-II.instr"
    (0)*DEG2RAD);
#line 23579 "RITA-II.c"
  rot_mul(mctr1, mcrotaslitGuideEnd, mcrotaa2);
  rot_transpose(mcrotamonochromator_curved, mctr1);
  rot_mul(mcrotaa2, mctr1, mcrotra2);
  mctc1 = coords_set(
#line 1222 "RITA-II.instr"
    0,
#line 1222 "RITA-II.instr"
    0,
#line 1222 "RITA-II.instr"
    0);
#line 23590 "RITA-II.c"
  rot_transpose(mcrotafocus_mono, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaa2 = coords_add(mcposafocus_mono, mctc2);
  mctc1 = coords_sub(mcposamonochromator_curved, mcposaa2);
  mcposra2 = rot_apply(mcrotaa2, mctc1);
  mcDEBUG_COMPONENT("a2", mcposaa2, mcrotaa2)
  mccomp_posa[55] = mcposaa2;
  mccomp_posr[55] = mcposra2;
  mcNCounter[55]  = mcPCounter[55] = mcP2Counter[55] = 0;
  mcAbsorbProp[55]= 0;
    /* Component slitShutter. */
  /* Setting parameters for component slitShutter. */
  SIG_MESSAGE("slitShutter (Init:SetPar)");
#line 1227 "RITA-II.instr"
  mccslitShutter_xmin = -0.02;
#line 1227 "RITA-II.instr"
  mccslitShutter_xmax = 0.02;
#line 1228 "RITA-II.instr"
  mccslitShutter_ymin = -0.075;
#line 1228 "RITA-II.instr"
  mccslitShutter_ymax = 0.075;
#line 46 "RITA-II.instr"
  mccslitShutter_radius = 0;
#line 46 "RITA-II.instr"
  mccslitShutter_xwidth = 0;
#line 46 "RITA-II.instr"
  mccslitShutter_yheight = 0;
#line 23618 "RITA-II.c"

  SIG_MESSAGE("slitShutter (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1230 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1230 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1230 "RITA-II.instr"
    (0)*DEG2RAD);
#line 23628 "RITA-II.c"
  rot_mul(mctr1, mcrotaa2, mcrotaslitShutter);
  rot_transpose(mcrotaa2, mctr1);
  rot_mul(mcrotaslitShutter, mctr1, mcrotrslitShutter);
  mctc1 = coords_set(
#line 1229 "RITA-II.instr"
    0,
#line 1229 "RITA-II.instr"
    0,
#line 1229 "RITA-II.instr"
    0.2);
#line 23639 "RITA-II.c"
  rot_transpose(mcrotaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaslitShutter = coords_add(mcposaa2, mctc2);
  mctc1 = coords_sub(mcposaa2, mcposaslitShutter);
  mcposrslitShutter = rot_apply(mcrotaslitShutter, mctc1);
  mcDEBUG_COMPONENT("slitShutter", mcposaslitShutter, mcrotaslitShutter)
  mccomp_posa[56] = mcposaslitShutter;
  mccomp_posr[56] = mcposrslitShutter;
  mcNCounter[56]  = mcPCounter[56] = mcP2Counter[56] = 0;
  mcAbsorbProp[56]= 0;
    /* Component MSCollimator. */
  /* Setting parameters for component MSCollimator. */
  SIG_MESSAGE("MSCollimator (Init:SetPar)");
#line 1233 "RITA-II.instr"
  mccMSCollimator_xmin = -0.02;
#line 1233 "RITA-II.instr"
  mccMSCollimator_xmax = 0.02;
#line 1233 "RITA-II.instr"
  mccMSCollimator_ymin = -0.075;
#line 1233 "RITA-II.instr"
  mccMSCollimator_ymax = 0.075;
#line 46 "RITA-II.instr"
  mccMSCollimator_xwidth = 0;
#line 46 "RITA-II.instr"
  mccMSCollimator_yheight = 0;
#line 1233 "RITA-II.instr"
  mccMSCollimator_length = 0.20;
#line 1234 "RITA-II.instr"
  mccMSCollimator_divergence = mcipCOLL_MS;
#line 46 "RITA-II.instr"
  mccMSCollimator_transmission = 1;
#line 46 "RITA-II.instr"
  mccMSCollimator_divergenceV = 0;
#line 23673 "RITA-II.c"

  SIG_MESSAGE("MSCollimator (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23680 "RITA-II.c"
  rot_mul(mctr1, mcrotaa2, mcrotaMSCollimator);
  rot_transpose(mcrotaslitShutter, mctr1);
  rot_mul(mcrotaMSCollimator, mctr1, mcrotrMSCollimator);
  mctc1 = coords_set(
#line 1235 "RITA-II.instr"
    0,
#line 1235 "RITA-II.instr"
    0,
#line 1235 "RITA-II.instr"
    dmc);
#line 23691 "RITA-II.c"
  rot_transpose(mcrotaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaMSCollimator = coords_add(mcposaa2, mctc2);
  mctc1 = coords_sub(mcposaslitShutter, mcposaMSCollimator);
  mcposrMSCollimator = rot_apply(mcrotaMSCollimator, mctc1);
  mcDEBUG_COMPONENT("MSCollimator", mcposaMSCollimator, mcrotaMSCollimator)
  mccomp_posa[57] = mcposaMSCollimator;
  mccomp_posr[57] = mcposrMSCollimator;
  mcNCounter[57]  = mcPCounter[57] = mcP2Counter[57] = 0;
  mcAbsorbProp[57]= 0;
    /* Component infilter. */
  /* Setting parameters for component infilter. */
  SIG_MESSAGE("infilter (Init:SetPar)");
#line 1239 "RITA-II.instr"
  if(mcipINFILTERFILE) strncpy(mccinfilter_filename, mcipINFILTERFILE ? mcipINFILTERFILE : "", 16384); else mccinfilter_filename[0]='\0';
#line 1239 "RITA-II.instr"
  if("wavevector multiply") strncpy(mccinfilter_options, "wavevector multiply" ? "wavevector multiply" : "", 16384); else mccinfilter_options[0]='\0';
#line 1239 "RITA-II.instr"
  mccinfilter_xmin = -0.02;
#line 1239 "RITA-II.instr"
  mccinfilter_xmax = 0.02;
#line 1239 "RITA-II.instr"
  mccinfilter_ymin = -0.075;
#line 1239 "RITA-II.instr"
  mccinfilter_ymax = 0.075;
#line 76 "RITA-II.instr"
  mccinfilter_xwidth = 0;
#line 76 "RITA-II.instr"
  mccinfilter_yheight = 0;
#line 76 "RITA-II.instr"
  mccinfilter_thickness = 1;
#line 76 "RITA-II.instr"
  mccinfilter_scaling = 1;
#line 76 "RITA-II.instr"
  mccinfilter_verbose = 0;
#line 23727 "RITA-II.c"

  SIG_MESSAGE("infilter (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23734 "RITA-II.c"
  rot_mul(mctr1, mcrotaMSCollimator, mcrotainfilter);
  rot_transpose(mcrotaMSCollimator, mctr1);
  rot_mul(mcrotainfilter, mctr1, mcrotrinfilter);
  mctc1 = coords_set(
#line 1240 "RITA-II.instr"
    0,
#line 1240 "RITA-II.instr"
    0,
#line 1240 "RITA-II.instr"
    0.201);
#line 23745 "RITA-II.c"
  rot_transpose(mcrotaMSCollimator, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposainfilter = coords_add(mcposaMSCollimator, mctc2);
  mctc1 = coords_sub(mcposaMSCollimator, mcposainfilter);
  mcposrinfilter = rot_apply(mcrotainfilter, mctc1);
  mcDEBUG_COMPONENT("infilter", mcposainfilter, mcrotainfilter)
  mccomp_posa[58] = mcposainfilter;
  mccomp_posr[58] = mcposrinfilter;
  mcNCounter[58]  = mcPCounter[58] = mcP2Counter[58] = 0;
  mcAbsorbProp[58]= 0;
    /* Component psd_virt. */
  /* Setting parameters for component psd_virt. */
  SIG_MESSAGE("psd_virt (Init:SetPar)");
#line 1244 "RITA-II.instr"
  if("psd_virt.dat") strncpy(mccpsd_virt_filename, "psd_virt.dat" ? "psd_virt.dat" : "", 16384); else mccpsd_virt_filename[0]='\0';
#line 50 "RITA-II.instr"
  mccpsd_virt_xmin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_virt_xmax = 0.05;
#line 50 "RITA-II.instr"
  mccpsd_virt_ymin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_virt_ymax = 0.05;
#line 1244 "RITA-II.instr"
  mccpsd_virt_xwidth = 0.10;
#line 1244 "RITA-II.instr"
  mccpsd_virt_yheight = 0.10;
#line 50 "RITA-II.instr"
  mccpsd_virt_restore_neutron = 0;
#line 50 "RITA-II.instr"
  mccpsd_virt_nowritefile = 0;
#line 23777 "RITA-II.c"

  SIG_MESSAGE("psd_virt (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23784 "RITA-II.c"
  rot_mul(mctr1, mcrotaa2, mcrotapsd_virt);
  rot_transpose(mcrotainfilter, mctr1);
  rot_mul(mcrotapsd_virt, mctr1, mcrotrpsd_virt);
  mctc1 = coords_set(
#line 1245 "RITA-II.instr"
    0,
#line 1245 "RITA-II.instr"
    0,
#line 1245 "RITA-II.instr"
    dmv -0.01);
#line 23795 "RITA-II.c"
  rot_transpose(mcrotaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_virt = coords_add(mcposaa2, mctc2);
  mctc1 = coords_sub(mcposainfilter, mcposapsd_virt);
  mcposrpsd_virt = rot_apply(mcrotapsd_virt, mctc1);
  mcDEBUG_COMPONENT("psd_virt", mcposapsd_virt, mcrotapsd_virt)
  mccomp_posa[59] = mcposapsd_virt;
  mccomp_posr[59] = mcposrpsd_virt;
  mcNCounter[59]  = mcPCounter[59] = mcP2Counter[59] = 0;
  mcAbsorbProp[59]= 0;
    /* Component lmon_virt. */
  /* Setting parameters for component lmon_virt. */
  SIG_MESSAGE("lmon_virt (Init:SetPar)");
#line 1249 "RITA-II.instr"
  if("lmon_virt.dat") strncpy(mcclmon_virt_filename, "lmon_virt.dat" ? "lmon_virt.dat" : "", 16384); else mcclmon_virt_filename[0]='\0';
#line 50 "RITA-II.instr"
  mcclmon_virt_xmin = -0.05;
#line 50 "RITA-II.instr"
  mcclmon_virt_xmax = 0.05;
#line 50 "RITA-II.instr"
  mcclmon_virt_ymin = -0.05;
#line 50 "RITA-II.instr"
  mcclmon_virt_ymax = 0.05;
#line 1249 "RITA-II.instr"
  mcclmon_virt_xwidth = 0.06;
#line 1249 "RITA-II.instr"
  mcclmon_virt_yheight = 0.10;
#line 1250 "RITA-II.instr"
  mcclmon_virt_Lmin = lmin;
#line 1250 "RITA-II.instr"
  mcclmon_virt_Lmax = lmax;
#line 1250 "RITA-II.instr"
  mcclmon_virt_restore_neutron = 1;
#line 51 "RITA-II.instr"
  mcclmon_virt_nowritefile = 0;
#line 23831 "RITA-II.c"

  SIG_MESSAGE("lmon_virt (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23838 "RITA-II.c"
  rot_mul(mctr1, mcrotaa2, mcrotalmon_virt);
  rot_transpose(mcrotapsd_virt, mctr1);
  rot_mul(mcrotalmon_virt, mctr1, mcrotrlmon_virt);
  mctc1 = coords_set(
#line 1251 "RITA-II.instr"
    0,
#line 1251 "RITA-II.instr"
    0,
#line 1251 "RITA-II.instr"
    dmv);
#line 23849 "RITA-II.c"
  rot_transpose(mcrotaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposalmon_virt = coords_add(mcposaa2, mctc2);
  mctc1 = coords_sub(mcposapsd_virt, mcposalmon_virt);
  mcposrlmon_virt = rot_apply(mcrotalmon_virt, mctc1);
  mcDEBUG_COMPONENT("lmon_virt", mcposalmon_virt, mcrotalmon_virt)
  mccomp_posa[60] = mcposalmon_virt;
  mccomp_posr[60] = mcposrlmon_virt;
  mcNCounter[60]  = mcPCounter[60] = mcP2Counter[60] = 0;
  mcAbsorbProp[60]= 0;
    /* Component aa2. */
  /* Setting parameters for component aa2. */
  SIG_MESSAGE("aa2 (Init:SetPar)");

  SIG_MESSAGE("aa2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23869 "RITA-II.c"
  rot_mul(mctr1, mcrotaa2, mcrotaaa2);
  rot_transpose(mcrotalmon_virt, mctr1);
  rot_mul(mcrotaaa2, mctr1, mcrotraa2);
  mctc1 = coords_set(
#line 1254 "RITA-II.instr"
    0,
#line 1254 "RITA-II.instr"
    0,
#line 1254 "RITA-II.instr"
    dmv);
#line 23880 "RITA-II.c"
  rot_transpose(mcrotaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaaa2 = coords_add(mcposaa2, mctc2);
  mctc1 = coords_sub(mcposalmon_virt, mcposaaa2);
  mcposraa2 = rot_apply(mcrotaaa2, mctc1);
  mcDEBUG_COMPONENT("aa2", mcposaaa2, mcrotaaa2)
  mccomp_posa[61] = mcposaaa2;
  mccomp_posr[61] = mcposraa2;
  mcNCounter[61]  = mcPCounter[61] = mcP2Counter[61] = 0;
  mcAbsorbProp[61]= 0;
    /* Component virtualout. */
  /* Setting parameters for component virtualout. */
  SIG_MESSAGE("virtualout (Init:SetPar)");
#line 1258 "RITA-II.instr"
  if(mcipSOURCEFILE) strncpy(mccvirtualout_filename, mcipSOURCEFILE ? mcipSOURCEFILE : "", 16384); else mccvirtualout_filename[0]='\0';
#line 1258 "RITA-II.instr"
  mccvirtualout_bufsize = 0;
#line 23898 "RITA-II.c"

  SIG_MESSAGE("virtualout (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23905 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotavirtualout);
  rot_transpose(mcrotaaa2, mctr1);
  rot_mul(mcrotavirtualout, mctr1, mcrotrvirtualout);
  mctc1 = coords_set(
#line 1259 "RITA-II.instr"
    0,
#line 1259 "RITA-II.instr"
    0,
#line 1259 "RITA-II.instr"
    0);
#line 23916 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposavirtualout = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposaaa2, mcposavirtualout);
  mcposrvirtualout = rot_apply(mcrotavirtualout, mctc1);
  mcDEBUG_COMPONENT("virtualout", mcposavirtualout, mcrotavirtualout)
  mccomp_posa[62] = mcposavirtualout;
  mccomp_posr[62] = mcposrvirtualout;
  mcNCounter[62]  = mcPCounter[62] = mcP2Counter[62] = 0;
  mcAbsorbProp[62]= 0;
    /* Component virtualsource. */
  /* Setting parameters for component virtualsource. */
  SIG_MESSAGE("virtualsource (Init:SetPar)");
#line 1262 "RITA-II.instr"
  if(mcipSOURCEFILE) strncpy(mccvirtualsource_filename, mcipSOURCEFILE ? mcipSOURCEFILE : "", 16384); else mccvirtualsource_filename[0]='\0';
#line 1262 "RITA-II.instr"
  mccvirtualsource_verbose = 1;
#line 1262 "RITA-II.instr"
  mccvirtualsource_repeat_count = mcipREP;
#line 64 "RITA-II.instr"
  mccvirtualsource_smooth = 1;
#line 64 "RITA-II.instr"
  mccvirtualsource_display = 0;
#line 23940 "RITA-II.c"

  SIG_MESSAGE("virtualsource (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23947 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotavirtualsource);
  rot_transpose(mcrotavirtualout, mctr1);
  rot_mul(mcrotavirtualsource, mctr1, mcrotrvirtualsource);
  mctc1 = coords_set(
#line 1263 "RITA-II.instr"
    0,
#line 1263 "RITA-II.instr"
    0,
#line 1263 "RITA-II.instr"
    0);
#line 23958 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposavirtualsource = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposavirtualout, mcposavirtualsource);
  mcposrvirtualsource = rot_apply(mcrotavirtualsource, mctc1);
  mcDEBUG_COMPONENT("virtualsource", mcposavirtualsource, mcrotavirtualsource)
  mccomp_posa[63] = mcposavirtualsource;
  mccomp_posr[63] = mcposrvirtualsource;
  mcNCounter[63]  = mcPCounter[63] = mcP2Counter[63] = 0;
  mcAbsorbProp[63]= 0;
    /* Component OrderMon. */
  /* Setting parameters for component OrderMon. */
  SIG_MESSAGE("OrderMon (Init:SetPar)");
#line 1267 "RITA-II.instr"
  mccOrderMon_xwidth = 0.04;
#line 1267 "RITA-II.instr"
  mccOrderMon_yheight = 0.08;
#line 201 "RITA-II.instr"
  mccOrderMon_zdepth = 0;
#line 202 "RITA-II.instr"
  mccOrderMon_xmin = 0;
#line 202 "RITA-II.instr"
  mccOrderMon_xmax = 0;
#line 202 "RITA-II.instr"
  mccOrderMon_ymin = 0;
#line 202 "RITA-II.instr"
  mccOrderMon_ymax = 0;
#line 202 "RITA-II.instr"
  mccOrderMon_zmin = 0;
#line 202 "RITA-II.instr"
  mccOrderMon_zmax = 0;
#line 203 "RITA-II.instr"
  mccOrderMon_bins = 0;
#line 203 "RITA-II.instr"
  mccOrderMon_min = -1e40;
#line 203 "RITA-II.instr"
  mccOrderMon_max = 1e40;
#line 1269 "RITA-II.instr"
  mccOrderMon_restore_neutron = 1;
#line 203 "RITA-II.instr"
  mccOrderMon_radius = 0;
#line 1269 "RITA-II.instr"
  if("user1 bins=5 limits=[0.5 5.5], user1 bins=5 limits=[0.5 5.5]") strncpy(mccOrderMon_options, "user1 bins=5 limits=[0.5 5.5], user1 bins=5 limits=[0.5 5.5]" ? "user1 bins=5 limits=[0.5 5.5], user1 bins=5 limits=[0.5 5.5]" : "", 16384); else mccOrderMon_options[0]='\0';
#line 1269 "RITA-II.instr"
  if("OrderMonNtest.dat") strncpy(mccOrderMon_filename, "OrderMonNtest.dat" ? "OrderMonNtest.dat" : "", 16384); else mccOrderMon_filename[0]='\0';
#line 204 "RITA-II.instr"
  if("NULL") strncpy(mccOrderMon_geometry, "NULL" ? "NULL" : "", 16384); else mccOrderMon_geometry[0]='\0';
#line 1268 "RITA-II.instr"
  if("Intensity of multiples") strncpy(mccOrderMon_username1, "Intensity of multiples" ? "Intensity of multiples" : "", 16384); else mccOrderMon_username1[0]='\0';
#line 205 "RITA-II.instr"
  if("NULL") strncpy(mccOrderMon_username2, "NULL" ? "NULL" : "", 16384); else mccOrderMon_username2[0]='\0';
#line 205 "RITA-II.instr"
  if("NULL") strncpy(mccOrderMon_username3, "NULL" ? "NULL" : "", 16384); else mccOrderMon_username3[0]='\0';
#line 206 "RITA-II.instr"
  mccOrderMon_nowritefile = 0;
#line 24014 "RITA-II.c"

  SIG_MESSAGE("OrderMon (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24021 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotaOrderMon);
  rot_transpose(mcrotavirtualsource, mctr1);
  rot_mul(mcrotaOrderMon, mctr1, mcrotrOrderMon);
  mctc1 = coords_set(
#line 1270 "RITA-II.instr"
    0,
#line 1270 "RITA-II.instr"
    0,
#line 1270 "RITA-II.instr"
    0.170 -4e-3);
#line 24032 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaOrderMon = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposavirtualsource, mcposaOrderMon);
  mcposrOrderMon = rot_apply(mcrotaOrderMon, mctc1);
  mcDEBUG_COMPONENT("OrderMon", mcposaOrderMon, mcrotaOrderMon)
  mccomp_posa[64] = mcposaOrderMon;
  mccomp_posr[64] = mcposrOrderMon;
  mcNCounter[64]  = mcPCounter[64] = mcP2Counter[64] = 0;
  mcAbsorbProp[64]= 0;
    /* Component kMoni. */
  /* Setting parameters for component kMoni. */
  SIG_MESSAGE("kMoni (Init:SetPar)");
#line 54 "RITA-II.instr"
  mcckMoni_xmin = 0;
#line 54 "RITA-II.instr"
  mcckMoni_xmax = 0;
#line 54 "RITA-II.instr"
  mcckMoni_ymin = 0;
#line 54 "RITA-II.instr"
  mcckMoni_ymax = 0;
#line 1272 "RITA-II.instr"
  mcckMoni_xwidth = 0.04;
#line 1272 "RITA-II.instr"
  mcckMoni_yheight = 0.08;
#line 54 "RITA-II.instr"
  mcckMoni_psf = 0;
#line 1272 "RITA-II.instr"
  mcckMoni_k0 = 1.553;
#line 1272 "RITA-II.instr"
  mcckMoni_eff = EFF;
#line 1272 "RITA-II.instr"
  mcckMoni_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mcckMoni_nowritefile = 0;
#line 24068 "RITA-II.c"

  SIG_MESSAGE("kMoni (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24075 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotakMoni);
  rot_transpose(mcrotaOrderMon, mctr1);
  rot_mul(mcrotakMoni, mctr1, mcrotrkMoni);
  mctc1 = coords_set(
#line 1273 "RITA-II.instr"
    0,
#line 1273 "RITA-II.instr"
    0,
#line 1273 "RITA-II.instr"
    0.170 -3e-3);
#line 24086 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposakMoni = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposaOrderMon, mcposakMoni);
  mcposrkMoni = rot_apply(mcrotakMoni, mctc1);
  mcDEBUG_COMPONENT("kMoni", mcposakMoni, mcrotakMoni)
  mccomp_posa[65] = mcposakMoni;
  mccomp_posr[65] = mcposrkMoni;
  mcNCounter[65]  = mcPCounter[65] = mcP2Counter[65] = 0;
  mcAbsorbProp[65]= 0;
    /* Component kMoni1st. */
  /* Setting parameters for component kMoni1st. */
  SIG_MESSAGE("kMoni1st (Init:SetPar)");
#line 54 "RITA-II.instr"
  mcckMoni1st_xmin = 0;
#line 54 "RITA-II.instr"
  mcckMoni1st_xmax = 0;
#line 54 "RITA-II.instr"
  mcckMoni1st_ymin = 0;
#line 54 "RITA-II.instr"
  mcckMoni1st_ymax = 0;
#line 1275 "RITA-II.instr"
  mcckMoni1st_xwidth = 0.04;
#line 1275 "RITA-II.instr"
  mcckMoni1st_yheight = 0.08;
#line 54 "RITA-II.instr"
  mcckMoni1st_psf = 0;
#line 1275 "RITA-II.instr"
  mcckMoni1st_k0 = 1.553;
#line 1275 "RITA-II.instr"
  mcckMoni1st_eff = EFF;
#line 1275 "RITA-II.instr"
  mcckMoni1st_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mcckMoni1st_nowritefile = 0;
#line 24122 "RITA-II.c"

  SIG_MESSAGE("kMoni1st (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24129 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotakMoni1st);
  rot_transpose(mcrotakMoni, mctr1);
  rot_mul(mcrotakMoni1st, mctr1, mcrotrkMoni1st);
  mctc1 = coords_set(
#line 1276 "RITA-II.instr"
    0,
#line 1276 "RITA-II.instr"
    0,
#line 1276 "RITA-II.instr"
    0.170 -2e-3);
#line 24140 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposakMoni1st = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposakMoni, mcposakMoni1st);
  mcposrkMoni1st = rot_apply(mcrotakMoni1st, mctc1);
  mcDEBUG_COMPONENT("kMoni1st", mcposakMoni1st, mcrotakMoni1st)
  mccomp_posa[66] = mcposakMoni1st;
  mccomp_posr[66] = mcposrkMoni1st;
  mcNCounter[66]  = mcPCounter[66] = mcP2Counter[66] = 0;
  mcAbsorbProp[66]= 0;
    /* Component kMoni2nd. */
  /* Setting parameters for component kMoni2nd. */
  SIG_MESSAGE("kMoni2nd (Init:SetPar)");
#line 54 "RITA-II.instr"
  mcckMoni2nd_xmin = 0;
#line 54 "RITA-II.instr"
  mcckMoni2nd_xmax = 0;
#line 54 "RITA-II.instr"
  mcckMoni2nd_ymin = 0;
#line 54 "RITA-II.instr"
  mcckMoni2nd_ymax = 0;
#line 1278 "RITA-II.instr"
  mcckMoni2nd_xwidth = 0.04;
#line 1278 "RITA-II.instr"
  mcckMoni2nd_yheight = 0.08;
#line 54 "RITA-II.instr"
  mcckMoni2nd_psf = 0;
#line 1278 "RITA-II.instr"
  mcckMoni2nd_k0 = 1.553;
#line 1278 "RITA-II.instr"
  mcckMoni2nd_eff = EFF;
#line 1278 "RITA-II.instr"
  mcckMoni2nd_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mcckMoni2nd_nowritefile = 0;
#line 24176 "RITA-II.c"

  SIG_MESSAGE("kMoni2nd (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24183 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotakMoni2nd);
  rot_transpose(mcrotakMoni1st, mctr1);
  rot_mul(mcrotakMoni2nd, mctr1, mcrotrkMoni2nd);
  mctc1 = coords_set(
#line 1279 "RITA-II.instr"
    0,
#line 1279 "RITA-II.instr"
    0,
#line 1279 "RITA-II.instr"
    0.170 -1e-3);
#line 24194 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposakMoni2nd = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposakMoni1st, mcposakMoni2nd);
  mcposrkMoni2nd = rot_apply(mcrotakMoni2nd, mctc1);
  mcDEBUG_COMPONENT("kMoni2nd", mcposakMoni2nd, mcrotakMoni2nd)
  mccomp_posa[67] = mcposakMoni2nd;
  mccomp_posr[67] = mcposrkMoni2nd;
  mcNCounter[67]  = mcPCounter[67] = mcP2Counter[67] = 0;
  mcAbsorbProp[67]= 0;
    /* Component kMoni3rd. */
  /* Setting parameters for component kMoni3rd. */
  SIG_MESSAGE("kMoni3rd (Init:SetPar)");
#line 54 "RITA-II.instr"
  mcckMoni3rd_xmin = 0;
#line 54 "RITA-II.instr"
  mcckMoni3rd_xmax = 0;
#line 54 "RITA-II.instr"
  mcckMoni3rd_ymin = 0;
#line 54 "RITA-II.instr"
  mcckMoni3rd_ymax = 0;
#line 1282 "RITA-II.instr"
  mcckMoni3rd_xwidth = 0.04;
#line 1282 "RITA-II.instr"
  mcckMoni3rd_yheight = 0.08;
#line 54 "RITA-II.instr"
  mcckMoni3rd_psf = 0;
#line 1282 "RITA-II.instr"
  mcckMoni3rd_k0 = 1.553;
#line 1282 "RITA-II.instr"
  mcckMoni3rd_eff = EFF;
#line 1282 "RITA-II.instr"
  mcckMoni3rd_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mcckMoni3rd_nowritefile = 0;
#line 24230 "RITA-II.c"

  SIG_MESSAGE("kMoni3rd (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24237 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotakMoni3rd);
  rot_transpose(mcrotakMoni2nd, mctr1);
  rot_mul(mcrotakMoni3rd, mctr1, mcrotrkMoni3rd);
  mctc1 = coords_set(
#line 1283 "RITA-II.instr"
    0,
#line 1283 "RITA-II.instr"
    0,
#line 1283 "RITA-II.instr"
    0.170);
#line 24248 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposakMoni3rd = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposakMoni2nd, mcposakMoni3rd);
  mcposrkMoni3rd = rot_apply(mcrotakMoni3rd, mctc1);
  mcDEBUG_COMPONENT("kMoni3rd", mcposakMoni3rd, mcrotakMoni3rd)
  mccomp_posa[68] = mcposakMoni3rd;
  mccomp_posr[68] = mcposrkMoni3rd;
  mcNCounter[68]  = mcPCounter[68] = mcP2Counter[68] = 0;
  mcAbsorbProp[68]= 0;
    /* Component slitMonochromator. */
  /* Setting parameters for component slitMonochromator. */
  SIG_MESSAGE("slitMonochromator (Init:SetPar)");
#line 1287 "RITA-II.instr"
  mccslitMonochromator_xmin = - mcipMSL / 1000.0;
#line 1287 "RITA-II.instr"
  mccslitMonochromator_xmax = mcipMSR / 1000.0;
#line 1288 "RITA-II.instr"
  mccslitMonochromator_ymin = - mcipMSB / 1000.0;
#line 1288 "RITA-II.instr"
  mccslitMonochromator_ymax = mcipMST / 1000.0;
#line 46 "RITA-II.instr"
  mccslitMonochromator_radius = 0;
#line 46 "RITA-II.instr"
  mccslitMonochromator_xwidth = 0;
#line 46 "RITA-II.instr"
  mccslitMonochromator_yheight = 0;
#line 24276 "RITA-II.c"

  SIG_MESSAGE("slitMonochromator (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24283 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotaslitMonochromator);
  rot_transpose(mcrotakMoni3rd, mctr1);
  rot_mul(mcrotaslitMonochromator, mctr1, mcrotrslitMonochromator);
  mctc1 = coords_set(
#line 1289 "RITA-II.instr"
    0,
#line 1289 "RITA-II.instr"
    0,
#line 1289 "RITA-II.instr"
    0.285);
#line 24294 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaslitMonochromator = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposakMoni3rd, mcposaslitMonochromator);
  mcposrslitMonochromator = rot_apply(mcrotaslitMonochromator, mctc1);
  mcDEBUG_COMPONENT("slitMonochromator", mcposaslitMonochromator, mcrotaslitMonochromator)
  mccomp_posa[69] = mcposaslitMonochromator;
  mccomp_posr[69] = mcposrslitMonochromator;
  mcNCounter[69]  = mcPCounter[69] = mcP2Counter[69] = 0;
  mcAbsorbProp[69]= 0;
    /* Component Perspex. */
  /* Setting parameters for component Perspex. */
  SIG_MESSAGE("Perspex (Init:SetPar)");
#line 118 "RITA-II.instr"
  if(0) strncpy(mccPerspex_geometry, 0 ? 0 : "", 16384); else mccPerspex_geometry[0]='\0';
#line 118 "RITA-II.instr"
  mccPerspex_radius = 0;
#line 1291 "RITA-II.instr"
  mccPerspex_xwidth = 0.1;
#line 1291 "RITA-II.instr"
  mccPerspex_yheight = 0.1;
#line 1291 "RITA-II.instr"
  mccPerspex_zdepth = mcipPTHICK;
#line 118 "RITA-II.instr"
  mccPerspex_thickness = 0;
#line 119 "RITA-II.instr"
  mccPerspex_target_x = 0;
#line 119 "RITA-II.instr"
  mccPerspex_target_y = 0;
#line 119 "RITA-II.instr"
  mccPerspex_target_z = 0;
#line 119 "RITA-II.instr"
  mccPerspex_focus_r = 0;
#line 120 "RITA-II.instr"
  mccPerspex_focus_xw = 0;
#line 120 "RITA-II.instr"
  mccPerspex_focus_yh = 0;
#line 120 "RITA-II.instr"
  mccPerspex_focus_aw = 0;
#line 120 "RITA-II.instr"
  mccPerspex_focus_ah = 0;
#line 120 "RITA-II.instr"
  mccPerspex_target_index = 0;
#line 121 "RITA-II.instr"
  mccPerspex_pack = 1;
#line 1291 "RITA-II.instr"
  mccPerspex_p_interact = 1e-2;
#line 121 "RITA-II.instr"
  mccPerspex_f_QE = 0;
#line 121 "RITA-II.instr"
  mccPerspex_gamma = 0;
#line 121 "RITA-II.instr"
  mccPerspex_Etrans = 0;
#line 121 "RITA-II.instr"
  mccPerspex_deltaE = 0;
#line 1291 "RITA-II.instr"
  mccPerspex_sigma_abs = 0.019;
#line 1291 "RITA-II.instr"
  mccPerspex_sigma_inc = 4.7;
#line 1291 "RITA-II.instr"
  mccPerspex_Vc = 1;
#line 122 "RITA-II.instr"
  mccPerspex_concentric = 0;
#line 122 "RITA-II.instr"
  mccPerspex_order = 0;
#line 24360 "RITA-II.c"

  SIG_MESSAGE("Perspex (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24367 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotaPerspex);
  rot_transpose(mcrotaslitMonochromator, mctr1);
  rot_mul(mcrotaPerspex, mctr1, mcrotrPerspex);
  mctc1 = coords_set(
#line 1292 "RITA-II.instr"
    0,
#line 1292 "RITA-II.instr"
    0,
#line 1292 "RITA-II.instr"
    0.3);
#line 24378 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPerspex = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposaslitMonochromator, mcposaPerspex);
  mcposrPerspex = rot_apply(mcrotaPerspex, mctc1);
  mcDEBUG_COMPONENT("Perspex", mcposaPerspex, mcrotaPerspex)
  mccomp_posa[70] = mcposaPerspex;
  mccomp_posr[70] = mcposrPerspex;
  mcNCounter[70]  = mcPCounter[70] = mcP2Counter[70] = 0;
  mcAbsorbProp[70]= 0;
    /* Component psd_samplepos_1cm2. */
  /* Setting parameters for component psd_samplepos_1cm2. */
  SIG_MESSAGE("psd_samplepos_1cm2 (Init:SetPar)");
#line 1294 "RITA-II.instr"
  if("psd_samplepos_1cm2.dat") strncpy(mccpsd_samplepos_1cm2_filename, "psd_samplepos_1cm2.dat" ? "psd_samplepos_1cm2.dat" : "", 16384); else mccpsd_samplepos_1cm2_filename[0]='\0';
#line 50 "RITA-II.instr"
  mccpsd_samplepos_1cm2_xmin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_1cm2_xmax = 0.05;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_1cm2_ymin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_1cm2_ymax = 0.05;
#line 1294 "RITA-II.instr"
  mccpsd_samplepos_1cm2_xwidth = 0.01;
#line 1294 "RITA-II.instr"
  mccpsd_samplepos_1cm2_yheight = 0.01;
#line 1294 "RITA-II.instr"
  mccpsd_samplepos_1cm2_restore_neutron = 1;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_1cm2_nowritefile = 0;
#line 24410 "RITA-II.c"

  SIG_MESSAGE("psd_samplepos_1cm2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24417 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotapsd_samplepos_1cm2);
  rot_transpose(mcrotaPerspex, mctr1);
  rot_mul(mcrotapsd_samplepos_1cm2, mctr1, mcrotrpsd_samplepos_1cm2);
  mctc1 = coords_set(
#line 1295 "RITA-II.instr"
    0,
#line 1295 "RITA-II.instr"
    0,
#line 1295 "RITA-II.instr"
    dvs);
#line 24428 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_samplepos_1cm2 = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposaPerspex, mcposapsd_samplepos_1cm2);
  mcposrpsd_samplepos_1cm2 = rot_apply(mcrotapsd_samplepos_1cm2, mctc1);
  mcDEBUG_COMPONENT("psd_samplepos_1cm2", mcposapsd_samplepos_1cm2, mcrotapsd_samplepos_1cm2)
  mccomp_posa[71] = mcposapsd_samplepos_1cm2;
  mccomp_posr[71] = mcposrpsd_samplepos_1cm2;
  mcNCounter[71]  = mcPCounter[71] = mcP2Counter[71] = 0;
  mcAbsorbProp[71]= 0;
    /* Component emon_samplepos_1cm2. */
  /* Setting parameters for component emon_samplepos_1cm2. */
  SIG_MESSAGE("emon_samplepos_1cm2 (Init:SetPar)");
#line 1298 "RITA-II.instr"
  if("emon_samplepos_1cm2.dat") strncpy(mccemon_samplepos_1cm2_filename, "emon_samplepos_1cm2.dat" ? "emon_samplepos_1cm2.dat" : "", 16384); else mccemon_samplepos_1cm2_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_samplepos_1cm2_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_samplepos_1cm2_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_samplepos_1cm2_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_samplepos_1cm2_ymax = 0.05;
#line 1298 "RITA-II.instr"
  mccemon_samplepos_1cm2_xwidth = 0.01;
#line 1298 "RITA-II.instr"
  mccemon_samplepos_1cm2_yheight = 0.01;
#line 1298 "RITA-II.instr"
  mccemon_samplepos_1cm2_Emin = emini;
#line 1298 "RITA-II.instr"
  mccemon_samplepos_1cm2_Emax = emaxi;
#line 1298 "RITA-II.instr"
  mccemon_samplepos_1cm2_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_samplepos_1cm2_nowritefile = 0;
#line 24464 "RITA-II.c"

  SIG_MESSAGE("emon_samplepos_1cm2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24471 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotaemon_samplepos_1cm2);
  rot_transpose(mcrotapsd_samplepos_1cm2, mctr1);
  rot_mul(mcrotaemon_samplepos_1cm2, mctr1, mcrotremon_samplepos_1cm2);
  mctc1 = coords_set(
#line 1299 "RITA-II.instr"
    0,
#line 1299 "RITA-II.instr"
    0,
#line 1299 "RITA-II.instr"
    dvs);
#line 24482 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_samplepos_1cm2 = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposapsd_samplepos_1cm2, mcposaemon_samplepos_1cm2);
  mcposremon_samplepos_1cm2 = rot_apply(mcrotaemon_samplepos_1cm2, mctc1);
  mcDEBUG_COMPONENT("emon_samplepos_1cm2", mcposaemon_samplepos_1cm2, mcrotaemon_samplepos_1cm2)
  mccomp_posa[72] = mcposaemon_samplepos_1cm2;
  mccomp_posr[72] = mcposremon_samplepos_1cm2;
  mcNCounter[72]  = mcPCounter[72] = mcP2Counter[72] = 0;
  mcAbsorbProp[72]= 0;
    /* Component divmon_samplepos_1cm2. */
  /* Setting parameters for component divmon_samplepos_1cm2. */
  SIG_MESSAGE("divmon_samplepos_1cm2 (Init:SetPar)");
#line 1302 "RITA-II.instr"
  if("divmon_samplepos_1cm2.dat") strncpy(mccdivmon_samplepos_1cm2_filename, "divmon_samplepos_1cm2.dat" ? "divmon_samplepos_1cm2.dat" : "", 16384); else mccdivmon_samplepos_1cm2_filename[0]='\0';
#line 55 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_xmin = -0.05;
#line 55 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_xmax = 0.05;
#line 55 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_ymin = -0.05;
#line 55 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_ymax = 0.05;
#line 1303 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_xwidth = 0.01;
#line 1303 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_yheight = 0.01;
#line 1303 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_maxdiv_h = 3;
#line 1303 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_maxdiv_v = 3;
#line 1303 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_restore_neutron = 1;
#line 56 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_nx = 0;
#line 56 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_ny = 0;
#line 56 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_nz = 1;
#line 56 "RITA-II.instr"
  mccdivmon_samplepos_1cm2_nowritefile = 0;
#line 24524 "RITA-II.c"

  SIG_MESSAGE("divmon_samplepos_1cm2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24531 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotadivmon_samplepos_1cm2);
  rot_transpose(mcrotaemon_samplepos_1cm2, mctr1);
  rot_mul(mcrotadivmon_samplepos_1cm2, mctr1, mcrotrdivmon_samplepos_1cm2);
  mctc1 = coords_set(
#line 1304 "RITA-II.instr"
    0,
#line 1304 "RITA-II.instr"
    0,
#line 1304 "RITA-II.instr"
    dvs);
#line 24542 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposadivmon_samplepos_1cm2 = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposaemon_samplepos_1cm2, mcposadivmon_samplepos_1cm2);
  mcposrdivmon_samplepos_1cm2 = rot_apply(mcrotadivmon_samplepos_1cm2, mctc1);
  mcDEBUG_COMPONENT("divmon_samplepos_1cm2", mcposadivmon_samplepos_1cm2, mcrotadivmon_samplepos_1cm2)
  mccomp_posa[73] = mcposadivmon_samplepos_1cm2;
  mccomp_posr[73] = mcposrdivmon_samplepos_1cm2;
  mcNCounter[73]  = mcPCounter[73] = mcP2Counter[73] = 0;
  mcAbsorbProp[73]= 0;
    /* Component psd_samplepos_large. */
  /* Setting parameters for component psd_samplepos_large. */
  SIG_MESSAGE("psd_samplepos_large (Init:SetPar)");
#line 1306 "RITA-II.instr"
  if("psd_samplepos_large.dat") strncpy(mccpsd_samplepos_large_filename, "psd_samplepos_large.dat" ? "psd_samplepos_large.dat" : "", 16384); else mccpsd_samplepos_large_filename[0]='\0';
#line 50 "RITA-II.instr"
  mccpsd_samplepos_large_xmin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_large_xmax = 0.05;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_large_ymin = -0.05;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_large_ymax = 0.05;
#line 1306 "RITA-II.instr"
  mccpsd_samplepos_large_xwidth = 0.06;
#line 1306 "RITA-II.instr"
  mccpsd_samplepos_large_yheight = 0.06;
#line 1306 "RITA-II.instr"
  mccpsd_samplepos_large_restore_neutron = 1;
#line 50 "RITA-II.instr"
  mccpsd_samplepos_large_nowritefile = 0;
#line 24574 "RITA-II.c"

  SIG_MESSAGE("psd_samplepos_large (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24581 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotapsd_samplepos_large);
  rot_transpose(mcrotadivmon_samplepos_1cm2, mctr1);
  rot_mul(mcrotapsd_samplepos_large, mctr1, mcrotrpsd_samplepos_large);
  mctc1 = coords_set(
#line 1307 "RITA-II.instr"
    0,
#line 1307 "RITA-II.instr"
    0,
#line 1307 "RITA-II.instr"
    dvs);
#line 24592 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_samplepos_large = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposadivmon_samplepos_1cm2, mcposapsd_samplepos_large);
  mcposrpsd_samplepos_large = rot_apply(mcrotapsd_samplepos_large, mctc1);
  mcDEBUG_COMPONENT("psd_samplepos_large", mcposapsd_samplepos_large, mcrotapsd_samplepos_large)
  mccomp_posa[74] = mcposapsd_samplepos_large;
  mccomp_posr[74] = mcposrpsd_samplepos_large;
  mcNCounter[74]  = mcPCounter[74] = mcP2Counter[74] = 0;
  mcAbsorbProp[74]= 0;
    /* Component a3. */
  /* Setting parameters for component a3. */
  SIG_MESSAGE("a3 (Init:SetPar)");

  SIG_MESSAGE("a3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1311 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1311 "RITA-II.instr"
    (machine_real . a3)*DEG2RAD,
#line 1311 "RITA-II.instr"
    (0)*DEG2RAD);
#line 24615 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotaa3);
  rot_transpose(mcrotapsd_samplepos_large, mctr1);
  rot_mul(mcrotaa3, mctr1, mcrotra3);
  mctc1 = coords_set(
#line 1310 "RITA-II.instr"
    0,
#line 1310 "RITA-II.instr"
    0,
#line 1310 "RITA-II.instr"
    dvs);
#line 24626 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaa3 = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposapsd_samplepos_large, mcposaa3);
  mcposra3 = rot_apply(mcrotaa3, mctc1);
  mcDEBUG_COMPONENT("a3", mcposaa3, mcrotaa3)
  mccomp_posa[75] = mcposaa3;
  mccomp_posr[75] = mcposra3;
  mcNCounter[75]  = mcPCounter[75] = mcP2Counter[75] = 0;
  mcAbsorbProp[75]= 0;
    /* Component aa3. */
  /* Setting parameters for component aa3. */
  SIG_MESSAGE("aa3 (Init:SetPar)");

  SIG_MESSAGE("aa3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1315 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1315 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1315 "RITA-II.instr"
    (mcipTILT)*DEG2RAD);
#line 24649 "RITA-II.c"
  rot_mul(mctr1, mcrotaa3, mcrotaaa3);
  rot_transpose(mcrotaa3, mctr1);
  rot_mul(mcrotaaa3, mctr1, mcrotraa3);
  mctc1 = coords_set(
#line 1314 "RITA-II.instr"
    0,
#line 1314 "RITA-II.instr"
    0,
#line 1314 "RITA-II.instr"
    0);
#line 24660 "RITA-II.c"
  rot_transpose(mcrotaa3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaaa3 = coords_add(mcposaa3, mctc2);
  mctc1 = coords_sub(mcposaa3, mcposaaa3);
  mcposraa3 = rot_apply(mcrotaaa3, mctc1);
  mcDEBUG_COMPONENT("aa3", mcposaaa3, mcrotaaa3)
  mccomp_posa[76] = mcposaaa3;
  mccomp_posr[76] = mcposraa3;
  mcNCounter[76]  = mcPCounter[76] = mcP2Counter[76] = 0;
  mcAbsorbProp[76]= 0;
    /* Component incohSample. */
  /* Setting parameters for component incohSample. */
  SIG_MESSAGE("incohSample (Init:SetPar)");
#line 118 "RITA-II.instr"
  if(0) strncpy(mccincohSample_geometry, 0 ? 0 : "", 16384); else mccincohSample_geometry[0]='\0';
#line 1320 "RITA-II.instr"
  mccincohSample_radius = 0.0201 / 2;
#line 118 "RITA-II.instr"
  mccincohSample_xwidth = 0;
#line 1320 "RITA-II.instr"
  mccincohSample_yheight = 0.0187;
#line 118 "RITA-II.instr"
  mccincohSample_zdepth = 0;
#line 1320 "RITA-II.instr"
  mccincohSample_thickness = 0.0201 / 2 -0.0149 / 2;
#line 119 "RITA-II.instr"
  mccincohSample_target_x = 0;
#line 119 "RITA-II.instr"
  mccincohSample_target_y = 0;
#line 119 "RITA-II.instr"
  mccincohSample_target_z = 0;
#line 119 "RITA-II.instr"
  mccincohSample_focus_r = 0;
#line 1321 "RITA-II.instr"
  mccincohSample_focus_xw = 0.16;
#line 1321 "RITA-II.instr"
  mccincohSample_focus_yh = 0.16;
#line 120 "RITA-II.instr"
  mccincohSample_focus_aw = 0;
#line 120 "RITA-II.instr"
  mccincohSample_focus_ah = 0;
#line 1320 "RITA-II.instr"
  mccincohSample_target_index = 10;
#line 121 "RITA-II.instr"
  mccincohSample_pack = 1;
#line 121 "RITA-II.instr"
  mccincohSample_p_interact = 1;
#line 121 "RITA-II.instr"
  mccincohSample_f_QE = 0;
#line 121 "RITA-II.instr"
  mccincohSample_gamma = 0;
#line 121 "RITA-II.instr"
  mccincohSample_Etrans = 0;
#line 121 "RITA-II.instr"
  mccincohSample_deltaE = 0;
#line 1320 "RITA-II.instr"
  mccincohSample_sigma_abs = 5.08;
#line 1320 "RITA-II.instr"
  mccincohSample_sigma_inc = 5.08;
#line 1320 "RITA-II.instr"
  mccincohSample_Vc = 13.827;
#line 122 "RITA-II.instr"
  mccincohSample_concentric = 0;
#line 122 "RITA-II.instr"
  mccincohSample_order = 0;
#line 24726 "RITA-II.c"

  SIG_MESSAGE("incohSample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24733 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa3, mcrotaincohSample);
  rot_transpose(mcrotaaa3, mctr1);
  rot_mul(mcrotaincohSample, mctr1, mcrotrincohSample);
  mctc1 = coords_set(
#line 1323 "RITA-II.instr"
    0,
#line 1323 "RITA-II.instr"
    0,
#line 1323 "RITA-II.instr"
    0);
#line 24744 "RITA-II.c"
  rot_transpose(mcrotaaa3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaincohSample = coords_add(mcposaaa3, mctc2);
  mctc1 = coords_sub(mcposaaa3, mcposaincohSample);
  mcposrincohSample = rot_apply(mcrotaincohSample, mctc1);
  mcDEBUG_COMPONENT("incohSample", mcposaincohSample, mcrotaincohSample)
  mccomp_posa[77] = mcposaincohSample;
  mccomp_posr[77] = mcposrincohSample;
  mcNCounter[77]  = mcPCounter[77] = mcP2Counter[77] = 0;
  mcAbsorbProp[77]= 0;
    /* Component powderSample. */
  /* Setting parameters for component powderSample. */
  SIG_MESSAGE("powderSample (Init:SetPar)");
#line 1326 "RITA-II.instr"
  if(PowderFile) strncpy(mccpowderSample_reflections, PowderFile ? PowderFile : "", 16384); else mccpowderSample_reflections[0]='\0';
#line 206 "RITA-II.instr"
  if("NULL") strncpy(mccpowderSample_geometry, "NULL" ? "NULL" : "", 16384); else mccpowderSample_geometry[0]='\0';
#line 1326 "RITA-II.instr"
  mccpowderSample_radius = 0.0068;
#line 1326 "RITA-II.instr"
  mccpowderSample_yheight = 0.015;
#line 207 "RITA-II.instr"
  mccpowderSample_xwidth = 0;
#line 207 "RITA-II.instr"
  mccpowderSample_zdepth = 0;
#line 207 "RITA-II.instr"
  mccpowderSample_thickness = 0;
#line 1326 "RITA-II.instr"
  mccpowderSample_pack = 1;
#line 1326 "RITA-II.instr"
  mccpowderSample_Vc = 254.52;
#line 1326 "RITA-II.instr"
  mccpowderSample_sigma_abs = 0.4625;
#line 1327 "RITA-II.instr"
  mccpowderSample_sigma_inc = 0.0188;
#line 208 "RITA-II.instr"
  mccpowderSample_delta_d_d = 0;
#line 1327 "RITA-II.instr"
  mccpowderSample_p_inc = 0;
#line 208 "RITA-II.instr"
  mccpowderSample_p_transmit = 0.1;
#line 209 "RITA-II.instr"
  mccpowderSample_DW = 0;
#line 209 "RITA-II.instr"
  mccpowderSample_nb_atoms = 1;
#line 209 "RITA-II.instr"
  mccpowderSample_d_omega = 0;
#line 1326 "RITA-II.instr"
  mccpowderSample_d_phi = 12;
#line 209 "RITA-II.instr"
  mccpowderSample_tth_sign = 0;
#line 209 "RITA-II.instr"
  mccpowderSample_p_interact = 0;
#line 210 "RITA-II.instr"
  mccpowderSample_concentric = 0;
#line 210 "RITA-II.instr"
  mccpowderSample_density = 0;
#line 210 "RITA-II.instr"
  mccpowderSample_weight = 0;
#line 1327 "RITA-II.instr"
  mccpowderSample_barns = mcipBARNS;
#line 210 "RITA-II.instr"
  mccpowderSample_Strain = 0;
#line 210 "RITA-II.instr"
  mccpowderSample_focus_flip = 0;
#line 210 "RITA-II.instr"
  mccpowderSample_target_index = 0;
#line 24812 "RITA-II.c"

  SIG_MESSAGE("powderSample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24819 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa3, mcrotapowderSample);
  rot_transpose(mcrotaincohSample, mctr1);
  rot_mul(mcrotapowderSample, mctr1, mcrotrpowderSample);
  mctc1 = coords_set(
#line 1329 "RITA-II.instr"
    0,
#line 1329 "RITA-II.instr"
    0,
#line 1329 "RITA-II.instr"
    0);
#line 24830 "RITA-II.c"
  rot_transpose(mcrotaaa3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapowderSample = coords_add(mcposaaa3, mctc2);
  mctc1 = coords_sub(mcposaincohSample, mcposapowderSample);
  mcposrpowderSample = rot_apply(mcrotapowderSample, mctc1);
  mcDEBUG_COMPONENT("powderSample", mcposapowderSample, mcrotapowderSample)
  mccomp_posa[78] = mcposapowderSample;
  mccomp_posr[78] = mcposrpowderSample;
  mcNCounter[78]  = mcPCounter[78] = mcP2Counter[78] = 0;
  mcAbsorbProp[78]= 0;
    /* Component crystalSample. */
  /* Setting parameters for component crystalSample. */
  SIG_MESSAGE("crystalSample (Init:SetPar)");
#line 1332 "RITA-II.instr"
  if(SingleXFile) strncpy(mcccrystalSample_reflections, SingleXFile ? SingleXFile : "", 16384); else mcccrystalSample_reflections[0]='\0';
#line 275 "RITA-II.instr"
  if(0) strncpy(mcccrystalSample_geometry, 0 ? 0 : "", 16384); else mcccrystalSample_geometry[0]='\0';
#line 1332 "RITA-II.instr"
  mcccrystalSample_xwidth = mcipSAMPLESIZE;
#line 1332 "RITA-II.instr"
  mcccrystalSample_yheight = mcipSAMPLESIZE;
#line 1332 "RITA-II.instr"
  mcccrystalSample_zdepth = mcipSAMPLESIZE;
#line 276 "RITA-II.instr"
  mcccrystalSample_radius = 0;
#line 1332 "RITA-II.instr"
  mcccrystalSample_delta_d_d = mcipDD_D;
#line 1332 "RITA-II.instr"
  mcccrystalSample_mosaic = mcipMOS;
#line 277 "RITA-II.instr"
  mcccrystalSample_mosaic_a = -1;
#line 277 "RITA-II.instr"
  mcccrystalSample_mosaic_b = -1;
#line 277 "RITA-II.instr"
  mcccrystalSample_mosaic_c = -1;
#line 278 "RITA-II.instr"
  mcccrystalSample_recip_cell = 0;
#line 1333 "RITA-II.instr"
  mcccrystalSample_barns = mcipBARNS;
#line 1333 "RITA-II.instr"
  mcccrystalSample_ax = mcipAAX;
#line 1333 "RITA-II.instr"
  mcccrystalSample_ay = mcipAAY;
#line 1333 "RITA-II.instr"
  mcccrystalSample_az = mcipAAZ;
#line 1333 "RITA-II.instr"
  mcccrystalSample_bx = mcipBBX;
#line 1333 "RITA-II.instr"
  mcccrystalSample_by = mcipBBY;
#line 1333 "RITA-II.instr"
  mcccrystalSample_bz = mcipBBZ;
#line 1333 "RITA-II.instr"
  mcccrystalSample_cx = mcipCCX;
#line 1333 "RITA-II.instr"
  mcccrystalSample_cy = mcipCCY;
#line 1333 "RITA-II.instr"
  mcccrystalSample_cz = mcipCCZ;
#line 282 "RITA-II.instr"
  mcccrystalSample_p_transmit = -1;
#line 282 "RITA-II.instr"
  mcccrystalSample_sigma_abs = 0;
#line 282 "RITA-II.instr"
  mcccrystalSample_sigma_inc = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_aa = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_bb = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_cc = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_order = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_RX = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_RY = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_powder = 0;
#line 283 "RITA-II.instr"
  mcccrystalSample_PG = 0;
#line 284 "RITA-II.instr"
  mcccrystalSample_deltak = 1e-6;
#line 24912 "RITA-II.c"

  SIG_MESSAGE("crystalSample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24919 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa3, mcrotacrystalSample);
  rot_transpose(mcrotapowderSample, mctr1);
  rot_mul(mcrotacrystalSample, mctr1, mcrotrcrystalSample);
  mctc1 = coords_set(
#line 1335 "RITA-II.instr"
    0,
#line 1335 "RITA-II.instr"
    0,
#line 1335 "RITA-II.instr"
    0);
#line 24930 "RITA-II.c"
  rot_transpose(mcrotaaa3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacrystalSample = coords_add(mcposaaa3, mctc2);
  mctc1 = coords_sub(mcposapowderSample, mcposacrystalSample);
  mcposrcrystalSample = rot_apply(mcrotacrystalSample, mctc1);
  mcDEBUG_COMPONENT("crystalSample", mcposacrystalSample, mcrotacrystalSample)
  mccomp_posa[79] = mcposacrystalSample;
  mccomp_posr[79] = mcposrcrystalSample;
  mcNCounter[79]  = mcPCounter[79] = mcP2Counter[79] = 0;
  mcAbsorbProp[79]= 0;
    /* Component phononSample. */
  /* Setting parameters for component phononSample. */
  SIG_MESSAGE("phononSample (Init:SetPar)");
#line 1342 "RITA-II.instr"
  mccphononSample_radius = mcipSAMPLESIZE / 2;
#line 1342 "RITA-II.instr"
  mccphononSample_yheight = mcipSAMPLESIZE;
#line 1343 "RITA-II.instr"
  mccphononSample_sigma_abs = 0.171;
#line 1343 "RITA-II.instr"
  mccphononSample_sigma_inc = 0.003;
#line 1344 "RITA-II.instr"
  mccphononSample_a = 4.95;
#line 1344 "RITA-II.instr"
  mccphononSample_b = 4.95;
#line 1344 "RITA-II.instr"
  mccphononSample_M = 207.2;
#line 1344 "RITA-II.instr"
  mccphononSample_c = 10;
#line 1344 "RITA-II.instr"
  mccphononSample_DW = 1;
#line 1344 "RITA-II.instr"
  mccphononSample_T = 300;
#line 68 "RITA-II.instr"
  mccphononSample_target_x = 0;
#line 68 "RITA-II.instr"
  mccphononSample_target_y = 0;
#line 68 "RITA-II.instr"
  mccphononSample_target_z = 0;
#line 1345 "RITA-II.instr"
  mccphononSample_target_index = 7;
#line 68 "RITA-II.instr"
  mccphononSample_focus_r = 0;
#line 1342 "RITA-II.instr"
  mccphononSample_focus_xw = 0.16;
#line 1343 "RITA-II.instr"
  mccphononSample_focus_yh = 0.16;
#line 68 "RITA-II.instr"
  mccphononSample_focus_aw = 0;
#line 68 "RITA-II.instr"
  mccphononSample_focus_ah = 0;
#line 68 "RITA-II.instr"
  mccphononSample_gap = 0;
#line 24984 "RITA-II.c"

  SIG_MESSAGE("phononSample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24991 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa3, mcrotaphononSample);
  rot_transpose(mcrotacrystalSample, mctr1);
  rot_mul(mcrotaphononSample, mctr1, mcrotrphononSample);
  mctc1 = coords_set(
#line 1346 "RITA-II.instr"
    0,
#line 1346 "RITA-II.instr"
    0,
#line 1346 "RITA-II.instr"
    0);
#line 25002 "RITA-II.c"
  rot_transpose(mcrotaaa3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaphononSample = coords_add(mcposaaa3, mctc2);
  mctc1 = coords_sub(mcposacrystalSample, mcposaphononSample);
  mcposrphononSample = rot_apply(mcrotaphononSample, mctc1);
  mcDEBUG_COMPONENT("phononSample", mcposaphononSample, mcrotaphononSample)
  mccomp_posa[80] = mcposaphononSample;
  mccomp_posr[80] = mcposrphononSample;
  mcNCounter[80]  = mcPCounter[80] = mcP2Counter[80] = 0;
  mcAbsorbProp[80]= 0;
    /* Component psd_4pi. */
  /* Setting parameters for component psd_4pi. */
  SIG_MESSAGE("psd_4pi (Init:SetPar)");
#line 1349 "RITA-II.instr"
  if("psd_4pi") strncpy(mccpsd_4pi_filename, "psd_4pi" ? "psd_4pi" : "", 16384); else mccpsd_4pi_filename[0]='\0';
#line 1350 "RITA-II.instr"
  mccpsd_4pi_radius = 0.1;
#line 1350 "RITA-II.instr"
  mccpsd_4pi_restore_neutron = 1;
#line 49 "RITA-II.instr"
  mccpsd_4pi_nowritefile = 0;
#line 25024 "RITA-II.c"

  SIG_MESSAGE("psd_4pi (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25031 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotapsd_4pi);
  rot_transpose(mcrotaphononSample, mctr1);
  rot_mul(mcrotapsd_4pi, mctr1, mcrotrpsd_4pi);
  mctc1 = coords_set(
#line 1351 "RITA-II.instr"
    0,
#line 1351 "RITA-II.instr"
    0,
#line 1351 "RITA-II.instr"
    dvs);
#line 25042 "RITA-II.c"
  rot_transpose(mcrotaaa2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_4pi = coords_add(mcposaaa2, mctc2);
  mctc1 = coords_sub(mcposaphononSample, mcposapsd_4pi);
  mcposrpsd_4pi = rot_apply(mcrotapsd_4pi, mctc1);
  mcDEBUG_COMPONENT("psd_4pi", mcposapsd_4pi, mcrotapsd_4pi)
  mccomp_posa[81] = mcposapsd_4pi;
  mccomp_posr[81] = mcposrpsd_4pi;
  mcNCounter[81]  = mcPCounter[81] = mcP2Counter[81] = 0;
  mcAbsorbProp[81]= 0;
    /* Component a4. */
  /* Setting parameters for component a4. */
  SIG_MESSAGE("a4 (Init:SetPar)");

  SIG_MESSAGE("a4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1355 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1355 "RITA-II.instr"
    (machine_real . a4)*DEG2RAD,
#line 1355 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25065 "RITA-II.c"
  rot_mul(mctr1, mcrotaaa2, mcrotaa4);
  rot_transpose(mcrotapsd_4pi, mctr1);
  rot_mul(mcrotaa4, mctr1, mcrotra4);
  mctc1 = coords_set(
#line 1354 "RITA-II.instr"
    0,
#line 1354 "RITA-II.instr"
    0,
#line 1354 "RITA-II.instr"
    0);
#line 25076 "RITA-II.c"
  rot_transpose(mcrotaa3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaa4 = coords_add(mcposaa3, mctc2);
  mctc1 = coords_sub(mcposapsd_4pi, mcposaa4);
  mcposra4 = rot_apply(mcrotaa4, mctc1);
  mcDEBUG_COMPONENT("a4", mcposaa4, mcrotaa4)
  mccomp_posa[82] = mcposaa4;
  mccomp_posr[82] = mcposra4;
  mcNCounter[82]  = mcPCounter[82] = mcP2Counter[82] = 0;
  mcAbsorbProp[82]= 0;
    /* Component slitSample. */
  /* Setting parameters for component slitSample. */
  SIG_MESSAGE("slitSample (Init:SetPar)");
#line 1359 "RITA-II.instr"
  mccslitSample_xmin = - mcipSSL / 1000.0;
#line 1359 "RITA-II.instr"
  mccslitSample_xmax = mcipSSR / 1000.0;
#line 1360 "RITA-II.instr"
  mccslitSample_ymin = - mcipSSB / 1000.0;
#line 1360 "RITA-II.instr"
  mccslitSample_ymax = mcipSST / 1000.0;
#line 46 "RITA-II.instr"
  mccslitSample_radius = 0;
#line 46 "RITA-II.instr"
  mccslitSample_xwidth = 0;
#line 46 "RITA-II.instr"
  mccslitSample_yheight = 0;
#line 25104 "RITA-II.c"

  SIG_MESSAGE("slitSample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25111 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotaslitSample);
  rot_transpose(mcrotaa4, mctr1);
  rot_mul(mcrotaslitSample, mctr1, mcrotrslitSample);
  mctc1 = coords_set(
#line 1361 "RITA-II.instr"
    0,
#line 1361 "RITA-II.instr"
    0,
#line 1361 "RITA-II.instr"
    d_sample_slit);
#line 25122 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaslitSample = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposaa4, mcposaslitSample);
  mcposrslitSample = rot_apply(mcrotaslitSample, mctc1);
  mcDEBUG_COMPONENT("slitSample", mcposaslitSample, mcrotaslitSample)
  mccomp_posa[83] = mcposaslitSample;
  mccomp_posr[83] = mcposrslitSample;
  mcNCounter[83]  = mcPCounter[83] = mcP2Counter[83] = 0;
  mcAbsorbProp[83]= 0;
    /* Component filter_coll. */
  /* Setting parameters for component filter_coll. */
  SIG_MESSAGE("filter_coll (Init:SetPar)");
#line 1365 "RITA-II.instr"
  mccfilter_coll_theta_min = -10.26 / 2;
#line 1365 "RITA-II.instr"
  mccfilter_coll_theta_max = 10.26 / 2;
#line 1365 "RITA-II.instr"
  mccfilter_coll_nslit = 9;
#line 1365 "RITA-II.instr"
  mccfilter_coll_radius = 0.4525;
#line 1365 "RITA-II.instr"
  mccfilter_coll_length = 0.0988;
#line 1365 "RITA-II.instr"
  mccfilter_coll_h_in = 0.2;
#line 1365 "RITA-II.instr"
  mccfilter_coll_h_out = 0.2;
#line 1365 "RITA-II.instr"
  mccfilter_coll_d = 0.000125;
#line 1365 "RITA-II.instr"
  mccfilter_coll_verbose = 1;
#line 25154 "RITA-II.c"

  SIG_MESSAGE("filter_coll (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25161 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotafilter_coll);
  rot_transpose(mcrotaslitSample, mctr1);
  rot_mul(mcrotafilter_coll, mctr1, mcrotrfilter_coll);
  mctc1 = coords_set(
#line 1368 "RITA-II.instr"
    0,
#line 1368 "RITA-II.instr"
    0,
#line 1368 "RITA-II.instr"
    d_sample_filter -0.4525 -0.0988 / 2);
#line 25172 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposafilter_coll = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposaslitSample, mcposafilter_coll);
  mcposrfilter_coll = rot_apply(mcrotafilter_coll, mctc1);
  mcDEBUG_COMPONENT("filter_coll", mcposafilter_coll, mcrotafilter_coll)
  mccomp_posa[84] = mcposafilter_coll;
  mccomp_posr[84] = mcposrfilter_coll;
  mcNCounter[84]  = mcPCounter[84] = mcP2Counter[84] = 0;
  mcAbsorbProp[84]= 0;
    /* Component filter. */
  /* Setting parameters for component filter. */
  SIG_MESSAGE("filter (Init:SetPar)");
#line 1371 "RITA-II.instr"
  if(mcipOUTFILTERFILE) strncpy(mccfilter_filename, mcipOUTFILTERFILE ? mcipOUTFILTERFILE : "", 16384); else mccfilter_filename[0]='\0';
#line 1371 "RITA-II.instr"
  if("wavevector multiply") strncpy(mccfilter_options, "wavevector multiply" ? "wavevector multiply" : "", 16384); else mccfilter_options[0]='\0';
#line 1371 "RITA-II.instr"
  mccfilter_xmin = -0.1;
#line 1371 "RITA-II.instr"
  mccfilter_xmax = 0.1;
#line 1371 "RITA-II.instr"
  mccfilter_ymin = -0.1;
#line 1371 "RITA-II.instr"
  mccfilter_ymax = 0.1;
#line 76 "RITA-II.instr"
  mccfilter_xwidth = 0;
#line 76 "RITA-II.instr"
  mccfilter_yheight = 0;
#line 76 "RITA-II.instr"
  mccfilter_thickness = 1;
#line 76 "RITA-II.instr"
  mccfilter_scaling = 1;
#line 76 "RITA-II.instr"
  mccfilter_verbose = 0;
#line 25208 "RITA-II.c"

  SIG_MESSAGE("filter (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25215 "RITA-II.c"
  rot_mul(mctr1, mcrotafilter_coll, mcrotafilter);
  rot_transpose(mcrotafilter_coll, mctr1);
  rot_mul(mcrotafilter, mctr1, mcrotrfilter);
  mctc1 = coords_set(
#line 1373 "RITA-II.instr"
    0,
#line 1373 "RITA-II.instr"
    0,
#line 1373 "RITA-II.instr"
    0.4525 + 0.0988 + 0.0001);
#line 25226 "RITA-II.c"
  rot_transpose(mcrotafilter_coll, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposafilter = coords_add(mcposafilter_coll, mctc2);
  mctc1 = coords_sub(mcposafilter_coll, mcposafilter);
  mcposrfilter = rot_apply(mcrotafilter, mctc1);
  mcDEBUG_COMPONENT("filter", mcposafilter, mcrotafilter)
  mccomp_posa[85] = mcposafilter;
  mccomp_posr[85] = mcposrfilter;
  mcNCounter[85]  = mcPCounter[85] = mcP2Counter[85] = 0;
  mcAbsorbProp[85]= 0;
    /* Component ana_slit1. */
  /* Setting parameters for component ana_slit1. */
  SIG_MESSAGE("ana_slit1 (Init:SetPar)");
#line 1378 "RITA-II.instr"
  mccana_slit1_xmin = -0.158 / 2;
#line 1378 "RITA-II.instr"
  mccana_slit1_xmax = 0.158 / 2;
#line 1379 "RITA-II.instr"
  mccana_slit1_ymin = -0.08 / 2;
#line 1379 "RITA-II.instr"
  mccana_slit1_ymax = 0.08 / 2;
#line 46 "RITA-II.instr"
  mccana_slit1_radius = 0;
#line 46 "RITA-II.instr"
  mccana_slit1_xwidth = 0;
#line 46 "RITA-II.instr"
  mccana_slit1_yheight = 0;
#line 25254 "RITA-II.c"

  SIG_MESSAGE("ana_slit1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1381 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1381 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1381 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25264 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotaana_slit1);
  rot_transpose(mcrotafilter, mctr1);
  rot_mul(mcrotaana_slit1, mctr1, mcrotrana_slit1);
  mctc1 = coords_set(
#line 1380 "RITA-II.instr"
    0,
#line 1380 "RITA-II.instr"
    0,
#line 1380 "RITA-II.instr"
    d_sample_filter + 0.13);
#line 25275 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaana_slit1 = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposafilter, mcposaana_slit1);
  mcposrana_slit1 = rot_apply(mcrotaana_slit1, mctc1);
  mcDEBUG_COMPONENT("ana_slit1", mcposaana_slit1, mcrotaana_slit1)
  mccomp_posa[86] = mcposaana_slit1;
  mccomp_posr[86] = mcposrana_slit1;
  mcNCounter[86]  = mcPCounter[86] = mcP2Counter[86] = 0;
  mcAbsorbProp[86]= 0;
    /* Component ana_slit2. */
  /* Setting parameters for component ana_slit2. */
  SIG_MESSAGE("ana_slit2 (Init:SetPar)");
#line 1384 "RITA-II.instr"
  mccana_slit2_xmin = -0.158 / 2;
#line 1384 "RITA-II.instr"
  mccana_slit2_xmax = 0.158 / 2;
#line 1385 "RITA-II.instr"
  mccana_slit2_ymin = -0.103 / 2;
#line 1385 "RITA-II.instr"
  mccana_slit2_ymax = 0.103 / 2;
#line 46 "RITA-II.instr"
  mccana_slit2_radius = 0;
#line 46 "RITA-II.instr"
  mccana_slit2_xwidth = 0;
#line 46 "RITA-II.instr"
  mccana_slit2_yheight = 0;
#line 25303 "RITA-II.c"

  SIG_MESSAGE("ana_slit2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1387 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1387 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1387 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25313 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotaana_slit2);
  rot_transpose(mcrotaana_slit1, mctr1);
  rot_mul(mcrotaana_slit2, mctr1, mcrotrana_slit2);
  mctc1 = coords_set(
#line 1386 "RITA-II.instr"
    0,
#line 1386 "RITA-II.instr"
    0,
#line 1386 "RITA-II.instr"
    d_sample_filter + 0.33);
#line 25324 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaana_slit2 = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposaana_slit1, mcposaana_slit2);
  mcposrana_slit2 = rot_apply(mcrotaana_slit2, mctc1);
  mcDEBUG_COMPONENT("ana_slit2", mcposaana_slit2, mcrotaana_slit2)
  mccomp_posa[87] = mcposaana_slit2;
  mccomp_posr[87] = mcposrana_slit2;
  mcNCounter[87]  = mcPCounter[87] = mcP2Counter[87] = 0;
  mcAbsorbProp[87]= 0;
    /* Component emon_before_ana. */
  /* Setting parameters for component emon_before_ana. */
  SIG_MESSAGE("emon_before_ana (Init:SetPar)");
#line 1392 "RITA-II.instr"
  if("emon_before_ana.dat") strncpy(mccemon_before_ana_filename, "emon_before_ana.dat" ? "emon_before_ana.dat" : "", 16384); else mccemon_before_ana_filename[0]='\0';
#line 1391 "RITA-II.instr"
  mccemon_before_ana_xmin = -0.060;
#line 1391 "RITA-II.instr"
  mccemon_before_ana_xmax = 0.060;
#line 1391 "RITA-II.instr"
  mccemon_before_ana_ymin = -0.085;
#line 1391 "RITA-II.instr"
  mccemon_before_ana_ymax = 0.085;
#line 54 "RITA-II.instr"
  mccemon_before_ana_xwidth = 0;
#line 54 "RITA-II.instr"
  mccemon_before_ana_yheight = 0;
#line 1392 "RITA-II.instr"
  mccemon_before_ana_Emin = eminf;
#line 1392 "RITA-II.instr"
  mccemon_before_ana_Emax = emaxi;
#line 1392 "RITA-II.instr"
  mccemon_before_ana_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_before_ana_nowritefile = 0;
#line 25360 "RITA-II.c"

  SIG_MESSAGE("emon_before_ana (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25367 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotaemon_before_ana);
  rot_transpose(mcrotaana_slit2, mctr1);
  rot_mul(mcrotaemon_before_ana, mctr1, mcrotremon_before_ana);
  mctc1 = coords_set(
#line 1393 "RITA-II.instr"
    0,
#line 1393 "RITA-II.instr"
    0,
#line 1393 "RITA-II.instr"
    dsa -5 * ana_d);
#line 25378 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_before_ana = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposaana_slit2, mcposaemon_before_ana);
  mcposremon_before_ana = rot_apply(mcrotaemon_before_ana, mctc1);
  mcDEBUG_COMPONENT("emon_before_ana", mcposaemon_before_ana, mcrotaemon_before_ana)
  mccomp_posa[88] = mcposaemon_before_ana;
  mccomp_posr[88] = mcposremon_before_ana;
  mcNCounter[88]  = mcPCounter[88] = mcP2Counter[88] = 0;
  mcAbsorbProp[88]= 0;
    /* Component psd_before_ana. */
  /* Setting parameters for component psd_before_ana. */
  SIG_MESSAGE("psd_before_ana (Init:SetPar)");
#line 1396 "RITA-II.instr"
  if("psd_before_ana.dat") strncpy(mccpsd_before_ana_filename, "psd_before_ana.dat" ? "psd_before_ana.dat" : "", 16384); else mccpsd_before_ana_filename[0]='\0';
#line 1398 "RITA-II.instr"
  mccpsd_before_ana_xmin = -0.060;
#line 1398 "RITA-II.instr"
  mccpsd_before_ana_xmax = 0.060;
#line 1398 "RITA-II.instr"
  mccpsd_before_ana_ymin = -0.085;
#line 1398 "RITA-II.instr"
  mccpsd_before_ana_ymax = 0.085;
#line 50 "RITA-II.instr"
  mccpsd_before_ana_xwidth = 0;
#line 50 "RITA-II.instr"
  mccpsd_before_ana_yheight = 0;
#line 50 "RITA-II.instr"
  mccpsd_before_ana_restore_neutron = 0;
#line 50 "RITA-II.instr"
  mccpsd_before_ana_nowritefile = 0;
#line 25410 "RITA-II.c"

  SIG_MESSAGE("psd_before_ana (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25417 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotapsd_before_ana);
  rot_transpose(mcrotaemon_before_ana, mctr1);
  rot_mul(mcrotapsd_before_ana, mctr1, mcrotrpsd_before_ana);
  mctc1 = coords_set(
#line 1399 "RITA-II.instr"
    0,
#line 1399 "RITA-II.instr"
    0,
#line 1399 "RITA-II.instr"
    dsa -5 * ana_d + 0.001);
#line 25428 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_before_ana = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposaemon_before_ana, mcposapsd_before_ana);
  mcposrpsd_before_ana = rot_apply(mcrotapsd_before_ana, mctc1);
  mcDEBUG_COMPONENT("psd_before_ana", mcposapsd_before_ana, mcrotapsd_before_ana)
  mccomp_posa[89] = mcposapsd_before_ana;
  mccomp_posr[89] = mcposrpsd_before_ana;
  mcNCounter[89]  = mcPCounter[89] = mcP2Counter[89] = 0;
  mcAbsorbProp[89]= 0;
    /* Component divmon_before_ana. */
  /* Setting parameters for component divmon_before_ana. */
  SIG_MESSAGE("divmon_before_ana (Init:SetPar)");
#line 1402 "RITA-II.instr"
  if("divmon_before_ana") strncpy(mccdivmon_before_ana_filename, "divmon_before_ana" ? "divmon_before_ana" : "", 16384); else mccdivmon_before_ana_filename[0]='\0';
#line 55 "RITA-II.instr"
  mccdivmon_before_ana_xmin = -0.05;
#line 55 "RITA-II.instr"
  mccdivmon_before_ana_xmax = 0.05;
#line 55 "RITA-II.instr"
  mccdivmon_before_ana_ymin = -0.05;
#line 55 "RITA-II.instr"
  mccdivmon_before_ana_ymax = 0.05;
#line 1403 "RITA-II.instr"
  mccdivmon_before_ana_xwidth = 0.02;
#line 1403 "RITA-II.instr"
  mccdivmon_before_ana_yheight = 0.17;
#line 1403 "RITA-II.instr"
  mccdivmon_before_ana_maxdiv_h = 1;
#line 1403 "RITA-II.instr"
  mccdivmon_before_ana_maxdiv_v = 1;
#line 1403 "RITA-II.instr"
  mccdivmon_before_ana_restore_neutron = 1;
#line 56 "RITA-II.instr"
  mccdivmon_before_ana_nx = 0;
#line 56 "RITA-II.instr"
  mccdivmon_before_ana_ny = 0;
#line 56 "RITA-II.instr"
  mccdivmon_before_ana_nz = 1;
#line 56 "RITA-II.instr"
  mccdivmon_before_ana_nowritefile = 0;
#line 25470 "RITA-II.c"

  SIG_MESSAGE("divmon_before_ana (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25477 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotadivmon_before_ana);
  rot_transpose(mcrotapsd_before_ana, mctr1);
  rot_mul(mcrotadivmon_before_ana, mctr1, mcrotrdivmon_before_ana);
  mctc1 = coords_set(
#line 1404 "RITA-II.instr"
    0,
#line 1404 "RITA-II.instr"
    0,
#line 1404 "RITA-II.instr"
    dsa -5 * ana_d + 0.002);
#line 25488 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposadivmon_before_ana = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposapsd_before_ana, mcposadivmon_before_ana);
  mcposrdivmon_before_ana = rot_apply(mcrotadivmon_before_ana, mctc1);
  mcDEBUG_COMPONENT("divmon_before_ana", mcposadivmon_before_ana, mcrotadivmon_before_ana)
  mccomp_posa[90] = mcposadivmon_before_ana;
  mccomp_posr[90] = mcposrdivmon_before_ana;
  mcNCounter[90]  = mcPCounter[90] = mcP2Counter[90] = 0;
  mcAbsorbProp[90]= 0;
    /* Component focus_ana. */
  /* Setting parameters for component focus_ana. */
  SIG_MESSAGE("focus_ana (Init:SetPar)");

  SIG_MESSAGE("focus_ana (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1408 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1408 "RITA-II.instr"
    (machine_real . aa5)*DEG2RAD,
#line 1408 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25511 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotafocus_ana);
  rot_transpose(mcrotadivmon_before_ana, mctr1);
  rot_mul(mcrotafocus_ana, mctr1, mcrotrfocus_ana);
  mctc1 = coords_set(
#line 1407 "RITA-II.instr"
    0,
#line 1407 "RITA-II.instr"
    0,
#line 1407 "RITA-II.instr"
    dsa);
#line 25522 "RITA-II.c"
  rot_transpose(mcrotaa4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposafocus_ana = coords_add(mcposaa4, mctc2);
  mctc1 = coords_sub(mcposadivmon_before_ana, mcposafocus_ana);
  mcposrfocus_ana = rot_apply(mcrotafocus_ana, mctc1);
  mcDEBUG_COMPONENT("focus_ana", mcposafocus_ana, mcrotafocus_ana)
  mccomp_posa[91] = mcposafocus_ana;
  mccomp_posr[91] = mcposrfocus_ana;
  mcNCounter[91]  = mcPCounter[91] = mcP2Counter[91] = 0;
  mcAbsorbProp[91]= 0;
    /* Component an1l. */
  /* Setting parameters for component an1l. */
  SIG_MESSAGE("an1l (Init:SetPar)");
#line 1414 "RITA-II.instr"
  mccan1l_zmin = - wan / 2.0;
#line 1414 "RITA-II.instr"
  mccan1l_zmax = wan / 2.0;
#line 1414 "RITA-II.instr"
  mccan1l_ymin = - ana_h / 2.0;
#line 1414 "RITA-II.instr"
  mccan1l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan1l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan1l_yheight = 0;
#line 1415 "RITA-II.instr"
  mccan1l_mosaich = 40;
#line 1415 "RITA-II.instr"
  mccan1l_mosaicv = 40;
#line 1416 "RITA-II.instr"
  mccan1l_r0 = ana_r0;
#line 1416 "RITA-II.instr"
  mccan1l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan1l_DM = 0;
#line 25558 "RITA-II.c"

  SIG_MESSAGE("an1l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1418 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1418 "RITA-II.instr"
    (machine_real . c1)*DEG2RAD,
#line 1418 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25568 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan1l);
  rot_transpose(mcrotafocus_ana, mctr1);
  rot_mul(mcrotaan1l, mctr1, mcrotran1l);
  mctc1 = coords_set(
#line 1417 "RITA-II.instr"
    0,
#line 1417 "RITA-II.instr"
    0,
#line 1417 "RITA-II.instr"
    -4 * ana_d);
#line 25579 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan1l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposafocus_ana, mcposaan1l);
  mcposran1l = rot_apply(mcrotaan1l, mctc1);
  mcDEBUG_COMPONENT("an1l", mcposaan1l, mcrotaan1l)
  mccomp_posa[92] = mcposaan1l;
  mccomp_posr[92] = mcposran1l;
  mcNCounter[92]  = mcPCounter[92] = mcP2Counter[92] = 0;
  mcAbsorbProp[92]= 0;
    /* Component an1u. */
  /* Setting parameters for component an1u. */
  SIG_MESSAGE("an1u (Init:SetPar)");
#line 1425 "RITA-II.instr"
  mccan1u_zmin = - wan / 2.0;
#line 1425 "RITA-II.instr"
  mccan1u_zmax = wan / 2.0;
#line 1425 "RITA-II.instr"
  mccan1u_ymin = 0;
#line 1425 "RITA-II.instr"
  mccan1u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan1u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan1u_yheight = 0;
#line 1426 "RITA-II.instr"
  mccan1u_mosaich = 40;
#line 1426 "RITA-II.instr"
  mccan1u_mosaicv = 40;
#line 1427 "RITA-II.instr"
  mccan1u_r0 = ana_r0;
#line 1427 "RITA-II.instr"
  mccan1u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan1u_DM = 0;
#line 25615 "RITA-II.c"

  SIG_MESSAGE("an1u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1429 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1429 "RITA-II.instr"
    (machine_real . c1)*DEG2RAD,
#line 1429 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25625 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan1u);
  rot_transpose(mcrotaan1l, mctr1);
  rot_mul(mcrotaan1u, mctr1, mcrotran1u);
  mctc1 = coords_set(
#line 1428 "RITA-II.instr"
    0,
#line 1428 "RITA-II.instr"
    0,
#line 1428 "RITA-II.instr"
    -4 * ana_d);
#line 25636 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan1u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan1l, mcposaan1u);
  mcposran1u = rot_apply(mcrotaan1u, mctc1);
  mcDEBUG_COMPONENT("an1u", mcposaan1u, mcrotaan1u)
  mccomp_posa[93] = mcposaan1u;
  mccomp_posr[93] = mcposran1u;
  mcNCounter[93]  = mcPCounter[93] = mcP2Counter[93] = 0;
  mcAbsorbProp[93]= 0;
    /* Component an2l. */
  /* Setting parameters for component an2l. */
  SIG_MESSAGE("an2l (Init:SetPar)");
#line 1437 "RITA-II.instr"
  mccan2l_zmin = - wan / 2.0;
#line 1437 "RITA-II.instr"
  mccan2l_zmax = wan / 2.0;
#line 1437 "RITA-II.instr"
  mccan2l_ymin = - ana_h / 2.0;
#line 1437 "RITA-II.instr"
  mccan2l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan2l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan2l_yheight = 0;
#line 1438 "RITA-II.instr"
  mccan2l_mosaich = 38.7;
#line 1438 "RITA-II.instr"
  mccan2l_mosaicv = 38.7;
#line 1439 "RITA-II.instr"
  mccan2l_r0 = ana_r0;
#line 1439 "RITA-II.instr"
  mccan2l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan2l_DM = 0;
#line 25672 "RITA-II.c"

  SIG_MESSAGE("an2l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1441 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1441 "RITA-II.instr"
    (machine_real . c2)*DEG2RAD,
#line 1441 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25682 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan2l);
  rot_transpose(mcrotaan1u, mctr1);
  rot_mul(mcrotaan2l, mctr1, mcrotran2l);
  mctc1 = coords_set(
#line 1440 "RITA-II.instr"
    0,
#line 1440 "RITA-II.instr"
    0,
#line 1440 "RITA-II.instr"
    -3 * ana_d);
#line 25693 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan2l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan1u, mcposaan2l);
  mcposran2l = rot_apply(mcrotaan2l, mctc1);
  mcDEBUG_COMPONENT("an2l", mcposaan2l, mcrotaan2l)
  mccomp_posa[94] = mcposaan2l;
  mccomp_posr[94] = mcposran2l;
  mcNCounter[94]  = mcPCounter[94] = mcP2Counter[94] = 0;
  mcAbsorbProp[94]= 0;
    /* Component an2u. */
  /* Setting parameters for component an2u. */
  SIG_MESSAGE("an2u (Init:SetPar)");
#line 1448 "RITA-II.instr"
  mccan2u_zmin = - wan / 2.0;
#line 1448 "RITA-II.instr"
  mccan2u_zmax = wan / 2.0;
#line 1448 "RITA-II.instr"
  mccan2u_ymin = 0;
#line 1448 "RITA-II.instr"
  mccan2u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan2u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan2u_yheight = 0;
#line 1449 "RITA-II.instr"
  mccan2u_mosaich = 43.0;
#line 1449 "RITA-II.instr"
  mccan2u_mosaicv = 43.0;
#line 1450 "RITA-II.instr"
  mccan2u_r0 = ana_r0;
#line 1450 "RITA-II.instr"
  mccan2u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan2u_DM = 0;
#line 25729 "RITA-II.c"

  SIG_MESSAGE("an2u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1452 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1452 "RITA-II.instr"
    (machine_real . c2)*DEG2RAD,
#line 1452 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25739 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan2u);
  rot_transpose(mcrotaan2l, mctr1);
  rot_mul(mcrotaan2u, mctr1, mcrotran2u);
  mctc1 = coords_set(
#line 1451 "RITA-II.instr"
    0,
#line 1451 "RITA-II.instr"
    0,
#line 1451 "RITA-II.instr"
    -3 * ana_d);
#line 25750 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan2u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan2l, mcposaan2u);
  mcposran2u = rot_apply(mcrotaan2u, mctc1);
  mcDEBUG_COMPONENT("an2u", mcposaan2u, mcrotaan2u)
  mccomp_posa[95] = mcposaan2u;
  mccomp_posr[95] = mcposran2u;
  mcNCounter[95]  = mcPCounter[95] = mcP2Counter[95] = 0;
  mcAbsorbProp[95]= 0;
    /* Component an3l. */
  /* Setting parameters for component an3l. */
  SIG_MESSAGE("an3l (Init:SetPar)");
#line 1459 "RITA-II.instr"
  mccan3l_zmin = - wan / 2.0;
#line 1459 "RITA-II.instr"
  mccan3l_zmax = wan / 2.0;
#line 1459 "RITA-II.instr"
  mccan3l_ymin = - ana_h / 2.0;
#line 1459 "RITA-II.instr"
  mccan3l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan3l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan3l_yheight = 0;
#line 1460 "RITA-II.instr"
  mccan3l_mosaich = 31.1;
#line 1460 "RITA-II.instr"
  mccan3l_mosaicv = 31.1;
#line 1461 "RITA-II.instr"
  mccan3l_r0 = ana_r0;
#line 1461 "RITA-II.instr"
  mccan3l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan3l_DM = 0;
#line 25786 "RITA-II.c"

  SIG_MESSAGE("an3l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1463 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1463 "RITA-II.instr"
    (machine_real . c3)*DEG2RAD,
#line 1463 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25796 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan3l);
  rot_transpose(mcrotaan2u, mctr1);
  rot_mul(mcrotaan3l, mctr1, mcrotran3l);
  mctc1 = coords_set(
#line 1462 "RITA-II.instr"
    0,
#line 1462 "RITA-II.instr"
    0,
#line 1462 "RITA-II.instr"
    -2 * ana_d);
#line 25807 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan3l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan2u, mcposaan3l);
  mcposran3l = rot_apply(mcrotaan3l, mctc1);
  mcDEBUG_COMPONENT("an3l", mcposaan3l, mcrotaan3l)
  mccomp_posa[96] = mcposaan3l;
  mccomp_posr[96] = mcposran3l;
  mcNCounter[96]  = mcPCounter[96] = mcP2Counter[96] = 0;
  mcAbsorbProp[96]= 0;
    /* Component an3u. */
  /* Setting parameters for component an3u. */
  SIG_MESSAGE("an3u (Init:SetPar)");
#line 1470 "RITA-II.instr"
  mccan3u_zmin = - wan / 2.0;
#line 1470 "RITA-II.instr"
  mccan3u_zmax = wan / 2.0;
#line 1470 "RITA-II.instr"
  mccan3u_ymin = 0;
#line 1470 "RITA-II.instr"
  mccan3u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan3u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan3u_yheight = 0;
#line 1471 "RITA-II.instr"
  mccan3u_mosaich = 35.5;
#line 1471 "RITA-II.instr"
  mccan3u_mosaicv = 35.5;
#line 1472 "RITA-II.instr"
  mccan3u_r0 = ana_r0;
#line 1472 "RITA-II.instr"
  mccan3u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan3u_DM = 0;
#line 25843 "RITA-II.c"

  SIG_MESSAGE("an3u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1474 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1474 "RITA-II.instr"
    (machine_real . c3)*DEG2RAD,
#line 1474 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25853 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan3u);
  rot_transpose(mcrotaan3l, mctr1);
  rot_mul(mcrotaan3u, mctr1, mcrotran3u);
  mctc1 = coords_set(
#line 1473 "RITA-II.instr"
    0,
#line 1473 "RITA-II.instr"
    0,
#line 1473 "RITA-II.instr"
    -2 * ana_d);
#line 25864 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan3u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan3l, mcposaan3u);
  mcposran3u = rot_apply(mcrotaan3u, mctc1);
  mcDEBUG_COMPONENT("an3u", mcposaan3u, mcrotaan3u)
  mccomp_posa[97] = mcposaan3u;
  mccomp_posr[97] = mcposran3u;
  mcNCounter[97]  = mcPCounter[97] = mcP2Counter[97] = 0;
  mcAbsorbProp[97]= 0;
    /* Component an4l. */
  /* Setting parameters for component an4l. */
  SIG_MESSAGE("an4l (Init:SetPar)");
#line 1482 "RITA-II.instr"
  mccan4l_zmin = - wan / 2.0;
#line 1482 "RITA-II.instr"
  mccan4l_zmax = wan / 2.0;
#line 1482 "RITA-II.instr"
  mccan4l_ymin = - ana_h / 2.0;
#line 1482 "RITA-II.instr"
  mccan4l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan4l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan4l_yheight = 0;
#line 1483 "RITA-II.instr"
  mccan4l_mosaich = 27.2;
#line 1483 "RITA-II.instr"
  mccan4l_mosaicv = 27.2;
#line 1484 "RITA-II.instr"
  mccan4l_r0 = ana_r0;
#line 1484 "RITA-II.instr"
  mccan4l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan4l_DM = 0;
#line 25900 "RITA-II.c"

  SIG_MESSAGE("an4l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1486 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1486 "RITA-II.instr"
    (machine_real . c4)*DEG2RAD,
#line 1486 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25910 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan4l);
  rot_transpose(mcrotaan3u, mctr1);
  rot_mul(mcrotaan4l, mctr1, mcrotran4l);
  mctc1 = coords_set(
#line 1485 "RITA-II.instr"
    0,
#line 1485 "RITA-II.instr"
    0,
#line 1485 "RITA-II.instr"
    -1 * ana_d);
#line 25921 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan4l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan3u, mcposaan4l);
  mcposran4l = rot_apply(mcrotaan4l, mctc1);
  mcDEBUG_COMPONENT("an4l", mcposaan4l, mcrotaan4l)
  mccomp_posa[98] = mcposaan4l;
  mccomp_posr[98] = mcposran4l;
  mcNCounter[98]  = mcPCounter[98] = mcP2Counter[98] = 0;
  mcAbsorbProp[98]= 0;
    /* Component an4u. */
  /* Setting parameters for component an4u. */
  SIG_MESSAGE("an4u (Init:SetPar)");
#line 1493 "RITA-II.instr"
  mccan4u_zmin = - wan / 2.0;
#line 1493 "RITA-II.instr"
  mccan4u_zmax = wan / 2.0;
#line 1493 "RITA-II.instr"
  mccan4u_ymin = 0;
#line 1493 "RITA-II.instr"
  mccan4u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan4u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan4u_yheight = 0;
#line 1494 "RITA-II.instr"
  mccan4u_mosaich = 30.4;
#line 1494 "RITA-II.instr"
  mccan4u_mosaicv = 30.4;
#line 1495 "RITA-II.instr"
  mccan4u_r0 = ana_r0;
#line 1495 "RITA-II.instr"
  mccan4u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan4u_DM = 0;
#line 25957 "RITA-II.c"

  SIG_MESSAGE("an4u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1497 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1497 "RITA-II.instr"
    (machine_real . c4)*DEG2RAD,
#line 1497 "RITA-II.instr"
    (0)*DEG2RAD);
#line 25967 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan4u);
  rot_transpose(mcrotaan4l, mctr1);
  rot_mul(mcrotaan4u, mctr1, mcrotran4u);
  mctc1 = coords_set(
#line 1496 "RITA-II.instr"
    0,
#line 1496 "RITA-II.instr"
    0,
#line 1496 "RITA-II.instr"
    -1 * ana_d);
#line 25978 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan4u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan4l, mcposaan4u);
  mcposran4u = rot_apply(mcrotaan4u, mctc1);
  mcDEBUG_COMPONENT("an4u", mcposaan4u, mcrotaan4u)
  mccomp_posa[99] = mcposaan4u;
  mccomp_posr[99] = mcposran4u;
  mcNCounter[99]  = mcPCounter[99] = mcP2Counter[99] = 0;
  mcAbsorbProp[99]= 0;
    /* Component an5l. */
  /* Setting parameters for component an5l. */
  SIG_MESSAGE("an5l (Init:SetPar)");
#line 1504 "RITA-II.instr"
  mccan5l_zmin = - wan / 2.0;
#line 1504 "RITA-II.instr"
  mccan5l_zmax = wan / 2.0;
#line 1504 "RITA-II.instr"
  mccan5l_ymin = - ana_h / 2.0;
#line 1504 "RITA-II.instr"
  mccan5l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan5l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan5l_yheight = 0;
#line 1505 "RITA-II.instr"
  mccan5l_mosaich = 36.6;
#line 1505 "RITA-II.instr"
  mccan5l_mosaicv = 36.6;
#line 1506 "RITA-II.instr"
  mccan5l_r0 = ana_r0;
#line 1506 "RITA-II.instr"
  mccan5l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan5l_DM = 0;
#line 26014 "RITA-II.c"

  SIG_MESSAGE("an5l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1508 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1508 "RITA-II.instr"
    (machine_real . c5)*DEG2RAD,
#line 1508 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26024 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan5l);
  rot_transpose(mcrotaan4u, mctr1);
  rot_mul(mcrotaan5l, mctr1, mcrotran5l);
  mctc1 = coords_set(
#line 1507 "RITA-II.instr"
    0,
#line 1507 "RITA-II.instr"
    0,
#line 1507 "RITA-II.instr"
    0);
#line 26035 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan5l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan4u, mcposaan5l);
  mcposran5l = rot_apply(mcrotaan5l, mctc1);
  mcDEBUG_COMPONENT("an5l", mcposaan5l, mcrotaan5l)
  mccomp_posa[100] = mcposaan5l;
  mccomp_posr[100] = mcposran5l;
  mcNCounter[100]  = mcPCounter[100] = mcP2Counter[100] = 0;
  mcAbsorbProp[100]= 0;
    /* Component an5u. */
  /* Setting parameters for component an5u. */
  SIG_MESSAGE("an5u (Init:SetPar)");
#line 1515 "RITA-II.instr"
  mccan5u_zmin = - wan / 2.0;
#line 1515 "RITA-II.instr"
  mccan5u_zmax = wan / 2.0;
#line 1515 "RITA-II.instr"
  mccan5u_ymin = 0;
#line 1515 "RITA-II.instr"
  mccan5u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan5u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan5u_yheight = 0;
#line 1516 "RITA-II.instr"
  mccan5u_mosaich = 35.9;
#line 1516 "RITA-II.instr"
  mccan5u_mosaicv = 35.9;
#line 1517 "RITA-II.instr"
  mccan5u_r0 = ana_r0;
#line 1517 "RITA-II.instr"
  mccan5u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan5u_DM = 0;
#line 26071 "RITA-II.c"

  SIG_MESSAGE("an5u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1519 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1519 "RITA-II.instr"
    (machine_real . c5)*DEG2RAD,
#line 1519 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26081 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan5u);
  rot_transpose(mcrotaan5l, mctr1);
  rot_mul(mcrotaan5u, mctr1, mcrotran5u);
  mctc1 = coords_set(
#line 1518 "RITA-II.instr"
    0,
#line 1518 "RITA-II.instr"
    0,
#line 1518 "RITA-II.instr"
    0);
#line 26092 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan5u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan5l, mcposaan5u);
  mcposran5u = rot_apply(mcrotaan5u, mctc1);
  mcDEBUG_COMPONENT("an5u", mcposaan5u, mcrotaan5u)
  mccomp_posa[101] = mcposaan5u;
  mccomp_posr[101] = mcposran5u;
  mcNCounter[101]  = mcPCounter[101] = mcP2Counter[101] = 0;
  mcAbsorbProp[101]= 0;
    /* Component an6l. */
  /* Setting parameters for component an6l. */
  SIG_MESSAGE("an6l (Init:SetPar)");
#line 1526 "RITA-II.instr"
  mccan6l_zmin = - wan / 2.0;
#line 1526 "RITA-II.instr"
  mccan6l_zmax = wan / 2.0;
#line 1526 "RITA-II.instr"
  mccan6l_ymin = - ana_h / 2.0;
#line 1526 "RITA-II.instr"
  mccan6l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan6l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan6l_yheight = 0;
#line 1527 "RITA-II.instr"
  mccan6l_mosaich = 31.5;
#line 1527 "RITA-II.instr"
  mccan6l_mosaicv = 31.5;
#line 1528 "RITA-II.instr"
  mccan6l_r0 = ana_r0;
#line 1528 "RITA-II.instr"
  mccan6l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan6l_DM = 0;
#line 26128 "RITA-II.c"

  SIG_MESSAGE("an6l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1530 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1530 "RITA-II.instr"
    (machine_real . c6)*DEG2RAD,
#line 1530 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26138 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan6l);
  rot_transpose(mcrotaan5u, mctr1);
  rot_mul(mcrotaan6l, mctr1, mcrotran6l);
  mctc1 = coords_set(
#line 1529 "RITA-II.instr"
    0,
#line 1529 "RITA-II.instr"
    0,
#line 1529 "RITA-II.instr"
    ana_d);
#line 26149 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan6l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan5u, mcposaan6l);
  mcposran6l = rot_apply(mcrotaan6l, mctc1);
  mcDEBUG_COMPONENT("an6l", mcposaan6l, mcrotaan6l)
  mccomp_posa[102] = mcposaan6l;
  mccomp_posr[102] = mcposran6l;
  mcNCounter[102]  = mcPCounter[102] = mcP2Counter[102] = 0;
  mcAbsorbProp[102]= 0;
    /* Component an6u. */
  /* Setting parameters for component an6u. */
  SIG_MESSAGE("an6u (Init:SetPar)");
#line 1537 "RITA-II.instr"
  mccan6u_zmin = - wan / 2.0;
#line 1537 "RITA-II.instr"
  mccan6u_zmax = wan / 2.0;
#line 1537 "RITA-II.instr"
  mccan6u_ymin = 0;
#line 1537 "RITA-II.instr"
  mccan6u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan6u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan6u_yheight = 0;
#line 1538 "RITA-II.instr"
  mccan6u_mosaich = 36.1;
#line 1538 "RITA-II.instr"
  mccan6u_mosaicv = 36.1;
#line 1539 "RITA-II.instr"
  mccan6u_r0 = ana_r0;
#line 1539 "RITA-II.instr"
  mccan6u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan6u_DM = 0;
#line 26185 "RITA-II.c"

  SIG_MESSAGE("an6u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1541 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1541 "RITA-II.instr"
    (machine_real . c6)*DEG2RAD,
#line 1541 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26195 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan6u);
  rot_transpose(mcrotaan6l, mctr1);
  rot_mul(mcrotaan6u, mctr1, mcrotran6u);
  mctc1 = coords_set(
#line 1540 "RITA-II.instr"
    0,
#line 1540 "RITA-II.instr"
    0,
#line 1540 "RITA-II.instr"
    ana_d);
#line 26206 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan6u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan6l, mcposaan6u);
  mcposran6u = rot_apply(mcrotaan6u, mctc1);
  mcDEBUG_COMPONENT("an6u", mcposaan6u, mcrotaan6u)
  mccomp_posa[103] = mcposaan6u;
  mccomp_posr[103] = mcposran6u;
  mcNCounter[103]  = mcPCounter[103] = mcP2Counter[103] = 0;
  mcAbsorbProp[103]= 0;
    /* Component an7l. */
  /* Setting parameters for component an7l. */
  SIG_MESSAGE("an7l (Init:SetPar)");
#line 1549 "RITA-II.instr"
  mccan7l_zmin = - wan / 2.0;
#line 1549 "RITA-II.instr"
  mccan7l_zmax = wan / 2.0;
#line 1549 "RITA-II.instr"
  mccan7l_ymin = - ana_h / 2.0;
#line 1549 "RITA-II.instr"
  mccan7l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan7l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan7l_yheight = 0;
#line 1550 "RITA-II.instr"
  mccan7l_mosaich = 33.1;
#line 1550 "RITA-II.instr"
  mccan7l_mosaicv = 33.1;
#line 1551 "RITA-II.instr"
  mccan7l_r0 = ana_r0;
#line 1551 "RITA-II.instr"
  mccan7l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan7l_DM = 0;
#line 26242 "RITA-II.c"

  SIG_MESSAGE("an7l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1553 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1553 "RITA-II.instr"
    (machine_real . c7)*DEG2RAD,
#line 1553 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26252 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan7l);
  rot_transpose(mcrotaan6u, mctr1);
  rot_mul(mcrotaan7l, mctr1, mcrotran7l);
  mctc1 = coords_set(
#line 1552 "RITA-II.instr"
    0,
#line 1552 "RITA-II.instr"
    0,
#line 1552 "RITA-II.instr"
    2 * ana_d);
#line 26263 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan7l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan6u, mcposaan7l);
  mcposran7l = rot_apply(mcrotaan7l, mctc1);
  mcDEBUG_COMPONENT("an7l", mcposaan7l, mcrotaan7l)
  mccomp_posa[104] = mcposaan7l;
  mccomp_posr[104] = mcposran7l;
  mcNCounter[104]  = mcPCounter[104] = mcP2Counter[104] = 0;
  mcAbsorbProp[104]= 0;
    /* Component an7u. */
  /* Setting parameters for component an7u. */
  SIG_MESSAGE("an7u (Init:SetPar)");
#line 1560 "RITA-II.instr"
  mccan7u_zmin = - wan / 2.0;
#line 1560 "RITA-II.instr"
  mccan7u_zmax = wan / 2.0;
#line 1560 "RITA-II.instr"
  mccan7u_ymin = 0;
#line 1560 "RITA-II.instr"
  mccan7u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan7u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan7u_yheight = 0;
#line 1561 "RITA-II.instr"
  mccan7u_mosaich = 37.2;
#line 1561 "RITA-II.instr"
  mccan7u_mosaicv = 37.2;
#line 1562 "RITA-II.instr"
  mccan7u_r0 = ana_r0;
#line 1562 "RITA-II.instr"
  mccan7u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan7u_DM = 0;
#line 26299 "RITA-II.c"

  SIG_MESSAGE("an7u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1564 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1564 "RITA-II.instr"
    (machine_real . c7)*DEG2RAD,
#line 1564 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26309 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan7u);
  rot_transpose(mcrotaan7l, mctr1);
  rot_mul(mcrotaan7u, mctr1, mcrotran7u);
  mctc1 = coords_set(
#line 1563 "RITA-II.instr"
    0,
#line 1563 "RITA-II.instr"
    0,
#line 1563 "RITA-II.instr"
    2 * ana_d);
#line 26320 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan7u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan7l, mcposaan7u);
  mcposran7u = rot_apply(mcrotaan7u, mctc1);
  mcDEBUG_COMPONENT("an7u", mcposaan7u, mcrotaan7u)
  mccomp_posa[105] = mcposaan7u;
  mccomp_posr[105] = mcposran7u;
  mcNCounter[105]  = mcPCounter[105] = mcP2Counter[105] = 0;
  mcAbsorbProp[105]= 0;
    /* Component an8l. */
  /* Setting parameters for component an8l. */
  SIG_MESSAGE("an8l (Init:SetPar)");
#line 1571 "RITA-II.instr"
  mccan8l_zmin = - wan / 2.0;
#line 1571 "RITA-II.instr"
  mccan8l_zmax = wan / 2.0;
#line 1571 "RITA-II.instr"
  mccan8l_ymin = - ana_h / 2.0;
#line 1571 "RITA-II.instr"
  mccan8l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan8l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan8l_yheight = 0;
#line 1572 "RITA-II.instr"
  mccan8l_mosaich = 46.8;
#line 1572 "RITA-II.instr"
  mccan8l_mosaicv = 46.8;
#line 1573 "RITA-II.instr"
  mccan8l_r0 = ana_r0;
#line 1573 "RITA-II.instr"
  mccan8l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan8l_DM = 0;
#line 26356 "RITA-II.c"

  SIG_MESSAGE("an8l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1575 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1575 "RITA-II.instr"
    (machine_real . c8)*DEG2RAD,
#line 1575 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26366 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan8l);
  rot_transpose(mcrotaan7u, mctr1);
  rot_mul(mcrotaan8l, mctr1, mcrotran8l);
  mctc1 = coords_set(
#line 1574 "RITA-II.instr"
    0,
#line 1574 "RITA-II.instr"
    0,
#line 1574 "RITA-II.instr"
    3 * ana_d);
#line 26377 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan8l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan7u, mcposaan8l);
  mcposran8l = rot_apply(mcrotaan8l, mctc1);
  mcDEBUG_COMPONENT("an8l", mcposaan8l, mcrotaan8l)
  mccomp_posa[106] = mcposaan8l;
  mccomp_posr[106] = mcposran8l;
  mcNCounter[106]  = mcPCounter[106] = mcP2Counter[106] = 0;
  mcAbsorbProp[106]= 0;
    /* Component an8u. */
  /* Setting parameters for component an8u. */
  SIG_MESSAGE("an8u (Init:SetPar)");
#line 1582 "RITA-II.instr"
  mccan8u_zmin = - wan / 2.0;
#line 1582 "RITA-II.instr"
  mccan8u_zmax = wan / 2.0;
#line 1582 "RITA-II.instr"
  mccan8u_ymin = 0;
#line 1582 "RITA-II.instr"
  mccan8u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan8u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan8u_yheight = 0;
#line 1583 "RITA-II.instr"
  mccan8u_mosaich = 51.3;
#line 1583 "RITA-II.instr"
  mccan8u_mosaicv = 51.3;
#line 1584 "RITA-II.instr"
  mccan8u_r0 = ana_r0;
#line 1584 "RITA-II.instr"
  mccan8u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan8u_DM = 0;
#line 26413 "RITA-II.c"

  SIG_MESSAGE("an8u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1586 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1586 "RITA-II.instr"
    (machine_real . c8)*DEG2RAD,
#line 1586 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26423 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan8u);
  rot_transpose(mcrotaan8l, mctr1);
  rot_mul(mcrotaan8u, mctr1, mcrotran8u);
  mctc1 = coords_set(
#line 1585 "RITA-II.instr"
    0,
#line 1585 "RITA-II.instr"
    0,
#line 1585 "RITA-II.instr"
    3 * ana_d);
#line 26434 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan8u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan8l, mcposaan8u);
  mcposran8u = rot_apply(mcrotaan8u, mctc1);
  mcDEBUG_COMPONENT("an8u", mcposaan8u, mcrotaan8u)
  mccomp_posa[107] = mcposaan8u;
  mccomp_posr[107] = mcposran8u;
  mcNCounter[107]  = mcPCounter[107] = mcP2Counter[107] = 0;
  mcAbsorbProp[107]= 0;
    /* Component an9l. */
  /* Setting parameters for component an9l. */
  SIG_MESSAGE("an9l (Init:SetPar)");
#line 1593 "RITA-II.instr"
  mccan9l_zmin = - wan / 2.0;
#line 1593 "RITA-II.instr"
  mccan9l_zmax = wan / 2.0;
#line 1593 "RITA-II.instr"
  mccan9l_ymin = - ana_h / 2.0;
#line 1593 "RITA-II.instr"
  mccan9l_ymax = 0;
#line 65 "RITA-II.instr"
  mccan9l_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan9l_yheight = 0;
#line 1594 "RITA-II.instr"
  mccan9l_mosaich = 40;
#line 1594 "RITA-II.instr"
  mccan9l_mosaicv = 40;
#line 1595 "RITA-II.instr"
  mccan9l_r0 = ana_r0;
#line 1595 "RITA-II.instr"
  mccan9l_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan9l_DM = 0;
#line 26470 "RITA-II.c"

  SIG_MESSAGE("an9l (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1597 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1597 "RITA-II.instr"
    (machine_real . c9)*DEG2RAD,
#line 1597 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26480 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan9l);
  rot_transpose(mcrotaan8u, mctr1);
  rot_mul(mcrotaan9l, mctr1, mcrotran9l);
  mctc1 = coords_set(
#line 1596 "RITA-II.instr"
    0,
#line 1596 "RITA-II.instr"
    0,
#line 1596 "RITA-II.instr"
    4 * ana_d);
#line 26491 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan9l = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan8u, mcposaan9l);
  mcposran9l = rot_apply(mcrotaan9l, mctc1);
  mcDEBUG_COMPONENT("an9l", mcposaan9l, mcrotaan9l)
  mccomp_posa[108] = mcposaan9l;
  mccomp_posr[108] = mcposran9l;
  mcNCounter[108]  = mcPCounter[108] = mcP2Counter[108] = 0;
  mcAbsorbProp[108]= 0;
    /* Component an9u. */
  /* Setting parameters for component an9u. */
  SIG_MESSAGE("an9u (Init:SetPar)");
#line 1604 "RITA-II.instr"
  mccan9u_zmin = - wan / 2.0;
#line 1604 "RITA-II.instr"
  mccan9u_zmax = wan / 2.0;
#line 1604 "RITA-II.instr"
  mccan9u_ymin = 0;
#line 1604 "RITA-II.instr"
  mccan9u_ymax = ana_h / 2.0;
#line 65 "RITA-II.instr"
  mccan9u_zwidth = 0;
#line 65 "RITA-II.instr"
  mccan9u_yheight = 0;
#line 1605 "RITA-II.instr"
  mccan9u_mosaich = 40;
#line 1605 "RITA-II.instr"
  mccan9u_mosaicv = 40;
#line 1606 "RITA-II.instr"
  mccan9u_r0 = ana_r0;
#line 1606 "RITA-II.instr"
  mccan9u_Q = ana_q;
#line 66 "RITA-II.instr"
  mccan9u_DM = 0;
#line 26527 "RITA-II.c"

  SIG_MESSAGE("an9u (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1608 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1608 "RITA-II.instr"
    (machine_real . c9)*DEG2RAD,
#line 1608 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26537 "RITA-II.c"
  rot_mul(mctr1, mcrotafocus_ana, mcrotaan9u);
  rot_transpose(mcrotaan9l, mctr1);
  rot_mul(mcrotaan9u, mctr1, mcrotran9u);
  mctc1 = coords_set(
#line 1607 "RITA-II.instr"
    0,
#line 1607 "RITA-II.instr"
    0,
#line 1607 "RITA-II.instr"
    4 * ana_d);
#line 26548 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaan9u = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan9l, mcposaan9u);
  mcposran9u = rot_apply(mcrotaan9u, mctc1);
  mcDEBUG_COMPONENT("an9u", mcposaan9u, mcrotaan9u)
  mccomp_posa[109] = mcposaan9u;
  mccomp_posr[109] = mcposran9u;
  mcNCounter[109]  = mcPCounter[109] = mcP2Counter[109] = 0;
  mcAbsorbProp[109]= 0;
    /* Component a6. */
  /* Setting parameters for component a6. */
  SIG_MESSAGE("a6 (Init:SetPar)");

  SIG_MESSAGE("a6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1617 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1617 "RITA-II.instr"
    (machine_real . a6)*DEG2RAD,
#line 1617 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26571 "RITA-II.c"
  rot_mul(mctr1, mcrotaa4, mcrotaa6);
  rot_transpose(mcrotaan9u, mctr1);
  rot_mul(mcrotaa6, mctr1, mcrotra6);
  mctc1 = coords_set(
#line 1616 "RITA-II.instr"
    0,
#line 1616 "RITA-II.instr"
    0,
#line 1616 "RITA-II.instr"
    0);
#line 26582 "RITA-II.c"
  rot_transpose(mcrotafocus_ana, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaa6 = coords_add(mcposafocus_ana, mctc2);
  mctc1 = coords_sub(mcposaan9u, mcposaa6);
  mcposra6 = rot_apply(mcrotaa6, mctc1);
  mcDEBUG_COMPONENT("a6", mcposaa6, mcrotaa6)
  mccomp_posa[110] = mcposaa6;
  mccomp_posr[110] = mcposra6;
  mcNCounter[110]  = mcPCounter[110] = mcP2Counter[110] = 0;
  mcAbsorbProp[110]= 0;
    /* Component emon_before_coarse. */
  /* Setting parameters for component emon_before_coarse. */
  SIG_MESSAGE("emon_before_coarse (Init:SetPar)");
#line 1620 "RITA-II.instr"
  if("emon_before_coarse.dat") strncpy(mccemon_before_coarse_filename, "emon_before_coarse.dat" ? "emon_before_coarse.dat" : "", 16384); else mccemon_before_coarse_filename[0]='\0';
#line 1621 "RITA-II.instr"
  mccemon_before_coarse_xmin = -0.01;
#line 1621 "RITA-II.instr"
  mccemon_before_coarse_xmax = 0.01;
#line 1621 "RITA-II.instr"
  mccemon_before_coarse_ymin = -0.15;
#line 1621 "RITA-II.instr"
  mccemon_before_coarse_ymax = 0.15;
#line 54 "RITA-II.instr"
  mccemon_before_coarse_xwidth = 0;
#line 54 "RITA-II.instr"
  mccemon_before_coarse_yheight = 0;
#line 1620 "RITA-II.instr"
  mccemon_before_coarse_Emin = eminf;
#line 1620 "RITA-II.instr"
  mccemon_before_coarse_Emax = emaxf;
#line 1621 "RITA-II.instr"
  mccemon_before_coarse_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_before_coarse_nowritefile = 0;
#line 26618 "RITA-II.c"

  SIG_MESSAGE("emon_before_coarse (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26625 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_before_coarse);
  rot_transpose(mcrotaa6, mctr1);
  rot_mul(mcrotaemon_before_coarse, mctr1, mcrotremon_before_coarse);
  mctc1 = coords_set(
#line 1623 "RITA-II.instr"
    0,
#line 1623 "RITA-II.instr"
    0,
#line 1623 "RITA-II.instr"
    dad - BladeLength -0.02);
#line 26636 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_before_coarse = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaa6, mcposaemon_before_coarse);
  mcposremon_before_coarse = rot_apply(mcrotaemon_before_coarse, mctc1);
  mcDEBUG_COMPONENT("emon_before_coarse", mcposaemon_before_coarse, mcrotaemon_before_coarse)
  mccomp_posa[111] = mcposaemon_before_coarse;
  mccomp_posr[111] = mcposremon_before_coarse;
  mcNCounter[111]  = mcPCounter[111] = mcP2Counter[111] = 0;
  mcAbsorbProp[111]= 0;
    /* Component psd_before_coarse. */
  /* Setting parameters for component psd_before_coarse. */
  SIG_MESSAGE("psd_before_coarse (Init:SetPar)");
#line 1626 "RITA-II.instr"
  if("psd_before_coarse.dat") strncpy(mccpsd_before_coarse_filename, "psd_before_coarse.dat" ? "psd_before_coarse.dat" : "", 16384); else mccpsd_before_coarse_filename[0]='\0';
#line 1627 "RITA-II.instr"
  mccpsd_before_coarse_xmin = -0.15;
#line 1627 "RITA-II.instr"
  mccpsd_before_coarse_xmax = 0.15;
#line 1627 "RITA-II.instr"
  mccpsd_before_coarse_ymin = -0.15;
#line 1627 "RITA-II.instr"
  mccpsd_before_coarse_ymax = 0.15;
#line 50 "RITA-II.instr"
  mccpsd_before_coarse_xwidth = 0;
#line 50 "RITA-II.instr"
  mccpsd_before_coarse_yheight = 0;
#line 1627 "RITA-II.instr"
  mccpsd_before_coarse_restore_neutron = 1;
#line 50 "RITA-II.instr"
  mccpsd_before_coarse_nowritefile = 0;
#line 26668 "RITA-II.c"

  SIG_MESSAGE("psd_before_coarse (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1630 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1630 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1630 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26678 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_before_coarse);
  rot_transpose(mcrotaemon_before_coarse, mctr1);
  rot_mul(mcrotapsd_before_coarse, mctr1, mcrotrpsd_before_coarse);
  mctc1 = coords_set(
#line 1629 "RITA-II.instr"
    0,
#line 1629 "RITA-II.instr"
    0,
#line 1629 "RITA-II.instr"
    dad - BladeLength -0.01);
#line 26689 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_before_coarse = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_before_coarse, mcposapsd_before_coarse);
  mcposrpsd_before_coarse = rot_apply(mcrotapsd_before_coarse, mctc1);
  mcDEBUG_COMPONENT("psd_before_coarse", mcposapsd_before_coarse, mcrotapsd_before_coarse)
  mccomp_posa[112] = mcposapsd_before_coarse;
  mccomp_posr[112] = mcposrpsd_before_coarse;
  mcNCounter[112]  = mcPCounter[112] = mcP2Counter[112] = 0;
  mcAbsorbProp[112]= 0;
    /* Component ArmR1. */
  /* Setting parameters for component ArmR1. */
  SIG_MESSAGE("ArmR1 (Init:SetPar)");

  SIG_MESSAGE("ArmR1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1635 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1635 "RITA-II.instr"
    (- mcipRC / 9)*DEG2RAD,
#line 1635 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26712 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmR1);
  rot_transpose(mcrotapsd_before_coarse, mctr1);
  rot_mul(mcrotaArmR1, mctr1, mcrotrArmR1);
  mctc1 = coords_set(
#line 1634 "RITA-II.instr"
    - WindowSize / 2,
#line 1634 "RITA-II.instr"
    0,
#line 1634 "RITA-II.instr"
    dad -0.005);
#line 26723 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmR1 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_before_coarse, mcposaArmR1);
  mcposrArmR1 = rot_apply(mcrotaArmR1, mctc1);
  mcDEBUG_COMPONENT("ArmR1", mcposaArmR1, mcrotaArmR1)
  mccomp_posa[113] = mcposaArmR1;
  mccomp_posr[113] = mcposrArmR1;
  mcNCounter[113]  = mcPCounter[113] = mcP2Counter[113] = 0;
  mcAbsorbProp[113]= 0;
    /* Component BladeR1. */
  /* Setting parameters for component BladeR1. */
  SIG_MESSAGE("BladeR1 (Init:SetPar)");
#line 1637 "RITA-II.instr"
  mccBladeR1_xmin = - BladeThickness / 2;
#line 1637 "RITA-II.instr"
  mccBladeR1_xmax = BladeThickness / 2;
#line 1638 "RITA-II.instr"
  mccBladeR1_ymin = - BladeHeight / 2;
#line 1638 "RITA-II.instr"
  mccBladeR1_ymax = BladeHeight / 2;
#line 1639 "RITA-II.instr"
  mccBladeR1_zmin = - BladeLength;
#line 1639 "RITA-II.instr"
  mccBladeR1_zmax = 0;
#line 26749 "RITA-II.c"

  SIG_MESSAGE("BladeR1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26756 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmR1, mcrotaBladeR1);
  rot_transpose(mcrotaArmR1, mctr1);
  rot_mul(mcrotaBladeR1, mctr1, mcrotrBladeR1);
  mctc1 = coords_set(
#line 1640 "RITA-II.instr"
    0,
#line 1640 "RITA-II.instr"
    0,
#line 1640 "RITA-II.instr"
    0);
#line 26767 "RITA-II.c"
  rot_transpose(mcrotaArmR1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeR1 = coords_add(mcposaArmR1, mctc2);
  mctc1 = coords_sub(mcposaArmR1, mcposaBladeR1);
  mcposrBladeR1 = rot_apply(mcrotaBladeR1, mctc1);
  mcDEBUG_COMPONENT("BladeR1", mcposaBladeR1, mcrotaBladeR1)
  mccomp_posa[114] = mcposaBladeR1;
  mccomp_posr[114] = mcposrBladeR1;
  mcNCounter[114]  = mcPCounter[114] = mcP2Counter[114] = 0;
  mcAbsorbProp[114]= 0;
    /* Component ArmR2. */
  /* Setting parameters for component ArmR2. */
  SIG_MESSAGE("ArmR2 (Init:SetPar)");

  SIG_MESSAGE("ArmR2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1647 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1647 "RITA-II.instr"
    (-3 * mcipRC / 9)*DEG2RAD,
#line 1647 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26790 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmR2);
  rot_transpose(mcrotaBladeR1, mctr1);
  rot_mul(mcrotaArmR2, mctr1, mcrotrArmR2);
  mctc1 = coords_set(
#line 1646 "RITA-II.instr"
    -3 * WindowSize / 2,
#line 1646 "RITA-II.instr"
    0,
#line 1646 "RITA-II.instr"
    dad -0.005);
#line 26801 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmR2 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeR1, mcposaArmR2);
  mcposrArmR2 = rot_apply(mcrotaArmR2, mctc1);
  mcDEBUG_COMPONENT("ArmR2", mcposaArmR2, mcrotaArmR2)
  mccomp_posa[115] = mcposaArmR2;
  mccomp_posr[115] = mcposrArmR2;
  mcNCounter[115]  = mcPCounter[115] = mcP2Counter[115] = 0;
  mcAbsorbProp[115]= 0;
    /* Component BladeR2. */
  /* Setting parameters for component BladeR2. */
  SIG_MESSAGE("BladeR2 (Init:SetPar)");
#line 1649 "RITA-II.instr"
  mccBladeR2_xmin = - BladeThickness / 2;
#line 1649 "RITA-II.instr"
  mccBladeR2_xmax = BladeThickness / 2;
#line 1650 "RITA-II.instr"
  mccBladeR2_ymin = - BladeHeight / 2;
#line 1650 "RITA-II.instr"
  mccBladeR2_ymax = BladeHeight / 2;
#line 1651 "RITA-II.instr"
  mccBladeR2_zmin = - BladeLength;
#line 1651 "RITA-II.instr"
  mccBladeR2_zmax = 0;
#line 26827 "RITA-II.c"

  SIG_MESSAGE("BladeR2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26834 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmR2, mcrotaBladeR2);
  rot_transpose(mcrotaArmR2, mctr1);
  rot_mul(mcrotaBladeR2, mctr1, mcrotrBladeR2);
  mctc1 = coords_set(
#line 1652 "RITA-II.instr"
    0,
#line 1652 "RITA-II.instr"
    0,
#line 1652 "RITA-II.instr"
    0);
#line 26845 "RITA-II.c"
  rot_transpose(mcrotaArmR2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeR2 = coords_add(mcposaArmR2, mctc2);
  mctc1 = coords_sub(mcposaArmR2, mcposaBladeR2);
  mcposrBladeR2 = rot_apply(mcrotaBladeR2, mctc1);
  mcDEBUG_COMPONENT("BladeR2", mcposaBladeR2, mcrotaBladeR2)
  mccomp_posa[116] = mcposaBladeR2;
  mccomp_posr[116] = mcposrBladeR2;
  mcNCounter[116]  = mcPCounter[116] = mcP2Counter[116] = 0;
  mcAbsorbProp[116]= 0;
    /* Component ArmR3. */
  /* Setting parameters for component ArmR3. */
  SIG_MESSAGE("ArmR3 (Init:SetPar)");

  SIG_MESSAGE("ArmR3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1656 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1656 "RITA-II.instr"
    (-5 * mcipRC / 9)*DEG2RAD,
#line 1656 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26868 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmR3);
  rot_transpose(mcrotaBladeR2, mctr1);
  rot_mul(mcrotaArmR3, mctr1, mcrotrArmR3);
  mctc1 = coords_set(
#line 1655 "RITA-II.instr"
    -5 * WindowSize / 2,
#line 1655 "RITA-II.instr"
    0,
#line 1655 "RITA-II.instr"
    dad -0.005);
#line 26879 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmR3 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeR2, mcposaArmR3);
  mcposrArmR3 = rot_apply(mcrotaArmR3, mctc1);
  mcDEBUG_COMPONENT("ArmR3", mcposaArmR3, mcrotaArmR3)
  mccomp_posa[117] = mcposaArmR3;
  mccomp_posr[117] = mcposrArmR3;
  mcNCounter[117]  = mcPCounter[117] = mcP2Counter[117] = 0;
  mcAbsorbProp[117]= 0;
    /* Component BladeR3. */
  /* Setting parameters for component BladeR3. */
  SIG_MESSAGE("BladeR3 (Init:SetPar)");
#line 1658 "RITA-II.instr"
  mccBladeR3_xmin = - BladeThickness / 2;
#line 1658 "RITA-II.instr"
  mccBladeR3_xmax = BladeThickness / 2;
#line 1659 "RITA-II.instr"
  mccBladeR3_ymin = - BladeHeight / 2;
#line 1659 "RITA-II.instr"
  mccBladeR3_ymax = BladeHeight / 2;
#line 1660 "RITA-II.instr"
  mccBladeR3_zmin = - BladeLength;
#line 1660 "RITA-II.instr"
  mccBladeR3_zmax = 0;
#line 26905 "RITA-II.c"

  SIG_MESSAGE("BladeR3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26912 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmR3, mcrotaBladeR3);
  rot_transpose(mcrotaArmR3, mctr1);
  rot_mul(mcrotaBladeR3, mctr1, mcrotrBladeR3);
  mctc1 = coords_set(
#line 1661 "RITA-II.instr"
    0,
#line 1661 "RITA-II.instr"
    0,
#line 1661 "RITA-II.instr"
    0);
#line 26923 "RITA-II.c"
  rot_transpose(mcrotaArmR3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeR3 = coords_add(mcposaArmR3, mctc2);
  mctc1 = coords_sub(mcposaArmR3, mcposaBladeR3);
  mcposrBladeR3 = rot_apply(mcrotaBladeR3, mctc1);
  mcDEBUG_COMPONENT("BladeR3", mcposaBladeR3, mcrotaBladeR3)
  mccomp_posa[118] = mcposaBladeR3;
  mccomp_posr[118] = mcposrBladeR3;
  mcNCounter[118]  = mcPCounter[118] = mcP2Counter[118] = 0;
  mcAbsorbProp[118]= 0;
    /* Component ArmR4. */
  /* Setting parameters for component ArmR4. */
  SIG_MESSAGE("ArmR4 (Init:SetPar)");

  SIG_MESSAGE("ArmR4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1665 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1665 "RITA-II.instr"
    (-7 * mcipRC / 9)*DEG2RAD,
#line 1665 "RITA-II.instr"
    (0)*DEG2RAD);
#line 26946 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmR4);
  rot_transpose(mcrotaBladeR3, mctr1);
  rot_mul(mcrotaArmR4, mctr1, mcrotrArmR4);
  mctc1 = coords_set(
#line 1664 "RITA-II.instr"
    -7 * WindowSize / 2,
#line 1664 "RITA-II.instr"
    0,
#line 1664 "RITA-II.instr"
    dad -0.005);
#line 26957 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmR4 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeR3, mcposaArmR4);
  mcposrArmR4 = rot_apply(mcrotaArmR4, mctc1);
  mcDEBUG_COMPONENT("ArmR4", mcposaArmR4, mcrotaArmR4)
  mccomp_posa[119] = mcposaArmR4;
  mccomp_posr[119] = mcposrArmR4;
  mcNCounter[119]  = mcPCounter[119] = mcP2Counter[119] = 0;
  mcAbsorbProp[119]= 0;
    /* Component BladeR4. */
  /* Setting parameters for component BladeR4. */
  SIG_MESSAGE("BladeR4 (Init:SetPar)");
#line 1667 "RITA-II.instr"
  mccBladeR4_xmin = - BladeThickness / 2;
#line 1667 "RITA-II.instr"
  mccBladeR4_xmax = BladeThickness / 2;
#line 1668 "RITA-II.instr"
  mccBladeR4_ymin = - BladeHeight / 2;
#line 1668 "RITA-II.instr"
  mccBladeR4_ymax = BladeHeight / 2;
#line 1669 "RITA-II.instr"
  mccBladeR4_zmin = - BladeLength;
#line 1669 "RITA-II.instr"
  mccBladeR4_zmax = 0;
#line 26983 "RITA-II.c"

  SIG_MESSAGE("BladeR4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26990 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmR4, mcrotaBladeR4);
  rot_transpose(mcrotaArmR4, mctr1);
  rot_mul(mcrotaBladeR4, mctr1, mcrotrBladeR4);
  mctc1 = coords_set(
#line 1670 "RITA-II.instr"
    0,
#line 1670 "RITA-II.instr"
    0,
#line 1670 "RITA-II.instr"
    0);
#line 27001 "RITA-II.c"
  rot_transpose(mcrotaArmR4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeR4 = coords_add(mcposaArmR4, mctc2);
  mctc1 = coords_sub(mcposaArmR4, mcposaBladeR4);
  mcposrBladeR4 = rot_apply(mcrotaBladeR4, mctc1);
  mcDEBUG_COMPONENT("BladeR4", mcposaBladeR4, mcrotaBladeR4)
  mccomp_posa[120] = mcposaBladeR4;
  mccomp_posr[120] = mcposrBladeR4;
  mcNCounter[120]  = mcPCounter[120] = mcP2Counter[120] = 0;
  mcAbsorbProp[120]= 0;
    /* Component ArmR5. */
  /* Setting parameters for component ArmR5. */
  SIG_MESSAGE("ArmR5 (Init:SetPar)");

  SIG_MESSAGE("ArmR5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1674 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1674 "RITA-II.instr"
    (-9 * mcipRC / 9)*DEG2RAD,
#line 1674 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27024 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmR5);
  rot_transpose(mcrotaBladeR4, mctr1);
  rot_mul(mcrotaArmR5, mctr1, mcrotrArmR5);
  mctc1 = coords_set(
#line 1673 "RITA-II.instr"
    -9 * WindowSize / 2,
#line 1673 "RITA-II.instr"
    0,
#line 1673 "RITA-II.instr"
    dad -0.005);
#line 27035 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmR5 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeR4, mcposaArmR5);
  mcposrArmR5 = rot_apply(mcrotaArmR5, mctc1);
  mcDEBUG_COMPONENT("ArmR5", mcposaArmR5, mcrotaArmR5)
  mccomp_posa[121] = mcposaArmR5;
  mccomp_posr[121] = mcposrArmR5;
  mcNCounter[121]  = mcPCounter[121] = mcP2Counter[121] = 0;
  mcAbsorbProp[121]= 0;
    /* Component BladeR5. */
  /* Setting parameters for component BladeR5. */
  SIG_MESSAGE("BladeR5 (Init:SetPar)");
#line 1676 "RITA-II.instr"
  mccBladeR5_xmin = - BladeThickness / 2;
#line 1676 "RITA-II.instr"
  mccBladeR5_xmax = BladeThickness / 2;
#line 1677 "RITA-II.instr"
  mccBladeR5_ymin = - BladeHeight / 2;
#line 1677 "RITA-II.instr"
  mccBladeR5_ymax = BladeHeight / 2;
#line 1678 "RITA-II.instr"
  mccBladeR5_zmin = - BladeLength;
#line 1678 "RITA-II.instr"
  mccBladeR5_zmax = 0;
#line 27061 "RITA-II.c"

  SIG_MESSAGE("BladeR5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27068 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmR5, mcrotaBladeR5);
  rot_transpose(mcrotaArmR5, mctr1);
  rot_mul(mcrotaBladeR5, mctr1, mcrotrBladeR5);
  mctc1 = coords_set(
#line 1679 "RITA-II.instr"
    0,
#line 1679 "RITA-II.instr"
    0,
#line 1679 "RITA-II.instr"
    0);
#line 27079 "RITA-II.c"
  rot_transpose(mcrotaArmR5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeR5 = coords_add(mcposaArmR5, mctc2);
  mctc1 = coords_sub(mcposaArmR5, mcposaBladeR5);
  mcposrBladeR5 = rot_apply(mcrotaBladeR5, mctc1);
  mcDEBUG_COMPONENT("BladeR5", mcposaBladeR5, mcrotaBladeR5)
  mccomp_posa[122] = mcposaBladeR5;
  mccomp_posr[122] = mcposrBladeR5;
  mcNCounter[122]  = mcPCounter[122] = mcP2Counter[122] = 0;
  mcAbsorbProp[122]= 0;
    /* Component ArmL1. */
  /* Setting parameters for component ArmL1. */
  SIG_MESSAGE("ArmL1 (Init:SetPar)");

  SIG_MESSAGE("ArmL1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1685 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1685 "RITA-II.instr"
    (mcipLC / 9)*DEG2RAD,
#line 1685 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27102 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmL1);
  rot_transpose(mcrotaBladeR5, mctr1);
  rot_mul(mcrotaArmL1, mctr1, mcrotrArmL1);
  mctc1 = coords_set(
#line 1684 "RITA-II.instr"
    WindowSize / 2,
#line 1684 "RITA-II.instr"
    0,
#line 1684 "RITA-II.instr"
    dad -0.005);
#line 27113 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmL1 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeR5, mcposaArmL1);
  mcposrArmL1 = rot_apply(mcrotaArmL1, mctc1);
  mcDEBUG_COMPONENT("ArmL1", mcposaArmL1, mcrotaArmL1)
  mccomp_posa[123] = mcposaArmL1;
  mccomp_posr[123] = mcposrArmL1;
  mcNCounter[123]  = mcPCounter[123] = mcP2Counter[123] = 0;
  mcAbsorbProp[123]= 0;
    /* Component BladeL1. */
  /* Setting parameters for component BladeL1. */
  SIG_MESSAGE("BladeL1 (Init:SetPar)");
#line 1687 "RITA-II.instr"
  mccBladeL1_xmin = - BladeThickness / 2;
#line 1687 "RITA-II.instr"
  mccBladeL1_xmax = BladeThickness / 2;
#line 1688 "RITA-II.instr"
  mccBladeL1_ymin = - BladeHeight / 2;
#line 1688 "RITA-II.instr"
  mccBladeL1_ymax = BladeHeight / 2;
#line 1689 "RITA-II.instr"
  mccBladeL1_zmin = - BladeLength;
#line 1689 "RITA-II.instr"
  mccBladeL1_zmax = 0;
#line 27139 "RITA-II.c"

  SIG_MESSAGE("BladeL1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27146 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmL1, mcrotaBladeL1);
  rot_transpose(mcrotaArmL1, mctr1);
  rot_mul(mcrotaBladeL1, mctr1, mcrotrBladeL1);
  mctc1 = coords_set(
#line 1690 "RITA-II.instr"
    0,
#line 1690 "RITA-II.instr"
    0,
#line 1690 "RITA-II.instr"
    0);
#line 27157 "RITA-II.c"
  rot_transpose(mcrotaArmL1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeL1 = coords_add(mcposaArmL1, mctc2);
  mctc1 = coords_sub(mcposaArmL1, mcposaBladeL1);
  mcposrBladeL1 = rot_apply(mcrotaBladeL1, mctc1);
  mcDEBUG_COMPONENT("BladeL1", mcposaBladeL1, mcrotaBladeL1)
  mccomp_posa[124] = mcposaBladeL1;
  mccomp_posr[124] = mcposrBladeL1;
  mcNCounter[124]  = mcPCounter[124] = mcP2Counter[124] = 0;
  mcAbsorbProp[124]= 0;
    /* Component ArmL2. */
  /* Setting parameters for component ArmL2. */
  SIG_MESSAGE("ArmL2 (Init:SetPar)");

  SIG_MESSAGE("ArmL2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1695 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1695 "RITA-II.instr"
    (3 * mcipLC / 9)*DEG2RAD,
#line 1695 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27180 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmL2);
  rot_transpose(mcrotaBladeL1, mctr1);
  rot_mul(mcrotaArmL2, mctr1, mcrotrArmL2);
  mctc1 = coords_set(
#line 1694 "RITA-II.instr"
    3 * WindowSize / 2,
#line 1694 "RITA-II.instr"
    0,
#line 1694 "RITA-II.instr"
    dad -0.005);
#line 27191 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmL2 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeL1, mcposaArmL2);
  mcposrArmL2 = rot_apply(mcrotaArmL2, mctc1);
  mcDEBUG_COMPONENT("ArmL2", mcposaArmL2, mcrotaArmL2)
  mccomp_posa[125] = mcposaArmL2;
  mccomp_posr[125] = mcposrArmL2;
  mcNCounter[125]  = mcPCounter[125] = mcP2Counter[125] = 0;
  mcAbsorbProp[125]= 0;
    /* Component BladeL2. */
  /* Setting parameters for component BladeL2. */
  SIG_MESSAGE("BladeL2 (Init:SetPar)");
#line 1697 "RITA-II.instr"
  mccBladeL2_xmin = - BladeThickness / 2;
#line 1697 "RITA-II.instr"
  mccBladeL2_xmax = BladeThickness / 2;
#line 1698 "RITA-II.instr"
  mccBladeL2_ymin = - BladeHeight / 2;
#line 1698 "RITA-II.instr"
  mccBladeL2_ymax = BladeHeight / 2;
#line 1699 "RITA-II.instr"
  mccBladeL2_zmin = - BladeLength;
#line 1699 "RITA-II.instr"
  mccBladeL2_zmax = 0;
#line 27217 "RITA-II.c"

  SIG_MESSAGE("BladeL2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27224 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmL2, mcrotaBladeL2);
  rot_transpose(mcrotaArmL2, mctr1);
  rot_mul(mcrotaBladeL2, mctr1, mcrotrBladeL2);
  mctc1 = coords_set(
#line 1700 "RITA-II.instr"
    0,
#line 1700 "RITA-II.instr"
    0,
#line 1700 "RITA-II.instr"
    0);
#line 27235 "RITA-II.c"
  rot_transpose(mcrotaArmL2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeL2 = coords_add(mcposaArmL2, mctc2);
  mctc1 = coords_sub(mcposaArmL2, mcposaBladeL2);
  mcposrBladeL2 = rot_apply(mcrotaBladeL2, mctc1);
  mcDEBUG_COMPONENT("BladeL2", mcposaBladeL2, mcrotaBladeL2)
  mccomp_posa[126] = mcposaBladeL2;
  mccomp_posr[126] = mcposrBladeL2;
  mcNCounter[126]  = mcPCounter[126] = mcP2Counter[126] = 0;
  mcAbsorbProp[126]= 0;
    /* Component ArmL3. */
  /* Setting parameters for component ArmL3. */
  SIG_MESSAGE("ArmL3 (Init:SetPar)");

  SIG_MESSAGE("ArmL3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1704 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1704 "RITA-II.instr"
    (5 * mcipLC / 9)*DEG2RAD,
#line 1704 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27258 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmL3);
  rot_transpose(mcrotaBladeL2, mctr1);
  rot_mul(mcrotaArmL3, mctr1, mcrotrArmL3);
  mctc1 = coords_set(
#line 1703 "RITA-II.instr"
    5 * WindowSize / 2,
#line 1703 "RITA-II.instr"
    0,
#line 1703 "RITA-II.instr"
    dad -0.005);
#line 27269 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmL3 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeL2, mcposaArmL3);
  mcposrArmL3 = rot_apply(mcrotaArmL3, mctc1);
  mcDEBUG_COMPONENT("ArmL3", mcposaArmL3, mcrotaArmL3)
  mccomp_posa[127] = mcposaArmL3;
  mccomp_posr[127] = mcposrArmL3;
  mcNCounter[127]  = mcPCounter[127] = mcP2Counter[127] = 0;
  mcAbsorbProp[127]= 0;
    /* Component BladeL3. */
  /* Setting parameters for component BladeL3. */
  SIG_MESSAGE("BladeL3 (Init:SetPar)");
#line 1706 "RITA-II.instr"
  mccBladeL3_xmin = - BladeThickness / 2;
#line 1706 "RITA-II.instr"
  mccBladeL3_xmax = BladeThickness / 2;
#line 1707 "RITA-II.instr"
  mccBladeL3_ymin = - BladeHeight / 2;
#line 1707 "RITA-II.instr"
  mccBladeL3_ymax = BladeHeight / 2;
#line 1708 "RITA-II.instr"
  mccBladeL3_zmin = - BladeLength;
#line 1708 "RITA-II.instr"
  mccBladeL3_zmax = 0;
#line 27295 "RITA-II.c"

  SIG_MESSAGE("BladeL3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27302 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmL3, mcrotaBladeL3);
  rot_transpose(mcrotaArmL3, mctr1);
  rot_mul(mcrotaBladeL3, mctr1, mcrotrBladeL3);
  mctc1 = coords_set(
#line 1709 "RITA-II.instr"
    0,
#line 1709 "RITA-II.instr"
    0,
#line 1709 "RITA-II.instr"
    0);
#line 27313 "RITA-II.c"
  rot_transpose(mcrotaArmL3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeL3 = coords_add(mcposaArmL3, mctc2);
  mctc1 = coords_sub(mcposaArmL3, mcposaBladeL3);
  mcposrBladeL3 = rot_apply(mcrotaBladeL3, mctc1);
  mcDEBUG_COMPONENT("BladeL3", mcposaBladeL3, mcrotaBladeL3)
  mccomp_posa[128] = mcposaBladeL3;
  mccomp_posr[128] = mcposrBladeL3;
  mcNCounter[128]  = mcPCounter[128] = mcP2Counter[128] = 0;
  mcAbsorbProp[128]= 0;
    /* Component ArmL4. */
  /* Setting parameters for component ArmL4. */
  SIG_MESSAGE("ArmL4 (Init:SetPar)");

  SIG_MESSAGE("ArmL4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1713 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1713 "RITA-II.instr"
    (7 * mcipLC / 9)*DEG2RAD,
#line 1713 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27336 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmL4);
  rot_transpose(mcrotaBladeL3, mctr1);
  rot_mul(mcrotaArmL4, mctr1, mcrotrArmL4);
  mctc1 = coords_set(
#line 1712 "RITA-II.instr"
    7 * WindowSize / 2,
#line 1712 "RITA-II.instr"
    0,
#line 1712 "RITA-II.instr"
    dad -0.005);
#line 27347 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmL4 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeL3, mcposaArmL4);
  mcposrArmL4 = rot_apply(mcrotaArmL4, mctc1);
  mcDEBUG_COMPONENT("ArmL4", mcposaArmL4, mcrotaArmL4)
  mccomp_posa[129] = mcposaArmL4;
  mccomp_posr[129] = mcposrArmL4;
  mcNCounter[129]  = mcPCounter[129] = mcP2Counter[129] = 0;
  mcAbsorbProp[129]= 0;
    /* Component BladeL4. */
  /* Setting parameters for component BladeL4. */
  SIG_MESSAGE("BladeL4 (Init:SetPar)");
#line 1715 "RITA-II.instr"
  mccBladeL4_xmin = - BladeThickness / 2;
#line 1715 "RITA-II.instr"
  mccBladeL4_xmax = BladeThickness / 2;
#line 1716 "RITA-II.instr"
  mccBladeL4_ymin = - BladeHeight / 2;
#line 1716 "RITA-II.instr"
  mccBladeL4_ymax = BladeHeight / 2;
#line 1717 "RITA-II.instr"
  mccBladeL4_zmin = - BladeLength;
#line 1717 "RITA-II.instr"
  mccBladeL4_zmax = 0;
#line 27373 "RITA-II.c"

  SIG_MESSAGE("BladeL4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27380 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmL4, mcrotaBladeL4);
  rot_transpose(mcrotaArmL4, mctr1);
  rot_mul(mcrotaBladeL4, mctr1, mcrotrBladeL4);
  mctc1 = coords_set(
#line 1718 "RITA-II.instr"
    0,
#line 1718 "RITA-II.instr"
    0,
#line 1718 "RITA-II.instr"
    0);
#line 27391 "RITA-II.c"
  rot_transpose(mcrotaArmL4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeL4 = coords_add(mcposaArmL4, mctc2);
  mctc1 = coords_sub(mcposaArmL4, mcposaBladeL4);
  mcposrBladeL4 = rot_apply(mcrotaBladeL4, mctc1);
  mcDEBUG_COMPONENT("BladeL4", mcposaBladeL4, mcrotaBladeL4)
  mccomp_posa[130] = mcposaBladeL4;
  mccomp_posr[130] = mcposrBladeL4;
  mcNCounter[130]  = mcPCounter[130] = mcP2Counter[130] = 0;
  mcAbsorbProp[130]= 0;
    /* Component ArmL5. */
  /* Setting parameters for component ArmL5. */
  SIG_MESSAGE("ArmL5 (Init:SetPar)");

  SIG_MESSAGE("ArmL5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1722 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1722 "RITA-II.instr"
    (9 * mcipLC / 9)*DEG2RAD,
#line 1722 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27414 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaArmL5);
  rot_transpose(mcrotaBladeL4, mctr1);
  rot_mul(mcrotaArmL5, mctr1, mcrotrArmL5);
  mctc1 = coords_set(
#line 1721 "RITA-II.instr"
    9 * WindowSize / 2,
#line 1721 "RITA-II.instr"
    0,
#line 1721 "RITA-II.instr"
    dad -0.005);
#line 27425 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmL5 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeL4, mcposaArmL5);
  mcposrArmL5 = rot_apply(mcrotaArmL5, mctc1);
  mcDEBUG_COMPONENT("ArmL5", mcposaArmL5, mcrotaArmL5)
  mccomp_posa[131] = mcposaArmL5;
  mccomp_posr[131] = mcposrArmL5;
  mcNCounter[131]  = mcPCounter[131] = mcP2Counter[131] = 0;
  mcAbsorbProp[131]= 0;
    /* Component BladeL5. */
  /* Setting parameters for component BladeL5. */
  SIG_MESSAGE("BladeL5 (Init:SetPar)");
#line 1727 "RITA-II.instr"
  mccBladeL5_xmin = - BladeThickness / 2;
#line 1727 "RITA-II.instr"
  mccBladeL5_xmax = BladeThickness / 2;
#line 1728 "RITA-II.instr"
  mccBladeL5_ymin = - BladeHeight / 2;
#line 1728 "RITA-II.instr"
  mccBladeL5_ymax = BladeHeight / 2;
#line 1729 "RITA-II.instr"
  mccBladeL5_zmin = - BladeLength;
#line 1729 "RITA-II.instr"
  mccBladeL5_zmax = 0;
#line 27451 "RITA-II.c"

  SIG_MESSAGE("BladeL5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27458 "RITA-II.c"
  rot_mul(mctr1, mcrotaArmL5, mcrotaBladeL5);
  rot_transpose(mcrotaArmL5, mctr1);
  rot_mul(mcrotaBladeL5, mctr1, mcrotrBladeL5);
  mctc1 = coords_set(
#line 1730 "RITA-II.instr"
    0,
#line 1730 "RITA-II.instr"
    0,
#line 1730 "RITA-II.instr"
    0);
#line 27469 "RITA-II.c"
  rot_transpose(mcrotaArmL5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBladeL5 = coords_add(mcposaArmL5, mctc2);
  mctc1 = coords_sub(mcposaArmL5, mcposaBladeL5);
  mcposrBladeL5 = rot_apply(mcrotaBladeL5, mctc1);
  mcDEBUG_COMPONENT("BladeL5", mcposaBladeL5, mcrotaBladeL5)
  mccomp_posa[132] = mcposaBladeL5;
  mccomp_posr[132] = mcposrBladeL5;
  mcNCounter[132]  = mcPCounter[132] = mcP2Counter[132] = 0;
  mcAbsorbProp[132]= 0;
    /* Component psd_detector. */
  /* Setting parameters for component psd_detector. */
  SIG_MESSAGE("psd_detector (Init:SetPar)");
#line 1733 "RITA-II.instr"
  mccpsd_detector_xmin = - det_width / 2.0;
#line 1733 "RITA-II.instr"
  mccpsd_detector_xmax = det_width / 2.0;
#line 1733 "RITA-II.instr"
  mccpsd_detector_ymin = - det_height / 2.0;
#line 1734 "RITA-II.instr"
  mccpsd_detector_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_detector_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_detector_yheight = 0;
#line 1734 "RITA-II.instr"
  mccpsd_detector_psf = PSF;
#line 1732 "RITA-II.instr"
  mccpsd_detector_k0 = 1.553;
#line 1732 "RITA-II.instr"
  mccpsd_detector_eff = 0.8;
#line 1734 "RITA-II.instr"
  mccpsd_detector_restore_neutron = 0;
#line 54 "RITA-II.instr"
  mccpsd_detector_nowritefile = 0;
#line 27505 "RITA-II.c"

  SIG_MESSAGE("psd_detector (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1736 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1736 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1736 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27515 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_detector);
  rot_transpose(mcrotaBladeL5, mctr1);
  rot_mul(mcrotapsd_detector, mctr1, mcrotrpsd_detector);
  mctc1 = coords_set(
#line 1735 "RITA-II.instr"
    0,
#line 1735 "RITA-II.instr"
    0,
#line 1735 "RITA-II.instr"
    dad + 0.0215);
#line 27526 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_detector = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaBladeL5, mcposapsd_detector);
  mcposrpsd_detector = rot_apply(mcrotapsd_detector, mctc1);
  mcDEBUG_COMPONENT("psd_detector", mcposapsd_detector, mcrotapsd_detector)
  mccomp_posa[133] = mcposapsd_detector;
  mccomp_posr[133] = mcposrpsd_detector;
  mcNCounter[133]  = mcPCounter[133] = mcP2Counter[133] = 0;
  mcAbsorbProp[133]= 0;
    /* Component emon_detector. */
  /* Setting parameters for component emon_detector. */
  SIG_MESSAGE("emon_detector (Init:SetPar)");
#line 1743 "RITA-II.instr"
  if("detector.dat") strncpy(mccemon_detector_filename, "detector.dat" ? "detector.dat" : "", 16384); else mccemon_detector_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_detector_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_detector_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_detector_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_detector_ymax = 0.05;
#line 1743 "RITA-II.instr"
  mccemon_detector_xwidth = det_width;
#line 1743 "RITA-II.instr"
  mccemon_detector_yheight = det_height;
#line 1743 "RITA-II.instr"
  mccemon_detector_Emin = eminf;
#line 1743 "RITA-II.instr"
  mccemon_detector_Emax = emaxf;
#line 1743 "RITA-II.instr"
  mccemon_detector_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_detector_nowritefile = 0;
#line 27562 "RITA-II.c"

  SIG_MESSAGE("emon_detector (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1745 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1745 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1745 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27572 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_detector);
  rot_transpose(mcrotapsd_detector, mctr1);
  rot_mul(mcrotaemon_detector, mctr1, mcrotremon_detector);
  mctc1 = coords_set(
#line 1744 "RITA-II.instr"
    0,
#line 1744 "RITA-II.instr"
    0,
#line 1744 "RITA-II.instr"
    dad + 0.0215);
#line 27583 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_detector = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_detector, mcposaemon_detector);
  mcposremon_detector = rot_apply(mcrotaemon_detector, mctc1);
  mcDEBUG_COMPONENT("emon_detector", mcposaemon_detector, mcrotaemon_detector)
  mccomp_posa[134] = mcposaemon_detector;
  mccomp_posr[134] = mcposremon_detector;
  mcNCounter[134]  = mcPCounter[134] = mcP2Counter[134] = 0;
  mcAbsorbProp[134]= 0;
    /* Component psd_window1. */
  /* Setting parameters for component psd_window1. */
  SIG_MESSAGE("psd_window1 (Init:SetPar)");
#line 1748 "RITA-II.instr"
  mccpsd_window1_xmin = - det_width / 2.0;
#line 1748 "RITA-II.instr"
  mccpsd_window1_xmax = det_width / 2.0;
#line 1748 "RITA-II.instr"
  mccpsd_window1_ymin = - det_height / 2.0;
#line 1749 "RITA-II.instr"
  mccpsd_window1_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window1_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window1_yheight = 0;
#line 1749 "RITA-II.instr"
  mccpsd_window1_psf = PSF;
#line 1747 "RITA-II.instr"
  mccpsd_window1_k0 = 1.553;
#line 1747 "RITA-II.instr"
  mccpsd_window1_eff = 0.8;
#line 1749 "RITA-II.instr"
  mccpsd_window1_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window1_nowritefile = 0;
#line 27619 "RITA-II.c"

  SIG_MESSAGE("psd_window1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1751 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1751 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1751 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27629 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window1);
  rot_transpose(mcrotaemon_detector, mctr1);
  rot_mul(mcrotapsd_window1, mctr1, mcrotrpsd_window1);
  mctc1 = coords_set(
#line 1750 "RITA-II.instr"
    0,
#line 1750 "RITA-II.instr"
    0,
#line 1750 "RITA-II.instr"
    dad + 0.0215);
#line 27640 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window1 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_detector, mcposapsd_window1);
  mcposrpsd_window1 = rot_apply(mcrotapsd_window1, mctc1);
  mcDEBUG_COMPONENT("psd_window1", mcposapsd_window1, mcrotapsd_window1)
  mccomp_posa[135] = mcposapsd_window1;
  mccomp_posr[135] = mcposrpsd_window1;
  mcNCounter[135]  = mcPCounter[135] = mcP2Counter[135] = 0;
  mcAbsorbProp[135]= 0;
    /* Component emon_window1. */
  /* Setting parameters for component emon_window1. */
  SIG_MESSAGE("emon_window1 (Init:SetPar)");
#line 1754 "RITA-II.instr"
  if("window1.dat") strncpy(mccemon_window1_filename, "window1.dat" ? "window1.dat" : "", 16384); else mccemon_window1_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window1_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window1_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window1_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window1_ymax = 0.05;
#line 1754 "RITA-II.instr"
  mccemon_window1_xwidth = det_width;
#line 1754 "RITA-II.instr"
  mccemon_window1_yheight = det_height;
#line 1754 "RITA-II.instr"
  mccemon_window1_Emin = eminf;
#line 1754 "RITA-II.instr"
  mccemon_window1_Emax = emaxf;
#line 1754 "RITA-II.instr"
  mccemon_window1_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window1_nowritefile = 0;
#line 27676 "RITA-II.c"

  SIG_MESSAGE("emon_window1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1756 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1756 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1756 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27686 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window1);
  rot_transpose(mcrotapsd_window1, mctr1);
  rot_mul(mcrotaemon_window1, mctr1, mcrotremon_window1);
  mctc1 = coords_set(
#line 1755 "RITA-II.instr"
    0,
#line 1755 "RITA-II.instr"
    0,
#line 1755 "RITA-II.instr"
    dad + 0.0215);
#line 27697 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window1 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window1, mcposaemon_window1);
  mcposremon_window1 = rot_apply(mcrotaemon_window1, mctc1);
  mcDEBUG_COMPONENT("emon_window1", mcposaemon_window1, mcrotaemon_window1)
  mccomp_posa[136] = mcposaemon_window1;
  mccomp_posr[136] = mcposremon_window1;
  mcNCounter[136]  = mcPCounter[136] = mcP2Counter[136] = 0;
  mcAbsorbProp[136]= 0;
    /* Component psd_window2. */
  /* Setting parameters for component psd_window2. */
  SIG_MESSAGE("psd_window2 (Init:SetPar)");
#line 1759 "RITA-II.instr"
  mccpsd_window2_xmin = - det_width / 2.0;
#line 1759 "RITA-II.instr"
  mccpsd_window2_xmax = det_width / 2.0;
#line 1759 "RITA-II.instr"
  mccpsd_window2_ymin = - det_height / 2.0;
#line 1760 "RITA-II.instr"
  mccpsd_window2_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window2_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window2_yheight = 0;
#line 1760 "RITA-II.instr"
  mccpsd_window2_psf = PSF;
#line 1758 "RITA-II.instr"
  mccpsd_window2_k0 = 1.553;
#line 1758 "RITA-II.instr"
  mccpsd_window2_eff = 0.8;
#line 1760 "RITA-II.instr"
  mccpsd_window2_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window2_nowritefile = 0;
#line 27733 "RITA-II.c"

  SIG_MESSAGE("psd_window2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1762 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1762 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1762 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27743 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window2);
  rot_transpose(mcrotaemon_window1, mctr1);
  rot_mul(mcrotapsd_window2, mctr1, mcrotrpsd_window2);
  mctc1 = coords_set(
#line 1761 "RITA-II.instr"
    0,
#line 1761 "RITA-II.instr"
    0,
#line 1761 "RITA-II.instr"
    dad + 0.0215);
#line 27754 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window2 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window1, mcposapsd_window2);
  mcposrpsd_window2 = rot_apply(mcrotapsd_window2, mctc1);
  mcDEBUG_COMPONENT("psd_window2", mcposapsd_window2, mcrotapsd_window2)
  mccomp_posa[137] = mcposapsd_window2;
  mccomp_posr[137] = mcposrpsd_window2;
  mcNCounter[137]  = mcPCounter[137] = mcP2Counter[137] = 0;
  mcAbsorbProp[137]= 0;
    /* Component emon_window2. */
  /* Setting parameters for component emon_window2. */
  SIG_MESSAGE("emon_window2 (Init:SetPar)");
#line 1766 "RITA-II.instr"
  if("window2.dat") strncpy(mccemon_window2_filename, "window2.dat" ? "window2.dat" : "", 16384); else mccemon_window2_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window2_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window2_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window2_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window2_ymax = 0.05;
#line 1766 "RITA-II.instr"
  mccemon_window2_xwidth = det_width;
#line 1766 "RITA-II.instr"
  mccemon_window2_yheight = det_height;
#line 1766 "RITA-II.instr"
  mccemon_window2_Emin = eminf;
#line 1766 "RITA-II.instr"
  mccemon_window2_Emax = emaxf;
#line 1766 "RITA-II.instr"
  mccemon_window2_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window2_nowritefile = 0;
#line 27790 "RITA-II.c"

  SIG_MESSAGE("emon_window2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1768 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1768 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1768 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27800 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window2);
  rot_transpose(mcrotapsd_window2, mctr1);
  rot_mul(mcrotaemon_window2, mctr1, mcrotremon_window2);
  mctc1 = coords_set(
#line 1767 "RITA-II.instr"
    0,
#line 1767 "RITA-II.instr"
    0,
#line 1767 "RITA-II.instr"
    dad + 0.0215);
#line 27811 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window2 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window2, mcposaemon_window2);
  mcposremon_window2 = rot_apply(mcrotaemon_window2, mctc1);
  mcDEBUG_COMPONENT("emon_window2", mcposaemon_window2, mcrotaemon_window2)
  mccomp_posa[138] = mcposaemon_window2;
  mccomp_posr[138] = mcposremon_window2;
  mcNCounter[138]  = mcPCounter[138] = mcP2Counter[138] = 0;
  mcAbsorbProp[138]= 0;
    /* Component psd_window3. */
  /* Setting parameters for component psd_window3. */
  SIG_MESSAGE("psd_window3 (Init:SetPar)");
#line 1771 "RITA-II.instr"
  mccpsd_window3_xmin = - det_width / 2.0;
#line 1771 "RITA-II.instr"
  mccpsd_window3_xmax = det_width / 2.0;
#line 1771 "RITA-II.instr"
  mccpsd_window3_ymin = - det_height / 2.0;
#line 1772 "RITA-II.instr"
  mccpsd_window3_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window3_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window3_yheight = 0;
#line 1772 "RITA-II.instr"
  mccpsd_window3_psf = PSF;
#line 1770 "RITA-II.instr"
  mccpsd_window3_k0 = 1.553;
#line 1770 "RITA-II.instr"
  mccpsd_window3_eff = 0.8;
#line 1772 "RITA-II.instr"
  mccpsd_window3_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window3_nowritefile = 0;
#line 27847 "RITA-II.c"

  SIG_MESSAGE("psd_window3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1774 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1774 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1774 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27857 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window3);
  rot_transpose(mcrotaemon_window2, mctr1);
  rot_mul(mcrotapsd_window3, mctr1, mcrotrpsd_window3);
  mctc1 = coords_set(
#line 1773 "RITA-II.instr"
    0,
#line 1773 "RITA-II.instr"
    0,
#line 1773 "RITA-II.instr"
    dad + 0.0215);
#line 27868 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window3 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window2, mcposapsd_window3);
  mcposrpsd_window3 = rot_apply(mcrotapsd_window3, mctc1);
  mcDEBUG_COMPONENT("psd_window3", mcposapsd_window3, mcrotapsd_window3)
  mccomp_posa[139] = mcposapsd_window3;
  mccomp_posr[139] = mcposrpsd_window3;
  mcNCounter[139]  = mcPCounter[139] = mcP2Counter[139] = 0;
  mcAbsorbProp[139]= 0;
    /* Component emon_window3. */
  /* Setting parameters for component emon_window3. */
  SIG_MESSAGE("emon_window3 (Init:SetPar)");
#line 1778 "RITA-II.instr"
  if("window3.dat") strncpy(mccemon_window3_filename, "window3.dat" ? "window3.dat" : "", 16384); else mccemon_window3_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window3_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window3_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window3_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window3_ymax = 0.05;
#line 1778 "RITA-II.instr"
  mccemon_window3_xwidth = det_width;
#line 1778 "RITA-II.instr"
  mccemon_window3_yheight = det_height;
#line 1778 "RITA-II.instr"
  mccemon_window3_Emin = eminf;
#line 1778 "RITA-II.instr"
  mccemon_window3_Emax = emaxf;
#line 1778 "RITA-II.instr"
  mccemon_window3_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window3_nowritefile = 0;
#line 27904 "RITA-II.c"

  SIG_MESSAGE("emon_window3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1780 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1780 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1780 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27914 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window3);
  rot_transpose(mcrotapsd_window3, mctr1);
  rot_mul(mcrotaemon_window3, mctr1, mcrotremon_window3);
  mctc1 = coords_set(
#line 1779 "RITA-II.instr"
    0,
#line 1779 "RITA-II.instr"
    0,
#line 1779 "RITA-II.instr"
    dad + 0.0215 + 0.0008);
#line 27925 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window3 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window3, mcposaemon_window3);
  mcposremon_window3 = rot_apply(mcrotaemon_window3, mctc1);
  mcDEBUG_COMPONENT("emon_window3", mcposaemon_window3, mcrotaemon_window3)
  mccomp_posa[140] = mcposaemon_window3;
  mccomp_posr[140] = mcposremon_window3;
  mcNCounter[140]  = mcPCounter[140] = mcP2Counter[140] = 0;
  mcAbsorbProp[140]= 0;
    /* Component psd_window4. */
  /* Setting parameters for component psd_window4. */
  SIG_MESSAGE("psd_window4 (Init:SetPar)");
#line 1783 "RITA-II.instr"
  mccpsd_window4_xmin = - det_width / 2.0;
#line 1783 "RITA-II.instr"
  mccpsd_window4_xmax = det_width / 2.0;
#line 1783 "RITA-II.instr"
  mccpsd_window4_ymin = - det_height / 2.0;
#line 1784 "RITA-II.instr"
  mccpsd_window4_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window4_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window4_yheight = 0;
#line 1784 "RITA-II.instr"
  mccpsd_window4_psf = PSF;
#line 1782 "RITA-II.instr"
  mccpsd_window4_k0 = 1.553;
#line 1782 "RITA-II.instr"
  mccpsd_window4_eff = 0.8;
#line 1784 "RITA-II.instr"
  mccpsd_window4_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window4_nowritefile = 0;
#line 27961 "RITA-II.c"

  SIG_MESSAGE("psd_window4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1786 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1786 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1786 "RITA-II.instr"
    (0)*DEG2RAD);
#line 27971 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window4);
  rot_transpose(mcrotaemon_window3, mctr1);
  rot_mul(mcrotapsd_window4, mctr1, mcrotrpsd_window4);
  mctc1 = coords_set(
#line 1785 "RITA-II.instr"
    0,
#line 1785 "RITA-II.instr"
    0,
#line 1785 "RITA-II.instr"
    dad + 0.0215);
#line 27982 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window4 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window3, mcposapsd_window4);
  mcposrpsd_window4 = rot_apply(mcrotapsd_window4, mctc1);
  mcDEBUG_COMPONENT("psd_window4", mcposapsd_window4, mcrotapsd_window4)
  mccomp_posa[141] = mcposapsd_window4;
  mccomp_posr[141] = mcposrpsd_window4;
  mcNCounter[141]  = mcPCounter[141] = mcP2Counter[141] = 0;
  mcAbsorbProp[141]= 0;
    /* Component emon_window4. */
  /* Setting parameters for component emon_window4. */
  SIG_MESSAGE("emon_window4 (Init:SetPar)");
#line 1790 "RITA-II.instr"
  if("window4.dat") strncpy(mccemon_window4_filename, "window4.dat" ? "window4.dat" : "", 16384); else mccemon_window4_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window4_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window4_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window4_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window4_ymax = 0.05;
#line 1790 "RITA-II.instr"
  mccemon_window4_xwidth = det_width;
#line 1790 "RITA-II.instr"
  mccemon_window4_yheight = det_height;
#line 1790 "RITA-II.instr"
  mccemon_window4_Emin = eminf;
#line 1790 "RITA-II.instr"
  mccemon_window4_Emax = emaxf;
#line 1790 "RITA-II.instr"
  mccemon_window4_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window4_nowritefile = 0;
#line 28018 "RITA-II.c"

  SIG_MESSAGE("emon_window4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1792 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1792 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1792 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28028 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window4);
  rot_transpose(mcrotapsd_window4, mctr1);
  rot_mul(mcrotaemon_window4, mctr1, mcrotremon_window4);
  mctc1 = coords_set(
#line 1791 "RITA-II.instr"
    0,
#line 1791 "RITA-II.instr"
    0,
#line 1791 "RITA-II.instr"
    dad + 0.0215);
#line 28039 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window4 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window4, mcposaemon_window4);
  mcposremon_window4 = rot_apply(mcrotaemon_window4, mctc1);
  mcDEBUG_COMPONENT("emon_window4", mcposaemon_window4, mcrotaemon_window4)
  mccomp_posa[142] = mcposaemon_window4;
  mccomp_posr[142] = mcposremon_window4;
  mcNCounter[142]  = mcPCounter[142] = mcP2Counter[142] = 0;
  mcAbsorbProp[142]= 0;
    /* Component psd_window5. */
  /* Setting parameters for component psd_window5. */
  SIG_MESSAGE("psd_window5 (Init:SetPar)");
#line 1795 "RITA-II.instr"
  mccpsd_window5_xmin = - det_width / 2.0;
#line 1795 "RITA-II.instr"
  mccpsd_window5_xmax = det_width / 2.0;
#line 1795 "RITA-II.instr"
  mccpsd_window5_ymin = - det_height / 2.0;
#line 1796 "RITA-II.instr"
  mccpsd_window5_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window5_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window5_yheight = 0;
#line 1796 "RITA-II.instr"
  mccpsd_window5_psf = PSF;
#line 1794 "RITA-II.instr"
  mccpsd_window5_k0 = 1.553;
#line 1794 "RITA-II.instr"
  mccpsd_window5_eff = 0.8;
#line 1796 "RITA-II.instr"
  mccpsd_window5_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window5_nowritefile = 0;
#line 28075 "RITA-II.c"

  SIG_MESSAGE("psd_window5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1798 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1798 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1798 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28085 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window5);
  rot_transpose(mcrotaemon_window4, mctr1);
  rot_mul(mcrotapsd_window5, mctr1, mcrotrpsd_window5);
  mctc1 = coords_set(
#line 1797 "RITA-II.instr"
    0,
#line 1797 "RITA-II.instr"
    0,
#line 1797 "RITA-II.instr"
    dad + 0.0215);
#line 28096 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window5 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window4, mcposapsd_window5);
  mcposrpsd_window5 = rot_apply(mcrotapsd_window5, mctc1);
  mcDEBUG_COMPONENT("psd_window5", mcposapsd_window5, mcrotapsd_window5)
  mccomp_posa[143] = mcposapsd_window5;
  mccomp_posr[143] = mcposrpsd_window5;
  mcNCounter[143]  = mcPCounter[143] = mcP2Counter[143] = 0;
  mcAbsorbProp[143]= 0;
    /* Component emon_window5. */
  /* Setting parameters for component emon_window5. */
  SIG_MESSAGE("emon_window5 (Init:SetPar)");
#line 1802 "RITA-II.instr"
  if("window5.dat") strncpy(mccemon_window5_filename, "window5.dat" ? "window5.dat" : "", 16384); else mccemon_window5_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window5_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window5_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window5_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window5_ymax = 0.05;
#line 1802 "RITA-II.instr"
  mccemon_window5_xwidth = det_width;
#line 1802 "RITA-II.instr"
  mccemon_window5_yheight = det_height;
#line 1802 "RITA-II.instr"
  mccemon_window5_Emin = eminf;
#line 1802 "RITA-II.instr"
  mccemon_window5_Emax = emaxf;
#line 1802 "RITA-II.instr"
  mccemon_window5_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window5_nowritefile = 0;
#line 28132 "RITA-II.c"

  SIG_MESSAGE("emon_window5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1804 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1804 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1804 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28142 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window5);
  rot_transpose(mcrotapsd_window5, mctr1);
  rot_mul(mcrotaemon_window5, mctr1, mcrotremon_window5);
  mctc1 = coords_set(
#line 1803 "RITA-II.instr"
    0,
#line 1803 "RITA-II.instr"
    0,
#line 1803 "RITA-II.instr"
    dad + 0.0215);
#line 28153 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window5 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window5, mcposaemon_window5);
  mcposremon_window5 = rot_apply(mcrotaemon_window5, mctc1);
  mcDEBUG_COMPONENT("emon_window5", mcposaemon_window5, mcrotaemon_window5)
  mccomp_posa[144] = mcposaemon_window5;
  mccomp_posr[144] = mcposremon_window5;
  mcNCounter[144]  = mcPCounter[144] = mcP2Counter[144] = 0;
  mcAbsorbProp[144]= 0;
    /* Component psd_window6. */
  /* Setting parameters for component psd_window6. */
  SIG_MESSAGE("psd_window6 (Init:SetPar)");
#line 1808 "RITA-II.instr"
  mccpsd_window6_xmin = - det_width / 2.0;
#line 1808 "RITA-II.instr"
  mccpsd_window6_xmax = det_width / 2.0;
#line 1808 "RITA-II.instr"
  mccpsd_window6_ymin = - det_height / 2.0;
#line 1809 "RITA-II.instr"
  mccpsd_window6_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window6_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window6_yheight = 0;
#line 1809 "RITA-II.instr"
  mccpsd_window6_psf = PSF;
#line 1807 "RITA-II.instr"
  mccpsd_window6_k0 = 1.553;
#line 1807 "RITA-II.instr"
  mccpsd_window6_eff = 0.8;
#line 1809 "RITA-II.instr"
  mccpsd_window6_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window6_nowritefile = 0;
#line 28189 "RITA-II.c"

  SIG_MESSAGE("psd_window6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1811 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1811 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1811 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28199 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window6);
  rot_transpose(mcrotaemon_window5, mctr1);
  rot_mul(mcrotapsd_window6, mctr1, mcrotrpsd_window6);
  mctc1 = coords_set(
#line 1810 "RITA-II.instr"
    0,
#line 1810 "RITA-II.instr"
    0,
#line 1810 "RITA-II.instr"
    dad + 0.0215);
#line 28210 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window6 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window5, mcposapsd_window6);
  mcposrpsd_window6 = rot_apply(mcrotapsd_window6, mctc1);
  mcDEBUG_COMPONENT("psd_window6", mcposapsd_window6, mcrotapsd_window6)
  mccomp_posa[145] = mcposapsd_window6;
  mccomp_posr[145] = mcposrpsd_window6;
  mcNCounter[145]  = mcPCounter[145] = mcP2Counter[145] = 0;
  mcAbsorbProp[145]= 0;
    /* Component emon_window6. */
  /* Setting parameters for component emon_window6. */
  SIG_MESSAGE("emon_window6 (Init:SetPar)");
#line 1815 "RITA-II.instr"
  if("window6.dat") strncpy(mccemon_window6_filename, "window6.dat" ? "window6.dat" : "", 16384); else mccemon_window6_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window6_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window6_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window6_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window6_ymax = 0.05;
#line 1815 "RITA-II.instr"
  mccemon_window6_xwidth = det_width;
#line 1815 "RITA-II.instr"
  mccemon_window6_yheight = det_height;
#line 1815 "RITA-II.instr"
  mccemon_window6_Emin = eminf;
#line 1815 "RITA-II.instr"
  mccemon_window6_Emax = emaxf;
#line 1815 "RITA-II.instr"
  mccemon_window6_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window6_nowritefile = 0;
#line 28246 "RITA-II.c"

  SIG_MESSAGE("emon_window6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1817 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1817 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1817 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28256 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window6);
  rot_transpose(mcrotapsd_window6, mctr1);
  rot_mul(mcrotaemon_window6, mctr1, mcrotremon_window6);
  mctc1 = coords_set(
#line 1816 "RITA-II.instr"
    0,
#line 1816 "RITA-II.instr"
    0,
#line 1816 "RITA-II.instr"
    dad + 0.0215);
#line 28267 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window6 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window6, mcposaemon_window6);
  mcposremon_window6 = rot_apply(mcrotaemon_window6, mctc1);
  mcDEBUG_COMPONENT("emon_window6", mcposaemon_window6, mcrotaemon_window6)
  mccomp_posa[146] = mcposaemon_window6;
  mccomp_posr[146] = mcposremon_window6;
  mcNCounter[146]  = mcPCounter[146] = mcP2Counter[146] = 0;
  mcAbsorbProp[146]= 0;
    /* Component psd_window7. */
  /* Setting parameters for component psd_window7. */
  SIG_MESSAGE("psd_window7 (Init:SetPar)");
#line 1820 "RITA-II.instr"
  mccpsd_window7_xmin = - det_width / 2.0;
#line 1820 "RITA-II.instr"
  mccpsd_window7_xmax = det_width / 2.0;
#line 1820 "RITA-II.instr"
  mccpsd_window7_ymin = - det_height / 2.0;
#line 1821 "RITA-II.instr"
  mccpsd_window7_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window7_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window7_yheight = 0;
#line 1821 "RITA-II.instr"
  mccpsd_window7_psf = PSF;
#line 1819 "RITA-II.instr"
  mccpsd_window7_k0 = 1.553;
#line 1819 "RITA-II.instr"
  mccpsd_window7_eff = 0.8;
#line 1821 "RITA-II.instr"
  mccpsd_window7_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window7_nowritefile = 0;
#line 28303 "RITA-II.c"

  SIG_MESSAGE("psd_window7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1823 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1823 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1823 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28313 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window7);
  rot_transpose(mcrotaemon_window6, mctr1);
  rot_mul(mcrotapsd_window7, mctr1, mcrotrpsd_window7);
  mctc1 = coords_set(
#line 1822 "RITA-II.instr"
    0,
#line 1822 "RITA-II.instr"
    0,
#line 1822 "RITA-II.instr"
    dad + 0.0215);
#line 28324 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window7 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window6, mcposapsd_window7);
  mcposrpsd_window7 = rot_apply(mcrotapsd_window7, mctc1);
  mcDEBUG_COMPONENT("psd_window7", mcposapsd_window7, mcrotapsd_window7)
  mccomp_posa[147] = mcposapsd_window7;
  mccomp_posr[147] = mcposrpsd_window7;
  mcNCounter[147]  = mcPCounter[147] = mcP2Counter[147] = 0;
  mcAbsorbProp[147]= 0;
    /* Component emon_window7. */
  /* Setting parameters for component emon_window7. */
  SIG_MESSAGE("emon_window7 (Init:SetPar)");
#line 1827 "RITA-II.instr"
  if("window7.dat") strncpy(mccemon_window7_filename, "window7.dat" ? "window7.dat" : "", 16384); else mccemon_window7_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window7_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window7_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window7_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window7_ymax = 0.05;
#line 1827 "RITA-II.instr"
  mccemon_window7_xwidth = det_width;
#line 1827 "RITA-II.instr"
  mccemon_window7_yheight = det_height;
#line 1827 "RITA-II.instr"
  mccemon_window7_Emin = eminf;
#line 1827 "RITA-II.instr"
  mccemon_window7_Emax = emaxf;
#line 1827 "RITA-II.instr"
  mccemon_window7_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window7_nowritefile = 0;
#line 28360 "RITA-II.c"

  SIG_MESSAGE("emon_window7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1829 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1829 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1829 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28370 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window7);
  rot_transpose(mcrotapsd_window7, mctr1);
  rot_mul(mcrotaemon_window7, mctr1, mcrotremon_window7);
  mctc1 = coords_set(
#line 1828 "RITA-II.instr"
    0,
#line 1828 "RITA-II.instr"
    0,
#line 1828 "RITA-II.instr"
    dad + 0.0215);
#line 28381 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window7 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window7, mcposaemon_window7);
  mcposremon_window7 = rot_apply(mcrotaemon_window7, mctc1);
  mcDEBUG_COMPONENT("emon_window7", mcposaemon_window7, mcrotaemon_window7)
  mccomp_posa[148] = mcposaemon_window7;
  mccomp_posr[148] = mcposremon_window7;
  mcNCounter[148]  = mcPCounter[148] = mcP2Counter[148] = 0;
  mcAbsorbProp[148]= 0;
    /* Component psd_window8. */
  /* Setting parameters for component psd_window8. */
  SIG_MESSAGE("psd_window8 (Init:SetPar)");
#line 1832 "RITA-II.instr"
  mccpsd_window8_xmin = - det_width / 2.0;
#line 1832 "RITA-II.instr"
  mccpsd_window8_xmax = det_width / 2.0;
#line 1832 "RITA-II.instr"
  mccpsd_window8_ymin = - det_height / 2.0;
#line 1833 "RITA-II.instr"
  mccpsd_window8_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window8_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window8_yheight = 0;
#line 1833 "RITA-II.instr"
  mccpsd_window8_psf = PSF;
#line 1831 "RITA-II.instr"
  mccpsd_window8_k0 = 1.553;
#line 1831 "RITA-II.instr"
  mccpsd_window8_eff = 0.8;
#line 1833 "RITA-II.instr"
  mccpsd_window8_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window8_nowritefile = 0;
#line 28417 "RITA-II.c"

  SIG_MESSAGE("psd_window8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1835 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1835 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1835 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28427 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window8);
  rot_transpose(mcrotaemon_window7, mctr1);
  rot_mul(mcrotapsd_window8, mctr1, mcrotrpsd_window8);
  mctc1 = coords_set(
#line 1834 "RITA-II.instr"
    0,
#line 1834 "RITA-II.instr"
    0,
#line 1834 "RITA-II.instr"
    dad + 0.0215);
#line 28438 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window8 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window7, mcposapsd_window8);
  mcposrpsd_window8 = rot_apply(mcrotapsd_window8, mctc1);
  mcDEBUG_COMPONENT("psd_window8", mcposapsd_window8, mcrotapsd_window8)
  mccomp_posa[149] = mcposapsd_window8;
  mccomp_posr[149] = mcposrpsd_window8;
  mcNCounter[149]  = mcPCounter[149] = mcP2Counter[149] = 0;
  mcAbsorbProp[149]= 0;
    /* Component emon_window8. */
  /* Setting parameters for component emon_window8. */
  SIG_MESSAGE("emon_window8 (Init:SetPar)");
#line 1839 "RITA-II.instr"
  if("window8.dat") strncpy(mccemon_window8_filename, "window8.dat" ? "window8.dat" : "", 16384); else mccemon_window8_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window8_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window8_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window8_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window8_ymax = 0.05;
#line 1839 "RITA-II.instr"
  mccemon_window8_xwidth = det_width;
#line 1839 "RITA-II.instr"
  mccemon_window8_yheight = det_height;
#line 1839 "RITA-II.instr"
  mccemon_window8_Emin = eminf;
#line 1839 "RITA-II.instr"
  mccemon_window8_Emax = emaxf;
#line 1839 "RITA-II.instr"
  mccemon_window8_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window8_nowritefile = 0;
#line 28474 "RITA-II.c"

  SIG_MESSAGE("emon_window8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1841 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1841 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1841 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28484 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window8);
  rot_transpose(mcrotapsd_window8, mctr1);
  rot_mul(mcrotaemon_window8, mctr1, mcrotremon_window8);
  mctc1 = coords_set(
#line 1840 "RITA-II.instr"
    0,
#line 1840 "RITA-II.instr"
    0,
#line 1840 "RITA-II.instr"
    dad + 0.0215);
#line 28495 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window8 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window8, mcposaemon_window8);
  mcposremon_window8 = rot_apply(mcrotaemon_window8, mctc1);
  mcDEBUG_COMPONENT("emon_window8", mcposaemon_window8, mcrotaemon_window8)
  mccomp_posa[150] = mcposaemon_window8;
  mccomp_posr[150] = mcposremon_window8;
  mcNCounter[150]  = mcPCounter[150] = mcP2Counter[150] = 0;
  mcAbsorbProp[150]= 0;
    /* Component psd_window9. */
  /* Setting parameters for component psd_window9. */
  SIG_MESSAGE("psd_window9 (Init:SetPar)");
#line 1844 "RITA-II.instr"
  mccpsd_window9_xmin = - det_width / 2.0;
#line 1844 "RITA-II.instr"
  mccpsd_window9_xmax = det_width / 2.0;
#line 1844 "RITA-II.instr"
  mccpsd_window9_ymin = - det_height / 2.0;
#line 1845 "RITA-II.instr"
  mccpsd_window9_ymax = det_height / 2.0;
#line 54 "RITA-II.instr"
  mccpsd_window9_xwidth = 0;
#line 54 "RITA-II.instr"
  mccpsd_window9_yheight = 0;
#line 1845 "RITA-II.instr"
  mccpsd_window9_psf = PSF;
#line 1843 "RITA-II.instr"
  mccpsd_window9_k0 = 1.553;
#line 1843 "RITA-II.instr"
  mccpsd_window9_eff = 0.8;
#line 1845 "RITA-II.instr"
  mccpsd_window9_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccpsd_window9_nowritefile = 0;
#line 28531 "RITA-II.c"

  SIG_MESSAGE("psd_window9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1847 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1847 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1847 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28541 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotapsd_window9);
  rot_transpose(mcrotaemon_window8, mctr1);
  rot_mul(mcrotapsd_window9, mctr1, mcrotrpsd_window9);
  mctc1 = coords_set(
#line 1846 "RITA-II.instr"
    0,
#line 1846 "RITA-II.instr"
    0,
#line 1846 "RITA-II.instr"
    dad + 0.0215);
#line 28552 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_window9 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposaemon_window8, mcposapsd_window9);
  mcposrpsd_window9 = rot_apply(mcrotapsd_window9, mctc1);
  mcDEBUG_COMPONENT("psd_window9", mcposapsd_window9, mcrotapsd_window9)
  mccomp_posa[151] = mcposapsd_window9;
  mccomp_posr[151] = mcposrpsd_window9;
  mcNCounter[151]  = mcPCounter[151] = mcP2Counter[151] = 0;
  mcAbsorbProp[151]= 0;
    /* Component emon_window9. */
  /* Setting parameters for component emon_window9. */
  SIG_MESSAGE("emon_window9 (Init:SetPar)");
#line 1851 "RITA-II.instr"
  if("window9.dat") strncpy(mccemon_window9_filename, "window9.dat" ? "window9.dat" : "", 16384); else mccemon_window9_filename[0]='\0';
#line 53 "RITA-II.instr"
  mccemon_window9_xmin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window9_xmax = 0.05;
#line 53 "RITA-II.instr"
  mccemon_window9_ymin = -0.05;
#line 53 "RITA-II.instr"
  mccemon_window9_ymax = 0.05;
#line 1851 "RITA-II.instr"
  mccemon_window9_xwidth = det_width;
#line 1851 "RITA-II.instr"
  mccemon_window9_yheight = det_height;
#line 1851 "RITA-II.instr"
  mccemon_window9_Emin = eminf;
#line 1851 "RITA-II.instr"
  mccemon_window9_Emax = emaxf;
#line 1851 "RITA-II.instr"
  mccemon_window9_restore_neutron = 1;
#line 54 "RITA-II.instr"
  mccemon_window9_nowritefile = 0;
#line 28588 "RITA-II.c"

  SIG_MESSAGE("emon_window9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1853 "RITA-II.instr"
    (0)*DEG2RAD,
#line 1853 "RITA-II.instr"
    (180)*DEG2RAD,
#line 1853 "RITA-II.instr"
    (0)*DEG2RAD);
#line 28598 "RITA-II.c"
  rot_mul(mctr1, mcrotaa6, mcrotaemon_window9);
  rot_transpose(mcrotapsd_window9, mctr1);
  rot_mul(mcrotaemon_window9, mctr1, mcrotremon_window9);
  mctc1 = coords_set(
#line 1852 "RITA-II.instr"
    0,
#line 1852 "RITA-II.instr"
    0,
#line 1852 "RITA-II.instr"
    dad + 0.0215);
#line 28609 "RITA-II.c"
  rot_transpose(mcrotaa6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaemon_window9 = coords_add(mcposaa6, mctc2);
  mctc1 = coords_sub(mcposapsd_window9, mcposaemon_window9);
  mcposremon_window9 = rot_apply(mcrotaemon_window9, mctc1);
  mcDEBUG_COMPONENT("emon_window9", mcposaemon_window9, mcrotaemon_window9)
  mccomp_posa[152] = mcposaemon_window9;
  mccomp_posr[152] = mcposremon_window9;
  mcNCounter[152]  = mcPCounter[152] = mcP2Counter[152] = 0;
  mcAbsorbProp[152]= 0;
  /* Component initializations. */
  /* Initializations for component armSource. */
  SIG_MESSAGE("armSource (Init)");
#define mccompcurname  armSource
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccarmSource_IntermediateCnts
#define StartTime mccarmSource_StartTime
#define EndTime mccarmSource_EndTime
#define CurrentTime mccarmSource_CurrentTime
#define profile mccarmSource_profile
#define percent mccarmSource_percent
#define flag_save mccarmSource_flag_save
#define minutes mccarmSource_minutes
#line 57 "/usr/share/mcstas/2.5/misc/Progress_bar.comp"
{
IntermediateCnts=0;
StartTime=0;
EndTime=0;
CurrentTime=0;

fprintf(stdout, "[%s] Initialize\n", mcinstrument_name);
  if (percent*mcget_ncount()/100 < 1e5) {
    percent=1e5*100.0/mcget_ncount();
  }
}
#line 28646 "RITA-II.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component source. */
  SIG_MESSAGE("source (Init)");
#define mccompcurname  source
#define mccompcurtype  Source_gen4
#define mccompcurindex 2
#define flux_file mccsource_flux_file
#define xdiv_file mccsource_xdiv_file
#define ydiv_file mccsource_ydiv_file
#define p_in mccsource_p_in
#define lambda0 mccsource_lambda0
#define lambda02 mccsource_lambda02
#define L2P mccsource_L2P
#define lambda0b mccsource_lambda0b
#define lambda02b mccsource_lambda02b
#define L2Pb mccsource_L2Pb
#define lambda0c mccsource_lambda0c
#define lambda02c mccsource_lambda02c
#define L2Pc mccsource_L2Pc
#define pTable mccsource_pTable
#define pTable_x mccsource_pTable_x
#define pTable_y mccsource_pTable_y
#define radius mccsource_radius
#define dist mccsource_dist
#define xw mccsource_xw
#define yh mccsource_yh
#define E0 mccsource_E0
#define dE mccsource_dE
#define Lambda0 mccsource_Lambda0
#define dLambda mccsource_dLambda
#define I1 mccsource_I1
#define h mccsource_h
#define w mccsource_w
#define gaussian mccsource_gaussian
#define verbose mccsource_verbose
#define T1 mccsource_T1
#define flux_file_perAA mccsource_flux_file_perAA
#define flux_file_log mccsource_flux_file_log
#define Lmin mccsource_Lmin
#define Lmax mccsource_Lmax
#define Emin mccsource_Emin
#define Emax mccsource_Emax
#define T2 mccsource_T2
#define I2 mccsource_I2
#define T3 mccsource_T3
#define I3 mccsource_I3
#define length mccsource_length
#define phi_init mccsource_phi_init
#define theta_init mccsource_theta_init
#define HEtailA mccsource_HEtailA
#define HEtailL0 mccsource_HEtailL0
#line 208 "/usr/share/mcstas/2.5/contrib/Source_gen4.comp"
{
  double source_area, k;

  /* spectrum characteristics */
  if (flux_file && strlen(flux_file) > 0) {
    if (Table_Read(&pTable, flux_file, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr, "Source_gen: %s: can not read file %s\n", NAME_CURRENT_COMP, flux_file));
    /* put table in Log scale */
    int i;
    if (pTable.columns < 2) exit(fprintf(stderr, "Source_gen: %s: Flux file %s should contain at least 2 columns\n", NAME_CURRENT_COMP, flux_file));
    double table_lmin=FLT_MAX, table_lmax=-FLT_MAX;
    double tmin=FLT_MAX, tmax=-FLT_MAX;
    for (i=0; i<pTable.rows; i++) {
      double val = Table_Index(pTable, i,1);
      val = Table_Index(pTable, i,0); /* lambda */
      if (val > tmax) tmax=val;
      if (val < tmin) tmin=val;
    }
    for (i=0; i<pTable.rows; i++) {
      double val = Table_Index(pTable, i,1);
      if (val < 0) fprintf(stderr, "Source_gen: %s: File %s has negative flux at row %i\n", NAME_CURRENT_COMP, flux_file, i+1);
      if (flux_file_log)
        val = log(val > 0 ? val : tmin/10);
      Table_SetElement(&pTable, i, 1, val);
      val = Table_Index(pTable, i,0); /* lambda */
      if (val > table_lmax) table_lmax=val;
      if (val < table_lmin) table_lmin=val;
    }
    if (!Lmin && !Lmax && !Lambda0 && !dLambda && !E0 && !dE && !Emin && !Emax) {
      Lmin = table_lmin; Lmax = table_lmax;
    }
    if (Lmax > table_lmax) {
      if (verbose) fprintf(stderr, "Source_gen: %s: Maximum wavelength %g is beyond table range upper limit %g. Constraining.\n", NAME_CURRENT_COMP, Lmax, table_lmax);
      Lmax = table_lmax;
    }
    if (Lmin < table_lmin) {
      if (verbose) fprintf(stderr, "Source_gen: %s: Minimum wavelength %g is below table range lower limit %g. Constraining.\n", NAME_CURRENT_COMP, Lmin, table_lmin);
      Lmin = table_lmin;
    }
  } else
  {
    k  = 1.38066e-23; /* k_B */
    if (T1 > 0)
    {
      lambda0  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T1);
      lambda02 = lambda0*lambda0;
      L2P      = 2*lambda02*lambda02;
    }
    else
      { lambda0 = Lambda0; }

    if (T2 > 0)
    {
      lambda0b  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T2);
      lambda02b = lambda0b*lambda0b;
      L2Pb      = 2*lambda02b*lambda02b;
    }
    else
      { lambda0b = Lambda0; }

    if (T3 > 0)
    {
      lambda0c  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T3);
      lambda02c = lambda0c*lambda0c;
      L2Pc      = 2*lambda02c*lambda02c;
    }
    else
      { lambda0c = Lambda0; }
  }

  /* now read position-divergence files, if any */
  if (xdiv_file && strlen(xdiv_file) > 0) {
    int i,j;
    if (Table_Read(&pTable_x, xdiv_file, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr, "Source_gen: %s: can not read file %s\n", NAME_CURRENT_COMP, xdiv_file));
    pTable_xsum = 0;
    for (i=0; i<pTable_x.rows; i++)
      for (j=0; j<pTable_x.columns; j++)
        pTable_xsum += Table_Index(pTable_x, i,j);

    /* now extract limits */
    char **parsing;
    char xylimits[1024];
    strcpy(xylimits, "");
    parsing = Table_ParseHeader(pTable_x.header,
      "xlimits", "xylimits",
      NULL);

    if (parsing) {
      if (parsing[0])  strcpy(xylimits, str_dup_numeric(parsing[0]));
      if (parsing[1] && !strlen(xylimits))
                       strcpy(xylimits, str_dup_numeric(parsing[1]));
      for (i=0; i<=1; i++) {
        if (parsing[i]) free(parsing[i]);
      }
      free(parsing);
    }
    i = sscanf(xylimits, "%lg %lg %lg %lg",
      &(pTable_xmin),  &(pTable_xmax),
      &(pTable_dxmin), &(pTable_dxmax));
    if (i != 2 && i != 4 && verbose)
      fprintf(stderr, "Source_gen: %s: invalid xylimits '%s' from file %s. extracted %i values\n",
        NAME_CURRENT_COMP, xylimits, xdiv_file, i);

    if (!w) w=pTable_xmax-pTable_xmin;
    if (!xw && !dist) xw=fabs(pTable_dxmax-pTable_dxmin);
  }

  if (ydiv_file && strlen(ydiv_file) > 0) {
    int i,j;
    if (Table_Read(&pTable_y, ydiv_file, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr, "Source_gen: %s: can not read file %s\n", NAME_CURRENT_COMP, ydiv_file));
    pTable_ysum = 0;
    for (i=0; i<pTable_y.rows; i++)
      for (j=0; j<pTable_y.columns; j++)
        pTable_ysum += Table_Index(pTable_y, i,j);

    /* now extract limits */
    char **parsing;
    char xylimits[1024];
    strcpy(xylimits, "");
    parsing = Table_ParseHeader(pTable_y.header,
      "xlimits", "xylimits",
      NULL);

    if (parsing) {
      if (parsing[0])  strcpy(xylimits,str_dup_numeric(parsing[0]));
      if (parsing[1] && !strlen(xylimits))
                       strcpy(xylimits,str_dup_numeric(parsing[1]));
      for (i=0; i<=1; i++) {
        if (parsing[i]) free(parsing[i]);
      }
      free(parsing);
    }
    i = sscanf(xylimits, "%lg %lg %lg %lg",
      &(pTable_ymin),  &(pTable_ymax),
      &(pTable_dymin), &(pTable_dymax));
    if (i != 2 && i != 4 && verbose)
      fprintf(stderr, "Source_gen: %s: invalid xylimits '%s' from file %s. extracted %i values\n",
        NAME_CURRENT_COMP, xylimits, ydiv_file, i);
    if (!h)  h=pTable_ymax-pTable_ymin;
    if (!yh && !dist) yh=fabs(pTable_dymax-pTable_dymin);
  }

  /* tests for parameter values */
  if (Emin < 0 || Emax < 0 || Lmin < 0 || Lmax < 0 || E0 < 0 || dE < 0 || Lambda0 < 0 || dLambda < 0)
  {
    fprintf(stderr,"Source_gen: %s: Error: Negative average\n"
                   "            or range values for wavelength or energy encountered\n",
                   NAME_CURRENT_COMP);
    exit(-1);
  }
  if ((Emin == 0 && Emax > 0) || (dE > 0 && dE >= E0))
  {
    fprintf(stderr,"Source_gen: %s: Error: minimal energy cannot be less or equal zero\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  if ((Emax >= Emin) && (Emin > 0))
  { E0 = (Emax+Emin)/2;
    dE = (Emax-Emin)/2;
  }
  if ((E0 > dE) && (dE >= 0))
  {
    Lmin = sqrt(81.81/(E0+dE)); /* Angstroem */
    Lmax = sqrt(81.81/(E0-dE));
  }
  if (Lmax > 0)
  { Lambda0 = (Lmax+Lmin)/2;
    dLambda = (Lmax-Lmin)/2;
  }
  if ((Lambda0 < dLambda) || (dLambda < 0))
  { fprintf(stderr,"Source_gen: %s: Error: Wavelength range %.3f +/- %.3f AA calculated \n",
      NAME_CURRENT_COMP, Lambda0, dLambda);
    fprintf(stderr,"- whole wavelength range must be >= 0 \n");
    fprintf(stderr,"- range must be > 0; otherwise intensity gets zero, use other sources in this case \n\n");
    exit(-1);
  }

  radius = fabs(radius); w=fabs(w); h=fabs(h);  I1=fabs(I1);
  Lambda0=fabs(Lambda0); dLambda=fabs(dLambda);
  xw = fabs(xw); yh=fabs(yh); dist=fabs(dist);

  if (dist == 0)
  {
    fprintf(stderr,"Source_gen: %s: warning: focusing distance is null.\n"
                   "            xw and yh interpreted as full divergence in [deg]\n",
                   NAME_CURRENT_COMP);
  }
  Lmin = Lambda0 - dLambda; /* Angstroem */
  Lmax = Lambda0 + dLambda;

  /* compute initial weight factor p_in to get [n/s] */
  if ((I1 > 0  && T1 >= 0) || (flux_file && strlen(flux_file) > 0))
  { /* the I1,2,3 are usually in [n/s/cm2/st/AA] */
    if (radius)
      source_area = radius*radius*PI*1e4; /* circular cm^2 */
    else
      source_area = h*w*1e4; /* square cm^2 */
    p_in  = source_area; /* cm2 */
    p_in *= (Lmax-Lmin); /* AA. 1 bin=AA/n */
    if (flux_file && strlen(flux_file) && !flux_file_perAA)  p_in *= pTable.rows/(Lmax-Lmin);
  }
  else
    p_in = (I1 > 0? I1 : 1)/4/PI; /* Small angle approx. */
  p_in /= mcget_ncount();
  if (!T1 && I1) p_in *= I1;

  if (radius == 0 && h == 0 && w == 0)
  {
    fprintf(stderr,"Source_gen: %s: Error: Please specify source geometry (radius, h, w)\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  if (xw*yh == 0)
  {
    fprintf(stderr,"Source_gen: %s: Error: Please specify source target (xw, yh)\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }

  if (verbose)
  {
    printf("Source_gen: component %s ", NAME_CURRENT_COMP);
    if ((h == 0) || (w == 0))
      printf("(disk, radius=%g)", radius);
    else
      printf("(square %g x %g)",h,w);
    printf("\n            spectra ");
    printf("%.3f to %.3f AA (%.3f to %.3f meV)", Lmin, Lmax, 81.81/Lmax/Lmax, 81.81/Lmin/Lmin);
    if (gaussian)
      printf(", gaussian divergence beam");
    printf("\n");
    if (flux_file && strlen(flux_file) > 0)
    { printf("  File %s for flux distribution used. Flux is dPhi/dLambda in [n/s/AA]. \n", flux_file);
      Table_Info(pTable);
    }
    else if (T1>=0 && I1)
    { if (T1 != 0)
        printf("            T1=%.1f K (%.3f AA)", T1, lambda0);
      if (T2*I2 != 0)
        printf(", T2=%.1f K (%.3f AA)", T2, lambda0b);
      if (T3*I3 != 0)
        printf(", T3=%.1f K (%.3f AA)", T3, lambda0c);
      if (T1) printf("\n");
      printf("  Flux is dPhi/dLambda in [n/s/cm2].\n");
    }
    else
    { printf("  Flux is Phi in [n/s].\n");
    }
    if (xdiv_file && strlen(xdiv_file) > 0)
      printf("  File %s x=[%g:%g] [m] xdiv=[%g:%g] [deg] used as horizontal phase space distribution.\n", xdiv_file, pTable_xmin, pTable_xmax, pTable_dxmin, pTable_dxmax);
    if (ydiv_file && strlen(ydiv_file) > 0)
      printf("  File %s y=[%g:%g] [m] ydiv=[%g:%g] [deg] used as vertical phase space distribution.\n", ydiv_file, pTable_ymin, pTable_ymax, pTable_dymin, pTable_dymax);
  }
  else
    if (verbose == -1)
      printf("Source_gen: component %s unactivated", NAME_CURRENT_COMP);
}
#line 28969 "RITA-II.c"
#undef HEtailL0
#undef HEtailA
#undef theta_init
#undef phi_init
#undef length
#undef I3
#undef T3
#undef I2
#undef T2
#undef Emax
#undef Emin
#undef Lmax
#undef Lmin
#undef flux_file_log
#undef flux_file_perAA
#undef T1
#undef verbose
#undef gaussian
#undef w
#undef h
#undef I1
#undef dLambda
#undef Lambda0
#undef dE
#undef E0
#undef yh
#undef xw
#undef dist
#undef radius
#undef pTable_y
#undef pTable_x
#undef pTable
#undef L2Pc
#undef lambda02c
#undef lambda0c
#undef L2Pb
#undef lambda02b
#undef lambda0b
#undef L2P
#undef lambda02
#undef lambda0
#undef p_in
#undef ydiv_file
#undef xdiv_file
#undef flux_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component slitGuideBegin. */
  SIG_MESSAGE("slitGuideBegin (Init)");
#define mccompcurname  slitGuideBegin
#define mccompcurtype  Slit
#define mccompcurindex 3
#define xmin mccslitGuideBegin_xmin
#define xmax mccslitGuideBegin_xmax
#define ymin mccslitGuideBegin_ymin
#define ymax mccslitGuideBegin_ymax
#define radius mccslitGuideBegin_radius
#define xwidth mccslitGuideBegin_xwidth
#define yheight mccslitGuideBegin_yheight
#line 50 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 29051 "RITA-II.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component lmon_guide_start. */
  SIG_MESSAGE("lmon_guide_start (Init)");
#define mccompcurname  lmon_guide_start
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mcclmon_guide_start_nL
#define L_N mcclmon_guide_start_L_N
#define L_p mcclmon_guide_start_L_p
#define L_p2 mcclmon_guide_start_L_p2
#define filename mcclmon_guide_start_filename
#define xmin mcclmon_guide_start_xmin
#define xmax mcclmon_guide_start_xmax
#define ymin mcclmon_guide_start_ymin
#define ymax mcclmon_guide_start_ymax
#define xwidth mcclmon_guide_start_xwidth
#define yheight mcclmon_guide_start_yheight
#define Lmin mcclmon_guide_start_Lmin
#define Lmax mcclmon_guide_start_Lmax
#define restore_neutron mcclmon_guide_start_restore_neutron
#define nowritefile mcclmon_guide_start_nowritefile
#line 62 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 29104 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideStraight. */
  SIG_MESSAGE("guideStraight (Init)");
#define mccompcurname  guideStraight
#define mccompcurtype  Guide
#define mccompcurindex 5
#define pTable mccguideStraight_pTable
#define reflect mccguideStraight_reflect
#define w1 mccguideStraight_w1
#define h1 mccguideStraight_h1
#define w2 mccguideStraight_w2
#define h2 mccguideStraight_h2
#define l mccguideStraight_l
#define R0 mccguideStraight_R0
#define Qc mccguideStraight_Qc
#define alpha mccguideStraight_alpha
#define m mccguideStraight_m
#define W mccguideStraight_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29160 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved1. */
  SIG_MESSAGE("guideCurved1 (Init)");
#define mccompcurname  guideCurved1
#define mccompcurtype  Guide
#define mccompcurindex 6
#define pTable mccguideCurved1_pTable
#define reflect mccguideCurved1_reflect
#define w1 mccguideCurved1_w1
#define h1 mccguideCurved1_h1
#define w2 mccguideCurved1_w2
#define h2 mccguideCurved1_h2
#define l mccguideCurved1_l
#define R0 mccguideCurved1_R0
#define Qc mccguideCurved1_Qc
#define alpha mccguideCurved1_alpha
#define m mccguideCurved1_m
#define W mccguideCurved1_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29213 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved2. */
  SIG_MESSAGE("guideCurved2 (Init)");
#define mccompcurname  guideCurved2
#define mccompcurtype  Guide
#define mccompcurindex 7
#define pTable mccguideCurved2_pTable
#define reflect mccguideCurved2_reflect
#define w1 mccguideCurved2_w1
#define h1 mccguideCurved2_h1
#define w2 mccguideCurved2_w2
#define h2 mccguideCurved2_h2
#define l mccguideCurved2_l
#define R0 mccguideCurved2_R0
#define Qc mccguideCurved2_Qc
#define alpha mccguideCurved2_alpha
#define m mccguideCurved2_m
#define W mccguideCurved2_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29266 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved3. */
  SIG_MESSAGE("guideCurved3 (Init)");
#define mccompcurname  guideCurved3
#define mccompcurtype  Guide
#define mccompcurindex 8
#define pTable mccguideCurved3_pTable
#define reflect mccguideCurved3_reflect
#define w1 mccguideCurved3_w1
#define h1 mccguideCurved3_h1
#define w2 mccguideCurved3_w2
#define h2 mccguideCurved3_h2
#define l mccguideCurved3_l
#define R0 mccguideCurved3_R0
#define Qc mccguideCurved3_Qc
#define alpha mccguideCurved3_alpha
#define m mccguideCurved3_m
#define W mccguideCurved3_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29319 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved4. */
  SIG_MESSAGE("guideCurved4 (Init)");
#define mccompcurname  guideCurved4
#define mccompcurtype  Guide
#define mccompcurindex 9
#define pTable mccguideCurved4_pTable
#define reflect mccguideCurved4_reflect
#define w1 mccguideCurved4_w1
#define h1 mccguideCurved4_h1
#define w2 mccguideCurved4_w2
#define h2 mccguideCurved4_h2
#define l mccguideCurved4_l
#define R0 mccguideCurved4_R0
#define Qc mccguideCurved4_Qc
#define alpha mccguideCurved4_alpha
#define m mccguideCurved4_m
#define W mccguideCurved4_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29372 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved5. */
  SIG_MESSAGE("guideCurved5 (Init)");
#define mccompcurname  guideCurved5
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccguideCurved5_pTable
#define reflect mccguideCurved5_reflect
#define w1 mccguideCurved5_w1
#define h1 mccguideCurved5_h1
#define w2 mccguideCurved5_w2
#define h2 mccguideCurved5_h2
#define l mccguideCurved5_l
#define R0 mccguideCurved5_R0
#define Qc mccguideCurved5_Qc
#define alpha mccguideCurved5_alpha
#define m mccguideCurved5_m
#define W mccguideCurved5_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29425 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved6. */
  SIG_MESSAGE("guideCurved6 (Init)");
#define mccompcurname  guideCurved6
#define mccompcurtype  Guide
#define mccompcurindex 11
#define pTable mccguideCurved6_pTable
#define reflect mccguideCurved6_reflect
#define w1 mccguideCurved6_w1
#define h1 mccguideCurved6_h1
#define w2 mccguideCurved6_w2
#define h2 mccguideCurved6_h2
#define l mccguideCurved6_l
#define R0 mccguideCurved6_R0
#define Qc mccguideCurved6_Qc
#define alpha mccguideCurved6_alpha
#define m mccguideCurved6_m
#define W mccguideCurved6_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29478 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved7. */
  SIG_MESSAGE("guideCurved7 (Init)");
#define mccompcurname  guideCurved7
#define mccompcurtype  Guide
#define mccompcurindex 12
#define pTable mccguideCurved7_pTable
#define reflect mccguideCurved7_reflect
#define w1 mccguideCurved7_w1
#define h1 mccguideCurved7_h1
#define w2 mccguideCurved7_w2
#define h2 mccguideCurved7_h2
#define l mccguideCurved7_l
#define R0 mccguideCurved7_R0
#define Qc mccguideCurved7_Qc
#define alpha mccguideCurved7_alpha
#define m mccguideCurved7_m
#define W mccguideCurved7_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29531 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved8. */
  SIG_MESSAGE("guideCurved8 (Init)");
#define mccompcurname  guideCurved8
#define mccompcurtype  Guide
#define mccompcurindex 13
#define pTable mccguideCurved8_pTable
#define reflect mccguideCurved8_reflect
#define w1 mccguideCurved8_w1
#define h1 mccguideCurved8_h1
#define w2 mccguideCurved8_w2
#define h2 mccguideCurved8_h2
#define l mccguideCurved8_l
#define R0 mccguideCurved8_R0
#define Qc mccguideCurved8_Qc
#define alpha mccguideCurved8_alpha
#define m mccguideCurved8_m
#define W mccguideCurved8_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29584 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved9. */
  SIG_MESSAGE("guideCurved9 (Init)");
#define mccompcurname  guideCurved9
#define mccompcurtype  Guide
#define mccompcurindex 14
#define pTable mccguideCurved9_pTable
#define reflect mccguideCurved9_reflect
#define w1 mccguideCurved9_w1
#define h1 mccguideCurved9_h1
#define w2 mccguideCurved9_w2
#define h2 mccguideCurved9_h2
#define l mccguideCurved9_l
#define R0 mccguideCurved9_R0
#define Qc mccguideCurved9_Qc
#define alpha mccguideCurved9_alpha
#define m mccguideCurved9_m
#define W mccguideCurved9_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29637 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved10. */
  SIG_MESSAGE("guideCurved10 (Init)");
#define mccompcurname  guideCurved10
#define mccompcurtype  Guide
#define mccompcurindex 15
#define pTable mccguideCurved10_pTable
#define reflect mccguideCurved10_reflect
#define w1 mccguideCurved10_w1
#define h1 mccguideCurved10_h1
#define w2 mccguideCurved10_w2
#define h2 mccguideCurved10_h2
#define l mccguideCurved10_l
#define R0 mccguideCurved10_R0
#define Qc mccguideCurved10_Qc
#define alpha mccguideCurved10_alpha
#define m mccguideCurved10_m
#define W mccguideCurved10_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29690 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved11. */
  SIG_MESSAGE("guideCurved11 (Init)");
#define mccompcurname  guideCurved11
#define mccompcurtype  Guide
#define mccompcurindex 16
#define pTable mccguideCurved11_pTable
#define reflect mccguideCurved11_reflect
#define w1 mccguideCurved11_w1
#define h1 mccguideCurved11_h1
#define w2 mccguideCurved11_w2
#define h2 mccguideCurved11_h2
#define l mccguideCurved11_l
#define R0 mccguideCurved11_R0
#define Qc mccguideCurved11_Qc
#define alpha mccguideCurved11_alpha
#define m mccguideCurved11_m
#define W mccguideCurved11_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29743 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved12. */
  SIG_MESSAGE("guideCurved12 (Init)");
#define mccompcurname  guideCurved12
#define mccompcurtype  Guide
#define mccompcurindex 17
#define pTable mccguideCurved12_pTable
#define reflect mccguideCurved12_reflect
#define w1 mccguideCurved12_w1
#define h1 mccguideCurved12_h1
#define w2 mccguideCurved12_w2
#define h2 mccguideCurved12_h2
#define l mccguideCurved12_l
#define R0 mccguideCurved12_R0
#define Qc mccguideCurved12_Qc
#define alpha mccguideCurved12_alpha
#define m mccguideCurved12_m
#define W mccguideCurved12_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29796 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved13. */
  SIG_MESSAGE("guideCurved13 (Init)");
#define mccompcurname  guideCurved13
#define mccompcurtype  Guide
#define mccompcurindex 18
#define pTable mccguideCurved13_pTable
#define reflect mccguideCurved13_reflect
#define w1 mccguideCurved13_w1
#define h1 mccguideCurved13_h1
#define w2 mccguideCurved13_w2
#define h2 mccguideCurved13_h2
#define l mccguideCurved13_l
#define R0 mccguideCurved13_R0
#define Qc mccguideCurved13_Qc
#define alpha mccguideCurved13_alpha
#define m mccguideCurved13_m
#define W mccguideCurved13_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29849 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved14. */
  SIG_MESSAGE("guideCurved14 (Init)");
#define mccompcurname  guideCurved14
#define mccompcurtype  Guide
#define mccompcurindex 19
#define pTable mccguideCurved14_pTable
#define reflect mccguideCurved14_reflect
#define w1 mccguideCurved14_w1
#define h1 mccguideCurved14_h1
#define w2 mccguideCurved14_w2
#define h2 mccguideCurved14_h2
#define l mccguideCurved14_l
#define R0 mccguideCurved14_R0
#define Qc mccguideCurved14_Qc
#define alpha mccguideCurved14_alpha
#define m mccguideCurved14_m
#define W mccguideCurved14_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29902 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved15. */
  SIG_MESSAGE("guideCurved15 (Init)");
#define mccompcurname  guideCurved15
#define mccompcurtype  Guide
#define mccompcurindex 20
#define pTable mccguideCurved15_pTable
#define reflect mccguideCurved15_reflect
#define w1 mccguideCurved15_w1
#define h1 mccguideCurved15_h1
#define w2 mccguideCurved15_w2
#define h2 mccguideCurved15_h2
#define l mccguideCurved15_l
#define R0 mccguideCurved15_R0
#define Qc mccguideCurved15_Qc
#define alpha mccguideCurved15_alpha
#define m mccguideCurved15_m
#define W mccguideCurved15_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 29955 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved16. */
  SIG_MESSAGE("guideCurved16 (Init)");
#define mccompcurname  guideCurved16
#define mccompcurtype  Guide
#define mccompcurindex 21
#define pTable mccguideCurved16_pTable
#define reflect mccguideCurved16_reflect
#define w1 mccguideCurved16_w1
#define h1 mccguideCurved16_h1
#define w2 mccguideCurved16_w2
#define h2 mccguideCurved16_h2
#define l mccguideCurved16_l
#define R0 mccguideCurved16_R0
#define Qc mccguideCurved16_Qc
#define alpha mccguideCurved16_alpha
#define m mccguideCurved16_m
#define W mccguideCurved16_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30008 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved17. */
  SIG_MESSAGE("guideCurved17 (Init)");
#define mccompcurname  guideCurved17
#define mccompcurtype  Guide
#define mccompcurindex 22
#define pTable mccguideCurved17_pTable
#define reflect mccguideCurved17_reflect
#define w1 mccguideCurved17_w1
#define h1 mccguideCurved17_h1
#define w2 mccguideCurved17_w2
#define h2 mccguideCurved17_h2
#define l mccguideCurved17_l
#define R0 mccguideCurved17_R0
#define Qc mccguideCurved17_Qc
#define alpha mccguideCurved17_alpha
#define m mccguideCurved17_m
#define W mccguideCurved17_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30061 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved18. */
  SIG_MESSAGE("guideCurved18 (Init)");
#define mccompcurname  guideCurved18
#define mccompcurtype  Guide
#define mccompcurindex 23
#define pTable mccguideCurved18_pTable
#define reflect mccguideCurved18_reflect
#define w1 mccguideCurved18_w1
#define h1 mccguideCurved18_h1
#define w2 mccguideCurved18_w2
#define h2 mccguideCurved18_h2
#define l mccguideCurved18_l
#define R0 mccguideCurved18_R0
#define Qc mccguideCurved18_Qc
#define alpha mccguideCurved18_alpha
#define m mccguideCurved18_m
#define W mccguideCurved18_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30114 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved19. */
  SIG_MESSAGE("guideCurved19 (Init)");
#define mccompcurname  guideCurved19
#define mccompcurtype  Guide
#define mccompcurindex 24
#define pTable mccguideCurved19_pTable
#define reflect mccguideCurved19_reflect
#define w1 mccguideCurved19_w1
#define h1 mccguideCurved19_h1
#define w2 mccguideCurved19_w2
#define h2 mccguideCurved19_h2
#define l mccguideCurved19_l
#define R0 mccguideCurved19_R0
#define Qc mccguideCurved19_Qc
#define alpha mccguideCurved19_alpha
#define m mccguideCurved19_m
#define W mccguideCurved19_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30167 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved20. */
  SIG_MESSAGE("guideCurved20 (Init)");
#define mccompcurname  guideCurved20
#define mccompcurtype  Guide
#define mccompcurindex 25
#define pTable mccguideCurved20_pTable
#define reflect mccguideCurved20_reflect
#define w1 mccguideCurved20_w1
#define h1 mccguideCurved20_h1
#define w2 mccguideCurved20_w2
#define h2 mccguideCurved20_h2
#define l mccguideCurved20_l
#define R0 mccguideCurved20_R0
#define Qc mccguideCurved20_Qc
#define alpha mccguideCurved20_alpha
#define m mccguideCurved20_m
#define W mccguideCurved20_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30220 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved21. */
  SIG_MESSAGE("guideCurved21 (Init)");
#define mccompcurname  guideCurved21
#define mccompcurtype  Guide
#define mccompcurindex 26
#define pTable mccguideCurved21_pTable
#define reflect mccguideCurved21_reflect
#define w1 mccguideCurved21_w1
#define h1 mccguideCurved21_h1
#define w2 mccguideCurved21_w2
#define h2 mccguideCurved21_h2
#define l mccguideCurved21_l
#define R0 mccguideCurved21_R0
#define Qc mccguideCurved21_Qc
#define alpha mccguideCurved21_alpha
#define m mccguideCurved21_m
#define W mccguideCurved21_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30273 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved22. */
  SIG_MESSAGE("guideCurved22 (Init)");
#define mccompcurname  guideCurved22
#define mccompcurtype  Guide
#define mccompcurindex 27
#define pTable mccguideCurved22_pTable
#define reflect mccguideCurved22_reflect
#define w1 mccguideCurved22_w1
#define h1 mccguideCurved22_h1
#define w2 mccguideCurved22_w2
#define h2 mccguideCurved22_h2
#define l mccguideCurved22_l
#define R0 mccguideCurved22_R0
#define Qc mccguideCurved22_Qc
#define alpha mccguideCurved22_alpha
#define m mccguideCurved22_m
#define W mccguideCurved22_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30326 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved23. */
  SIG_MESSAGE("guideCurved23 (Init)");
#define mccompcurname  guideCurved23
#define mccompcurtype  Guide
#define mccompcurindex 28
#define pTable mccguideCurved23_pTable
#define reflect mccguideCurved23_reflect
#define w1 mccguideCurved23_w1
#define h1 mccguideCurved23_h1
#define w2 mccguideCurved23_w2
#define h2 mccguideCurved23_h2
#define l mccguideCurved23_l
#define R0 mccguideCurved23_R0
#define Qc mccguideCurved23_Qc
#define alpha mccguideCurved23_alpha
#define m mccguideCurved23_m
#define W mccguideCurved23_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30379 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved24. */
  SIG_MESSAGE("guideCurved24 (Init)");
#define mccompcurname  guideCurved24
#define mccompcurtype  Guide
#define mccompcurindex 29
#define pTable mccguideCurved24_pTable
#define reflect mccguideCurved24_reflect
#define w1 mccguideCurved24_w1
#define h1 mccguideCurved24_h1
#define w2 mccguideCurved24_w2
#define h2 mccguideCurved24_h2
#define l mccguideCurved24_l
#define R0 mccguideCurved24_R0
#define Qc mccguideCurved24_Qc
#define alpha mccguideCurved24_alpha
#define m mccguideCurved24_m
#define W mccguideCurved24_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30432 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved25. */
  SIG_MESSAGE("guideCurved25 (Init)");
#define mccompcurname  guideCurved25
#define mccompcurtype  Guide
#define mccompcurindex 30
#define pTable mccguideCurved25_pTable
#define reflect mccguideCurved25_reflect
#define w1 mccguideCurved25_w1
#define h1 mccguideCurved25_h1
#define w2 mccguideCurved25_w2
#define h2 mccguideCurved25_h2
#define l mccguideCurved25_l
#define R0 mccguideCurved25_R0
#define Qc mccguideCurved25_Qc
#define alpha mccguideCurved25_alpha
#define m mccguideCurved25_m
#define W mccguideCurved25_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30485 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved26. */
  SIG_MESSAGE("guideCurved26 (Init)");
#define mccompcurname  guideCurved26
#define mccompcurtype  Guide
#define mccompcurindex 31
#define pTable mccguideCurved26_pTable
#define reflect mccguideCurved26_reflect
#define w1 mccguideCurved26_w1
#define h1 mccguideCurved26_h1
#define w2 mccguideCurved26_w2
#define h2 mccguideCurved26_h2
#define l mccguideCurved26_l
#define R0 mccguideCurved26_R0
#define Qc mccguideCurved26_Qc
#define alpha mccguideCurved26_alpha
#define m mccguideCurved26_m
#define W mccguideCurved26_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30538 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved27. */
  SIG_MESSAGE("guideCurved27 (Init)");
#define mccompcurname  guideCurved27
#define mccompcurtype  Guide
#define mccompcurindex 32
#define pTable mccguideCurved27_pTable
#define reflect mccguideCurved27_reflect
#define w1 mccguideCurved27_w1
#define h1 mccguideCurved27_h1
#define w2 mccguideCurved27_w2
#define h2 mccguideCurved27_h2
#define l mccguideCurved27_l
#define R0 mccguideCurved27_R0
#define Qc mccguideCurved27_Qc
#define alpha mccguideCurved27_alpha
#define m mccguideCurved27_m
#define W mccguideCurved27_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30591 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved28. */
  SIG_MESSAGE("guideCurved28 (Init)");
#define mccompcurname  guideCurved28
#define mccompcurtype  Guide
#define mccompcurindex 33
#define pTable mccguideCurved28_pTable
#define reflect mccguideCurved28_reflect
#define w1 mccguideCurved28_w1
#define h1 mccguideCurved28_h1
#define w2 mccguideCurved28_w2
#define h2 mccguideCurved28_h2
#define l mccguideCurved28_l
#define R0 mccguideCurved28_R0
#define Qc mccguideCurved28_Qc
#define alpha mccguideCurved28_alpha
#define m mccguideCurved28_m
#define W mccguideCurved28_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30644 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved29. */
  SIG_MESSAGE("guideCurved29 (Init)");
#define mccompcurname  guideCurved29
#define mccompcurtype  Guide
#define mccompcurindex 34
#define pTable mccguideCurved29_pTable
#define reflect mccguideCurved29_reflect
#define w1 mccguideCurved29_w1
#define h1 mccguideCurved29_h1
#define w2 mccguideCurved29_w2
#define h2 mccguideCurved29_h2
#define l mccguideCurved29_l
#define R0 mccguideCurved29_R0
#define Qc mccguideCurved29_Qc
#define alpha mccguideCurved29_alpha
#define m mccguideCurved29_m
#define W mccguideCurved29_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30697 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved30. */
  SIG_MESSAGE("guideCurved30 (Init)");
#define mccompcurname  guideCurved30
#define mccompcurtype  Guide
#define mccompcurindex 35
#define pTable mccguideCurved30_pTable
#define reflect mccguideCurved30_reflect
#define w1 mccguideCurved30_w1
#define h1 mccguideCurved30_h1
#define w2 mccguideCurved30_w2
#define h2 mccguideCurved30_h2
#define l mccguideCurved30_l
#define R0 mccguideCurved30_R0
#define Qc mccguideCurved30_Qc
#define alpha mccguideCurved30_alpha
#define m mccguideCurved30_m
#define W mccguideCurved30_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30750 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved31. */
  SIG_MESSAGE("guideCurved31 (Init)");
#define mccompcurname  guideCurved31
#define mccompcurtype  Guide
#define mccompcurindex 36
#define pTable mccguideCurved31_pTable
#define reflect mccguideCurved31_reflect
#define w1 mccguideCurved31_w1
#define h1 mccguideCurved31_h1
#define w2 mccguideCurved31_w2
#define h2 mccguideCurved31_h2
#define l mccguideCurved31_l
#define R0 mccguideCurved31_R0
#define Qc mccguideCurved31_Qc
#define alpha mccguideCurved31_alpha
#define m mccguideCurved31_m
#define W mccguideCurved31_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30803 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved32. */
  SIG_MESSAGE("guideCurved32 (Init)");
#define mccompcurname  guideCurved32
#define mccompcurtype  Guide
#define mccompcurindex 37
#define pTable mccguideCurved32_pTable
#define reflect mccguideCurved32_reflect
#define w1 mccguideCurved32_w1
#define h1 mccguideCurved32_h1
#define w2 mccguideCurved32_w2
#define h2 mccguideCurved32_h2
#define l mccguideCurved32_l
#define R0 mccguideCurved32_R0
#define Qc mccguideCurved32_Qc
#define alpha mccguideCurved32_alpha
#define m mccguideCurved32_m
#define W mccguideCurved32_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30856 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved33. */
  SIG_MESSAGE("guideCurved33 (Init)");
#define mccompcurname  guideCurved33
#define mccompcurtype  Guide
#define mccompcurindex 38
#define pTable mccguideCurved33_pTable
#define reflect mccguideCurved33_reflect
#define w1 mccguideCurved33_w1
#define h1 mccguideCurved33_h1
#define w2 mccguideCurved33_w2
#define h2 mccguideCurved33_h2
#define l mccguideCurved33_l
#define R0 mccguideCurved33_R0
#define Qc mccguideCurved33_Qc
#define alpha mccguideCurved33_alpha
#define m mccguideCurved33_m
#define W mccguideCurved33_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30909 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved34. */
  SIG_MESSAGE("guideCurved34 (Init)");
#define mccompcurname  guideCurved34
#define mccompcurtype  Guide
#define mccompcurindex 39
#define pTable mccguideCurved34_pTable
#define reflect mccguideCurved34_reflect
#define w1 mccguideCurved34_w1
#define h1 mccguideCurved34_h1
#define w2 mccguideCurved34_w2
#define h2 mccguideCurved34_h2
#define l mccguideCurved34_l
#define R0 mccguideCurved34_R0
#define Qc mccguideCurved34_Qc
#define alpha mccguideCurved34_alpha
#define m mccguideCurved34_m
#define W mccguideCurved34_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 30962 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved35. */
  SIG_MESSAGE("guideCurved35 (Init)");
#define mccompcurname  guideCurved35
#define mccompcurtype  Guide
#define mccompcurindex 40
#define pTable mccguideCurved35_pTable
#define reflect mccguideCurved35_reflect
#define w1 mccguideCurved35_w1
#define h1 mccguideCurved35_h1
#define w2 mccguideCurved35_w2
#define h2 mccguideCurved35_h2
#define l mccguideCurved35_l
#define R0 mccguideCurved35_R0
#define Qc mccguideCurved35_Qc
#define alpha mccguideCurved35_alpha
#define m mccguideCurved35_m
#define W mccguideCurved35_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31015 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved36. */
  SIG_MESSAGE("guideCurved36 (Init)");
#define mccompcurname  guideCurved36
#define mccompcurtype  Guide
#define mccompcurindex 41
#define pTable mccguideCurved36_pTable
#define reflect mccguideCurved36_reflect
#define w1 mccguideCurved36_w1
#define h1 mccguideCurved36_h1
#define w2 mccguideCurved36_w2
#define h2 mccguideCurved36_h2
#define l mccguideCurved36_l
#define R0 mccguideCurved36_R0
#define Qc mccguideCurved36_Qc
#define alpha mccguideCurved36_alpha
#define m mccguideCurved36_m
#define W mccguideCurved36_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31068 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved37. */
  SIG_MESSAGE("guideCurved37 (Init)");
#define mccompcurname  guideCurved37
#define mccompcurtype  Guide
#define mccompcurindex 42
#define pTable mccguideCurved37_pTable
#define reflect mccguideCurved37_reflect
#define w1 mccguideCurved37_w1
#define h1 mccguideCurved37_h1
#define w2 mccguideCurved37_w2
#define h2 mccguideCurved37_h2
#define l mccguideCurved37_l
#define R0 mccguideCurved37_R0
#define Qc mccguideCurved37_Qc
#define alpha mccguideCurved37_alpha
#define m mccguideCurved37_m
#define W mccguideCurved37_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31121 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved38. */
  SIG_MESSAGE("guideCurved38 (Init)");
#define mccompcurname  guideCurved38
#define mccompcurtype  Guide
#define mccompcurindex 43
#define pTable mccguideCurved38_pTable
#define reflect mccguideCurved38_reflect
#define w1 mccguideCurved38_w1
#define h1 mccguideCurved38_h1
#define w2 mccguideCurved38_w2
#define h2 mccguideCurved38_h2
#define l mccguideCurved38_l
#define R0 mccguideCurved38_R0
#define Qc mccguideCurved38_Qc
#define alpha mccguideCurved38_alpha
#define m mccguideCurved38_m
#define W mccguideCurved38_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31174 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved39. */
  SIG_MESSAGE("guideCurved39 (Init)");
#define mccompcurname  guideCurved39
#define mccompcurtype  Guide
#define mccompcurindex 44
#define pTable mccguideCurved39_pTable
#define reflect mccguideCurved39_reflect
#define w1 mccguideCurved39_w1
#define h1 mccguideCurved39_h1
#define w2 mccguideCurved39_w2
#define h2 mccguideCurved39_h2
#define l mccguideCurved39_l
#define R0 mccguideCurved39_R0
#define Qc mccguideCurved39_Qc
#define alpha mccguideCurved39_alpha
#define m mccguideCurved39_m
#define W mccguideCurved39_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31227 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guideCurved40. */
  SIG_MESSAGE("guideCurved40 (Init)");
#define mccompcurname  guideCurved40
#define mccompcurtype  Guide
#define mccompcurindex 45
#define pTable mccguideCurved40_pTable
#define reflect mccguideCurved40_reflect
#define w1 mccguideCurved40_w1
#define h1 mccguideCurved40_h1
#define w2 mccguideCurved40_w2
#define h2 mccguideCurved40_h2
#define l mccguideCurved40_l
#define R0 mccguideCurved40_R0
#define Qc mccguideCurved40_Qc
#define alpha mccguideCurved40_alpha
#define m mccguideCurved40_m
#define W mccguideCurved40_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31280 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component bunker. */
  SIG_MESSAGE("bunker (Init)");
#define mccompcurname  bunker
#define mccompcurtype  Guide
#define mccompcurindex 46
#define pTable mccbunker_pTable
#define reflect mccbunker_reflect
#define w1 mccbunker_w1
#define h1 mccbunker_h1
#define w2 mccbunker_w2
#define h2 mccbunker_h2
#define l mccbunker_l
#define R0 mccbunker_R0
#define Qc mccbunker_Qc
#define alpha mccbunker_alpha
#define m mccbunker_m
#define W mccbunker_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31333 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component guide3. */
  SIG_MESSAGE("guide3 (Init)");
#define mccompcurname  guide3
#define mccompcurtype  Guide
#define mccompcurindex 47
#define pTable mccguide3_pTable
#define reflect mccguide3_reflect
#define w1 mccguide3_w1
#define h1 mccguide3_h1
#define w2 mccguide3_w2
#define h2 mccguide3_h2
#define l mccguide3_l
#define R0 mccguide3_R0
#define Qc mccguide3_Qc
#define alpha mccguide3_alpha
#define m mccguide3_m
#define W mccguide3_W
#line 74 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 31386 "RITA-II.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component slitGuideEnd. */
  SIG_MESSAGE("slitGuideEnd (Init)");
#define mccompcurname  slitGuideEnd
#define mccompcurtype  Slit
#define mccompcurindex 48
#define xmin mccslitGuideEnd_xmin
#define xmax mccslitGuideEnd_xmax
#define ymin mccslitGuideEnd_ymin
#define ymax mccslitGuideEnd_ymax
#define radius mccslitGuideEnd_radius
#define xwidth mccslitGuideEnd_xwidth
#define yheight mccslitGuideEnd_yheight
#line 50 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 31435 "RITA-II.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_guide_end. */
  SIG_MESSAGE("psd_guide_end (Init)");
#define mccompcurname  psd_guide_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccpsd_guide_end_nx
#define ny mccpsd_guide_end_ny
#define PSD_N mccpsd_guide_end_PSD_N
#define PSD_p mccpsd_guide_end_PSD_p
#define PSD_p2 mccpsd_guide_end_PSD_p2
#define filename mccpsd_guide_end_filename
#define xmin mccpsd_guide_end_xmin
#define xmax mccpsd_guide_end_xmax
#define ymin mccpsd_guide_end_ymin
#define ymax mccpsd_guide_end_ymax
#define xwidth mccpsd_guide_end_xwidth
#define yheight mccpsd_guide_end_yheight
#define restore_neutron mccpsd_guide_end_restore_neutron
#define nowritefile mccpsd_guide_end_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 31488 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_guide_end. */
  SIG_MESSAGE("emon_guide_end (Init)");
#define mccompcurname  emon_guide_end
#define mccompcurtype  E_monitor
#define mccompcurindex 50
#define nE mccemon_guide_end_nE
#define E_N mccemon_guide_end_E_N
#define E_p mccemon_guide_end_E_p
#define E_p2 mccemon_guide_end_E_p2
#define S_p mccemon_guide_end_S_p
#define S_pE mccemon_guide_end_S_pE
#define S_pE2 mccemon_guide_end_S_pE2
#define filename mccemon_guide_end_filename
#define xmin mccemon_guide_end_xmin
#define xmax mccemon_guide_end_xmax
#define ymin mccemon_guide_end_ymin
#define ymax mccemon_guide_end_ymax
#define xwidth mccemon_guide_end_xwidth
#define yheight mccemon_guide_end_yheight
#define Emin mccemon_guide_end_Emin
#define Emax mccemon_guide_end_Emax
#define restore_neutron mccemon_guide_end_restore_neutron
#define nowritefile mccemon_guide_end_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 31552 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component lmon_guide_end. */
  SIG_MESSAGE("lmon_guide_end (Init)");
#define mccompcurname  lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mcclmon_guide_end_nL
#define L_N mcclmon_guide_end_L_N
#define L_p mcclmon_guide_end_L_p
#define L_p2 mcclmon_guide_end_L_p2
#define filename mcclmon_guide_end_filename
#define xmin mcclmon_guide_end_xmin
#define xmax mcclmon_guide_end_xmax
#define ymin mcclmon_guide_end_ymin
#define ymax mcclmon_guide_end_ymax
#define xwidth mcclmon_guide_end_xwidth
#define yheight mcclmon_guide_end_yheight
#define Lmin mcclmon_guide_end_Lmin
#define Lmax mcclmon_guide_end_Lmax
#define restore_neutron mcclmon_guide_end_restore_neutron
#define nowritefile mcclmon_guide_end_nowritefile
#line 62 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 31616 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component divmon_guide_end. */
  SIG_MESSAGE("divmon_guide_end (Init)");
#define mccompcurname  divmon_guide_end
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 52
#define nh mccdivmon_guide_end_nh
#define nv mccdivmon_guide_end_nv
#define Div_N mccdivmon_guide_end_Div_N
#define Div_p mccdivmon_guide_end_Div_p
#define Div_p2 mccdivmon_guide_end_Div_p2
#define filename mccdivmon_guide_end_filename
#define xmin mccdivmon_guide_end_xmin
#define xmax mccdivmon_guide_end_xmax
#define ymin mccdivmon_guide_end_ymin
#define ymax mccdivmon_guide_end_ymax
#define xwidth mccdivmon_guide_end_xwidth
#define yheight mccdivmon_guide_end_yheight
#define maxdiv_h mccdivmon_guide_end_maxdiv_h
#define maxdiv_v mccdivmon_guide_end_maxdiv_v
#define restore_neutron mccdivmon_guide_end_restore_neutron
#define nx mccdivmon_guide_end_nx
#define ny mccdivmon_guide_end_ny
#define nz mccdivmon_guide_end_nz
#define nowritefile mccdivmon_guide_end_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Divergence_monitor: %s: Null detection area !\n"
                   "ERROR               (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<nv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 31683 "RITA-II.c"
#undef nowritefile
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component focus_mono. */
  SIG_MESSAGE("focus_mono (Init)");

  /* Initializations for component monochromator_curved. */
  SIG_MESSAGE("monochromator_curved (Init)");
#define mccompcurname  monochromator_curved
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 54
#define mos_rms_y mccmonochromator_curved_mos_rms_y
#define mos_rms_z mccmonochromator_curved_mos_rms_z
#define mos_rms_max mccmonochromator_curved_mos_rms_max
#define mono_Q mccmonochromator_curved_mono_Q
#define SlabWidth mccmonochromator_curved_SlabWidth
#define SlabHeight mccmonochromator_curved_SlabHeight
#define rTable mccmonochromator_curved_rTable
#define tTable mccmonochromator_curved_tTable
#define row mccmonochromator_curved_row
#define col mccmonochromator_curved_col
#define tiltH mccmonochromator_curved_tiltH
#define tiltV mccmonochromator_curved_tiltV
#define reflect mccmonochromator_curved_reflect
#define transmit mccmonochromator_curved_transmit
#define zwidth mccmonochromator_curved_zwidth
#define yheight mccmonochromator_curved_yheight
#define gap mccmonochromator_curved_gap
#define NH mccmonochromator_curved_NH
#define NV mccmonochromator_curved_NV
#define mosaich mccmonochromator_curved_mosaich
#define mosaicv mccmonochromator_curved_mosaicv
#define r0 mccmonochromator_curved_r0
#define t0 mccmonochromator_curved_t0
#define Q mccmonochromator_curved_Q
#define RV mccmonochromator_curved_RV
#define RH mccmonochromator_curved_RH
#define DM mccmonochromator_curved_DM
#define mosaic mccmonochromator_curved_mosaic
#define width mccmonochromator_curved_width
#define height mccmonochromator_curved_height
#define verbose mccmonochromator_curved_verbose
#define order mccmonochromator_curved_order
#line 148 "/usr/share/mcstas/2.5/optics/Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 31828 "RITA-II.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component a2. */
  SIG_MESSAGE("a2 (Init)");

  /* Initializations for component slitShutter. */
  SIG_MESSAGE("slitShutter (Init)");
#define mccompcurname  slitShutter
#define mccompcurtype  Slit
#define mccompcurindex 56
#define xmin mccslitShutter_xmin
#define xmax mccslitShutter_xmax
#define ymin mccslitShutter_ymin
#define ymax mccslitShutter_ymax
#define radius mccslitShutter_radius
#define xwidth mccslitShutter_xwidth
#define yheight mccslitShutter_yheight
#line 50 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 31900 "RITA-II.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component MSCollimator. */
  SIG_MESSAGE("MSCollimator (Init)");
#define mccompcurname  MSCollimator
#define mccompcurtype  Collimator_linear
#define mccompcurindex 57
#define slope mccMSCollimator_slope
#define slopeV mccMSCollimator_slopeV
#define xmin mccMSCollimator_xmin
#define xmax mccMSCollimator_xmax
#define ymin mccMSCollimator_ymin
#define ymax mccMSCollimator_ymax
#define xwidth mccMSCollimator_xwidth
#define yheight mccMSCollimator_yheight
#define length mccMSCollimator_length
#define divergence mccMSCollimator_divergence
#define transmission mccMSCollimator_transmission
#define divergenceV mccMSCollimator_divergenceV
#line 54 "/usr/share/mcstas/2.5/optics/Collimator_linear.comp"
{
slope = tan(MIN2RAD*divergence);
  slopeV= tan(MIN2RAD*divergenceV);
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)) {
    printf("Collimator_linear: %s: Null slit opening area !\n"
	         "ERROR              (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
    exit(0);
  }

}
#line 31944 "RITA-II.c"
#undef divergenceV
#undef transmission
#undef divergence
#undef length
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef slopeV
#undef slope
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component infilter. */
  SIG_MESSAGE("infilter (Init)");
#define mccompcurname  infilter
#define mccompcurtype  Filter_gen
#define mccompcurindex 58
#define pTable mccinfilter_pTable
#define Mode_Table mccinfilter_Mode_Table
#define Type_Table mccinfilter_Type_Table
#define filename mccinfilter_filename
#define options mccinfilter_options
#define xmin mccinfilter_xmin
#define xmax mccinfilter_xmax
#define ymin mccinfilter_ymin
#define ymax mccinfilter_ymax
#define xwidth mccinfilter_xwidth
#define yheight mccinfilter_yheight
#define thickness mccinfilter_thickness
#define scaling mccinfilter_scaling
#define verbose mccinfilter_verbose
#line 126 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  Mode_Table = FLUX_ADAPT_MULT;
  Type_Table = UNKNOWN_TABLE;

  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  FilterGen_Mode(options, &Mode_Table, &Type_Table, &verbose);

  if (filename != NULL && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
  {
    if (Table_Read(&pTable, filename, 1) <= 0) /* read 1st block data from filename into pTable */
      exit(fprintf(stderr,"Filter_gen: %s: can not read filename %s\n", NAME_CURRENT_COMP, filename));

    Table_Rebin(&pTable);         /* rebin as evenly, increasing array */
    if (pTable.rows < 2 || !pTable.step_x) {
      Table_Free(&pTable);
    }
    if (pTable.data)
    {
      FilterGen_Mode(pTable.header, &Mode_Table, &Type_Table, &verbose);
      if (verbose)
      {
        Table_Info(pTable);
        printf("Filter_gen: %s: Filter data [", NAME_CURRENT_COMP);
        if (Type_Table == ENERGY_TABLE) printf("Energy");
        if (Type_Table == WAVEVECTOR_TABLE) printf("Wavevector");
        if (Type_Table == WAVELENGTH_TABLE) printf("Wavelength");
        if (Type_Table == UNKNOWN_TABLE) printf("UNKNOWN (not used)");
        printf(", Flux] in ");
        if (Mode_Table == FLUX_ADAPT_MULT) printf("multiply");
        else if (Mode_Table == FLUX_ADAPT_ADD) printf("add");
        else printf("set");
        printf(" mode\n");
      }
    } else fprintf(stderr,"Filter_gen: %s: file %s contains no data.\n", NAME_CURRENT_COMP, filename);

  } else pTable.data = NULL;
}
#line 32020 "RITA-II.c"
#undef verbose
#undef scaling
#undef thickness
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef options
#undef filename
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_virt. */
  SIG_MESSAGE("psd_virt (Init)");
#define mccompcurname  psd_virt
#define mccompcurtype  PSD_monitor
#define mccompcurindex 59
#define nx mccpsd_virt_nx
#define ny mccpsd_virt_ny
#define PSD_N mccpsd_virt_PSD_N
#define PSD_p mccpsd_virt_PSD_p
#define PSD_p2 mccpsd_virt_PSD_p2
#define filename mccpsd_virt_filename
#define xmin mccpsd_virt_xmin
#define xmax mccpsd_virt_xmax
#define ymin mccpsd_virt_ymin
#define ymax mccpsd_virt_ymax
#define xwidth mccpsd_virt_xwidth
#define yheight mccpsd_virt_yheight
#define restore_neutron mccpsd_virt_restore_neutron
#define nowritefile mccpsd_virt_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 32080 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component lmon_virt. */
  SIG_MESSAGE("lmon_virt (Init)");
#define mccompcurname  lmon_virt
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mcclmon_virt_nL
#define L_N mcclmon_virt_L_N
#define L_p mcclmon_virt_L_p
#define L_p2 mcclmon_virt_L_p2
#define filename mcclmon_virt_filename
#define xmin mcclmon_virt_xmin
#define xmax mcclmon_virt_xmax
#define ymin mcclmon_virt_ymin
#define ymax mcclmon_virt_ymax
#define xwidth mcclmon_virt_xwidth
#define yheight mcclmon_virt_yheight
#define Lmin mcclmon_virt_Lmin
#define Lmax mcclmon_virt_Lmax
#define restore_neutron mcclmon_virt_restore_neutron
#define nowritefile mcclmon_virt_nowritefile
#line 62 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 32140 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component aa2. */
  SIG_MESSAGE("aa2 (Init)");

  /* Initializations for component virtualout. */
  SIG_MESSAGE("virtualout (Init)");
#define mccompcurname  virtualout
#define mccompcurtype  Virtual_output
#define mccompcurindex 62
#define DEFS mccvirtualout_DEFS
#define Vars mccvirtualout_Vars
#define filename mccvirtualout_filename
#define bufsize mccvirtualout_bufsize
#line 78 "/usr/share/mcstas/2.5/sources/Virtual_output.comp"
{
sprintf(type,"text");
  long element_size=85; /* mean size per neutron for ascii storing */

  strcpy(Vars.compcurname, NAME_CURRENT_COMP);

  if (bufsize > 0) sprintf(Vars.option, "list=%g borders", bufsize);
  else strcpy(Vars.option, "list all borders");

  if (type && strlen(type) && strcmp(type, "NULL") && strcmp(type,"0"))
  {
    if (strstr(type, "Vitess"))
    { fprintf(stderr, "Virtual_output: %s: Vitess files may be generated using the Vitess_output component\n", NAME_CURRENT_COMP); exit(-1); }
    if (strstr(type, "binary") || strstr(type, "float")) {
      strcat(Vars.option, ", binary float");
      element_size = sizeof(float);
    } else if (strstr(type, "double")) {
      strcat(Vars.option, ", binary double");
      element_size = sizeof(double);
    }
  }

  strcat(Vars.option,", x y z vx vy vz t sx sy sz");
  Monitor_nD_Init(&DEFS, &Vars, 0.1, 0.1, 0, 0,0,0,0,0,0,0); /* dims for mcdisplay */
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  if (bufsize > 0)
    printf("Warning: Virtual_output: %s: buffer size=%g not recommended\n", NAME_CURRENT_COMP, bufsize);
  if (bufsize > 0) printf(
           "Virtual_output: %s: Beware virtual output generated file size (max %g Mo)\n"
           "WARNING         Memory required is %g Mo\n", NAME_CURRENT_COMP,
           bufsize*element_size/1e6, bufsize*sizeof(double)/1e6);
}
#line 32209 "RITA-II.c"
#undef bufsize
#undef filename
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component virtualsource. */
  SIG_MESSAGE("virtualsource (Init)");
#define mccompcurname  virtualsource
#define mccompcurtype  Virtual_input
#define mccompcurindex 63
#define read_block mccvirtualsource_read_block
#define pos mccvirtualsource_pos
#define nrows mccvirtualsource_nrows
#define Offset mccvirtualsource_Offset
#define rTable mccvirtualsource_rTable
#define repeat_number mccvirtualsource_repeat_number
#define filename_ncount mccvirtualsource_filename_ncount
#define mean_vx mccvirtualsource_mean_vx
#define mean_vy mccvirtualsource_mean_vy
#define mean_vz mccvirtualsource_mean_vz
#define mean_dx mccvirtualsource_mean_dx
#define mean_dy mccvirtualsource_mean_dy
#define mean_dz mccvirtualsource_mean_dz
#define n_neutrons mccvirtualsource_n_neutrons
#define min_x mccvirtualsource_min_x
#define min_y mccvirtualsource_min_y
#define min_z mccvirtualsource_min_z
#define max_x mccvirtualsource_max_x
#define max_y mccvirtualsource_max_y
#define max_z mccvirtualsource_max_z
#define min_vx mccvirtualsource_min_vx
#define min_vy mccvirtualsource_min_vy
#define min_vz mccvirtualsource_min_vz
#define max_vx mccvirtualsource_max_vx
#define max_vy mccvirtualsource_max_vy
#define max_vz mccvirtualsource_max_vz
#define first_block mccvirtualsource_first_block
#define mean_x mccvirtualsource_mean_x
#define mean_y mccvirtualsource_mean_y
#define mean_z mccvirtualsource_mean_z
#define end_reading mccvirtualsource_end_reading
#define n_count_extrapolated mccvirtualsource_n_count_extrapolated
#define repeat_cnt mccvirtualsource_repeat_cnt
#define filename mccvirtualsource_filename
#define verbose mccvirtualsource_verbose
#define repeat_count mccvirtualsource_repeat_count
#define smooth mccvirtualsource_smooth
#define display mccvirtualsource_display
#line 128 "/usr/share/mcstas/2.5/sources/Virtual_input.comp"
{
  repeat_number=1;
  pos=0;
  nrows=0;
  Offset=0;
  filename_ncount=0;
  n_neutrons=0;
  read_block=1;
  first_block=1;
  end_reading=0;
  mean_x=0;
  mean_y=0;
  mean_z=0;
  mean_vx=0;
  mean_vy=0;
  mean_vz=0;
  mean_dx=0;
  mean_dy=0;
  mean_dz=0;
  min_x=FLT_MAX;
  min_y=FLT_MAX;
  min_z=FLT_MAX;
  max_x=-FLT_MAX;
  max_y=-FLT_MAX;
  max_z=-FLT_MAX;
  min_vx=FLT_MAX;
  min_vy=FLT_MAX;
  min_vz=FLT_MAX;
  max_vx=-FLT_MAX;
  max_vy=-FLT_MAX;
  max_vz=-FLT_MAX;
  n_count_extrapolated=0;


  sprintf(type,"text");
  Table_Init(&rTable, 0, 0);

  if (!filename || !repeat_count)
  {
    fprintf(stderr,"Virtual_input: %s: please give me a filename name (filename) to read (repeat_count>0).\n", NAME_CURRENT_COMP);
    exit(-1);
  }

  if (filename && strlen(filename) && strcmp(filename, "NULL") && strcmp(filename,"0") && repeat_count>0) {
    if (type && strstr(type, "Vitess"))
    { fprintf(stderr, "Virtual_input: %s: Vitess files may be read using the Vitess_input component\n", NAME_CURRENT_COMP); exit(-1); }

    if (verbose)
      printf("Virtual_input: %s: Reading neutron events from filename '%s'. Repeat %g time(s)\n", NAME_CURRENT_COMP, filename, repeat_count);

#if defined (USE_MPI)
    if (!smooth && mpi_node_count > 1) {
      if (verbose)
      printf("Virtual_input: %s: smoothing (smooth=1) is recommended when running MPI execution\n", NAME_CURRENT_COMP);
    }
#endif

    double min_dv=fabs(max_vx-min_vx);
    if (min_dv > fabs(max_vy-min_vy)) min_dv = fabs(max_vy-min_vy);
    if (min_dv > fabs(max_vz-min_vz)) min_dv = fabs(max_vz-min_vz);
    min_vx = min_dv;

    if (verbose && smooth)
        printf("* Beam will be smoothed\n");
  } else if (!filename)
    exit(fprintf(stderr,"Virtual_input: %s: please give me a filename name (filename).\n", NAME_CURRENT_COMP));

  repeat_cnt = repeat_count;
#if defined (USE_MPI)
  repeat_cnt = ceil(1.0*repeat_cnt/mpi_node_count);
#endif
}
#line 32334 "RITA-II.c"
#undef display
#undef smooth
#undef repeat_count
#undef verbose
#undef filename
#undef repeat_cnt
#undef n_count_extrapolated
#undef end_reading
#undef mean_z
#undef mean_y
#undef mean_x
#undef first_block
#undef max_vz
#undef max_vy
#undef max_vx
#undef min_vz
#undef min_vy
#undef min_vx
#undef max_z
#undef max_y
#undef max_x
#undef min_z
#undef min_y
#undef min_x
#undef n_neutrons
#undef mean_dz
#undef mean_dy
#undef mean_dx
#undef mean_vz
#undef mean_vy
#undef mean_vx
#undef filename_ncount
#undef repeat_number
#undef rTable
#undef Offset
#undef nrows
#undef pos
#undef read_block
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component OrderMon. */
  SIG_MESSAGE("OrderMon (Init)");
#define mccompcurname  OrderMon
#define mccompcurtype  Monitor_nD
#define mccompcurindex 64
#define user1 mccOrderMon_user1
#define user2 mccOrderMon_user2
#define user3 mccOrderMon_user3
#define DEFS mccOrderMon_DEFS
#define Vars mccOrderMon_Vars
#define detector mccOrderMon_detector
#define offdata mccOrderMon_offdata
#define xwidth mccOrderMon_xwidth
#define yheight mccOrderMon_yheight
#define zdepth mccOrderMon_zdepth
#define xmin mccOrderMon_xmin
#define xmax mccOrderMon_xmax
#define ymin mccOrderMon_ymin
#define ymax mccOrderMon_ymax
#define zmin mccOrderMon_zmin
#define zmax mccOrderMon_zmax
#define bins mccOrderMon_bins
#define min mccOrderMon_min
#define max mccOrderMon_max
#define restore_neutron mccOrderMon_restore_neutron
#define radius mccOrderMon_radius
#define options mccOrderMon_options
#define filename mccOrderMon_filename
#define geometry mccOrderMon_geometry
#define username1 mccOrderMon_username1
#define username2 mccOrderMon_username2
#define username3 mccOrderMon_username3
#define nowritefile mccOrderMon_nowritefile
#line 230 "/usr/share/mcstas/2.5/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 32489 "RITA-II.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component kMoni. */
  SIG_MESSAGE("kMoni (Init)");
#define mccompcurname  kMoni
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 65
#define nx mcckMoni_nx
#define ny mcckMoni_ny
#define filename mcckMoni_filename
#define PSD_N mcckMoni_PSD_N
#define PSD_p mcckMoni_PSD_p
#define PSD_p2 mcckMoni_PSD_p2
#define weight mcckMoni_weight
#define xmin mcckMoni_xmin
#define xmax mcckMoni_xmax
#define ymin mcckMoni_ymin
#define ymax mcckMoni_ymax
#define xwidth mcckMoni_xwidth
#define yheight mcckMoni_yheight
#define psf mcckMoni_psf
#define k0 mcckMoni_k0
#define eff mcckMoni_eff
#define restore_neutron mcckMoni_restore_neutron
#define nowritefile mcckMoni_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 32567 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component kMoni1st. */
  SIG_MESSAGE("kMoni1st (Init)");
#define mccompcurname  kMoni1st
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 66
#define nx mcckMoni1st_nx
#define ny mcckMoni1st_ny
#define filename mcckMoni1st_filename
#define PSD_N mcckMoni1st_PSD_N
#define PSD_p mcckMoni1st_PSD_p
#define PSD_p2 mcckMoni1st_PSD_p2
#define weight mcckMoni1st_weight
#define xmin mcckMoni1st_xmin
#define xmax mcckMoni1st_xmax
#define ymin mcckMoni1st_ymin
#define ymax mcckMoni1st_ymax
#define xwidth mcckMoni1st_xwidth
#define yheight mcckMoni1st_yheight
#define psf mcckMoni1st_psf
#define k0 mcckMoni1st_k0
#define eff mcckMoni1st_eff
#define restore_neutron mcckMoni1st_restore_neutron
#define nowritefile mcckMoni1st_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 32635 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component kMoni2nd. */
  SIG_MESSAGE("kMoni2nd (Init)");
#define mccompcurname  kMoni2nd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 67
#define nx mcckMoni2nd_nx
#define ny mcckMoni2nd_ny
#define filename mcckMoni2nd_filename
#define PSD_N mcckMoni2nd_PSD_N
#define PSD_p mcckMoni2nd_PSD_p
#define PSD_p2 mcckMoni2nd_PSD_p2
#define weight mcckMoni2nd_weight
#define xmin mcckMoni2nd_xmin
#define xmax mcckMoni2nd_xmax
#define ymin mcckMoni2nd_ymin
#define ymax mcckMoni2nd_ymax
#define xwidth mcckMoni2nd_xwidth
#define yheight mcckMoni2nd_yheight
#define psf mcckMoni2nd_psf
#define k0 mcckMoni2nd_k0
#define eff mcckMoni2nd_eff
#define restore_neutron mcckMoni2nd_restore_neutron
#define nowritefile mcckMoni2nd_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 32703 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component kMoni3rd. */
  SIG_MESSAGE("kMoni3rd (Init)");
#define mccompcurname  kMoni3rd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 68
#define nx mcckMoni3rd_nx
#define ny mcckMoni3rd_ny
#define filename mcckMoni3rd_filename
#define PSD_N mcckMoni3rd_PSD_N
#define PSD_p mcckMoni3rd_PSD_p
#define PSD_p2 mcckMoni3rd_PSD_p2
#define weight mcckMoni3rd_weight
#define xmin mcckMoni3rd_xmin
#define xmax mcckMoni3rd_xmax
#define ymin mcckMoni3rd_ymin
#define ymax mcckMoni3rd_ymax
#define xwidth mcckMoni3rd_xwidth
#define yheight mcckMoni3rd_yheight
#define psf mcckMoni3rd_psf
#define k0 mcckMoni3rd_k0
#define eff mcckMoni3rd_eff
#define restore_neutron mcckMoni3rd_restore_neutron
#define nowritefile mcckMoni3rd_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 32771 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component slitMonochromator. */
  SIG_MESSAGE("slitMonochromator (Init)");
#define mccompcurname  slitMonochromator
#define mccompcurtype  Slit
#define mccompcurindex 69
#define xmin mccslitMonochromator_xmin
#define xmax mccslitMonochromator_xmax
#define ymin mccslitMonochromator_ymin
#define ymax mccslitMonochromator_ymax
#define radius mccslitMonochromator_radius
#define xwidth mccslitMonochromator_xwidth
#define yheight mccslitMonochromator_yheight
#line 50 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 32826 "RITA-II.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Perspex. */
  SIG_MESSAGE("Perspex (Init)");
#define mccompcurname  Perspex
#define mccompcurtype  Incoherent
#define mccompcurindex 70
#define VarsInc mccPerspex_VarsInc
#define offdata mccPerspex_offdata
#define geometry mccPerspex_geometry
#define radius mccPerspex_radius
#define xwidth mccPerspex_xwidth
#define yheight mccPerspex_yheight
#define zdepth mccPerspex_zdepth
#define thickness mccPerspex_thickness
#define target_x mccPerspex_target_x
#define target_y mccPerspex_target_y
#define target_z mccPerspex_target_z
#define focus_r mccPerspex_focus_r
#define focus_xw mccPerspex_focus_xw
#define focus_yh mccPerspex_focus_yh
#define focus_aw mccPerspex_focus_aw
#define focus_ah mccPerspex_focus_ah
#define target_index mccPerspex_target_index
#define pack mccPerspex_pack
#define p_interact mccPerspex_p_interact
#define f_QE mccPerspex_f_QE
#define gamma mccPerspex_gamma
#define Etrans mccPerspex_Etrans
#define deltaE mccPerspex_deltaE
#define sigma_abs mccPerspex_sigma_abs
#define sigma_inc mccPerspex_sigma_inc
#define Vc mccPerspex_Vc
#define concentric mccPerspex_concentric
#define order mccPerspex_order
#line 156 "/usr/share/mcstas/2.5/samples/Incoherent.comp"
{
  VarsInc.shape=-1; /* -1:no shape, 0:cyl, 1:box, 2:sphere, 3:any-shape  */
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {
	  if (off_init(geometry, xwidth, yheight, zdepth, 0, &offdata)) {
      VarsInc.shape=3; thickness=0; concentric=0;
    }
  }
  else if (xwidth && yheight && zdepth)  VarsInc.shape=1; /* box */
  else if (radius > 0 &&  yheight)       VarsInc.shape=0; /* cylinder */
  else if (radius > 0 && !yheight)       VarsInc.shape=2; /* sphere */

  if (VarsInc.shape < 0)
    exit(fprintf(stderr,"Incoherent: %s: sample has invalid dimensions.\n"
                        "ERROR       Please check parameter values (xwidth, yheight, zdepth, radius).\n", NAME_CURRENT_COMP));
  if (thickness) {
    if (radius && (radius < thickness || ( yheight && (yheight < 2*thickness)))) {
      fprintf(stderr,"Incoherent: %s: hollow sample thickness is larger than its volume (sphere/cylinder).\n"
                     "WARNING     Please check parameter values. Using bulk sample (thickness=0).\n", NAME_CURRENT_COMP);
      thickness=0;
    }
    else if (!radius && (xwidth < 2*thickness || yheight < 2*thickness || zdepth < 2*thickness)) {
      fprintf(stderr,"Incoherent: %s: hollow sample thickness is larger than its volume (box).\n"
                     "WARNING     Please check parameter values. Using bulk sample (thickness=0).\n", NAME_CURRENT_COMP);
      thickness=0;
    }
  }

  if (concentric && thickness<=0) {
    printf("Incoherent: %s:Can not use concentric mode\n"
           "WARNING     on non hollow shape. Ignoring.\n",
           NAME_CURRENT_COMP);
    concentric=0;
  }

  VarsInc.sigma_a= sigma_abs;
  VarsInc.sigma_i= sigma_inc;
  VarsInc.rho    = (pack/Vc);
  VarsInc.my_s   = (VarsInc.rho * 100 * VarsInc.sigma_i);
  VarsInc.my_a_v = (VarsInc.rho * 100 * VarsInc.sigma_a);

  /* now compute target coords if a component index is supplied */
  VarsInc.tx= VarsInc.ty=VarsInc.tz=0;
  if (!target_index && !target_x && !target_y && !target_z) target_index=1;
  if (target_index)
  {
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &VarsInc.tx, &VarsInc.ty, &VarsInc.tz);
  }
  else
  { VarsInc.tx = target_x; VarsInc.ty = target_y; VarsInc.tz = target_z; }

  if (!(VarsInc.tx || VarsInc.ty || VarsInc.tz)) {
    MPI_MASTER(
    printf("Incoherent: %s: The target is not defined. Using direct beam (Z-axis).\n",
      NAME_CURRENT_COMP);
    );
    VarsInc.tz=1;
  }

  /* different ways of setting rectangular area */
  VarsInc.aw  = VarsInc.ah = 0;
  if (focus_xw) { VarsInc.xw = focus_xw; }
  if (focus_yh) { VarsInc.yh = focus_yh; }
  if (focus_aw) { VarsInc.aw = DEG2RAD*focus_aw; }
  if (focus_ah) { VarsInc.ah = DEG2RAD*focus_ah; }

  MPI_MASTER(
  printf("Incoherent: %s: Vc=%g [Angs] sigma_abs=%g [barn] sigma_inc=%g [barn]\n",
      NAME_CURRENT_COMP, Vc, VarsInc.sigma_a, VarsInc.sigma_i);
  );

}
#line 32946 "RITA-II.c"
#undef order
#undef concentric
#undef Vc
#undef sigma_inc
#undef sigma_abs
#undef deltaE
#undef Etrans
#undef gamma
#undef f_QE
#undef p_interact
#undef pack
#undef target_index
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef focus_r
#undef target_z
#undef target_y
#undef target_x
#undef thickness
#undef zdepth
#undef yheight
#undef xwidth
#undef radius
#undef geometry
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_samplepos_1cm2. */
  SIG_MESSAGE("psd_samplepos_1cm2 (Init)");
#define mccompcurname  psd_samplepos_1cm2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 71
#define nx mccpsd_samplepos_1cm2_nx
#define ny mccpsd_samplepos_1cm2_ny
#define PSD_N mccpsd_samplepos_1cm2_PSD_N
#define PSD_p mccpsd_samplepos_1cm2_PSD_p
#define PSD_p2 mccpsd_samplepos_1cm2_PSD_p2
#define filename mccpsd_samplepos_1cm2_filename
#define xmin mccpsd_samplepos_1cm2_xmin
#define xmax mccpsd_samplepos_1cm2_xmax
#define ymin mccpsd_samplepos_1cm2_ymin
#define ymax mccpsd_samplepos_1cm2_ymax
#define xwidth mccpsd_samplepos_1cm2_xwidth
#define yheight mccpsd_samplepos_1cm2_yheight
#define restore_neutron mccpsd_samplepos_1cm2_restore_neutron
#define nowritefile mccpsd_samplepos_1cm2_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 33020 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_samplepos_1cm2. */
  SIG_MESSAGE("emon_samplepos_1cm2 (Init)");
#define mccompcurname  emon_samplepos_1cm2
#define mccompcurtype  E_monitor
#define mccompcurindex 72
#define nE mccemon_samplepos_1cm2_nE
#define E_N mccemon_samplepos_1cm2_E_N
#define E_p mccemon_samplepos_1cm2_E_p
#define E_p2 mccemon_samplepos_1cm2_E_p2
#define S_p mccemon_samplepos_1cm2_S_p
#define S_pE mccemon_samplepos_1cm2_S_pE
#define S_pE2 mccemon_samplepos_1cm2_S_pE2
#define filename mccemon_samplepos_1cm2_filename
#define xmin mccemon_samplepos_1cm2_xmin
#define xmax mccemon_samplepos_1cm2_xmax
#define ymin mccemon_samplepos_1cm2_ymin
#define ymax mccemon_samplepos_1cm2_ymax
#define xwidth mccemon_samplepos_1cm2_xwidth
#define yheight mccemon_samplepos_1cm2_yheight
#define Emin mccemon_samplepos_1cm2_Emin
#define Emax mccemon_samplepos_1cm2_Emax
#define restore_neutron mccemon_samplepos_1cm2_restore_neutron
#define nowritefile mccemon_samplepos_1cm2_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 33084 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component divmon_samplepos_1cm2. */
  SIG_MESSAGE("divmon_samplepos_1cm2 (Init)");
#define mccompcurname  divmon_samplepos_1cm2
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 73
#define nh mccdivmon_samplepos_1cm2_nh
#define nv mccdivmon_samplepos_1cm2_nv
#define Div_N mccdivmon_samplepos_1cm2_Div_N
#define Div_p mccdivmon_samplepos_1cm2_Div_p
#define Div_p2 mccdivmon_samplepos_1cm2_Div_p2
#define filename mccdivmon_samplepos_1cm2_filename
#define xmin mccdivmon_samplepos_1cm2_xmin
#define xmax mccdivmon_samplepos_1cm2_xmax
#define ymin mccdivmon_samplepos_1cm2_ymin
#define ymax mccdivmon_samplepos_1cm2_ymax
#define xwidth mccdivmon_samplepos_1cm2_xwidth
#define yheight mccdivmon_samplepos_1cm2_yheight
#define maxdiv_h mccdivmon_samplepos_1cm2_maxdiv_h
#define maxdiv_v mccdivmon_samplepos_1cm2_maxdiv_v
#define restore_neutron mccdivmon_samplepos_1cm2_restore_neutron
#define nx mccdivmon_samplepos_1cm2_nx
#define ny mccdivmon_samplepos_1cm2_ny
#define nz mccdivmon_samplepos_1cm2_nz
#define nowritefile mccdivmon_samplepos_1cm2_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Divergence_monitor: %s: Null detection area !\n"
                   "ERROR               (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<nv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 33154 "RITA-II.c"
#undef nowritefile
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_samplepos_large. */
  SIG_MESSAGE("psd_samplepos_large (Init)");
#define mccompcurname  psd_samplepos_large
#define mccompcurtype  PSD_monitor
#define mccompcurindex 74
#define nx mccpsd_samplepos_large_nx
#define ny mccpsd_samplepos_large_ny
#define PSD_N mccpsd_samplepos_large_PSD_N
#define PSD_p mccpsd_samplepos_large_PSD_p
#define PSD_p2 mccpsd_samplepos_large_PSD_p2
#define filename mccpsd_samplepos_large_filename
#define xmin mccpsd_samplepos_large_xmin
#define xmax mccpsd_samplepos_large_xmax
#define ymin mccpsd_samplepos_large_ymin
#define ymax mccpsd_samplepos_large_ymax
#define xwidth mccpsd_samplepos_large_xwidth
#define yheight mccpsd_samplepos_large_yheight
#define restore_neutron mccpsd_samplepos_large_restore_neutron
#define nowritefile mccpsd_samplepos_large_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 33219 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component a3. */
  SIG_MESSAGE("a3 (Init)");

  /* Initializations for component aa3. */
  SIG_MESSAGE("aa3 (Init)");

  /* Initializations for component incohSample. */
  SIG_MESSAGE("incohSample (Init)");
#define mccompcurname  incohSample
#define mccompcurtype  Incoherent
#define mccompcurindex 77
#define VarsInc mccincohSample_VarsInc
#define offdata mccincohSample_offdata
#define geometry mccincohSample_geometry
#define radius mccincohSample_radius
#define xwidth mccincohSample_xwidth
#define yheight mccincohSample_yheight
#define zdepth mccincohSample_zdepth
#define thickness mccincohSample_thickness
#define target_x mccincohSample_target_x
#define target_y mccincohSample_target_y
#define target_z mccincohSample_target_z
#define focus_r mccincohSample_focus_r
#define focus_xw mccincohSample_focus_xw
#define focus_yh mccincohSample_focus_yh
#define focus_aw mccincohSample_focus_aw
#define focus_ah mccincohSample_focus_ah
#define target_index mccincohSample_target_index
#define pack mccincohSample_pack
#define p_interact mccincohSample_p_interact
#define f_QE mccincohSample_f_QE
#define gamma mccincohSample_gamma
#define Etrans mccincohSample_Etrans
#define deltaE mccincohSample_deltaE
#define sigma_abs mccincohSample_sigma_abs
#define sigma_inc mccincohSample_sigma_inc
#define Vc mccincohSample_Vc
#define concentric mccincohSample_concentric
#define order mccincohSample_order
#line 156 "/usr/share/mcstas/2.5/samples/Incoherent.comp"
{
  VarsInc.shape=-1; /* -1:no shape, 0:cyl, 1:box, 2:sphere, 3:any-shape  */
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {
	  if (off_init(geometry, xwidth, yheight, zdepth, 0, &offdata)) {
      VarsInc.shape=3; thickness=0; concentric=0;
    }
  }
  else if (xwidth && yheight && zdepth)  VarsInc.shape=1; /* box */
  else if (radius > 0 &&  yheight)       VarsInc.shape=0; /* cylinder */
  else if (radius > 0 && !yheight)       VarsInc.shape=2; /* sphere */

  if (VarsInc.shape < 0)
    exit(fprintf(stderr,"Incoherent: %s: sample has invalid dimensions.\n"
                        "ERROR       Please check parameter values (xwidth, yheight, zdepth, radius).\n", NAME_CURRENT_COMP));
  if (thickness) {
    if (radius && (radius < thickness || ( yheight && (yheight < 2*thickness)))) {
      fprintf(stderr,"Incoherent: %s: hollow sample thickness is larger than its volume (sphere/cylinder).\n"
                     "WARNING     Please check parameter values. Using bulk sample (thickness=0).\n", NAME_CURRENT_COMP);
      thickness=0;
    }
    else if (!radius && (xwidth < 2*thickness || yheight < 2*thickness || zdepth < 2*thickness)) {
      fprintf(stderr,"Incoherent: %s: hollow sample thickness is larger than its volume (box).\n"
                     "WARNING     Please check parameter values. Using bulk sample (thickness=0).\n", NAME_CURRENT_COMP);
      thickness=0;
    }
  }

  if (concentric && thickness<=0) {
    printf("Incoherent: %s:Can not use concentric mode\n"
           "WARNING     on non hollow shape. Ignoring.\n",
           NAME_CURRENT_COMP);
    concentric=0;
  }

  VarsInc.sigma_a= sigma_abs;
  VarsInc.sigma_i= sigma_inc;
  VarsInc.rho    = (pack/Vc);
  VarsInc.my_s   = (VarsInc.rho * 100 * VarsInc.sigma_i);
  VarsInc.my_a_v = (VarsInc.rho * 100 * VarsInc.sigma_a);

  /* now compute target coords if a component index is supplied */
  VarsInc.tx= VarsInc.ty=VarsInc.tz=0;
  if (!target_index && !target_x && !target_y && !target_z) target_index=1;
  if (target_index)
  {
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &VarsInc.tx, &VarsInc.ty, &VarsInc.tz);
  }
  else
  { VarsInc.tx = target_x; VarsInc.ty = target_y; VarsInc.tz = target_z; }

  if (!(VarsInc.tx || VarsInc.ty || VarsInc.tz)) {
    MPI_MASTER(
    printf("Incoherent: %s: The target is not defined. Using direct beam (Z-axis).\n",
      NAME_CURRENT_COMP);
    );
    VarsInc.tz=1;
  }

  /* different ways of setting rectangular area */
  VarsInc.aw  = VarsInc.ah = 0;
  if (focus_xw) { VarsInc.xw = focus_xw; }
  if (focus_yh) { VarsInc.yh = focus_yh; }
  if (focus_aw) { VarsInc.aw = DEG2RAD*focus_aw; }
  if (focus_ah) { VarsInc.ah = DEG2RAD*focus_ah; }

  MPI_MASTER(
  printf("Incoherent: %s: Vc=%g [Angs] sigma_abs=%g [barn] sigma_inc=%g [barn]\n",
      NAME_CURRENT_COMP, Vc, VarsInc.sigma_a, VarsInc.sigma_i);
  );

}
#line 33352 "RITA-II.c"
#undef order
#undef concentric
#undef Vc
#undef sigma_inc
#undef sigma_abs
#undef deltaE
#undef Etrans
#undef gamma
#undef f_QE
#undef p_interact
#undef pack
#undef target_index
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef focus_r
#undef target_z
#undef target_y
#undef target_x
#undef thickness
#undef zdepth
#undef yheight
#undef xwidth
#undef radius
#undef geometry
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component powderSample. */
  SIG_MESSAGE("powderSample (Init)");
#define mccompcurname  powderSample
#define mccompcurtype  PowderN
#define mccompcurindex 78
#define format mccpowderSample_format
#define line_info mccpowderSample_line_info
#define columns mccpowderSample_columns
#define offdata mccpowderSample_offdata
#define reflections mccpowderSample_reflections
#define geometry mccpowderSample_geometry
#define radius mccpowderSample_radius
#define yheight mccpowderSample_yheight
#define xwidth mccpowderSample_xwidth
#define zdepth mccpowderSample_zdepth
#define thickness mccpowderSample_thickness
#define pack mccpowderSample_pack
#define Vc mccpowderSample_Vc
#define sigma_abs mccpowderSample_sigma_abs
#define sigma_inc mccpowderSample_sigma_inc
#define delta_d_d mccpowderSample_delta_d_d
#define p_inc mccpowderSample_p_inc
#define p_transmit mccpowderSample_p_transmit
#define DW mccpowderSample_DW
#define nb_atoms mccpowderSample_nb_atoms
#define d_omega mccpowderSample_d_omega
#define d_phi mccpowderSample_d_phi
#define tth_sign mccpowderSample_tth_sign
#define p_interact mccpowderSample_p_interact
#define concentric mccpowderSample_concentric
#define density mccpowderSample_density
#define weight mccpowderSample_weight
#define barns mccpowderSample_barns
#define Strain mccpowderSample_Strain
#define focus_flip mccpowderSample_focus_flip
#define target_index mccpowderSample_target_index
#line 560 "/usr/share/mcstas/2.5/samples/PowderN.comp"
{
  columns = (int[])format;

  int i=0;
  struct line_data *L;
  line_info.Dd       = delta_d_d;
  line_info.DWfactor = DW;
  line_info.V_0      = Vc;
  line_info.rho      = density;
  line_info.at_weight= weight;
  line_info.at_nb    = nb_atoms;
  line_info.sigma_a  = sigma_abs;
  line_info.sigma_i  = sigma_inc;
  line_info.flag_barns=barns;
  line_info.shape    = 0;
  line_info.flag_warning=0;
  line_info.Epsilon  = Strain;
  line_info.radius_i =line_info.xwidth_i=line_info.yheight_i=line_info.zdepth_i=0;
  line_info.v  = 0;
  line_info.Nq = 0;
  line_info.v_min = FLT_MAX; line_info.v_max = 0;
  line_info.neutron_passed=0;
  line_info.nb_reuses = line_info.nb_refl = line_info.nb_refl_count = 0;
  line_info.xs_compute= line_info.xs_reuse= line_info.xs_calls =0;
  for (i=0; i< 9; i++) line_info.column_order[i] = columns[i];
  strncpy(line_info.compname, NAME_CURRENT_COMP, 256);

  line_info.shape=-1; /* -1:no shape, 0:cyl, 1:box, 2:sphere, 3:any-shape  */
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {
	  if (off_init(geometry, xwidth, yheight, zdepth, 0, &offdata)) {
      line_info.shape=3; thickness=0; concentric=0;
    }
  }
  else if (xwidth && yheight && zdepth)  line_info.shape=1; /* box */
  else if (radius > 0 && yheight)        line_info.shape=0; /* cylinder */
  else if (radius > 0 && !yheight)       line_info.shape=2; /* sphere */

  if (line_info.shape < 0)
    exit(fprintf(stderr,"PowderN: %s: sample has invalid dimensions.\n"
                        "ERROR    Please check parameter values (xwidth, yheight, zdepth, radius).\n", NAME_CURRENT_COMP));
  if (thickness) {
    if (radius && (radius < fabs(thickness))) {
      MPI_MASTER(
      printf("PowderN: %s: hollow sample thickness is larger than its volume (sphere/cylinder).\n"
                     "WARNING  Please check parameter values. Using bulk sample (thickness=0).\n", NAME_CURRENT_COMP);
      );
      thickness=0;
    }
    else if (!radius && (xwidth < 2*fabs(thickness) || yheight < 2*fabs(thickness) || zdepth < 2*fabs(thickness))) {
      MPI_MASTER(
      printf("PowderN: %s: hollow sample thickness is larger than its volume (box).\n"
                     "WARNING  Please check parameter values.\n", NAME_CURRENT_COMP);
      );
    }
  }

  if (concentric && thickness==0) {
    MPI_MASTER(
    printf("PowderN: %s:Can not use concentric mode\n"
           "WARNING     on non hollow shape. Ignoring.\n",
           NAME_CURRENT_COMP);
    );
    concentric=0;
  }

  if (thickness>0) {
    if (radius>thickness) {
      line_info.radius_i=radius-thickness;
    } else {
      if (xwidth>2*thickness)  line_info.xwidth_i =xwidth -2*thickness;
      if (yheight>2*thickness) line_info.yheight_i=yheight-2*thickness;
      if (zdepth>2*thickness)  line_info.zdepth_i =zdepth -2*thickness;
    }
  } else if (thickness<0) {
    thickness = fabs(thickness);
    if (radius) {
      line_info.radius_i=radius;
      radius=line_info.radius_i+thickness;
    } else {
      line_info.xwidth_i =xwidth;
      line_info.yheight_i=yheight;
      line_info.zdepth_i =zdepth;
      xwidth   =xwidth +2*thickness;
      yheight  =yheight+2*thickness;
      zdepth   =zdepth +2*thickness;
    }
  }

  if (!line_info.yheight_i) {
    line_info.yheight_i = yheight;
  }
  if (p_interact) {
    if (p_interact < p_inc) { double tmp=p_interact; p_interact=p_inc; p_inc=tmp; }
    p_transmit = 1-p_interact-p_inc;
  }

  if (p_inc + p_transmit > 1) {
    MPI_MASTER(
    printf("PowderN: %s: You have requested an unmeaningful choice of the 'p_inc' and 'p_transmit' parameters (sum is %g, exeeding 1). Fixing.\n",
                 NAME_CURRENT_COMP, p_inc+p_transmit);
    );
    if (p_inc > p_transmit) p_transmit=1-2*p_inc;
    else p_transmit=1-2*p_inc;
  } else if (p_inc + p_transmit == 1) {
    MPI_MASTER(
    printf("PowderN: %s: You have requested all neutrons be attenuated\n"
           "WARNING  or incoherently scattered!\n", NAME_CURRENT_COMP);
    );
  }

  if (concentric) {
    MPI_MASTER(
    printf("PowderN: %s: Concentric mode - remember to include the 'opposite' copy of this component !\n"
           "WARNING  The equivalent, 'opposite' comp should have concentric=0\n", NAME_CURRENT_COMP);
    );
    if (p_transmit == 0) {
      MPI_MASTER(
      printf("PowderN: %s: Concentric mode and p_transmit==0 !?\n"
             "WARNING  Don't you want any transmitted neutrons?\n", NAME_CURRENT_COMP);
      );
    }
  }

  if (reflections && strlen(reflections) && strcmp(reflections, "NULL") && strcmp(reflections, "0")) {
    i = read_line_data(reflections, &line_info);
    if (i == 0)
      exit(fprintf(stderr,"PowderN: %s: reflection file %s is not valid.\n"
                          "ERROR    Please check file format (laz or lau).\n", NAME_CURRENT_COMP, reflections));
  }

  /* compute the scattering unit density from material weight and density */
  /* the weight of the scattering element is the chemical formula molecular weight
   * times the nb of chemical formulae in the scattering element (nb_atoms) */
  if (!line_info.V_0 && line_info.at_nb > 0
    && line_info.at_weight > 0 && line_info.rho > 0) {
    /* molar volume [cm^3/mol] = weight [g/mol] / density [g/cm^3] */
    /* atom density per Angs^3 = [mol/cm^3] * N_Avogadro *(1e-8)^3 */
    line_info.V_0 = line_info.at_nb
      /(line_info.rho/line_info.at_weight/1e24*6.02214199e23);
  }

  /* the scattering unit cross sections are the chemical formula onces
   * times the nb of chemical formulae in the scattering element */
  if (line_info.at_nb > 0) {
    line_info.sigma_a *= line_info.at_nb; line_info.sigma_i *= line_info.at_nb;
  }

  if (line_info.sigma_a<0) line_info.sigma_a=0;
  if (line_info.sigma_i<0) line_info.sigma_i=0;

  if (line_info.V_0 <= 0)
  MPI_MASTER(
    printf("PowderN: %s: density/unit cell volume is NULL (Vc). Unactivating component.\n", NAME_CURRENT_COMP);
  );

  if (line_info.V_0 > 0 && p_inc && !line_info.sigma_i) {
  MPI_MASTER(
    printf("PowderN: %s: WARNING: You have requested statistics for incoherent scattering but not defined sigma_inc!\n", NAME_CURRENT_COMP);
  );
  }

  if (line_info.flag_barns) { /* Factor 100 to convert from barns to fm^2 */
    line_info.XsectionFactor = 100;
  } else {
    line_info.XsectionFactor = 1;
  }

  if (line_info.V_0 > 0 && i) {
    L = line_info.list;

    line_info.q_v = malloc(line_info.count*sizeof(double));
    line_info.w_v = malloc(line_info.count*sizeof(double));
    line_info.my_s_v2 = malloc(line_info.count*sizeof(double));
    if (!line_info.q_v || !line_info.w_v || !line_info.my_s_v2)
      exit(fprintf(stderr,"PowderN: %s: ERROR allocating memory (init)\n", NAME_CURRENT_COMP));
    for(i=0; i<line_info.count; i++)
    {
      line_info.my_s_v2[i] = 4*PI*PI*PI*pack*(L[i].DWfactor ? L[i].DWfactor : 1)
                 /(line_info.V_0*line_info.V_0*V2K*V2K)
                 *(L[i].j * L[i].F2 / L[i].q)*line_info.XsectionFactor;
      /* Is not yet divided by v^2 */
      /* Squires [3.103] */
      line_info.q_v[i] = L[i].q*K2V;
      line_info.w_v[i] = L[i].w;
    }
  }
  if (line_info.V_0 > 0) {
    /* Is not yet divided by v */
    line_info.my_a_v = pack*line_info.sigma_a/line_info.V_0*2200*100;   // Factor 100 to convert from barns to fm^2
    line_info.my_inc = pack*line_info.sigma_i/line_info.V_0*100;   // Factor 100 to convert from barns to fm^2
    MPI_MASTER(
    printf("PowderN: %s: Vc=%g [Angs] sigma_abs=%g [barn] sigma_inc=%g [barn] reflections=%s\n",
      NAME_CURRENT_COMP, line_info.V_0, line_info.sigma_a, line_info.sigma_i, reflections && strlen(reflections) ? reflections : "NULL");
    );
  }
  
  /* update JS, 1/7/2017
    Get target coordinates relative to the local reference frame.
  */
    if (target_index) {
		Coords ToTarget;
		ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
		ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
		coords_get(ToTarget, &tgt_x, &tgt_y, &tgt_z);
		NORM(tgt_x, tgt_y, tgt_z);
		printf("PowderN: Target direction = (%g %g %g)\n",tgt_x, tgt_y, tgt_z);
	} else {
		tgt_x=0.0;
		tgt_y=0.0;
		tgt_z=1.0;
	}	   

}
#line 33635 "RITA-II.c"
#undef target_index
#undef focus_flip
#undef Strain
#undef barns
#undef weight
#undef density
#undef concentric
#undef p_interact
#undef tth_sign
#undef d_phi
#undef d_omega
#undef nb_atoms
#undef DW
#undef p_transmit
#undef p_inc
#undef delta_d_d
#undef sigma_inc
#undef sigma_abs
#undef Vc
#undef pack
#undef thickness
#undef zdepth
#undef xwidth
#undef yheight
#undef radius
#undef geometry
#undef reflections
#undef offdata
#undef columns
#undef line_info
#undef format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component crystalSample. */
  SIG_MESSAGE("crystalSample (Init)");
#define mccompcurname  crystalSample
#define mccompcurtype  Single_crystal
#define mccompcurindex 79
#define mosaic_AB mcccrystalSample_mosaic_AB
#define hkl_info mcccrystalSample_hkl_info
#define offdata mcccrystalSample_offdata
#define reflections mcccrystalSample_reflections
#define geometry mcccrystalSample_geometry
#define xwidth mcccrystalSample_xwidth
#define yheight mcccrystalSample_yheight
#define zdepth mcccrystalSample_zdepth
#define radius mcccrystalSample_radius
#define delta_d_d mcccrystalSample_delta_d_d
#define mosaic mcccrystalSample_mosaic
#define mosaic_a mcccrystalSample_mosaic_a
#define mosaic_b mcccrystalSample_mosaic_b
#define mosaic_c mcccrystalSample_mosaic_c
#define recip_cell mcccrystalSample_recip_cell
#define barns mcccrystalSample_barns
#define ax mcccrystalSample_ax
#define ay mcccrystalSample_ay
#define az mcccrystalSample_az
#define bx mcccrystalSample_bx
#define by mcccrystalSample_by
#define bz mcccrystalSample_bz
#define cx mcccrystalSample_cx
#define cy mcccrystalSample_cy
#define cz mcccrystalSample_cz
#define p_transmit mcccrystalSample_p_transmit
#define sigma_abs mcccrystalSample_sigma_abs
#define sigma_inc mcccrystalSample_sigma_inc
#define aa mcccrystalSample_aa
#define bb mcccrystalSample_bb
#define cc mcccrystalSample_cc
#define order mcccrystalSample_order
#define RX mcccrystalSample_RX
#define RY mcccrystalSample_RY
#define powder mcccrystalSample_powder
#define PG mcccrystalSample_PG
#define deltak mcccrystalSample_deltak
#line 967 "/usr/share/mcstas/2.5/samples/Single_crystal.comp"
{
  double as, bs, cs;
  int i=0;

  /* transfer input parameters */
  hkl_info.m_delta_d_d = delta_d_d;
  hkl_info.m_a  = 0;
  hkl_info.m_b  = 0;
  hkl_info.m_c  = 0;
  hkl_info.m_aa = aa;
  hkl_info.m_bb = bb;
  hkl_info.m_cc = cc;
  hkl_info.m_ax = ax;
  hkl_info.m_ay = ay;
  hkl_info.m_az = az;
  hkl_info.m_bx = bx;
  hkl_info.m_by = by;
  hkl_info.m_bz = bz;
  hkl_info.m_cx = cx;
  hkl_info.m_cy = cy;
  hkl_info.m_cz = cz;
  hkl_info.sigma_a = sigma_abs;
  hkl_info.sigma_i = sigma_inc;
  hkl_info.recip   = recip_cell;

  /* default format h,k,l,F,F2  */
  hkl_info.column_order[0]=1;
  hkl_info.column_order[1]=2;
  hkl_info.column_order[2]=3;
  hkl_info.column_order[3]=0;
  hkl_info.column_order[4]=7;
  hkl_info.kix = hkl_info.kiy = hkl_info.kiz = 0;
  hkl_info.nb_reuses = hkl_info.nb_refl = hkl_info.nb_refl_count = 0;
  hkl_info.tau_count = 0;

  /*this is necessary to allow a numerical array to be passed through as a DEFINITION parameter*/
  double mosaic_ABin[]=mosaic_AB;
  /* Read in structure factors, and do some pre-calculations. */
  if (!read_hkl_data(reflections, &hkl_info, mosaic, mosaic_a, mosaic_b, mosaic_c, mosaic_ABin)) {
    printf("Single_crystal: %s: Error: Aborting.\n", NAME_CURRENT_COMP);
    exit(0);
  }

  if (hkl_info.sigma_a<0) hkl_info.sigma_a=0;
  if (hkl_info.sigma_i<0) hkl_info.sigma_i=0;

  if (hkl_info.count)
    printf("Single_crystal: %s: Read %d reflections from file '%s'\n",
      NAME_CURRENT_COMP, hkl_info.count, reflections);
  else printf("Single_crystal: %s: Using incoherent elastic scattering only sigma=%g.\n",
      NAME_CURRENT_COMP, hkl_info.sigma_i);

  hkl_info.shape=-1; /* -1:no shape, 0:cyl, 1:box, 2:sphere, 3:any-shape  */
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {
	  if (off_init(geometry, xwidth, yheight, zdepth, 0, &offdata)) {
      hkl_info.shape=3;
    }
  }
  else if (xwidth && yheight && zdepth)  hkl_info.shape=1; /* box */
  else if (radius > 0 && yheight)        hkl_info.shape=0; /* cylinder */
  else if (radius > 0 && !yheight)       hkl_info.shape=2; /* sphere */

  if (hkl_info.shape < 0)
    exit(fprintf(stderr,"Single_crystal: %s: sample has invalid dimensions.\n"
                        "ERROR           Please check parameter values (xwidth, yheight, zdepth, radius).\n", NAME_CURRENT_COMP));

  printf("Single_crystal: %s: Vc=%g [Angs] sigma_abs=%g [barn] sigma_inc=%g [barn] reflections=%s\n",
      NAME_CURRENT_COMP, hkl_info.V0, hkl_info.sigma_a, hkl_info.sigma_i,
      reflections && strlen(reflections) ? reflections : "NULL");

  if (powder && PG)
    exit(fprintf(stderr,"Single_crystal: %s: powder and PG modes can not be used together!\n"
	     "ERROR           Please use EITHER powder or PG mode.\n", NAME_CURRENT_COMP));

  if (powder && !(order==1)) {
    fprintf(stderr,"Single_crystal: %s: powder mode means implicit choice of no multiple scattering!\n"
	    "WARNING setting order=1\n", NAME_CURRENT_COMP);
    order=1;
  }

  if (PG && !(order==1)) {
    fprintf(stderr,"Single_crystal: %s: PG mode means implicit choice of no multiple scattering!\n"
	    "WARNING setting order=1\n", NAME_CURRENT_COMP);
    order=1;
  }


}
#line 33802 "RITA-II.c"
#undef deltak
#undef PG
#undef powder
#undef RY
#undef RX
#undef order
#undef cc
#undef bb
#undef aa
#undef sigma_inc
#undef sigma_abs
#undef p_transmit
#undef cz
#undef cy
#undef cx
#undef bz
#undef by
#undef bx
#undef az
#undef ay
#undef ax
#undef barns
#undef recip_cell
#undef mosaic_c
#undef mosaic_b
#undef mosaic_a
#undef mosaic
#undef delta_d_d
#undef radius
#undef zdepth
#undef yheight
#undef xwidth
#undef geometry
#undef reflections
#undef offdata
#undef hkl_info
#undef mosaic_AB
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component phononSample. */
  SIG_MESSAGE("phononSample (Init)");
#define mccompcurname  phononSample
#define mccompcurtype  Phonon_simple
#define mccompcurindex 80
#define V_rho mccphononSample_V_rho
#define V_my_s mccphononSample_V_my_s
#define V_my_a_v mccphononSample_V_my_a_v
#define DV mccphononSample_DV
#define parms mccphononSample_parms
#define radius mccphononSample_radius
#define yheight mccphononSample_yheight
#define sigma_abs mccphononSample_sigma_abs
#define sigma_inc mccphononSample_sigma_inc
#define a mccphononSample_a
#define b mccphononSample_b
#define M mccphononSample_M
#define c mccphononSample_c
#define DW mccphononSample_DW
#define T mccphononSample_T
#define target_x mccphononSample_target_x
#define target_y mccphononSample_target_y
#define target_z mccphononSample_target_z
#define target_index mccphononSample_target_index
#define focus_r mccphononSample_focus_r
#define focus_xw mccphononSample_focus_xw
#define focus_yh mccphononSample_focus_yh
#define focus_aw mccphononSample_focus_aw
#define focus_ah mccphononSample_focus_ah
#define gap mccphononSample_gap
#line 241 "/usr/share/mcstas/2.5/samples/Phonon_simple.comp"
{
  V_rho = 4/(a*a*a);
  V_my_s = (V_rho * 100 * sigma_inc);
  V_my_a_v = (V_rho * 100 * sigma_abs * 2200);
  DV = 0.001;   /* Velocity change used for numerical derivative */

  /* now compute target coords if a component index is supplied */
  if (!target_index && !target_x && !target_y && !target_z) target_index=1;
  if (target_index){
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &target_x, &target_y, &target_z);
  }
  if (!(target_x || target_y || target_z)) {
    printf("Phonon_simple: %s: The target is not defined. Using direct beam (Z-axis).\n",
      NAME_CURRENT_COMP);
    target_z=1;
  }
}
#line 33895 "RITA-II.c"
#undef gap
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef focus_r
#undef target_index
#undef target_z
#undef target_y
#undef target_x
#undef T
#undef DW
#undef c
#undef M
#undef b
#undef a
#undef sigma_inc
#undef sigma_abs
#undef yheight
#undef radius
#undef parms
#undef DV
#undef V_my_a_v
#undef V_my_s
#undef V_rho
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_4pi. */
  SIG_MESSAGE("psd_4pi (Init)");
#define mccompcurname  psd_4pi
#define mccompcurtype  PSD_monitor_4PI
#define mccompcurindex 81
#define nx mccpsd_4pi_nx
#define ny mccpsd_4pi_ny
#define PSD_N mccpsd_4pi_PSD_N
#define PSD_p mccpsd_4pi_PSD_p
#define PSD_p2 mccpsd_4pi_PSD_p2
#define filename mccpsd_4pi_filename
#define radius mccpsd_4pi_radius
#define restore_neutron mccpsd_4pi_restore_neutron
#define nowritefile mccpsd_4pi_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/PSD_monitor_4PI.comp"
{
int i,j;

for (i=0; i<nx; i++)
    for (j=0; j<ny; j++)
    {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
}
#line 33951 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef radius
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component a4. */
  SIG_MESSAGE("a4 (Init)");

  /* Initializations for component slitSample. */
  SIG_MESSAGE("slitSample (Init)");
#define mccompcurname  slitSample
#define mccompcurtype  Slit
#define mccompcurindex 83
#define xmin mccslitSample_xmin
#define xmax mccslitSample_xmax
#define ymin mccslitSample_ymin
#define ymax mccslitSample_ymax
#define radius mccslitSample_radius
#define xwidth mccslitSample_xwidth
#define yheight mccslitSample_yheight
#line 50 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 34000 "RITA-II.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component filter_coll. */
  SIG_MESSAGE("filter_coll (Init)");
#define mccompcurname  filter_coll
#define mccompcurtype  Exact_radial_coll
#define mccompcurindex 84
#define alpha_in mccfilter_coll_alpha_in
#define alpha_out mccfilter_coll_alpha_out
#define out_radius mccfilter_coll_out_radius
#define beta_in mccfilter_coll_beta_in
#define beta_out mccfilter_coll_beta_out
#define iw mccfilter_coll_iw
#define ow mccfilter_coll_ow
#define divergence mccfilter_coll_divergence
#define theta mccfilter_coll_theta
#define theta_min mccfilter_coll_theta_min
#define theta_max mccfilter_coll_theta_max
#define nslit mccfilter_coll_nslit
#define radius mccfilter_coll_radius
#define length mccfilter_coll_length
#define h_in mccfilter_coll_h_in
#define h_out mccfilter_coll_h_out
#define d mccfilter_coll_d
#define verbose mccfilter_coll_verbose
#line 62 "/usr/share/mcstas/2.5/contrib/Exact_radial_coll.comp"
{
/* check for input parameters */
if (radius <= 0) exit(printf("Exact_radial_coll: %s: radius must be positive\n", NAME_CURRENT_COMP));
  if (h_in <= 0) exit(printf("Exact_radial_coll: %s: h_in must be positive\n", NAME_CURRENT_COMP));
  if (h_out <= 0) exit(printf("Exact_radial_coll: %s: h_out must be positive\n", NAME_CURRENT_COMP));
  if (d <= 0) exit(printf("Exact_radial_coll: %s: d must be positive\n", NAME_CURRENT_COMP));
  if (nslit <= 0)  exit(printf("Exact_radial_coll: %s: number of channels must be positive\n", NAME_CURRENT_COMP));
  if ((nslit - floor (nslit)) > 0) exit(printf("Exact_radial_coll: %s: number of channels must be an integer\n", NAME_CURRENT_COMP));
  if (length <= 0)    exit(printf("Exact_radial_coll: %s: collimator length must be positive\n", NAME_CURRENT_COMP));
  if (theta_max <= theta_min) exit(printf("Exact_radial_coll: %s: theta_max must be greater than theta_min\n", NAME_CURRENT_COMP));

  theta_max *= DEG2RAD;
  theta_min *= DEG2RAD;
  theta = theta_max - theta_min;
  out_radius = radius + length;
  beta_in =  2*asin(d / (2 * radius));
  beta_out=  2*asin(d / (2 * out_radius));
  if (theta < nslit*beta_in) exit(printf("Exact_radial_coll: %s: the %6.0f foils of %g [meter]\n"
                                             "do not fit within the angular range theta = %4.2f [deg]\n",
                                             NAME_CURRENT_COMP, nslit, d, theta*RAD2DEG));
  alpha_in = (theta - nslit*beta_in)/nslit;
  alpha_out = (theta - nslit*beta_out)/nslit;
  iw = 2*radius*sin((alpha_in/2));
  ow = 2*out_radius*sin((alpha_out/2));
  divergence=(iw+ow)/(sqrt(4*length*length-(ow-iw)*(ow-iw)));

  if (verbose) {
    printf("Exact_radial_coll: %s: foil thickness is %.2g [millimeter]\n", NAME_CURRENT_COMP, d*1000);
    printf("                  opening each  input slit [%.3g:%.0f] [millimeter]\n", iw*1000, h_in*1000);
    printf("                  opening each output slit [%.3g:%.0f] [millimeter]\n", ow*1000, h_out*1000);
    printf("                  divergence per channel is %g [min] \n", divergence*RAD2MIN);
  }
}
#line 34069 "RITA-II.c"
#undef verbose
#undef d
#undef h_out
#undef h_in
#undef length
#undef radius
#undef nslit
#undef theta_max
#undef theta_min
#undef theta
#undef divergence
#undef ow
#undef iw
#undef beta_out
#undef beta_in
#undef out_radius
#undef alpha_out
#undef alpha_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component filter. */
  SIG_MESSAGE("filter (Init)");
#define mccompcurname  filter
#define mccompcurtype  Filter_gen
#define mccompcurindex 85
#define pTable mccfilter_pTable
#define Mode_Table mccfilter_Mode_Table
#define Type_Table mccfilter_Type_Table
#define filename mccfilter_filename
#define options mccfilter_options
#define xmin mccfilter_xmin
#define xmax mccfilter_xmax
#define ymin mccfilter_ymin
#define ymax mccfilter_ymax
#define xwidth mccfilter_xwidth
#define yheight mccfilter_yheight
#define thickness mccfilter_thickness
#define scaling mccfilter_scaling
#define verbose mccfilter_verbose
#line 126 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  Mode_Table = FLUX_ADAPT_MULT;
  Type_Table = UNKNOWN_TABLE;

  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  FilterGen_Mode(options, &Mode_Table, &Type_Table, &verbose);

  if (filename != NULL && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
  {
    if (Table_Read(&pTable, filename, 1) <= 0) /* read 1st block data from filename into pTable */
      exit(fprintf(stderr,"Filter_gen: %s: can not read filename %s\n", NAME_CURRENT_COMP, filename));

    Table_Rebin(&pTable);         /* rebin as evenly, increasing array */
    if (pTable.rows < 2 || !pTable.step_x) {
      Table_Free(&pTable);
    }
    if (pTable.data)
    {
      FilterGen_Mode(pTable.header, &Mode_Table, &Type_Table, &verbose);
      if (verbose)
      {
        Table_Info(pTable);
        printf("Filter_gen: %s: Filter data [", NAME_CURRENT_COMP);
        if (Type_Table == ENERGY_TABLE) printf("Energy");
        if (Type_Table == WAVEVECTOR_TABLE) printf("Wavevector");
        if (Type_Table == WAVELENGTH_TABLE) printf("Wavelength");
        if (Type_Table == UNKNOWN_TABLE) printf("UNKNOWN (not used)");
        printf(", Flux] in ");
        if (Mode_Table == FLUX_ADAPT_MULT) printf("multiply");
        else if (Mode_Table == FLUX_ADAPT_ADD) printf("add");
        else printf("set");
        printf(" mode\n");
      }
    } else fprintf(stderr,"Filter_gen: %s: file %s contains no data.\n", NAME_CURRENT_COMP, filename);

  } else pTable.data = NULL;
}
#line 34151 "RITA-II.c"
#undef verbose
#undef scaling
#undef thickness
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef options
#undef filename
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ana_slit1. */
  SIG_MESSAGE("ana_slit1 (Init)");
#define mccompcurname  ana_slit1
#define mccompcurtype  Slit
#define mccompcurindex 86
#define xmin mccana_slit1_xmin
#define xmax mccana_slit1_xmax
#define ymin mccana_slit1_ymin
#define ymax mccana_slit1_ymax
#define radius mccana_slit1_radius
#define xwidth mccana_slit1_xwidth
#define yheight mccana_slit1_yheight
#line 50 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 34202 "RITA-II.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ana_slit2. */
  SIG_MESSAGE("ana_slit2 (Init)");
#define mccompcurname  ana_slit2
#define mccompcurtype  Slit
#define mccompcurindex 87
#define xmin mccana_slit2_xmin
#define xmax mccana_slit2_xmax
#define ymin mccana_slit2_ymin
#define ymax mccana_slit2_ymax
#define radius mccana_slit2_radius
#define xwidth mccana_slit2_xwidth
#define yheight mccana_slit2_yheight
#line 50 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 34246 "RITA-II.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_before_ana. */
  SIG_MESSAGE("emon_before_ana (Init)");
#define mccompcurname  emon_before_ana
#define mccompcurtype  E_monitor
#define mccompcurindex 88
#define nE mccemon_before_ana_nE
#define E_N mccemon_before_ana_E_N
#define E_p mccemon_before_ana_E_p
#define E_p2 mccemon_before_ana_E_p2
#define S_p mccemon_before_ana_S_p
#define S_pE mccemon_before_ana_S_pE
#define S_pE2 mccemon_before_ana_S_pE2
#define filename mccemon_before_ana_filename
#define xmin mccemon_before_ana_xmin
#define xmax mccemon_before_ana_xmax
#define ymin mccemon_before_ana_ymin
#define ymax mccemon_before_ana_ymax
#define xwidth mccemon_before_ana_xwidth
#define yheight mccemon_before_ana_yheight
#define Emin mccemon_before_ana_Emin
#define Emax mccemon_before_ana_Emax
#define restore_neutron mccemon_before_ana_restore_neutron
#define nowritefile mccemon_before_ana_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 34303 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_before_ana. */
  SIG_MESSAGE("psd_before_ana (Init)");
#define mccompcurname  psd_before_ana
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define nx mccpsd_before_ana_nx
#define ny mccpsd_before_ana_ny
#define PSD_N mccpsd_before_ana_PSD_N
#define PSD_p mccpsd_before_ana_PSD_p
#define PSD_p2 mccpsd_before_ana_PSD_p2
#define filename mccpsd_before_ana_filename
#define xmin mccpsd_before_ana_xmin
#define xmax mccpsd_before_ana_xmax
#define ymin mccpsd_before_ana_ymin
#define ymax mccpsd_before_ana_ymax
#define xwidth mccpsd_before_ana_xwidth
#define yheight mccpsd_before_ana_yheight
#define restore_neutron mccpsd_before_ana_restore_neutron
#define nowritefile mccpsd_before_ana_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 34367 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component divmon_before_ana. */
  SIG_MESSAGE("divmon_before_ana (Init)");
#define mccompcurname  divmon_before_ana
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 90
#define nh mccdivmon_before_ana_nh
#define nv mccdivmon_before_ana_nv
#define Div_N mccdivmon_before_ana_Div_N
#define Div_p mccdivmon_before_ana_Div_p
#define Div_p2 mccdivmon_before_ana_Div_p2
#define filename mccdivmon_before_ana_filename
#define xmin mccdivmon_before_ana_xmin
#define xmax mccdivmon_before_ana_xmax
#define ymin mccdivmon_before_ana_ymin
#define ymax mccdivmon_before_ana_ymax
#define xwidth mccdivmon_before_ana_xwidth
#define yheight mccdivmon_before_ana_yheight
#define maxdiv_h mccdivmon_before_ana_maxdiv_h
#define maxdiv_v mccdivmon_before_ana_maxdiv_v
#define restore_neutron mccdivmon_before_ana_restore_neutron
#define nx mccdivmon_before_ana_nx
#define ny mccdivmon_before_ana_ny
#define nz mccdivmon_before_ana_nz
#define nowritefile mccdivmon_before_ana_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Divergence_monitor: %s: Null detection area !\n"
                   "ERROR               (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<nv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 34433 "RITA-II.c"
#undef nowritefile
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component focus_ana. */
  SIG_MESSAGE("focus_ana (Init)");

  /* Initializations for component an1l. */
  SIG_MESSAGE("an1l (Init)");
#define mccompcurname  an1l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 92
#define mos_rms_y mccan1l_mos_rms_y
#define mos_rms_z mccan1l_mos_rms_z
#define mos_rms_max mccan1l_mos_rms_max
#define mono_Q mccan1l_mono_Q
#define zmin mccan1l_zmin
#define zmax mccan1l_zmax
#define ymin mccan1l_ymin
#define ymax mccan1l_ymax
#define zwidth mccan1l_zwidth
#define yheight mccan1l_yheight
#define mosaich mccan1l_mosaich
#define mosaicv mccan1l_mosaicv
#define r0 mccan1l_r0
#define Q mccan1l_Q
#define DM mccan1l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34495 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an1u. */
  SIG_MESSAGE("an1u (Init)");
#define mccompcurname  an1u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 93
#define mos_rms_y mccan1u_mos_rms_y
#define mos_rms_z mccan1u_mos_rms_z
#define mos_rms_max mccan1u_mos_rms_max
#define mono_Q mccan1u_mono_Q
#define zmin mccan1u_zmin
#define zmax mccan1u_zmax
#define ymin mccan1u_ymin
#define ymax mccan1u_ymax
#define zwidth mccan1u_zwidth
#define yheight mccan1u_yheight
#define mosaich mccan1u_mosaich
#define mosaicv mccan1u_mosaicv
#define r0 mccan1u_r0
#define Q mccan1u_Q
#define DM mccan1u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34550 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an2l. */
  SIG_MESSAGE("an2l (Init)");
#define mccompcurname  an2l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 94
#define mos_rms_y mccan2l_mos_rms_y
#define mos_rms_z mccan2l_mos_rms_z
#define mos_rms_max mccan2l_mos_rms_max
#define mono_Q mccan2l_mono_Q
#define zmin mccan2l_zmin
#define zmax mccan2l_zmax
#define ymin mccan2l_ymin
#define ymax mccan2l_ymax
#define zwidth mccan2l_zwidth
#define yheight mccan2l_yheight
#define mosaich mccan2l_mosaich
#define mosaicv mccan2l_mosaicv
#define r0 mccan2l_r0
#define Q mccan2l_Q
#define DM mccan2l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34605 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an2u. */
  SIG_MESSAGE("an2u (Init)");
#define mccompcurname  an2u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 95
#define mos_rms_y mccan2u_mos_rms_y
#define mos_rms_z mccan2u_mos_rms_z
#define mos_rms_max mccan2u_mos_rms_max
#define mono_Q mccan2u_mono_Q
#define zmin mccan2u_zmin
#define zmax mccan2u_zmax
#define ymin mccan2u_ymin
#define ymax mccan2u_ymax
#define zwidth mccan2u_zwidth
#define yheight mccan2u_yheight
#define mosaich mccan2u_mosaich
#define mosaicv mccan2u_mosaicv
#define r0 mccan2u_r0
#define Q mccan2u_Q
#define DM mccan2u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34660 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an3l. */
  SIG_MESSAGE("an3l (Init)");
#define mccompcurname  an3l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 96
#define mos_rms_y mccan3l_mos_rms_y
#define mos_rms_z mccan3l_mos_rms_z
#define mos_rms_max mccan3l_mos_rms_max
#define mono_Q mccan3l_mono_Q
#define zmin mccan3l_zmin
#define zmax mccan3l_zmax
#define ymin mccan3l_ymin
#define ymax mccan3l_ymax
#define zwidth mccan3l_zwidth
#define yheight mccan3l_yheight
#define mosaich mccan3l_mosaich
#define mosaicv mccan3l_mosaicv
#define r0 mccan3l_r0
#define Q mccan3l_Q
#define DM mccan3l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34715 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an3u. */
  SIG_MESSAGE("an3u (Init)");
#define mccompcurname  an3u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 97
#define mos_rms_y mccan3u_mos_rms_y
#define mos_rms_z mccan3u_mos_rms_z
#define mos_rms_max mccan3u_mos_rms_max
#define mono_Q mccan3u_mono_Q
#define zmin mccan3u_zmin
#define zmax mccan3u_zmax
#define ymin mccan3u_ymin
#define ymax mccan3u_ymax
#define zwidth mccan3u_zwidth
#define yheight mccan3u_yheight
#define mosaich mccan3u_mosaich
#define mosaicv mccan3u_mosaicv
#define r0 mccan3u_r0
#define Q mccan3u_Q
#define DM mccan3u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34770 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an4l. */
  SIG_MESSAGE("an4l (Init)");
#define mccompcurname  an4l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 98
#define mos_rms_y mccan4l_mos_rms_y
#define mos_rms_z mccan4l_mos_rms_z
#define mos_rms_max mccan4l_mos_rms_max
#define mono_Q mccan4l_mono_Q
#define zmin mccan4l_zmin
#define zmax mccan4l_zmax
#define ymin mccan4l_ymin
#define ymax mccan4l_ymax
#define zwidth mccan4l_zwidth
#define yheight mccan4l_yheight
#define mosaich mccan4l_mosaich
#define mosaicv mccan4l_mosaicv
#define r0 mccan4l_r0
#define Q mccan4l_Q
#define DM mccan4l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34825 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an4u. */
  SIG_MESSAGE("an4u (Init)");
#define mccompcurname  an4u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 99
#define mos_rms_y mccan4u_mos_rms_y
#define mos_rms_z mccan4u_mos_rms_z
#define mos_rms_max mccan4u_mos_rms_max
#define mono_Q mccan4u_mono_Q
#define zmin mccan4u_zmin
#define zmax mccan4u_zmax
#define ymin mccan4u_ymin
#define ymax mccan4u_ymax
#define zwidth mccan4u_zwidth
#define yheight mccan4u_yheight
#define mosaich mccan4u_mosaich
#define mosaicv mccan4u_mosaicv
#define r0 mccan4u_r0
#define Q mccan4u_Q
#define DM mccan4u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34880 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an5l. */
  SIG_MESSAGE("an5l (Init)");
#define mccompcurname  an5l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 100
#define mos_rms_y mccan5l_mos_rms_y
#define mos_rms_z mccan5l_mos_rms_z
#define mos_rms_max mccan5l_mos_rms_max
#define mono_Q mccan5l_mono_Q
#define zmin mccan5l_zmin
#define zmax mccan5l_zmax
#define ymin mccan5l_ymin
#define ymax mccan5l_ymax
#define zwidth mccan5l_zwidth
#define yheight mccan5l_yheight
#define mosaich mccan5l_mosaich
#define mosaicv mccan5l_mosaicv
#define r0 mccan5l_r0
#define Q mccan5l_Q
#define DM mccan5l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34935 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an5u. */
  SIG_MESSAGE("an5u (Init)");
#define mccompcurname  an5u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 101
#define mos_rms_y mccan5u_mos_rms_y
#define mos_rms_z mccan5u_mos_rms_z
#define mos_rms_max mccan5u_mos_rms_max
#define mono_Q mccan5u_mono_Q
#define zmin mccan5u_zmin
#define zmax mccan5u_zmax
#define ymin mccan5u_ymin
#define ymax mccan5u_ymax
#define zwidth mccan5u_zwidth
#define yheight mccan5u_yheight
#define mosaich mccan5u_mosaich
#define mosaicv mccan5u_mosaicv
#define r0 mccan5u_r0
#define Q mccan5u_Q
#define DM mccan5u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 34990 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an6l. */
  SIG_MESSAGE("an6l (Init)");
#define mccompcurname  an6l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 102
#define mos_rms_y mccan6l_mos_rms_y
#define mos_rms_z mccan6l_mos_rms_z
#define mos_rms_max mccan6l_mos_rms_max
#define mono_Q mccan6l_mono_Q
#define zmin mccan6l_zmin
#define zmax mccan6l_zmax
#define ymin mccan6l_ymin
#define ymax mccan6l_ymax
#define zwidth mccan6l_zwidth
#define yheight mccan6l_yheight
#define mosaich mccan6l_mosaich
#define mosaicv mccan6l_mosaicv
#define r0 mccan6l_r0
#define Q mccan6l_Q
#define DM mccan6l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35045 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an6u. */
  SIG_MESSAGE("an6u (Init)");
#define mccompcurname  an6u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 103
#define mos_rms_y mccan6u_mos_rms_y
#define mos_rms_z mccan6u_mos_rms_z
#define mos_rms_max mccan6u_mos_rms_max
#define mono_Q mccan6u_mono_Q
#define zmin mccan6u_zmin
#define zmax mccan6u_zmax
#define ymin mccan6u_ymin
#define ymax mccan6u_ymax
#define zwidth mccan6u_zwidth
#define yheight mccan6u_yheight
#define mosaich mccan6u_mosaich
#define mosaicv mccan6u_mosaicv
#define r0 mccan6u_r0
#define Q mccan6u_Q
#define DM mccan6u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35100 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an7l. */
  SIG_MESSAGE("an7l (Init)");
#define mccompcurname  an7l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 104
#define mos_rms_y mccan7l_mos_rms_y
#define mos_rms_z mccan7l_mos_rms_z
#define mos_rms_max mccan7l_mos_rms_max
#define mono_Q mccan7l_mono_Q
#define zmin mccan7l_zmin
#define zmax mccan7l_zmax
#define ymin mccan7l_ymin
#define ymax mccan7l_ymax
#define zwidth mccan7l_zwidth
#define yheight mccan7l_yheight
#define mosaich mccan7l_mosaich
#define mosaicv mccan7l_mosaicv
#define r0 mccan7l_r0
#define Q mccan7l_Q
#define DM mccan7l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35155 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an7u. */
  SIG_MESSAGE("an7u (Init)");
#define mccompcurname  an7u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 105
#define mos_rms_y mccan7u_mos_rms_y
#define mos_rms_z mccan7u_mos_rms_z
#define mos_rms_max mccan7u_mos_rms_max
#define mono_Q mccan7u_mono_Q
#define zmin mccan7u_zmin
#define zmax mccan7u_zmax
#define ymin mccan7u_ymin
#define ymax mccan7u_ymax
#define zwidth mccan7u_zwidth
#define yheight mccan7u_yheight
#define mosaich mccan7u_mosaich
#define mosaicv mccan7u_mosaicv
#define r0 mccan7u_r0
#define Q mccan7u_Q
#define DM mccan7u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35210 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an8l. */
  SIG_MESSAGE("an8l (Init)");
#define mccompcurname  an8l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 106
#define mos_rms_y mccan8l_mos_rms_y
#define mos_rms_z mccan8l_mos_rms_z
#define mos_rms_max mccan8l_mos_rms_max
#define mono_Q mccan8l_mono_Q
#define zmin mccan8l_zmin
#define zmax mccan8l_zmax
#define ymin mccan8l_ymin
#define ymax mccan8l_ymax
#define zwidth mccan8l_zwidth
#define yheight mccan8l_yheight
#define mosaich mccan8l_mosaich
#define mosaicv mccan8l_mosaicv
#define r0 mccan8l_r0
#define Q mccan8l_Q
#define DM mccan8l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35265 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an8u. */
  SIG_MESSAGE("an8u (Init)");
#define mccompcurname  an8u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 107
#define mos_rms_y mccan8u_mos_rms_y
#define mos_rms_z mccan8u_mos_rms_z
#define mos_rms_max mccan8u_mos_rms_max
#define mono_Q mccan8u_mono_Q
#define zmin mccan8u_zmin
#define zmax mccan8u_zmax
#define ymin mccan8u_ymin
#define ymax mccan8u_ymax
#define zwidth mccan8u_zwidth
#define yheight mccan8u_yheight
#define mosaich mccan8u_mosaich
#define mosaicv mccan8u_mosaicv
#define r0 mccan8u_r0
#define Q mccan8u_Q
#define DM mccan8u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35320 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an9l. */
  SIG_MESSAGE("an9l (Init)");
#define mccompcurname  an9l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 108
#define mos_rms_y mccan9l_mos_rms_y
#define mos_rms_z mccan9l_mos_rms_z
#define mos_rms_max mccan9l_mos_rms_max
#define mono_Q mccan9l_mono_Q
#define zmin mccan9l_zmin
#define zmax mccan9l_zmax
#define ymin mccan9l_ymin
#define ymax mccan9l_ymax
#define zwidth mccan9l_zwidth
#define yheight mccan9l_yheight
#define mosaich mccan9l_mosaich
#define mosaicv mccan9l_mosaicv
#define r0 mccan9l_r0
#define Q mccan9l_Q
#define DM mccan9l_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35375 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component an9u. */
  SIG_MESSAGE("an9u (Init)");
#define mccompcurname  an9u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 109
#define mos_rms_y mccan9u_mos_rms_y
#define mos_rms_z mccan9u_mos_rms_z
#define mos_rms_max mccan9u_mos_rms_max
#define mono_Q mccan9u_mono_Q
#define zmin mccan9u_zmin
#define zmax mccan9u_zmax
#define ymin mccan9u_ymin
#define ymax mccan9u_ymax
#define zwidth mccan9u_zwidth
#define yheight mccan9u_yheight
#define mosaich mccan9u_mosaich
#define mosaicv mccan9u_mosaicv
#define r0 mccan9u_r0
#define Q mccan9u_Q
#define DM mccan9u_DM
#line 102 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  mos_rms_y = MIN2RAD*mosaicv/sqrt(8*log(2));
  mos_rms_z = MIN2RAD*mosaich/sqrt(8*log(2));
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (zwidth>0)  { zmax = zwidth/2;  zmin=-zmax; }
  if (yheight>0) { ymax = yheight/2; ymin=-ymax; }

  if (zmin==zmax || ymin==ymax)
    exit(fprintf(stderr, "Monochromator_flat: %s : Surface is null (zmin,zmax,ymin,ymax)\n", NAME_CURRENT_COMP));
}
#line 35430 "RITA-II.c"
#undef DM
#undef Q
#undef r0
#undef mosaicv
#undef mosaich
#undef yheight
#undef zwidth
#undef ymax
#undef ymin
#undef zmax
#undef zmin
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component a6. */
  SIG_MESSAGE("a6 (Init)");

  /* Initializations for component emon_before_coarse. */
  SIG_MESSAGE("emon_before_coarse (Init)");
#define mccompcurname  emon_before_coarse
#define mccompcurtype  E_monitor
#define mccompcurindex 111
#define nE mccemon_before_coarse_nE
#define E_N mccemon_before_coarse_E_N
#define E_p mccemon_before_coarse_E_p
#define E_p2 mccemon_before_coarse_E_p2
#define S_p mccemon_before_coarse_S_p
#define S_pE mccemon_before_coarse_S_pE
#define S_pE2 mccemon_before_coarse_S_pE2
#define filename mccemon_before_coarse_filename
#define xmin mccemon_before_coarse_xmin
#define xmax mccemon_before_coarse_xmax
#define ymin mccemon_before_coarse_ymin
#define ymax mccemon_before_coarse_ymax
#define xwidth mccemon_before_coarse_xwidth
#define yheight mccemon_before_coarse_yheight
#define Emin mccemon_before_coarse_Emin
#define Emax mccemon_before_coarse_Emax
#define restore_neutron mccemon_before_coarse_restore_neutron
#define nowritefile mccemon_before_coarse_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 35498 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_before_coarse. */
  SIG_MESSAGE("psd_before_coarse (Init)");
#define mccompcurname  psd_before_coarse
#define mccompcurtype  PSD_monitor
#define mccompcurindex 112
#define nx mccpsd_before_coarse_nx
#define ny mccpsd_before_coarse_ny
#define PSD_N mccpsd_before_coarse_PSD_N
#define PSD_p mccpsd_before_coarse_PSD_p
#define PSD_p2 mccpsd_before_coarse_PSD_p2
#define filename mccpsd_before_coarse_filename
#define xmin mccpsd_before_coarse_xmin
#define xmax mccpsd_before_coarse_xmax
#define ymin mccpsd_before_coarse_ymin
#define ymax mccpsd_before_coarse_ymax
#define xwidth mccpsd_before_coarse_xwidth
#define yheight mccpsd_before_coarse_yheight
#define restore_neutron mccpsd_before_coarse_restore_neutron
#define nowritefile mccpsd_before_coarse_nowritefile
#line 61 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 35562 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmR1. */
  SIG_MESSAGE("ArmR1 (Init)");

  /* Initializations for component BladeR1. */
  SIG_MESSAGE("BladeR1 (Init)");
#define mccompcurname  BladeR1
#define mccompcurtype  Absorber
#define mccompcurindex 114
#define xw mccBladeR1_xw
#define yh mccBladeR1_yh
#define zt mccBladeR1_zt
#define xm mccBladeR1_xm
#define ym mccBladeR1_ym
#define zm mccBladeR1_zm
#define xmin mccBladeR1_xmin
#define xmax mccBladeR1_xmax
#define ymin mccBladeR1_ymin
#define ymax mccBladeR1_ymax
#define zmin mccBladeR1_zmin
#define zmax mccBladeR1_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35612 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmR2. */
  SIG_MESSAGE("ArmR2 (Init)");

  /* Initializations for component BladeR2. */
  SIG_MESSAGE("BladeR2 (Init)");
#define mccompcurname  BladeR2
#define mccompcurtype  Absorber
#define mccompcurindex 116
#define xw mccBladeR2_xw
#define yh mccBladeR2_yh
#define zt mccBladeR2_zt
#define xm mccBladeR2_xm
#define ym mccBladeR2_ym
#define zm mccBladeR2_zm
#define xmin mccBladeR2_xmin
#define xmax mccBladeR2_xmax
#define ymin mccBladeR2_ymin
#define ymax mccBladeR2_ymax
#define zmin mccBladeR2_zmin
#define zmax mccBladeR2_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35660 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmR3. */
  SIG_MESSAGE("ArmR3 (Init)");

  /* Initializations for component BladeR3. */
  SIG_MESSAGE("BladeR3 (Init)");
#define mccompcurname  BladeR3
#define mccompcurtype  Absorber
#define mccompcurindex 118
#define xw mccBladeR3_xw
#define yh mccBladeR3_yh
#define zt mccBladeR3_zt
#define xm mccBladeR3_xm
#define ym mccBladeR3_ym
#define zm mccBladeR3_zm
#define xmin mccBladeR3_xmin
#define xmax mccBladeR3_xmax
#define ymin mccBladeR3_ymin
#define ymax mccBladeR3_ymax
#define zmin mccBladeR3_zmin
#define zmax mccBladeR3_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35708 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmR4. */
  SIG_MESSAGE("ArmR4 (Init)");

  /* Initializations for component BladeR4. */
  SIG_MESSAGE("BladeR4 (Init)");
#define mccompcurname  BladeR4
#define mccompcurtype  Absorber
#define mccompcurindex 120
#define xw mccBladeR4_xw
#define yh mccBladeR4_yh
#define zt mccBladeR4_zt
#define xm mccBladeR4_xm
#define ym mccBladeR4_ym
#define zm mccBladeR4_zm
#define xmin mccBladeR4_xmin
#define xmax mccBladeR4_xmax
#define ymin mccBladeR4_ymin
#define ymax mccBladeR4_ymax
#define zmin mccBladeR4_zmin
#define zmax mccBladeR4_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35756 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmR5. */
  SIG_MESSAGE("ArmR5 (Init)");

  /* Initializations for component BladeR5. */
  SIG_MESSAGE("BladeR5 (Init)");
#define mccompcurname  BladeR5
#define mccompcurtype  Absorber
#define mccompcurindex 122
#define xw mccBladeR5_xw
#define yh mccBladeR5_yh
#define zt mccBladeR5_zt
#define xm mccBladeR5_xm
#define ym mccBladeR5_ym
#define zm mccBladeR5_zm
#define xmin mccBladeR5_xmin
#define xmax mccBladeR5_xmax
#define ymin mccBladeR5_ymin
#define ymax mccBladeR5_ymax
#define zmin mccBladeR5_zmin
#define zmax mccBladeR5_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35804 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmL1. */
  SIG_MESSAGE("ArmL1 (Init)");

  /* Initializations for component BladeL1. */
  SIG_MESSAGE("BladeL1 (Init)");
#define mccompcurname  BladeL1
#define mccompcurtype  Absorber
#define mccompcurindex 124
#define xw mccBladeL1_xw
#define yh mccBladeL1_yh
#define zt mccBladeL1_zt
#define xm mccBladeL1_xm
#define ym mccBladeL1_ym
#define zm mccBladeL1_zm
#define xmin mccBladeL1_xmin
#define xmax mccBladeL1_xmax
#define ymin mccBladeL1_ymin
#define ymax mccBladeL1_ymax
#define zmin mccBladeL1_zmin
#define zmax mccBladeL1_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35852 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmL2. */
  SIG_MESSAGE("ArmL2 (Init)");

  /* Initializations for component BladeL2. */
  SIG_MESSAGE("BladeL2 (Init)");
#define mccompcurname  BladeL2
#define mccompcurtype  Absorber
#define mccompcurindex 126
#define xw mccBladeL2_xw
#define yh mccBladeL2_yh
#define zt mccBladeL2_zt
#define xm mccBladeL2_xm
#define ym mccBladeL2_ym
#define zm mccBladeL2_zm
#define xmin mccBladeL2_xmin
#define xmax mccBladeL2_xmax
#define ymin mccBladeL2_ymin
#define ymax mccBladeL2_ymax
#define zmin mccBladeL2_zmin
#define zmax mccBladeL2_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35900 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmL3. */
  SIG_MESSAGE("ArmL3 (Init)");

  /* Initializations for component BladeL3. */
  SIG_MESSAGE("BladeL3 (Init)");
#define mccompcurname  BladeL3
#define mccompcurtype  Absorber
#define mccompcurindex 128
#define xw mccBladeL3_xw
#define yh mccBladeL3_yh
#define zt mccBladeL3_zt
#define xm mccBladeL3_xm
#define ym mccBladeL3_ym
#define zm mccBladeL3_zm
#define xmin mccBladeL3_xmin
#define xmax mccBladeL3_xmax
#define ymin mccBladeL3_ymin
#define ymax mccBladeL3_ymax
#define zmin mccBladeL3_zmin
#define zmax mccBladeL3_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35948 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmL4. */
  SIG_MESSAGE("ArmL4 (Init)");

  /* Initializations for component BladeL4. */
  SIG_MESSAGE("BladeL4 (Init)");
#define mccompcurname  BladeL4
#define mccompcurtype  Absorber
#define mccompcurindex 130
#define xw mccBladeL4_xw
#define yh mccBladeL4_yh
#define zt mccBladeL4_zt
#define xm mccBladeL4_xm
#define ym mccBladeL4_ym
#define zm mccBladeL4_zm
#define xmin mccBladeL4_xmin
#define xmax mccBladeL4_xmax
#define ymin mccBladeL4_ymin
#define ymax mccBladeL4_ymax
#define zmin mccBladeL4_zmin
#define zmax mccBladeL4_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 35996 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmL5. */
  SIG_MESSAGE("ArmL5 (Init)");

  /* Initializations for component BladeL5. */
  SIG_MESSAGE("BladeL5 (Init)");
#define mccompcurname  BladeL5
#define mccompcurtype  Absorber
#define mccompcurindex 132
#define xw mccBladeL5_xw
#define yh mccBladeL5_yh
#define zt mccBladeL5_zt
#define xm mccBladeL5_xm
#define ym mccBladeL5_ym
#define zm mccBladeL5_zm
#define xmin mccBladeL5_xmin
#define xmax mccBladeL5_xmax
#define ymin mccBladeL5_ymin
#define ymax mccBladeL5_ymax
#define zmin mccBladeL5_zmin
#define zmax mccBladeL5_zmax
#line 47 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
xw = xmax-xmin;
yh = ymax-ymin;
zt = zmax-zmin;
xm = (xmax+xmin)/2;
  ym = (ymax+ymin)/2;
  zm = (zmax+zmin)/2;
  if (xw == 0 || yh == 0 || zt == 0)
    { fprintf(stderr,"Absorber: %s: Error: Slab volume is zero!\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 36044 "RITA-II.c"
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_detector. */
  SIG_MESSAGE("psd_detector (Init)");
#define mccompcurname  psd_detector
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 133
#define nx mccpsd_detector_nx
#define ny mccpsd_detector_ny
#define filename mccpsd_detector_filename
#define PSD_N mccpsd_detector_PSD_N
#define PSD_p mccpsd_detector_PSD_p
#define PSD_p2 mccpsd_detector_PSD_p2
#define weight mccpsd_detector_weight
#define xmin mccpsd_detector_xmin
#define xmax mccpsd_detector_xmax
#define ymin mccpsd_detector_ymin
#define ymax mccpsd_detector_ymax
#define xwidth mccpsd_detector_xwidth
#define yheight mccpsd_detector_yheight
#define psf mccpsd_detector_psf
#define k0 mccpsd_detector_k0
#define eff mccpsd_detector_eff
#define restore_neutron mccpsd_detector_restore_neutron
#define nowritefile mccpsd_detector_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 36106 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_detector. */
  SIG_MESSAGE("emon_detector (Init)");
#define mccompcurname  emon_detector
#define mccompcurtype  E_monitor
#define mccompcurindex 134
#define nE mccemon_detector_nE
#define E_N mccemon_detector_E_N
#define E_p mccemon_detector_E_p
#define E_p2 mccemon_detector_E_p2
#define S_p mccemon_detector_S_p
#define S_pE mccemon_detector_S_pE
#define S_pE2 mccemon_detector_S_pE2
#define filename mccemon_detector_filename
#define xmin mccemon_detector_xmin
#define xmax mccemon_detector_xmax
#define ymin mccemon_detector_ymin
#define ymax mccemon_detector_ymax
#define xwidth mccemon_detector_xwidth
#define yheight mccemon_detector_yheight
#define Emin mccemon_detector_Emin
#define Emax mccemon_detector_Emax
#define restore_neutron mccemon_detector_restore_neutron
#define nowritefile mccemon_detector_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 36174 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window1. */
  SIG_MESSAGE("psd_window1 (Init)");
#define mccompcurname  psd_window1
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 135
#define nx mccpsd_window1_nx
#define ny mccpsd_window1_ny
#define filename mccpsd_window1_filename
#define PSD_N mccpsd_window1_PSD_N
#define PSD_p mccpsd_window1_PSD_p
#define PSD_p2 mccpsd_window1_PSD_p2
#define weight mccpsd_window1_weight
#define xmin mccpsd_window1_xmin
#define xmax mccpsd_window1_xmax
#define ymin mccpsd_window1_ymin
#define ymax mccpsd_window1_ymax
#define xwidth mccpsd_window1_xwidth
#define yheight mccpsd_window1_yheight
#define psf mccpsd_window1_psf
#define k0 mccpsd_window1_k0
#define eff mccpsd_window1_eff
#define restore_neutron mccpsd_window1_restore_neutron
#define nowritefile mccpsd_window1_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 36242 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window1. */
  SIG_MESSAGE("emon_window1 (Init)");
#define mccompcurname  emon_window1
#define mccompcurtype  E_monitor
#define mccompcurindex 136
#define nE mccemon_window1_nE
#define E_N mccemon_window1_E_N
#define E_p mccemon_window1_E_p
#define E_p2 mccemon_window1_E_p2
#define S_p mccemon_window1_S_p
#define S_pE mccemon_window1_S_pE
#define S_pE2 mccemon_window1_S_pE2
#define filename mccemon_window1_filename
#define xmin mccemon_window1_xmin
#define xmax mccemon_window1_xmax
#define ymin mccemon_window1_ymin
#define ymax mccemon_window1_ymax
#define xwidth mccemon_window1_xwidth
#define yheight mccemon_window1_yheight
#define Emin mccemon_window1_Emin
#define Emax mccemon_window1_Emax
#define restore_neutron mccemon_window1_restore_neutron
#define nowritefile mccemon_window1_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 36310 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window2. */
  SIG_MESSAGE("psd_window2 (Init)");
#define mccompcurname  psd_window2
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 137
#define nx mccpsd_window2_nx
#define ny mccpsd_window2_ny
#define filename mccpsd_window2_filename
#define PSD_N mccpsd_window2_PSD_N
#define PSD_p mccpsd_window2_PSD_p
#define PSD_p2 mccpsd_window2_PSD_p2
#define weight mccpsd_window2_weight
#define xmin mccpsd_window2_xmin
#define xmax mccpsd_window2_xmax
#define ymin mccpsd_window2_ymin
#define ymax mccpsd_window2_ymax
#define xwidth mccpsd_window2_xwidth
#define yheight mccpsd_window2_yheight
#define psf mccpsd_window2_psf
#define k0 mccpsd_window2_k0
#define eff mccpsd_window2_eff
#define restore_neutron mccpsd_window2_restore_neutron
#define nowritefile mccpsd_window2_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 36378 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window2. */
  SIG_MESSAGE("emon_window2 (Init)");
#define mccompcurname  emon_window2
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccemon_window2_nE
#define E_N mccemon_window2_E_N
#define E_p mccemon_window2_E_p
#define E_p2 mccemon_window2_E_p2
#define S_p mccemon_window2_S_p
#define S_pE mccemon_window2_S_pE
#define S_pE2 mccemon_window2_S_pE2
#define filename mccemon_window2_filename
#define xmin mccemon_window2_xmin
#define xmax mccemon_window2_xmax
#define ymin mccemon_window2_ymin
#define ymax mccemon_window2_ymax
#define xwidth mccemon_window2_xwidth
#define yheight mccemon_window2_yheight
#define Emin mccemon_window2_Emin
#define Emax mccemon_window2_Emax
#define restore_neutron mccemon_window2_restore_neutron
#define nowritefile mccemon_window2_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 36446 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window3. */
  SIG_MESSAGE("psd_window3 (Init)");
#define mccompcurname  psd_window3
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 139
#define nx mccpsd_window3_nx
#define ny mccpsd_window3_ny
#define filename mccpsd_window3_filename
#define PSD_N mccpsd_window3_PSD_N
#define PSD_p mccpsd_window3_PSD_p
#define PSD_p2 mccpsd_window3_PSD_p2
#define weight mccpsd_window3_weight
#define xmin mccpsd_window3_xmin
#define xmax mccpsd_window3_xmax
#define ymin mccpsd_window3_ymin
#define ymax mccpsd_window3_ymax
#define xwidth mccpsd_window3_xwidth
#define yheight mccpsd_window3_yheight
#define psf mccpsd_window3_psf
#define k0 mccpsd_window3_k0
#define eff mccpsd_window3_eff
#define restore_neutron mccpsd_window3_restore_neutron
#define nowritefile mccpsd_window3_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 36514 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window3. */
  SIG_MESSAGE("emon_window3 (Init)");
#define mccompcurname  emon_window3
#define mccompcurtype  E_monitor
#define mccompcurindex 140
#define nE mccemon_window3_nE
#define E_N mccemon_window3_E_N
#define E_p mccemon_window3_E_p
#define E_p2 mccemon_window3_E_p2
#define S_p mccemon_window3_S_p
#define S_pE mccemon_window3_S_pE
#define S_pE2 mccemon_window3_S_pE2
#define filename mccemon_window3_filename
#define xmin mccemon_window3_xmin
#define xmax mccemon_window3_xmax
#define ymin mccemon_window3_ymin
#define ymax mccemon_window3_ymax
#define xwidth mccemon_window3_xwidth
#define yheight mccemon_window3_yheight
#define Emin mccemon_window3_Emin
#define Emax mccemon_window3_Emax
#define restore_neutron mccemon_window3_restore_neutron
#define nowritefile mccemon_window3_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 36582 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window4. */
  SIG_MESSAGE("psd_window4 (Init)");
#define mccompcurname  psd_window4
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 141
#define nx mccpsd_window4_nx
#define ny mccpsd_window4_ny
#define filename mccpsd_window4_filename
#define PSD_N mccpsd_window4_PSD_N
#define PSD_p mccpsd_window4_PSD_p
#define PSD_p2 mccpsd_window4_PSD_p2
#define weight mccpsd_window4_weight
#define xmin mccpsd_window4_xmin
#define xmax mccpsd_window4_xmax
#define ymin mccpsd_window4_ymin
#define ymax mccpsd_window4_ymax
#define xwidth mccpsd_window4_xwidth
#define yheight mccpsd_window4_yheight
#define psf mccpsd_window4_psf
#define k0 mccpsd_window4_k0
#define eff mccpsd_window4_eff
#define restore_neutron mccpsd_window4_restore_neutron
#define nowritefile mccpsd_window4_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 36650 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window4. */
  SIG_MESSAGE("emon_window4 (Init)");
#define mccompcurname  emon_window4
#define mccompcurtype  E_monitor
#define mccompcurindex 142
#define nE mccemon_window4_nE
#define E_N mccemon_window4_E_N
#define E_p mccemon_window4_E_p
#define E_p2 mccemon_window4_E_p2
#define S_p mccemon_window4_S_p
#define S_pE mccemon_window4_S_pE
#define S_pE2 mccemon_window4_S_pE2
#define filename mccemon_window4_filename
#define xmin mccemon_window4_xmin
#define xmax mccemon_window4_xmax
#define ymin mccemon_window4_ymin
#define ymax mccemon_window4_ymax
#define xwidth mccemon_window4_xwidth
#define yheight mccemon_window4_yheight
#define Emin mccemon_window4_Emin
#define Emax mccemon_window4_Emax
#define restore_neutron mccemon_window4_restore_neutron
#define nowritefile mccemon_window4_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 36718 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window5. */
  SIG_MESSAGE("psd_window5 (Init)");
#define mccompcurname  psd_window5
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 143
#define nx mccpsd_window5_nx
#define ny mccpsd_window5_ny
#define filename mccpsd_window5_filename
#define PSD_N mccpsd_window5_PSD_N
#define PSD_p mccpsd_window5_PSD_p
#define PSD_p2 mccpsd_window5_PSD_p2
#define weight mccpsd_window5_weight
#define xmin mccpsd_window5_xmin
#define xmax mccpsd_window5_xmax
#define ymin mccpsd_window5_ymin
#define ymax mccpsd_window5_ymax
#define xwidth mccpsd_window5_xwidth
#define yheight mccpsd_window5_yheight
#define psf mccpsd_window5_psf
#define k0 mccpsd_window5_k0
#define eff mccpsd_window5_eff
#define restore_neutron mccpsd_window5_restore_neutron
#define nowritefile mccpsd_window5_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 36786 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window5. */
  SIG_MESSAGE("emon_window5 (Init)");
#define mccompcurname  emon_window5
#define mccompcurtype  E_monitor
#define mccompcurindex 144
#define nE mccemon_window5_nE
#define E_N mccemon_window5_E_N
#define E_p mccemon_window5_E_p
#define E_p2 mccemon_window5_E_p2
#define S_p mccemon_window5_S_p
#define S_pE mccemon_window5_S_pE
#define S_pE2 mccemon_window5_S_pE2
#define filename mccemon_window5_filename
#define xmin mccemon_window5_xmin
#define xmax mccemon_window5_xmax
#define ymin mccemon_window5_ymin
#define ymax mccemon_window5_ymax
#define xwidth mccemon_window5_xwidth
#define yheight mccemon_window5_yheight
#define Emin mccemon_window5_Emin
#define Emax mccemon_window5_Emax
#define restore_neutron mccemon_window5_restore_neutron
#define nowritefile mccemon_window5_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 36854 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window6. */
  SIG_MESSAGE("psd_window6 (Init)");
#define mccompcurname  psd_window6
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 145
#define nx mccpsd_window6_nx
#define ny mccpsd_window6_ny
#define filename mccpsd_window6_filename
#define PSD_N mccpsd_window6_PSD_N
#define PSD_p mccpsd_window6_PSD_p
#define PSD_p2 mccpsd_window6_PSD_p2
#define weight mccpsd_window6_weight
#define xmin mccpsd_window6_xmin
#define xmax mccpsd_window6_xmax
#define ymin mccpsd_window6_ymin
#define ymax mccpsd_window6_ymax
#define xwidth mccpsd_window6_xwidth
#define yheight mccpsd_window6_yheight
#define psf mccpsd_window6_psf
#define k0 mccpsd_window6_k0
#define eff mccpsd_window6_eff
#define restore_neutron mccpsd_window6_restore_neutron
#define nowritefile mccpsd_window6_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 36922 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window6. */
  SIG_MESSAGE("emon_window6 (Init)");
#define mccompcurname  emon_window6
#define mccompcurtype  E_monitor
#define mccompcurindex 146
#define nE mccemon_window6_nE
#define E_N mccemon_window6_E_N
#define E_p mccemon_window6_E_p
#define E_p2 mccemon_window6_E_p2
#define S_p mccemon_window6_S_p
#define S_pE mccemon_window6_S_pE
#define S_pE2 mccemon_window6_S_pE2
#define filename mccemon_window6_filename
#define xmin mccemon_window6_xmin
#define xmax mccemon_window6_xmax
#define ymin mccemon_window6_ymin
#define ymax mccemon_window6_ymax
#define xwidth mccemon_window6_xwidth
#define yheight mccemon_window6_yheight
#define Emin mccemon_window6_Emin
#define Emax mccemon_window6_Emax
#define restore_neutron mccemon_window6_restore_neutron
#define nowritefile mccemon_window6_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 36990 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window7. */
  SIG_MESSAGE("psd_window7 (Init)");
#define mccompcurname  psd_window7
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 147
#define nx mccpsd_window7_nx
#define ny mccpsd_window7_ny
#define filename mccpsd_window7_filename
#define PSD_N mccpsd_window7_PSD_N
#define PSD_p mccpsd_window7_PSD_p
#define PSD_p2 mccpsd_window7_PSD_p2
#define weight mccpsd_window7_weight
#define xmin mccpsd_window7_xmin
#define xmax mccpsd_window7_xmax
#define ymin mccpsd_window7_ymin
#define ymax mccpsd_window7_ymax
#define xwidth mccpsd_window7_xwidth
#define yheight mccpsd_window7_yheight
#define psf mccpsd_window7_psf
#define k0 mccpsd_window7_k0
#define eff mccpsd_window7_eff
#define restore_neutron mccpsd_window7_restore_neutron
#define nowritefile mccpsd_window7_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 37058 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window7. */
  SIG_MESSAGE("emon_window7 (Init)");
#define mccompcurname  emon_window7
#define mccompcurtype  E_monitor
#define mccompcurindex 148
#define nE mccemon_window7_nE
#define E_N mccemon_window7_E_N
#define E_p mccemon_window7_E_p
#define E_p2 mccemon_window7_E_p2
#define S_p mccemon_window7_S_p
#define S_pE mccemon_window7_S_pE
#define S_pE2 mccemon_window7_S_pE2
#define filename mccemon_window7_filename
#define xmin mccemon_window7_xmin
#define xmax mccemon_window7_xmax
#define ymin mccemon_window7_ymin
#define ymax mccemon_window7_ymax
#define xwidth mccemon_window7_xwidth
#define yheight mccemon_window7_yheight
#define Emin mccemon_window7_Emin
#define Emax mccemon_window7_Emax
#define restore_neutron mccemon_window7_restore_neutron
#define nowritefile mccemon_window7_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 37126 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window8. */
  SIG_MESSAGE("psd_window8 (Init)");
#define mccompcurname  psd_window8
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 149
#define nx mccpsd_window8_nx
#define ny mccpsd_window8_ny
#define filename mccpsd_window8_filename
#define PSD_N mccpsd_window8_PSD_N
#define PSD_p mccpsd_window8_PSD_p
#define PSD_p2 mccpsd_window8_PSD_p2
#define weight mccpsd_window8_weight
#define xmin mccpsd_window8_xmin
#define xmax mccpsd_window8_xmax
#define ymin mccpsd_window8_ymin
#define ymax mccpsd_window8_ymax
#define xwidth mccpsd_window8_xwidth
#define yheight mccpsd_window8_yheight
#define psf mccpsd_window8_psf
#define k0 mccpsd_window8_k0
#define eff mccpsd_window8_eff
#define restore_neutron mccpsd_window8_restore_neutron
#define nowritefile mccpsd_window8_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 37194 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window8. */
  SIG_MESSAGE("emon_window8 (Init)");
#define mccompcurname  emon_window8
#define mccompcurtype  E_monitor
#define mccompcurindex 150
#define nE mccemon_window8_nE
#define E_N mccemon_window8_E_N
#define E_p mccemon_window8_E_p
#define E_p2 mccemon_window8_E_p2
#define S_p mccemon_window8_S_p
#define S_pE mccemon_window8_S_pE
#define S_pE2 mccemon_window8_S_pE2
#define filename mccemon_window8_filename
#define xmin mccemon_window8_xmin
#define xmax mccemon_window8_xmax
#define ymin mccemon_window8_ymin
#define ymax mccemon_window8_ymax
#define xwidth mccemon_window8_xwidth
#define yheight mccemon_window8_yheight
#define Emin mccemon_window8_Emin
#define Emax mccemon_window8_Emax
#define restore_neutron mccemon_window8_restore_neutron
#define nowritefile mccemon_window8_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 37262 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component psd_window9. */
  SIG_MESSAGE("psd_window9 (Init)");
#define mccompcurname  psd_window9
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 151
#define nx mccpsd_window9_nx
#define ny mccpsd_window9_ny
#define filename mccpsd_window9_filename
#define PSD_N mccpsd_window9_PSD_N
#define PSD_p mccpsd_window9_PSD_p
#define PSD_p2 mccpsd_window9_PSD_p2
#define weight mccpsd_window9_weight
#define xmin mccpsd_window9_xmin
#define xmax mccpsd_window9_xmax
#define ymin mccpsd_window9_ymin
#define ymax mccpsd_window9_ymax
#define xwidth mccpsd_window9_xwidth
#define yheight mccpsd_window9_yheight
#define psf mccpsd_window9_psf
#define k0 mccpsd_window9_k0
#define eff mccpsd_window9_eff
#define restore_neutron mccpsd_window9_restore_neutron
#define nowritefile mccpsd_window9_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 37330 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef eff
#undef k0
#undef psf
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component emon_window9. */
  SIG_MESSAGE("emon_window9 (Init)");
#define mccompcurname  emon_window9
#define mccompcurtype  E_monitor
#define mccompcurindex 152
#define nE mccemon_window9_nE
#define E_N mccemon_window9_E_N
#define E_p mccemon_window9_E_p
#define E_p2 mccemon_window9_E_p2
#define S_p mccemon_window9_S_p
#define S_pE mccemon_window9_S_pE
#define S_pE2 mccemon_window9_S_pE2
#define filename mccemon_window9_filename
#define xmin mccemon_window9_xmin
#define xmax mccemon_window9_xmax
#define ymin mccemon_window9_ymin
#define ymax mccemon_window9_ymax
#define xwidth mccemon_window9_xwidth
#define yheight mccemon_window9_yheight
#define Emin mccemon_window9_Emin
#define Emax mccemon_window9_Emax
#define restore_neutron mccemon_window9_restore_neutron
#define nowritefile mccemon_window9_nowritefile
#line 66 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 37398 "RITA-II.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if(mcdotrace) mcdisplay();
    mcDEBUG_INSTR_END()
  }

} /* end init */

void mcraytrace(void) {
  /* Neutronics-specific defines */
#ifdef NEUTRONICS
extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;
#endif
  /* End of Neutronics-specific defines */
  /* Copy neutron state to local variables. */
  MCNUM mcnlx = mcnx;
  MCNUM mcnly = mcny;
  MCNUM mcnlz = mcnz;
  MCNUM mcnlvx = mcnvx;
  MCNUM mcnlvy = mcnvy;
  MCNUM mcnlvz = mcnvz;
  MCNUM mcnlt = mcnt;
  MCNUM mcnlsx = mcnsx;
  MCNUM mcnlsy = mcnsy;
  MCNUM mcnlsz = mcnsz;
  MCNUM mcnlp = mcnp;

  mcDEBUG_ENTER()
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define mcabsorb mcabsorbAll
  /* SPLIT counter for component monochromator_curved */
  int mcSplit_monochromator_curved=0;
  /* SPLIT counter for component a3 */
  int mcSplit_a3=0;
  /* SPLIT counter for component focus_ana */
  int mcSplit_focus_ana=0;
  /* TRACE Component armSource [1] */
  mccoordschange(mcposrarmSource, mcrotrarmSource,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component armSource (without coords transformations) */
  mcJumpTrace_armSource:
  SIG_MESSAGE("armSource (Trace)");
  mcDEBUG_COMP("armSource")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparmSource
  STORE_NEUTRON(1,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[1]++;
  mcPCounter[1] += p;
  mcP2Counter[1] += p*p;
#define mccompcurname  armSource
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccarmSource_IntermediateCnts
#define StartTime mccarmSource_StartTime
#define EndTime mccarmSource_EndTime
#define CurrentTime mccarmSource_CurrentTime
{   /* Declarations of armSource=Progress_bar() SETTING parameters. */
char* profile = mccarmSource_profile;
MCNUM percent = mccarmSource_percent;
MCNUM flag_save = mccarmSource_flag_save;
MCNUM minutes = mccarmSource_minutes;
#line 70 "/usr/share/mcstas/2.5/misc/Progress_bar.comp"
{
  double ncount;
  ncount = mcget_run_num();
  if (!StartTime) {
    time(&StartTime); /* compute starting time */
    IntermediateCnts = 1e3;
  }
  time_t NowTime;
  time(&NowTime);
  /* compute initial estimate of computation duration */
  if (!EndTime && ncount >= IntermediateCnts) {
    CurrentTime = NowTime;
    if (difftime(NowTime,StartTime) > 10 && ncount) { /* wait 10 sec before writing ETA */
      EndTime = StartTime + (time_t)(difftime(NowTime,StartTime)
				     *(double)mcget_ncount()/ncount);
      IntermediateCnts = 0;
      fprintf(stdout, "\nTrace ETA ");
      if (difftime(EndTime,StartTime) < 60.0)
        fprintf(stdout, "%g [s] %% ", difftime(EndTime,StartTime));
      else if (difftime(EndTime,StartTime) > 3600.0)
        fprintf(stdout, "%g [h] %% ", difftime(EndTime,StartTime)/3600.0);
      else
        fprintf(stdout, "%g [min] %% ", difftime(EndTime,StartTime)/60.0);
    } else IntermediateCnts += 1e3;
    fflush(stdout);
  }

  /* display percentage when percent or minutes have reached step */
  if (EndTime && mcget_ncount() &&
    (    (minutes && difftime(NowTime,CurrentTime) > minutes*60)
      || (percent && !minutes && ncount >= IntermediateCnts))   )
  {
    fprintf(stdout, "%d ", (int)(ncount*100.0/mcget_ncount())); fflush(stdout);
    CurrentTime = NowTime;

    IntermediateCnts = ncount + percent*mcget_ncount()/100;
    /* check that next intermediate ncount check is a multiple of the desired percentage */
    IntermediateCnts = floor(IntermediateCnts*100/percent/mcget_ncount())*percent*mcget_ncount()/100;
    /* raise flag to indicate that we did something */
    SCATTER;
    if (flag_save) mcsave(NULL);
  }
}
#line 37580 "RITA-II.c"
}   /* End of armSource=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparmSource:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(1,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component source [2] */
  mccoordschange(mcposrsource, mcrotrsource,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component source (without coords transformations) */
  mcJumpTrace_source:
  SIG_MESSAGE("source (Trace)");
  mcDEBUG_COMP("source")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsource
  STORE_NEUTRON(2,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[2]++;
  mcPCounter[2] += p;
  mcP2Counter[2] += p*p;
#define mccompcurname  source
#define mccompcurtype  Source_gen4
#define mccompcurindex 2
#define flux_file mccsource_flux_file
#define xdiv_file mccsource_xdiv_file
#define ydiv_file mccsource_ydiv_file
#define p_in mccsource_p_in
#define lambda0 mccsource_lambda0
#define lambda02 mccsource_lambda02
#define L2P mccsource_L2P
#define lambda0b mccsource_lambda0b
#define lambda02b mccsource_lambda02b
#define L2Pb mccsource_L2Pb
#define lambda0c mccsource_lambda0c
#define lambda02c mccsource_lambda02c
#define L2Pc mccsource_L2Pc
#define pTable mccsource_pTable
#define pTable_x mccsource_pTable_x
#define pTable_y mccsource_pTable_y
{   /* Declarations of source=Source_gen4() SETTING parameters. */
MCNUM radius = mccsource_radius;
MCNUM dist = mccsource_dist;
MCNUM xw = mccsource_xw;
MCNUM yh = mccsource_yh;
MCNUM E0 = mccsource_E0;
MCNUM dE = mccsource_dE;
MCNUM Lambda0 = mccsource_Lambda0;
MCNUM dLambda = mccsource_dLambda;
MCNUM I1 = mccsource_I1;
MCNUM h = mccsource_h;
MCNUM w = mccsource_w;
MCNUM gaussian = mccsource_gaussian;
MCNUM verbose = mccsource_verbose;
MCNUM T1 = mccsource_T1;
MCNUM flux_file_perAA = mccsource_flux_file_perAA;
MCNUM flux_file_log = mccsource_flux_file_log;
MCNUM Lmin = mccsource_Lmin;
MCNUM Lmax = mccsource_Lmax;
MCNUM Emin = mccsource_Emin;
MCNUM Emax = mccsource_Emax;
MCNUM T2 = mccsource_T2;
MCNUM I2 = mccsource_I2;
MCNUM T3 = mccsource_T3;
MCNUM I3 = mccsource_I3;
MCNUM length = mccsource_length;
MCNUM phi_init = mccsource_phi_init;
MCNUM theta_init = mccsource_theta_init;
MCNUM HEtailA = mccsource_HEtailA;
MCNUM HEtailL0 = mccsource_HEtailL0;
/* 'source=Source_gen4()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 469 "/usr/share/mcstas/2.5/contrib/Source_gen4.comp"
{
  double theta0,phi0,theta1,phi1,chi,theta,phi,v,r, lambda;
  double tan_h, tan_v, Maxwell, lambda2, lambda5;

  if (verbose >= 0)
  {

    z=0;

    if ((h == 0) || (w == 0))
    {
      chi=2*PI*rand01();                          /* Choose point on source */
      r=sqrt(rand01())*radius;                    /* with uniform distribution. */
      x=r*cos(chi);
      y=r*sin(chi);
    }
    else
    {
      x = w*randpm1()/2;   /* select point on source (uniform) */
      y = h*randpm1()/2;
    }
    if (length != 0)
      z = length*randpm1()/2;

    if (dist == 0)
    {
      theta0 =  DEG2RAD*xw/2;
      phi0   =  DEG2RAD*yh/2;
      theta1 = -DEG2RAD*xw/2;
      phi1   = -DEG2RAD*yh/2;
    }
    else
    {
      theta0= -atan((x-xw/2.0)/dist)+theta_init/180*3.1415;              /* Angles to aim at target */
      phi0  = -atan((y-yh/2.0)/dist)+phi_init/180*3.1415;
      theta1= -atan((x+xw/2.0)/dist)+theta_init/180*3.1415;
      phi1  = -atan((y+yh/2.0)/dist)+phi_init/180*3.1415;
    }

    /* shot towards target : flat distribution */

    if (gaussian)
    {
      theta= theta0+(theta1- theta0)*(randnorm()*FWHM2RMS+0.5);
      phi  = phi0  +(phi1  - phi0)  *(randnorm()*FWHM2RMS+0.5);
    }
    else
    {
      theta= theta0+(theta1- theta0)*rand01();
      phi  = phi0  +(phi1  - phi0)  *rand01();
    }
    /* Assume linear distribution */
    lambda = Lambda0+dLambda*randpm1();
    if (lambda <= 0) ABSORB;

    v = K2V*(2*PI/lambda);
    p = p_in;
    if (!flux_file  || !strlen(flux_file))
      p *=  2 * fabs((theta1 - theta0)*sin((phi1 - phi0)/2)); /* solid angle */
    p *= cos(phi)*cos(theta);
    if (flux_file && strlen(flux_file) > 0)
    {
       double w=Table_Value(pTable, lambda, 1);
       if (flux_file_log) w=exp(w);
       p *= w;
    }
    else if (T1 > 0 && I1 > 0)
    {
      lambda2 = lambda*lambda;
      lambda5 = lambda2*lambda2*lambda;
      Maxwell = I1 * L2P/lambda5 * exp(-lambda02/lambda2);  /* 1/AA */

      if ((T2 > 0) && (I2 > 0))
      {
        Maxwell += I2 * L2Pb/lambda5 * exp(-lambda02b/lambda2);
      }
      if ((T3 > 0) && (I3 > 0))
      {
        Maxwell += I3 * L2Pc/lambda5 * exp(-lambda02c/lambda2);
      }
      if (HEtailA>0)
      {
        Maxwell+=HEtailA/(lambda-HEtailL0)/(lambda-HEtailL0);
      }
      p *= Maxwell;
    }

    /* Perform the correct treatment - no small angle approx. here! */
    tan_h = tan(theta);
    tan_v = tan(phi);
    vz = v / sqrt(1 + tan_v*tan_v + tan_h*tan_h);
    vy = tan_v * vz;
    vx = tan_h * vz;
    /* optional x-xdiv and y-ydiv weightening: position=along columns, div=along rows */
    if (xdiv_file && strlen(xdiv_file) > 0 && pTable_xsum > 0) {
      double i,j;
      j = (x-            pTable_xmin) /(pTable_xmax -pTable_xmin) *pTable_x.columns;
      i = (theta*RAD2DEG-pTable_dxmin)/(pTable_dxmax-pTable_dxmin)*pTable_x.rows;
      r = Table_Value2d(pTable_x, i,j); /* row, column */
      p *= r/pTable_xsum;
    }
    if (ydiv_file && strlen(ydiv_file) > 0 && pTable_ysum > 0) {
      double i,j;
      j = (y-            pTable_ymin) /(pTable_ymax -pTable_ymin) *pTable_y.columns;
      i = (phi*RAD2DEG-  pTable_dymin)/(pTable_dymax-pTable_dymin)*pTable_y.rows;
      r = Table_Value2d(pTable_y, i,j);
      p *= r/pTable_ysum;
    }
    SCATTER;
  }
}
#line 37849 "RITA-II.c"
}   /* End of source=Source_gen4() SETTING parameter declarations. */
#undef pTable_y
#undef pTable_x
#undef pTable
#undef L2Pc
#undef lambda02c
#undef lambda0c
#undef L2Pb
#undef lambda02b
#undef lambda0b
#undef L2P
#undef lambda02
#undef lambda0
#undef p_in
#undef ydiv_file
#undef xdiv_file
#undef flux_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsource:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(2,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component slitGuideBegin [3] */
  mccoordschange(mcposrslitGuideBegin, mcrotrslitGuideBegin,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component slitGuideBegin (without coords transformations) */
  mcJumpTrace_slitGuideBegin:
  SIG_MESSAGE("slitGuideBegin (Trace)");
  mcDEBUG_COMP("slitGuideBegin")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompslitGuideBegin
  STORE_NEUTRON(3,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[3]++;
  mcPCounter[3] += p;
  mcP2Counter[3] += p*p;
#define mccompcurname  slitGuideBegin
#define mccompcurtype  Slit
#define mccompcurindex 3
{   /* Declarations of slitGuideBegin=Slit() SETTING parameters. */
MCNUM xmin = mccslitGuideBegin_xmin;
MCNUM xmax = mccslitGuideBegin_xmax;
MCNUM ymin = mccslitGuideBegin_ymin;
MCNUM ymax = mccslitGuideBegin_ymax;
MCNUM radius = mccslitGuideBegin_radius;
MCNUM xwidth = mccslitGuideBegin_xwidth;
MCNUM yheight = mccslitGuideBegin_yheight;
/* 'slitGuideBegin=Slit()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 71 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 37989 "RITA-II.c"
}   /* End of slitGuideBegin=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompslitGuideBegin:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(3,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component lmon_guide_start [4] */
  mccoordschange(mcposrlmon_guide_start, mcrotrlmon_guide_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component lmon_guide_start (without coords transformations) */
  mcJumpTrace_lmon_guide_start:
  SIG_MESSAGE("lmon_guide_start (Trace)");
  mcDEBUG_COMP("lmon_guide_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComplmon_guide_start
  STORE_NEUTRON(4,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[4]++;
  mcPCounter[4] += p;
  mcP2Counter[4] += p*p;
#define mccompcurname  lmon_guide_start
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mcclmon_guide_start_nL
#define L_N mcclmon_guide_start_L_N
#define L_p mcclmon_guide_start_L_p
#define L_p2 mcclmon_guide_start_L_p2
{   /* Declarations of lmon_guide_start=L_monitor() SETTING parameters. */
char* filename = mcclmon_guide_start_filename;
MCNUM xmin = mcclmon_guide_start_xmin;
MCNUM xmax = mcclmon_guide_start_xmax;
MCNUM ymin = mcclmon_guide_start_ymin;
MCNUM ymax = mcclmon_guide_start_ymax;
MCNUM xwidth = mcclmon_guide_start_xwidth;
MCNUM yheight = mcclmon_guide_start_yheight;
MCNUM Lmin = mcclmon_guide_start_Lmin;
MCNUM Lmax = mcclmon_guide_start_Lmax;
MCNUM restore_neutron = mcclmon_guide_start_restore_neutron;
int nowritefile = mcclmon_guide_start_nowritefile;
/* 'lmon_guide_start=L_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 84 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 38134 "RITA-II.c"
}   /* End of lmon_guide_start=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComplmon_guide_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(4,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideStraight [5] */
  mccoordschange(mcposrguideStraight, mcrotrguideStraight,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideStraight (without coords transformations) */
  mcJumpTrace_guideStraight:
  SIG_MESSAGE("guideStraight (Trace)");
  mcDEBUG_COMP("guideStraight")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideStraight
  STORE_NEUTRON(5,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[5]++;
  mcPCounter[5] += p;
  mcP2Counter[5] += p*p;
#define mccompcurname  guideStraight
#define mccompcurtype  Guide
#define mccompcurindex 5
#define pTable mccguideStraight_pTable
{   /* Declarations of guideStraight=Guide() SETTING parameters. */
char* reflect = mccguideStraight_reflect;
MCNUM w1 = mccguideStraight_w1;
MCNUM h1 = mccguideStraight_h1;
MCNUM w2 = mccguideStraight_w2;
MCNUM h2 = mccguideStraight_h2;
MCNUM l = mccguideStraight_l;
MCNUM R0 = mccguideStraight_R0;
MCNUM Qc = mccguideStraight_Qc;
MCNUM alpha = mccguideStraight_alpha;
MCNUM m = mccguideStraight_m;
MCNUM W = mccguideStraight_W;
/* 'guideStraight=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 38365 "RITA-II.c"
}   /* End of guideStraight=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideStraight:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(5,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved1 [6] */
  mccoordschange(mcposrguideCurved1, mcrotrguideCurved1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved1 (without coords transformations) */
  mcJumpTrace_guideCurved1:
  SIG_MESSAGE("guideCurved1 (Trace)");
  mcDEBUG_COMP("guideCurved1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved1
  STORE_NEUTRON(6,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[6]++;
  mcPCounter[6] += p;
  mcP2Counter[6] += p*p;
#define mccompcurname  guideCurved1
#define mccompcurtype  Guide
#define mccompcurindex 6
#define pTable mccguideCurved1_pTable
{   /* Declarations of guideCurved1=Guide() SETTING parameters. */
char* reflect = mccguideCurved1_reflect;
MCNUM w1 = mccguideCurved1_w1;
MCNUM h1 = mccguideCurved1_h1;
MCNUM w2 = mccguideCurved1_w2;
MCNUM h2 = mccguideCurved1_h2;
MCNUM l = mccguideCurved1_l;
MCNUM R0 = mccguideCurved1_R0;
MCNUM Qc = mccguideCurved1_Qc;
MCNUM alpha = mccguideCurved1_alpha;
MCNUM m = mccguideCurved1_m;
MCNUM W = mccguideCurved1_W;
/* 'guideCurved1=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 38593 "RITA-II.c"
}   /* End of guideCurved1=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(6,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved2 [7] */
  mccoordschange(mcposrguideCurved2, mcrotrguideCurved2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved2 (without coords transformations) */
  mcJumpTrace_guideCurved2:
  SIG_MESSAGE("guideCurved2 (Trace)");
  mcDEBUG_COMP("guideCurved2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved2
  STORE_NEUTRON(7,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[7]++;
  mcPCounter[7] += p;
  mcP2Counter[7] += p*p;
#define mccompcurname  guideCurved2
#define mccompcurtype  Guide
#define mccompcurindex 7
#define pTable mccguideCurved2_pTable
{   /* Declarations of guideCurved2=Guide() SETTING parameters. */
char* reflect = mccguideCurved2_reflect;
MCNUM w1 = mccguideCurved2_w1;
MCNUM h1 = mccguideCurved2_h1;
MCNUM w2 = mccguideCurved2_w2;
MCNUM h2 = mccguideCurved2_h2;
MCNUM l = mccguideCurved2_l;
MCNUM R0 = mccguideCurved2_R0;
MCNUM Qc = mccguideCurved2_Qc;
MCNUM alpha = mccguideCurved2_alpha;
MCNUM m = mccguideCurved2_m;
MCNUM W = mccguideCurved2_W;
/* 'guideCurved2=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 38821 "RITA-II.c"
}   /* End of guideCurved2=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(7,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved3 [8] */
  mccoordschange(mcposrguideCurved3, mcrotrguideCurved3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved3 (without coords transformations) */
  mcJumpTrace_guideCurved3:
  SIG_MESSAGE("guideCurved3 (Trace)");
  mcDEBUG_COMP("guideCurved3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved3
  STORE_NEUTRON(8,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[8]++;
  mcPCounter[8] += p;
  mcP2Counter[8] += p*p;
#define mccompcurname  guideCurved3
#define mccompcurtype  Guide
#define mccompcurindex 8
#define pTable mccguideCurved3_pTable
{   /* Declarations of guideCurved3=Guide() SETTING parameters. */
char* reflect = mccguideCurved3_reflect;
MCNUM w1 = mccguideCurved3_w1;
MCNUM h1 = mccguideCurved3_h1;
MCNUM w2 = mccguideCurved3_w2;
MCNUM h2 = mccguideCurved3_h2;
MCNUM l = mccguideCurved3_l;
MCNUM R0 = mccguideCurved3_R0;
MCNUM Qc = mccguideCurved3_Qc;
MCNUM alpha = mccguideCurved3_alpha;
MCNUM m = mccguideCurved3_m;
MCNUM W = mccguideCurved3_W;
/* 'guideCurved3=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 39049 "RITA-II.c"
}   /* End of guideCurved3=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(8,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved4 [9] */
  mccoordschange(mcposrguideCurved4, mcrotrguideCurved4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved4 (without coords transformations) */
  mcJumpTrace_guideCurved4:
  SIG_MESSAGE("guideCurved4 (Trace)");
  mcDEBUG_COMP("guideCurved4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved4
  STORE_NEUTRON(9,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[9]++;
  mcPCounter[9] += p;
  mcP2Counter[9] += p*p;
#define mccompcurname  guideCurved4
#define mccompcurtype  Guide
#define mccompcurindex 9
#define pTable mccguideCurved4_pTable
{   /* Declarations of guideCurved4=Guide() SETTING parameters. */
char* reflect = mccguideCurved4_reflect;
MCNUM w1 = mccguideCurved4_w1;
MCNUM h1 = mccguideCurved4_h1;
MCNUM w2 = mccguideCurved4_w2;
MCNUM h2 = mccguideCurved4_h2;
MCNUM l = mccguideCurved4_l;
MCNUM R0 = mccguideCurved4_R0;
MCNUM Qc = mccguideCurved4_Qc;
MCNUM alpha = mccguideCurved4_alpha;
MCNUM m = mccguideCurved4_m;
MCNUM W = mccguideCurved4_W;
/* 'guideCurved4=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 39277 "RITA-II.c"
}   /* End of guideCurved4=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(9,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved5 [10] */
  mccoordschange(mcposrguideCurved5, mcrotrguideCurved5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved5 (without coords transformations) */
  mcJumpTrace_guideCurved5:
  SIG_MESSAGE("guideCurved5 (Trace)");
  mcDEBUG_COMP("guideCurved5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved5
  STORE_NEUTRON(10,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[10]++;
  mcPCounter[10] += p;
  mcP2Counter[10] += p*p;
#define mccompcurname  guideCurved5
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccguideCurved5_pTable
{   /* Declarations of guideCurved5=Guide() SETTING parameters. */
char* reflect = mccguideCurved5_reflect;
MCNUM w1 = mccguideCurved5_w1;
MCNUM h1 = mccguideCurved5_h1;
MCNUM w2 = mccguideCurved5_w2;
MCNUM h2 = mccguideCurved5_h2;
MCNUM l = mccguideCurved5_l;
MCNUM R0 = mccguideCurved5_R0;
MCNUM Qc = mccguideCurved5_Qc;
MCNUM alpha = mccguideCurved5_alpha;
MCNUM m = mccguideCurved5_m;
MCNUM W = mccguideCurved5_W;
/* 'guideCurved5=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 39505 "RITA-II.c"
}   /* End of guideCurved5=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(10,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved6 [11] */
  mccoordschange(mcposrguideCurved6, mcrotrguideCurved6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved6 (without coords transformations) */
  mcJumpTrace_guideCurved6:
  SIG_MESSAGE("guideCurved6 (Trace)");
  mcDEBUG_COMP("guideCurved6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved6
  STORE_NEUTRON(11,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[11]++;
  mcPCounter[11] += p;
  mcP2Counter[11] += p*p;
#define mccompcurname  guideCurved6
#define mccompcurtype  Guide
#define mccompcurindex 11
#define pTable mccguideCurved6_pTable
{   /* Declarations of guideCurved6=Guide() SETTING parameters. */
char* reflect = mccguideCurved6_reflect;
MCNUM w1 = mccguideCurved6_w1;
MCNUM h1 = mccguideCurved6_h1;
MCNUM w2 = mccguideCurved6_w2;
MCNUM h2 = mccguideCurved6_h2;
MCNUM l = mccguideCurved6_l;
MCNUM R0 = mccguideCurved6_R0;
MCNUM Qc = mccguideCurved6_Qc;
MCNUM alpha = mccguideCurved6_alpha;
MCNUM m = mccguideCurved6_m;
MCNUM W = mccguideCurved6_W;
/* 'guideCurved6=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 39733 "RITA-II.c"
}   /* End of guideCurved6=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(11,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved7 [12] */
  mccoordschange(mcposrguideCurved7, mcrotrguideCurved7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved7 (without coords transformations) */
  mcJumpTrace_guideCurved7:
  SIG_MESSAGE("guideCurved7 (Trace)");
  mcDEBUG_COMP("guideCurved7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved7
  STORE_NEUTRON(12,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[12]++;
  mcPCounter[12] += p;
  mcP2Counter[12] += p*p;
#define mccompcurname  guideCurved7
#define mccompcurtype  Guide
#define mccompcurindex 12
#define pTable mccguideCurved7_pTable
{   /* Declarations of guideCurved7=Guide() SETTING parameters. */
char* reflect = mccguideCurved7_reflect;
MCNUM w1 = mccguideCurved7_w1;
MCNUM h1 = mccguideCurved7_h1;
MCNUM w2 = mccguideCurved7_w2;
MCNUM h2 = mccguideCurved7_h2;
MCNUM l = mccguideCurved7_l;
MCNUM R0 = mccguideCurved7_R0;
MCNUM Qc = mccguideCurved7_Qc;
MCNUM alpha = mccguideCurved7_alpha;
MCNUM m = mccguideCurved7_m;
MCNUM W = mccguideCurved7_W;
/* 'guideCurved7=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 39961 "RITA-II.c"
}   /* End of guideCurved7=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(12,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved8 [13] */
  mccoordschange(mcposrguideCurved8, mcrotrguideCurved8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved8 (without coords transformations) */
  mcJumpTrace_guideCurved8:
  SIG_MESSAGE("guideCurved8 (Trace)");
  mcDEBUG_COMP("guideCurved8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved8
  STORE_NEUTRON(13,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[13]++;
  mcPCounter[13] += p;
  mcP2Counter[13] += p*p;
#define mccompcurname  guideCurved8
#define mccompcurtype  Guide
#define mccompcurindex 13
#define pTable mccguideCurved8_pTable
{   /* Declarations of guideCurved8=Guide() SETTING parameters. */
char* reflect = mccguideCurved8_reflect;
MCNUM w1 = mccguideCurved8_w1;
MCNUM h1 = mccguideCurved8_h1;
MCNUM w2 = mccguideCurved8_w2;
MCNUM h2 = mccguideCurved8_h2;
MCNUM l = mccguideCurved8_l;
MCNUM R0 = mccguideCurved8_R0;
MCNUM Qc = mccguideCurved8_Qc;
MCNUM alpha = mccguideCurved8_alpha;
MCNUM m = mccguideCurved8_m;
MCNUM W = mccguideCurved8_W;
/* 'guideCurved8=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 40189 "RITA-II.c"
}   /* End of guideCurved8=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved8:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(13,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved9 [14] */
  mccoordschange(mcposrguideCurved9, mcrotrguideCurved9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved9 (without coords transformations) */
  mcJumpTrace_guideCurved9:
  SIG_MESSAGE("guideCurved9 (Trace)");
  mcDEBUG_COMP("guideCurved9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved9
  STORE_NEUTRON(14,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[14]++;
  mcPCounter[14] += p;
  mcP2Counter[14] += p*p;
#define mccompcurname  guideCurved9
#define mccompcurtype  Guide
#define mccompcurindex 14
#define pTable mccguideCurved9_pTable
{   /* Declarations of guideCurved9=Guide() SETTING parameters. */
char* reflect = mccguideCurved9_reflect;
MCNUM w1 = mccguideCurved9_w1;
MCNUM h1 = mccguideCurved9_h1;
MCNUM w2 = mccguideCurved9_w2;
MCNUM h2 = mccguideCurved9_h2;
MCNUM l = mccguideCurved9_l;
MCNUM R0 = mccguideCurved9_R0;
MCNUM Qc = mccguideCurved9_Qc;
MCNUM alpha = mccguideCurved9_alpha;
MCNUM m = mccguideCurved9_m;
MCNUM W = mccguideCurved9_W;
/* 'guideCurved9=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 40417 "RITA-II.c"
}   /* End of guideCurved9=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved9:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(14,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved10 [15] */
  mccoordschange(mcposrguideCurved10, mcrotrguideCurved10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved10 (without coords transformations) */
  mcJumpTrace_guideCurved10:
  SIG_MESSAGE("guideCurved10 (Trace)");
  mcDEBUG_COMP("guideCurved10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved10
  STORE_NEUTRON(15,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[15]++;
  mcPCounter[15] += p;
  mcP2Counter[15] += p*p;
#define mccompcurname  guideCurved10
#define mccompcurtype  Guide
#define mccompcurindex 15
#define pTable mccguideCurved10_pTable
{   /* Declarations of guideCurved10=Guide() SETTING parameters. */
char* reflect = mccguideCurved10_reflect;
MCNUM w1 = mccguideCurved10_w1;
MCNUM h1 = mccguideCurved10_h1;
MCNUM w2 = mccguideCurved10_w2;
MCNUM h2 = mccguideCurved10_h2;
MCNUM l = mccguideCurved10_l;
MCNUM R0 = mccguideCurved10_R0;
MCNUM Qc = mccguideCurved10_Qc;
MCNUM alpha = mccguideCurved10_alpha;
MCNUM m = mccguideCurved10_m;
MCNUM W = mccguideCurved10_W;
/* 'guideCurved10=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 40645 "RITA-II.c"
}   /* End of guideCurved10=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved10:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(15,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved11 [16] */
  mccoordschange(mcposrguideCurved11, mcrotrguideCurved11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved11 (without coords transformations) */
  mcJumpTrace_guideCurved11:
  SIG_MESSAGE("guideCurved11 (Trace)");
  mcDEBUG_COMP("guideCurved11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved11
  STORE_NEUTRON(16,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[16]++;
  mcPCounter[16] += p;
  mcP2Counter[16] += p*p;
#define mccompcurname  guideCurved11
#define mccompcurtype  Guide
#define mccompcurindex 16
#define pTable mccguideCurved11_pTable
{   /* Declarations of guideCurved11=Guide() SETTING parameters. */
char* reflect = mccguideCurved11_reflect;
MCNUM w1 = mccguideCurved11_w1;
MCNUM h1 = mccguideCurved11_h1;
MCNUM w2 = mccguideCurved11_w2;
MCNUM h2 = mccguideCurved11_h2;
MCNUM l = mccguideCurved11_l;
MCNUM R0 = mccguideCurved11_R0;
MCNUM Qc = mccguideCurved11_Qc;
MCNUM alpha = mccguideCurved11_alpha;
MCNUM m = mccguideCurved11_m;
MCNUM W = mccguideCurved11_W;
/* 'guideCurved11=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 40873 "RITA-II.c"
}   /* End of guideCurved11=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved11:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(16,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved12 [17] */
  mccoordschange(mcposrguideCurved12, mcrotrguideCurved12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved12 (without coords transformations) */
  mcJumpTrace_guideCurved12:
  SIG_MESSAGE("guideCurved12 (Trace)");
  mcDEBUG_COMP("guideCurved12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved12
  STORE_NEUTRON(17,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[17]++;
  mcPCounter[17] += p;
  mcP2Counter[17] += p*p;
#define mccompcurname  guideCurved12
#define mccompcurtype  Guide
#define mccompcurindex 17
#define pTable mccguideCurved12_pTable
{   /* Declarations of guideCurved12=Guide() SETTING parameters. */
char* reflect = mccguideCurved12_reflect;
MCNUM w1 = mccguideCurved12_w1;
MCNUM h1 = mccguideCurved12_h1;
MCNUM w2 = mccguideCurved12_w2;
MCNUM h2 = mccguideCurved12_h2;
MCNUM l = mccguideCurved12_l;
MCNUM R0 = mccguideCurved12_R0;
MCNUM Qc = mccguideCurved12_Qc;
MCNUM alpha = mccguideCurved12_alpha;
MCNUM m = mccguideCurved12_m;
MCNUM W = mccguideCurved12_W;
/* 'guideCurved12=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 41101 "RITA-II.c"
}   /* End of guideCurved12=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved12:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(17,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved13 [18] */
  mccoordschange(mcposrguideCurved13, mcrotrguideCurved13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved13 (without coords transformations) */
  mcJumpTrace_guideCurved13:
  SIG_MESSAGE("guideCurved13 (Trace)");
  mcDEBUG_COMP("guideCurved13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved13
  STORE_NEUTRON(18,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[18]++;
  mcPCounter[18] += p;
  mcP2Counter[18] += p*p;
#define mccompcurname  guideCurved13
#define mccompcurtype  Guide
#define mccompcurindex 18
#define pTable mccguideCurved13_pTable
{   /* Declarations of guideCurved13=Guide() SETTING parameters. */
char* reflect = mccguideCurved13_reflect;
MCNUM w1 = mccguideCurved13_w1;
MCNUM h1 = mccguideCurved13_h1;
MCNUM w2 = mccguideCurved13_w2;
MCNUM h2 = mccguideCurved13_h2;
MCNUM l = mccguideCurved13_l;
MCNUM R0 = mccguideCurved13_R0;
MCNUM Qc = mccguideCurved13_Qc;
MCNUM alpha = mccguideCurved13_alpha;
MCNUM m = mccguideCurved13_m;
MCNUM W = mccguideCurved13_W;
/* 'guideCurved13=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 41329 "RITA-II.c"
}   /* End of guideCurved13=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved13:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(18,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved14 [19] */
  mccoordschange(mcposrguideCurved14, mcrotrguideCurved14,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved14 (without coords transformations) */
  mcJumpTrace_guideCurved14:
  SIG_MESSAGE("guideCurved14 (Trace)");
  mcDEBUG_COMP("guideCurved14")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved14
  STORE_NEUTRON(19,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[19]++;
  mcPCounter[19] += p;
  mcP2Counter[19] += p*p;
#define mccompcurname  guideCurved14
#define mccompcurtype  Guide
#define mccompcurindex 19
#define pTable mccguideCurved14_pTable
{   /* Declarations of guideCurved14=Guide() SETTING parameters. */
char* reflect = mccguideCurved14_reflect;
MCNUM w1 = mccguideCurved14_w1;
MCNUM h1 = mccguideCurved14_h1;
MCNUM w2 = mccguideCurved14_w2;
MCNUM h2 = mccguideCurved14_h2;
MCNUM l = mccguideCurved14_l;
MCNUM R0 = mccguideCurved14_R0;
MCNUM Qc = mccguideCurved14_Qc;
MCNUM alpha = mccguideCurved14_alpha;
MCNUM m = mccguideCurved14_m;
MCNUM W = mccguideCurved14_W;
/* 'guideCurved14=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 41557 "RITA-II.c"
}   /* End of guideCurved14=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved14:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(19,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved15 [20] */
  mccoordschange(mcposrguideCurved15, mcrotrguideCurved15,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved15 (without coords transformations) */
  mcJumpTrace_guideCurved15:
  SIG_MESSAGE("guideCurved15 (Trace)");
  mcDEBUG_COMP("guideCurved15")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved15
  STORE_NEUTRON(20,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[20]++;
  mcPCounter[20] += p;
  mcP2Counter[20] += p*p;
#define mccompcurname  guideCurved15
#define mccompcurtype  Guide
#define mccompcurindex 20
#define pTable mccguideCurved15_pTable
{   /* Declarations of guideCurved15=Guide() SETTING parameters. */
char* reflect = mccguideCurved15_reflect;
MCNUM w1 = mccguideCurved15_w1;
MCNUM h1 = mccguideCurved15_h1;
MCNUM w2 = mccguideCurved15_w2;
MCNUM h2 = mccguideCurved15_h2;
MCNUM l = mccguideCurved15_l;
MCNUM R0 = mccguideCurved15_R0;
MCNUM Qc = mccguideCurved15_Qc;
MCNUM alpha = mccguideCurved15_alpha;
MCNUM m = mccguideCurved15_m;
MCNUM W = mccguideCurved15_W;
/* 'guideCurved15=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 41785 "RITA-II.c"
}   /* End of guideCurved15=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved15:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(20,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved16 [21] */
  mccoordschange(mcposrguideCurved16, mcrotrguideCurved16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved16 (without coords transformations) */
  mcJumpTrace_guideCurved16:
  SIG_MESSAGE("guideCurved16 (Trace)");
  mcDEBUG_COMP("guideCurved16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved16
  STORE_NEUTRON(21,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[21]++;
  mcPCounter[21] += p;
  mcP2Counter[21] += p*p;
#define mccompcurname  guideCurved16
#define mccompcurtype  Guide
#define mccompcurindex 21
#define pTable mccguideCurved16_pTable
{   /* Declarations of guideCurved16=Guide() SETTING parameters. */
char* reflect = mccguideCurved16_reflect;
MCNUM w1 = mccguideCurved16_w1;
MCNUM h1 = mccguideCurved16_h1;
MCNUM w2 = mccguideCurved16_w2;
MCNUM h2 = mccguideCurved16_h2;
MCNUM l = mccguideCurved16_l;
MCNUM R0 = mccguideCurved16_R0;
MCNUM Qc = mccguideCurved16_Qc;
MCNUM alpha = mccguideCurved16_alpha;
MCNUM m = mccguideCurved16_m;
MCNUM W = mccguideCurved16_W;
/* 'guideCurved16=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 42013 "RITA-II.c"
}   /* End of guideCurved16=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved16:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(21,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved17 [22] */
  mccoordschange(mcposrguideCurved17, mcrotrguideCurved17,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved17 (without coords transformations) */
  mcJumpTrace_guideCurved17:
  SIG_MESSAGE("guideCurved17 (Trace)");
  mcDEBUG_COMP("guideCurved17")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved17
  STORE_NEUTRON(22,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[22]++;
  mcPCounter[22] += p;
  mcP2Counter[22] += p*p;
#define mccompcurname  guideCurved17
#define mccompcurtype  Guide
#define mccompcurindex 22
#define pTable mccguideCurved17_pTable
{   /* Declarations of guideCurved17=Guide() SETTING parameters. */
char* reflect = mccguideCurved17_reflect;
MCNUM w1 = mccguideCurved17_w1;
MCNUM h1 = mccguideCurved17_h1;
MCNUM w2 = mccguideCurved17_w2;
MCNUM h2 = mccguideCurved17_h2;
MCNUM l = mccguideCurved17_l;
MCNUM R0 = mccguideCurved17_R0;
MCNUM Qc = mccguideCurved17_Qc;
MCNUM alpha = mccguideCurved17_alpha;
MCNUM m = mccguideCurved17_m;
MCNUM W = mccguideCurved17_W;
/* 'guideCurved17=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 42241 "RITA-II.c"
}   /* End of guideCurved17=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved17:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(22,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved18 [23] */
  mccoordschange(mcposrguideCurved18, mcrotrguideCurved18,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved18 (without coords transformations) */
  mcJumpTrace_guideCurved18:
  SIG_MESSAGE("guideCurved18 (Trace)");
  mcDEBUG_COMP("guideCurved18")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved18
  STORE_NEUTRON(23,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[23]++;
  mcPCounter[23] += p;
  mcP2Counter[23] += p*p;
#define mccompcurname  guideCurved18
#define mccompcurtype  Guide
#define mccompcurindex 23
#define pTable mccguideCurved18_pTable
{   /* Declarations of guideCurved18=Guide() SETTING parameters. */
char* reflect = mccguideCurved18_reflect;
MCNUM w1 = mccguideCurved18_w1;
MCNUM h1 = mccguideCurved18_h1;
MCNUM w2 = mccguideCurved18_w2;
MCNUM h2 = mccguideCurved18_h2;
MCNUM l = mccguideCurved18_l;
MCNUM R0 = mccguideCurved18_R0;
MCNUM Qc = mccguideCurved18_Qc;
MCNUM alpha = mccguideCurved18_alpha;
MCNUM m = mccguideCurved18_m;
MCNUM W = mccguideCurved18_W;
/* 'guideCurved18=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 42469 "RITA-II.c"
}   /* End of guideCurved18=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved18:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(23,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved19 [24] */
  mccoordschange(mcposrguideCurved19, mcrotrguideCurved19,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved19 (without coords transformations) */
  mcJumpTrace_guideCurved19:
  SIG_MESSAGE("guideCurved19 (Trace)");
  mcDEBUG_COMP("guideCurved19")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved19
  STORE_NEUTRON(24,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[24]++;
  mcPCounter[24] += p;
  mcP2Counter[24] += p*p;
#define mccompcurname  guideCurved19
#define mccompcurtype  Guide
#define mccompcurindex 24
#define pTable mccguideCurved19_pTable
{   /* Declarations of guideCurved19=Guide() SETTING parameters. */
char* reflect = mccguideCurved19_reflect;
MCNUM w1 = mccguideCurved19_w1;
MCNUM h1 = mccguideCurved19_h1;
MCNUM w2 = mccguideCurved19_w2;
MCNUM h2 = mccguideCurved19_h2;
MCNUM l = mccguideCurved19_l;
MCNUM R0 = mccguideCurved19_R0;
MCNUM Qc = mccguideCurved19_Qc;
MCNUM alpha = mccguideCurved19_alpha;
MCNUM m = mccguideCurved19_m;
MCNUM W = mccguideCurved19_W;
/* 'guideCurved19=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 42697 "RITA-II.c"
}   /* End of guideCurved19=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved19:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(24,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved20 [25] */
  mccoordschange(mcposrguideCurved20, mcrotrguideCurved20,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved20 (without coords transformations) */
  mcJumpTrace_guideCurved20:
  SIG_MESSAGE("guideCurved20 (Trace)");
  mcDEBUG_COMP("guideCurved20")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved20
  STORE_NEUTRON(25,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[25]++;
  mcPCounter[25] += p;
  mcP2Counter[25] += p*p;
#define mccompcurname  guideCurved20
#define mccompcurtype  Guide
#define mccompcurindex 25
#define pTable mccguideCurved20_pTable
{   /* Declarations of guideCurved20=Guide() SETTING parameters. */
char* reflect = mccguideCurved20_reflect;
MCNUM w1 = mccguideCurved20_w1;
MCNUM h1 = mccguideCurved20_h1;
MCNUM w2 = mccguideCurved20_w2;
MCNUM h2 = mccguideCurved20_h2;
MCNUM l = mccguideCurved20_l;
MCNUM R0 = mccguideCurved20_R0;
MCNUM Qc = mccguideCurved20_Qc;
MCNUM alpha = mccguideCurved20_alpha;
MCNUM m = mccguideCurved20_m;
MCNUM W = mccguideCurved20_W;
/* 'guideCurved20=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 42925 "RITA-II.c"
}   /* End of guideCurved20=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved20:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(25,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved21 [26] */
  mccoordschange(mcposrguideCurved21, mcrotrguideCurved21,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved21 (without coords transformations) */
  mcJumpTrace_guideCurved21:
  SIG_MESSAGE("guideCurved21 (Trace)");
  mcDEBUG_COMP("guideCurved21")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved21
  STORE_NEUTRON(26,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[26]++;
  mcPCounter[26] += p;
  mcP2Counter[26] += p*p;
#define mccompcurname  guideCurved21
#define mccompcurtype  Guide
#define mccompcurindex 26
#define pTable mccguideCurved21_pTable
{   /* Declarations of guideCurved21=Guide() SETTING parameters. */
char* reflect = mccguideCurved21_reflect;
MCNUM w1 = mccguideCurved21_w1;
MCNUM h1 = mccguideCurved21_h1;
MCNUM w2 = mccguideCurved21_w2;
MCNUM h2 = mccguideCurved21_h2;
MCNUM l = mccguideCurved21_l;
MCNUM R0 = mccguideCurved21_R0;
MCNUM Qc = mccguideCurved21_Qc;
MCNUM alpha = mccguideCurved21_alpha;
MCNUM m = mccguideCurved21_m;
MCNUM W = mccguideCurved21_W;
/* 'guideCurved21=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 43153 "RITA-II.c"
}   /* End of guideCurved21=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved21:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(26,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved22 [27] */
  mccoordschange(mcposrguideCurved22, mcrotrguideCurved22,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved22 (without coords transformations) */
  mcJumpTrace_guideCurved22:
  SIG_MESSAGE("guideCurved22 (Trace)");
  mcDEBUG_COMP("guideCurved22")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved22
  STORE_NEUTRON(27,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[27]++;
  mcPCounter[27] += p;
  mcP2Counter[27] += p*p;
#define mccompcurname  guideCurved22
#define mccompcurtype  Guide
#define mccompcurindex 27
#define pTable mccguideCurved22_pTable
{   /* Declarations of guideCurved22=Guide() SETTING parameters. */
char* reflect = mccguideCurved22_reflect;
MCNUM w1 = mccguideCurved22_w1;
MCNUM h1 = mccguideCurved22_h1;
MCNUM w2 = mccguideCurved22_w2;
MCNUM h2 = mccguideCurved22_h2;
MCNUM l = mccguideCurved22_l;
MCNUM R0 = mccguideCurved22_R0;
MCNUM Qc = mccguideCurved22_Qc;
MCNUM alpha = mccguideCurved22_alpha;
MCNUM m = mccguideCurved22_m;
MCNUM W = mccguideCurved22_W;
/* 'guideCurved22=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 43381 "RITA-II.c"
}   /* End of guideCurved22=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved22:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(27,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved23 [28] */
  mccoordschange(mcposrguideCurved23, mcrotrguideCurved23,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved23 (without coords transformations) */
  mcJumpTrace_guideCurved23:
  SIG_MESSAGE("guideCurved23 (Trace)");
  mcDEBUG_COMP("guideCurved23")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved23
  STORE_NEUTRON(28,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[28]++;
  mcPCounter[28] += p;
  mcP2Counter[28] += p*p;
#define mccompcurname  guideCurved23
#define mccompcurtype  Guide
#define mccompcurindex 28
#define pTable mccguideCurved23_pTable
{   /* Declarations of guideCurved23=Guide() SETTING parameters. */
char* reflect = mccguideCurved23_reflect;
MCNUM w1 = mccguideCurved23_w1;
MCNUM h1 = mccguideCurved23_h1;
MCNUM w2 = mccguideCurved23_w2;
MCNUM h2 = mccguideCurved23_h2;
MCNUM l = mccguideCurved23_l;
MCNUM R0 = mccguideCurved23_R0;
MCNUM Qc = mccguideCurved23_Qc;
MCNUM alpha = mccguideCurved23_alpha;
MCNUM m = mccguideCurved23_m;
MCNUM W = mccguideCurved23_W;
/* 'guideCurved23=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 43609 "RITA-II.c"
}   /* End of guideCurved23=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved23:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(28,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved24 [29] */
  mccoordschange(mcposrguideCurved24, mcrotrguideCurved24,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved24 (without coords transformations) */
  mcJumpTrace_guideCurved24:
  SIG_MESSAGE("guideCurved24 (Trace)");
  mcDEBUG_COMP("guideCurved24")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved24
  STORE_NEUTRON(29,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[29]++;
  mcPCounter[29] += p;
  mcP2Counter[29] += p*p;
#define mccompcurname  guideCurved24
#define mccompcurtype  Guide
#define mccompcurindex 29
#define pTable mccguideCurved24_pTable
{   /* Declarations of guideCurved24=Guide() SETTING parameters. */
char* reflect = mccguideCurved24_reflect;
MCNUM w1 = mccguideCurved24_w1;
MCNUM h1 = mccguideCurved24_h1;
MCNUM w2 = mccguideCurved24_w2;
MCNUM h2 = mccguideCurved24_h2;
MCNUM l = mccguideCurved24_l;
MCNUM R0 = mccguideCurved24_R0;
MCNUM Qc = mccguideCurved24_Qc;
MCNUM alpha = mccguideCurved24_alpha;
MCNUM m = mccguideCurved24_m;
MCNUM W = mccguideCurved24_W;
/* 'guideCurved24=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 43837 "RITA-II.c"
}   /* End of guideCurved24=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved24:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(29,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved25 [30] */
  mccoordschange(mcposrguideCurved25, mcrotrguideCurved25,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved25 (without coords transformations) */
  mcJumpTrace_guideCurved25:
  SIG_MESSAGE("guideCurved25 (Trace)");
  mcDEBUG_COMP("guideCurved25")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved25
  STORE_NEUTRON(30,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[30]++;
  mcPCounter[30] += p;
  mcP2Counter[30] += p*p;
#define mccompcurname  guideCurved25
#define mccompcurtype  Guide
#define mccompcurindex 30
#define pTable mccguideCurved25_pTable
{   /* Declarations of guideCurved25=Guide() SETTING parameters. */
char* reflect = mccguideCurved25_reflect;
MCNUM w1 = mccguideCurved25_w1;
MCNUM h1 = mccguideCurved25_h1;
MCNUM w2 = mccguideCurved25_w2;
MCNUM h2 = mccguideCurved25_h2;
MCNUM l = mccguideCurved25_l;
MCNUM R0 = mccguideCurved25_R0;
MCNUM Qc = mccguideCurved25_Qc;
MCNUM alpha = mccguideCurved25_alpha;
MCNUM m = mccguideCurved25_m;
MCNUM W = mccguideCurved25_W;
/* 'guideCurved25=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 44065 "RITA-II.c"
}   /* End of guideCurved25=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved25:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(30,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved26 [31] */
  mccoordschange(mcposrguideCurved26, mcrotrguideCurved26,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved26 (without coords transformations) */
  mcJumpTrace_guideCurved26:
  SIG_MESSAGE("guideCurved26 (Trace)");
  mcDEBUG_COMP("guideCurved26")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved26
  STORE_NEUTRON(31,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[31]++;
  mcPCounter[31] += p;
  mcP2Counter[31] += p*p;
#define mccompcurname  guideCurved26
#define mccompcurtype  Guide
#define mccompcurindex 31
#define pTable mccguideCurved26_pTable
{   /* Declarations of guideCurved26=Guide() SETTING parameters. */
char* reflect = mccguideCurved26_reflect;
MCNUM w1 = mccguideCurved26_w1;
MCNUM h1 = mccguideCurved26_h1;
MCNUM w2 = mccguideCurved26_w2;
MCNUM h2 = mccguideCurved26_h2;
MCNUM l = mccguideCurved26_l;
MCNUM R0 = mccguideCurved26_R0;
MCNUM Qc = mccguideCurved26_Qc;
MCNUM alpha = mccguideCurved26_alpha;
MCNUM m = mccguideCurved26_m;
MCNUM W = mccguideCurved26_W;
/* 'guideCurved26=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 44293 "RITA-II.c"
}   /* End of guideCurved26=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved26:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(31,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved27 [32] */
  mccoordschange(mcposrguideCurved27, mcrotrguideCurved27,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved27 (without coords transformations) */
  mcJumpTrace_guideCurved27:
  SIG_MESSAGE("guideCurved27 (Trace)");
  mcDEBUG_COMP("guideCurved27")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved27
  STORE_NEUTRON(32,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[32]++;
  mcPCounter[32] += p;
  mcP2Counter[32] += p*p;
#define mccompcurname  guideCurved27
#define mccompcurtype  Guide
#define mccompcurindex 32
#define pTable mccguideCurved27_pTable
{   /* Declarations of guideCurved27=Guide() SETTING parameters. */
char* reflect = mccguideCurved27_reflect;
MCNUM w1 = mccguideCurved27_w1;
MCNUM h1 = mccguideCurved27_h1;
MCNUM w2 = mccguideCurved27_w2;
MCNUM h2 = mccguideCurved27_h2;
MCNUM l = mccguideCurved27_l;
MCNUM R0 = mccguideCurved27_R0;
MCNUM Qc = mccguideCurved27_Qc;
MCNUM alpha = mccguideCurved27_alpha;
MCNUM m = mccguideCurved27_m;
MCNUM W = mccguideCurved27_W;
/* 'guideCurved27=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 44521 "RITA-II.c"
}   /* End of guideCurved27=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved27:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(32,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved28 [33] */
  mccoordschange(mcposrguideCurved28, mcrotrguideCurved28,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved28 (without coords transformations) */
  mcJumpTrace_guideCurved28:
  SIG_MESSAGE("guideCurved28 (Trace)");
  mcDEBUG_COMP("guideCurved28")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved28
  STORE_NEUTRON(33,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[33]++;
  mcPCounter[33] += p;
  mcP2Counter[33] += p*p;
#define mccompcurname  guideCurved28
#define mccompcurtype  Guide
#define mccompcurindex 33
#define pTable mccguideCurved28_pTable
{   /* Declarations of guideCurved28=Guide() SETTING parameters. */
char* reflect = mccguideCurved28_reflect;
MCNUM w1 = mccguideCurved28_w1;
MCNUM h1 = mccguideCurved28_h1;
MCNUM w2 = mccguideCurved28_w2;
MCNUM h2 = mccguideCurved28_h2;
MCNUM l = mccguideCurved28_l;
MCNUM R0 = mccguideCurved28_R0;
MCNUM Qc = mccguideCurved28_Qc;
MCNUM alpha = mccguideCurved28_alpha;
MCNUM m = mccguideCurved28_m;
MCNUM W = mccguideCurved28_W;
/* 'guideCurved28=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 44749 "RITA-II.c"
}   /* End of guideCurved28=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved28:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(33,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved29 [34] */
  mccoordschange(mcposrguideCurved29, mcrotrguideCurved29,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved29 (without coords transformations) */
  mcJumpTrace_guideCurved29:
  SIG_MESSAGE("guideCurved29 (Trace)");
  mcDEBUG_COMP("guideCurved29")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved29
  STORE_NEUTRON(34,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[34]++;
  mcPCounter[34] += p;
  mcP2Counter[34] += p*p;
#define mccompcurname  guideCurved29
#define mccompcurtype  Guide
#define mccompcurindex 34
#define pTable mccguideCurved29_pTable
{   /* Declarations of guideCurved29=Guide() SETTING parameters. */
char* reflect = mccguideCurved29_reflect;
MCNUM w1 = mccguideCurved29_w1;
MCNUM h1 = mccguideCurved29_h1;
MCNUM w2 = mccguideCurved29_w2;
MCNUM h2 = mccguideCurved29_h2;
MCNUM l = mccguideCurved29_l;
MCNUM R0 = mccguideCurved29_R0;
MCNUM Qc = mccguideCurved29_Qc;
MCNUM alpha = mccguideCurved29_alpha;
MCNUM m = mccguideCurved29_m;
MCNUM W = mccguideCurved29_W;
/* 'guideCurved29=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 44977 "RITA-II.c"
}   /* End of guideCurved29=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved29:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(34,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved30 [35] */
  mccoordschange(mcposrguideCurved30, mcrotrguideCurved30,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved30 (without coords transformations) */
  mcJumpTrace_guideCurved30:
  SIG_MESSAGE("guideCurved30 (Trace)");
  mcDEBUG_COMP("guideCurved30")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved30
  STORE_NEUTRON(35,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[35]++;
  mcPCounter[35] += p;
  mcP2Counter[35] += p*p;
#define mccompcurname  guideCurved30
#define mccompcurtype  Guide
#define mccompcurindex 35
#define pTable mccguideCurved30_pTable
{   /* Declarations of guideCurved30=Guide() SETTING parameters. */
char* reflect = mccguideCurved30_reflect;
MCNUM w1 = mccguideCurved30_w1;
MCNUM h1 = mccguideCurved30_h1;
MCNUM w2 = mccguideCurved30_w2;
MCNUM h2 = mccguideCurved30_h2;
MCNUM l = mccguideCurved30_l;
MCNUM R0 = mccguideCurved30_R0;
MCNUM Qc = mccguideCurved30_Qc;
MCNUM alpha = mccguideCurved30_alpha;
MCNUM m = mccguideCurved30_m;
MCNUM W = mccguideCurved30_W;
/* 'guideCurved30=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 45205 "RITA-II.c"
}   /* End of guideCurved30=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved30:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(35,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved31 [36] */
  mccoordschange(mcposrguideCurved31, mcrotrguideCurved31,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved31 (without coords transformations) */
  mcJumpTrace_guideCurved31:
  SIG_MESSAGE("guideCurved31 (Trace)");
  mcDEBUG_COMP("guideCurved31")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved31
  STORE_NEUTRON(36,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[36]++;
  mcPCounter[36] += p;
  mcP2Counter[36] += p*p;
#define mccompcurname  guideCurved31
#define mccompcurtype  Guide
#define mccompcurindex 36
#define pTable mccguideCurved31_pTable
{   /* Declarations of guideCurved31=Guide() SETTING parameters. */
char* reflect = mccguideCurved31_reflect;
MCNUM w1 = mccguideCurved31_w1;
MCNUM h1 = mccguideCurved31_h1;
MCNUM w2 = mccguideCurved31_w2;
MCNUM h2 = mccguideCurved31_h2;
MCNUM l = mccguideCurved31_l;
MCNUM R0 = mccguideCurved31_R0;
MCNUM Qc = mccguideCurved31_Qc;
MCNUM alpha = mccguideCurved31_alpha;
MCNUM m = mccguideCurved31_m;
MCNUM W = mccguideCurved31_W;
/* 'guideCurved31=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 45433 "RITA-II.c"
}   /* End of guideCurved31=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved31:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(36,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved32 [37] */
  mccoordschange(mcposrguideCurved32, mcrotrguideCurved32,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved32 (without coords transformations) */
  mcJumpTrace_guideCurved32:
  SIG_MESSAGE("guideCurved32 (Trace)");
  mcDEBUG_COMP("guideCurved32")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved32
  STORE_NEUTRON(37,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[37]++;
  mcPCounter[37] += p;
  mcP2Counter[37] += p*p;
#define mccompcurname  guideCurved32
#define mccompcurtype  Guide
#define mccompcurindex 37
#define pTable mccguideCurved32_pTable
{   /* Declarations of guideCurved32=Guide() SETTING parameters. */
char* reflect = mccguideCurved32_reflect;
MCNUM w1 = mccguideCurved32_w1;
MCNUM h1 = mccguideCurved32_h1;
MCNUM w2 = mccguideCurved32_w2;
MCNUM h2 = mccguideCurved32_h2;
MCNUM l = mccguideCurved32_l;
MCNUM R0 = mccguideCurved32_R0;
MCNUM Qc = mccguideCurved32_Qc;
MCNUM alpha = mccguideCurved32_alpha;
MCNUM m = mccguideCurved32_m;
MCNUM W = mccguideCurved32_W;
/* 'guideCurved32=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 45661 "RITA-II.c"
}   /* End of guideCurved32=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved32:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(37,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved33 [38] */
  mccoordschange(mcposrguideCurved33, mcrotrguideCurved33,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved33 (without coords transformations) */
  mcJumpTrace_guideCurved33:
  SIG_MESSAGE("guideCurved33 (Trace)");
  mcDEBUG_COMP("guideCurved33")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved33
  STORE_NEUTRON(38,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[38]++;
  mcPCounter[38] += p;
  mcP2Counter[38] += p*p;
#define mccompcurname  guideCurved33
#define mccompcurtype  Guide
#define mccompcurindex 38
#define pTable mccguideCurved33_pTable
{   /* Declarations of guideCurved33=Guide() SETTING parameters. */
char* reflect = mccguideCurved33_reflect;
MCNUM w1 = mccguideCurved33_w1;
MCNUM h1 = mccguideCurved33_h1;
MCNUM w2 = mccguideCurved33_w2;
MCNUM h2 = mccguideCurved33_h2;
MCNUM l = mccguideCurved33_l;
MCNUM R0 = mccguideCurved33_R0;
MCNUM Qc = mccguideCurved33_Qc;
MCNUM alpha = mccguideCurved33_alpha;
MCNUM m = mccguideCurved33_m;
MCNUM W = mccguideCurved33_W;
/* 'guideCurved33=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 45889 "RITA-II.c"
}   /* End of guideCurved33=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved33:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(38,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved34 [39] */
  mccoordschange(mcposrguideCurved34, mcrotrguideCurved34,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved34 (without coords transformations) */
  mcJumpTrace_guideCurved34:
  SIG_MESSAGE("guideCurved34 (Trace)");
  mcDEBUG_COMP("guideCurved34")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved34
  STORE_NEUTRON(39,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[39]++;
  mcPCounter[39] += p;
  mcP2Counter[39] += p*p;
#define mccompcurname  guideCurved34
#define mccompcurtype  Guide
#define mccompcurindex 39
#define pTable mccguideCurved34_pTable
{   /* Declarations of guideCurved34=Guide() SETTING parameters. */
char* reflect = mccguideCurved34_reflect;
MCNUM w1 = mccguideCurved34_w1;
MCNUM h1 = mccguideCurved34_h1;
MCNUM w2 = mccguideCurved34_w2;
MCNUM h2 = mccguideCurved34_h2;
MCNUM l = mccguideCurved34_l;
MCNUM R0 = mccguideCurved34_R0;
MCNUM Qc = mccguideCurved34_Qc;
MCNUM alpha = mccguideCurved34_alpha;
MCNUM m = mccguideCurved34_m;
MCNUM W = mccguideCurved34_W;
/* 'guideCurved34=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 46117 "RITA-II.c"
}   /* End of guideCurved34=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved34:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(39,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved35 [40] */
  mccoordschange(mcposrguideCurved35, mcrotrguideCurved35,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved35 (without coords transformations) */
  mcJumpTrace_guideCurved35:
  SIG_MESSAGE("guideCurved35 (Trace)");
  mcDEBUG_COMP("guideCurved35")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved35
  STORE_NEUTRON(40,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[40]++;
  mcPCounter[40] += p;
  mcP2Counter[40] += p*p;
#define mccompcurname  guideCurved35
#define mccompcurtype  Guide
#define mccompcurindex 40
#define pTable mccguideCurved35_pTable
{   /* Declarations of guideCurved35=Guide() SETTING parameters. */
char* reflect = mccguideCurved35_reflect;
MCNUM w1 = mccguideCurved35_w1;
MCNUM h1 = mccguideCurved35_h1;
MCNUM w2 = mccguideCurved35_w2;
MCNUM h2 = mccguideCurved35_h2;
MCNUM l = mccguideCurved35_l;
MCNUM R0 = mccguideCurved35_R0;
MCNUM Qc = mccguideCurved35_Qc;
MCNUM alpha = mccguideCurved35_alpha;
MCNUM m = mccguideCurved35_m;
MCNUM W = mccguideCurved35_W;
/* 'guideCurved35=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 46345 "RITA-II.c"
}   /* End of guideCurved35=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved35:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(40,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved36 [41] */
  mccoordschange(mcposrguideCurved36, mcrotrguideCurved36,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved36 (without coords transformations) */
  mcJumpTrace_guideCurved36:
  SIG_MESSAGE("guideCurved36 (Trace)");
  mcDEBUG_COMP("guideCurved36")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved36
  STORE_NEUTRON(41,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[41]++;
  mcPCounter[41] += p;
  mcP2Counter[41] += p*p;
#define mccompcurname  guideCurved36
#define mccompcurtype  Guide
#define mccompcurindex 41
#define pTable mccguideCurved36_pTable
{   /* Declarations of guideCurved36=Guide() SETTING parameters. */
char* reflect = mccguideCurved36_reflect;
MCNUM w1 = mccguideCurved36_w1;
MCNUM h1 = mccguideCurved36_h1;
MCNUM w2 = mccguideCurved36_w2;
MCNUM h2 = mccguideCurved36_h2;
MCNUM l = mccguideCurved36_l;
MCNUM R0 = mccguideCurved36_R0;
MCNUM Qc = mccguideCurved36_Qc;
MCNUM alpha = mccguideCurved36_alpha;
MCNUM m = mccguideCurved36_m;
MCNUM W = mccguideCurved36_W;
/* 'guideCurved36=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 46573 "RITA-II.c"
}   /* End of guideCurved36=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved36:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(41,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved37 [42] */
  mccoordschange(mcposrguideCurved37, mcrotrguideCurved37,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved37 (without coords transformations) */
  mcJumpTrace_guideCurved37:
  SIG_MESSAGE("guideCurved37 (Trace)");
  mcDEBUG_COMP("guideCurved37")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved37
  STORE_NEUTRON(42,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[42]++;
  mcPCounter[42] += p;
  mcP2Counter[42] += p*p;
#define mccompcurname  guideCurved37
#define mccompcurtype  Guide
#define mccompcurindex 42
#define pTable mccguideCurved37_pTable
{   /* Declarations of guideCurved37=Guide() SETTING parameters. */
char* reflect = mccguideCurved37_reflect;
MCNUM w1 = mccguideCurved37_w1;
MCNUM h1 = mccguideCurved37_h1;
MCNUM w2 = mccguideCurved37_w2;
MCNUM h2 = mccguideCurved37_h2;
MCNUM l = mccguideCurved37_l;
MCNUM R0 = mccguideCurved37_R0;
MCNUM Qc = mccguideCurved37_Qc;
MCNUM alpha = mccguideCurved37_alpha;
MCNUM m = mccguideCurved37_m;
MCNUM W = mccguideCurved37_W;
/* 'guideCurved37=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 46801 "RITA-II.c"
}   /* End of guideCurved37=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved37:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(42,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved38 [43] */
  mccoordschange(mcposrguideCurved38, mcrotrguideCurved38,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved38 (without coords transformations) */
  mcJumpTrace_guideCurved38:
  SIG_MESSAGE("guideCurved38 (Trace)");
  mcDEBUG_COMP("guideCurved38")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved38
  STORE_NEUTRON(43,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[43]++;
  mcPCounter[43] += p;
  mcP2Counter[43] += p*p;
#define mccompcurname  guideCurved38
#define mccompcurtype  Guide
#define mccompcurindex 43
#define pTable mccguideCurved38_pTable
{   /* Declarations of guideCurved38=Guide() SETTING parameters. */
char* reflect = mccguideCurved38_reflect;
MCNUM w1 = mccguideCurved38_w1;
MCNUM h1 = mccguideCurved38_h1;
MCNUM w2 = mccguideCurved38_w2;
MCNUM h2 = mccguideCurved38_h2;
MCNUM l = mccguideCurved38_l;
MCNUM R0 = mccguideCurved38_R0;
MCNUM Qc = mccguideCurved38_Qc;
MCNUM alpha = mccguideCurved38_alpha;
MCNUM m = mccguideCurved38_m;
MCNUM W = mccguideCurved38_W;
/* 'guideCurved38=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 47029 "RITA-II.c"
}   /* End of guideCurved38=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved38:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(43,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved39 [44] */
  mccoordschange(mcposrguideCurved39, mcrotrguideCurved39,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved39 (without coords transformations) */
  mcJumpTrace_guideCurved39:
  SIG_MESSAGE("guideCurved39 (Trace)");
  mcDEBUG_COMP("guideCurved39")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved39
  STORE_NEUTRON(44,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[44]++;
  mcPCounter[44] += p;
  mcP2Counter[44] += p*p;
#define mccompcurname  guideCurved39
#define mccompcurtype  Guide
#define mccompcurindex 44
#define pTable mccguideCurved39_pTable
{   /* Declarations of guideCurved39=Guide() SETTING parameters. */
char* reflect = mccguideCurved39_reflect;
MCNUM w1 = mccguideCurved39_w1;
MCNUM h1 = mccguideCurved39_h1;
MCNUM w2 = mccguideCurved39_w2;
MCNUM h2 = mccguideCurved39_h2;
MCNUM l = mccguideCurved39_l;
MCNUM R0 = mccguideCurved39_R0;
MCNUM Qc = mccguideCurved39_Qc;
MCNUM alpha = mccguideCurved39_alpha;
MCNUM m = mccguideCurved39_m;
MCNUM W = mccguideCurved39_W;
/* 'guideCurved39=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 47257 "RITA-II.c"
}   /* End of guideCurved39=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved39:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(44,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guideCurved40 [45] */
  mccoordschange(mcposrguideCurved40, mcrotrguideCurved40,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guideCurved40 (without coords transformations) */
  mcJumpTrace_guideCurved40:
  SIG_MESSAGE("guideCurved40 (Trace)");
  mcDEBUG_COMP("guideCurved40")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguideCurved40
  STORE_NEUTRON(45,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[45]++;
  mcPCounter[45] += p;
  mcP2Counter[45] += p*p;
#define mccompcurname  guideCurved40
#define mccompcurtype  Guide
#define mccompcurindex 45
#define pTable mccguideCurved40_pTable
{   /* Declarations of guideCurved40=Guide() SETTING parameters. */
char* reflect = mccguideCurved40_reflect;
MCNUM w1 = mccguideCurved40_w1;
MCNUM h1 = mccguideCurved40_h1;
MCNUM w2 = mccguideCurved40_w2;
MCNUM h2 = mccguideCurved40_h2;
MCNUM l = mccguideCurved40_l;
MCNUM R0 = mccguideCurved40_R0;
MCNUM Qc = mccguideCurved40_Qc;
MCNUM alpha = mccguideCurved40_alpha;
MCNUM m = mccguideCurved40_m;
MCNUM W = mccguideCurved40_W;
/* 'guideCurved40=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 47485 "RITA-II.c"
}   /* End of guideCurved40=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguideCurved40:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(45,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component bunker [46] */
  mccoordschange(mcposrbunker, mcrotrbunker,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component bunker (without coords transformations) */
  mcJumpTrace_bunker:
  SIG_MESSAGE("bunker (Trace)");
  mcDEBUG_COMP("bunker")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompbunker
  STORE_NEUTRON(46,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[46]++;
  mcPCounter[46] += p;
  mcP2Counter[46] += p*p;
#define mccompcurname  bunker
#define mccompcurtype  Guide
#define mccompcurindex 46
#define pTable mccbunker_pTable
{   /* Declarations of bunker=Guide() SETTING parameters. */
char* reflect = mccbunker_reflect;
MCNUM w1 = mccbunker_w1;
MCNUM h1 = mccbunker_h1;
MCNUM w2 = mccbunker_w2;
MCNUM h2 = mccbunker_h2;
MCNUM l = mccbunker_l;
MCNUM R0 = mccbunker_R0;
MCNUM Qc = mccbunker_Qc;
MCNUM alpha = mccbunker_alpha;
MCNUM m = mccbunker_m;
MCNUM W = mccbunker_W;
/* 'bunker=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 47713 "RITA-II.c"
}   /* End of bunker=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompbunker:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(46,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component guide3 [47] */
  mccoordschange(mcposrguide3, mcrotrguide3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component guide3 (without coords transformations) */
  mcJumpTrace_guide3:
  SIG_MESSAGE("guide3 (Trace)");
  mcDEBUG_COMP("guide3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompguide3
  STORE_NEUTRON(47,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[47]++;
  mcPCounter[47] += p;
  mcP2Counter[47] += p*p;
#define mccompcurname  guide3
#define mccompcurtype  Guide
#define mccompcurindex 47
#define pTable mccguide3_pTable
{   /* Declarations of guide3=Guide() SETTING parameters. */
char* reflect = mccguide3_reflect;
MCNUM w1 = mccguide3_w1;
MCNUM h1 = mccguide3_h1;
MCNUM w2 = mccguide3_w2;
MCNUM h2 = mccguide3_h2;
MCNUM l = mccguide3_l;
MCNUM R0 = mccguide3_R0;
MCNUM Qc = mccguide3_Qc;
MCNUM alpha = mccguide3_alpha;
MCNUM m = mccguide3_m;
MCNUM W = mccguide3_W;
/* 'guide3=Guide()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 94 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 47941 "RITA-II.c"
}   /* End of guide3=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompguide3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(47,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component slitGuideEnd [48] */
  mccoordschange(mcposrslitGuideEnd, mcrotrslitGuideEnd,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component slitGuideEnd (without coords transformations) */
  mcJumpTrace_slitGuideEnd:
  SIG_MESSAGE("slitGuideEnd (Trace)");
  mcDEBUG_COMP("slitGuideEnd")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompslitGuideEnd
  STORE_NEUTRON(48,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[48]++;
  mcPCounter[48] += p;
  mcP2Counter[48] += p*p;
#define mccompcurname  slitGuideEnd
#define mccompcurtype  Slit
#define mccompcurindex 48
{   /* Declarations of slitGuideEnd=Slit() SETTING parameters. */
MCNUM xmin = mccslitGuideEnd_xmin;
MCNUM xmax = mccslitGuideEnd_xmax;
MCNUM ymin = mccslitGuideEnd_ymin;
MCNUM ymax = mccslitGuideEnd_ymax;
MCNUM radius = mccslitGuideEnd_radius;
MCNUM xwidth = mccslitGuideEnd_xwidth;
MCNUM yheight = mccslitGuideEnd_yheight;
/* 'slitGuideEnd=Slit()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 71 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 48066 "RITA-II.c"
}   /* End of slitGuideEnd=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompslitGuideEnd:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(48,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_guide_end [49] */
  mccoordschange(mcposrpsd_guide_end, mcrotrpsd_guide_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_guide_end (without coords transformations) */
  mcJumpTrace_psd_guide_end:
  SIG_MESSAGE("psd_guide_end (Trace)");
  mcDEBUG_COMP("psd_guide_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_guide_end
  STORE_NEUTRON(49,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[49]++;
  mcPCounter[49] += p;
  mcP2Counter[49] += p*p;
#define mccompcurname  psd_guide_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccpsd_guide_end_nx
#define ny mccpsd_guide_end_ny
#define PSD_N mccpsd_guide_end_PSD_N
#define PSD_p mccpsd_guide_end_PSD_p
#define PSD_p2 mccpsd_guide_end_PSD_p2
{   /* Declarations of psd_guide_end=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_guide_end_filename;
MCNUM xmin = mccpsd_guide_end_xmin;
MCNUM xmax = mccpsd_guide_end_xmax;
MCNUM ymin = mccpsd_guide_end_ymin;
MCNUM ymax = mccpsd_guide_end_ymax;
MCNUM xwidth = mccpsd_guide_end_xwidth;
MCNUM yheight = mccpsd_guide_end_yheight;
MCNUM restore_neutron = mccpsd_guide_end_restore_neutron;
int nowritefile = mccpsd_guide_end_nowritefile;
/* 'psd_guide_end=PSD_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 83 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 48206 "RITA-II.c"
}   /* End of psd_guide_end=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_guide_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(49,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_guide_end [50] */
  mccoordschange(mcposremon_guide_end, mcrotremon_guide_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_guide_end (without coords transformations) */
  mcJumpTrace_emon_guide_end:
  SIG_MESSAGE("emon_guide_end (Trace)");
  mcDEBUG_COMP("emon_guide_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_guide_end
  STORE_NEUTRON(50,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[50]++;
  mcPCounter[50] += p;
  mcP2Counter[50] += p*p;
#define mccompcurname  emon_guide_end
#define mccompcurtype  E_monitor
#define mccompcurindex 50
#define nE mccemon_guide_end_nE
#define E_N mccemon_guide_end_E_N
#define E_p mccemon_guide_end_E_p
#define E_p2 mccemon_guide_end_E_p2
#define S_p mccemon_guide_end_S_p
#define S_pE mccemon_guide_end_S_pE
#define S_pE2 mccemon_guide_end_S_pE2
{   /* Declarations of emon_guide_end=E_monitor() SETTING parameters. */
char* filename = mccemon_guide_end_filename;
MCNUM xmin = mccemon_guide_end_xmin;
MCNUM xmax = mccemon_guide_end_xmax;
MCNUM ymin = mccemon_guide_end_ymin;
MCNUM ymax = mccemon_guide_end_ymax;
MCNUM xwidth = mccemon_guide_end_xwidth;
MCNUM yheight = mccemon_guide_end_yheight;
MCNUM Emin = mccemon_guide_end_Emin;
MCNUM Emax = mccemon_guide_end_Emax;
MCNUM restore_neutron = mccemon_guide_end_restore_neutron;
int nowritefile = mccemon_guide_end_nowritefile;
#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 48362 "RITA-II.c"
}   /* End of emon_guide_end=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_guide_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(50,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component lmon_guide_end [51] */
  mccoordschange(mcposrlmon_guide_end, mcrotrlmon_guide_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component lmon_guide_end (without coords transformations) */
  mcJumpTrace_lmon_guide_end:
  SIG_MESSAGE("lmon_guide_end (Trace)");
  mcDEBUG_COMP("lmon_guide_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComplmon_guide_end
  STORE_NEUTRON(51,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[51]++;
  mcPCounter[51] += p;
  mcP2Counter[51] += p*p;
#define mccompcurname  lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mcclmon_guide_end_nL
#define L_N mcclmon_guide_end_L_N
#define L_p mcclmon_guide_end_L_p
#define L_p2 mcclmon_guide_end_L_p2
{   /* Declarations of lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mcclmon_guide_end_filename;
MCNUM xmin = mcclmon_guide_end_xmin;
MCNUM xmax = mcclmon_guide_end_xmax;
MCNUM ymin = mcclmon_guide_end_ymin;
MCNUM ymax = mcclmon_guide_end_ymax;
MCNUM xwidth = mcclmon_guide_end_xwidth;
MCNUM yheight = mcclmon_guide_end_yheight;
MCNUM Lmin = mcclmon_guide_end_Lmin;
MCNUM Lmax = mcclmon_guide_end_Lmax;
MCNUM restore_neutron = mcclmon_guide_end_restore_neutron;
int nowritefile = mcclmon_guide_end_nowritefile;
/* 'lmon_guide_end=L_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 84 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 48514 "RITA-II.c"
}   /* End of lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComplmon_guide_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(51,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component divmon_guide_end [52] */
  mccoordschange(mcposrdivmon_guide_end, mcrotrdivmon_guide_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component divmon_guide_end (without coords transformations) */
  mcJumpTrace_divmon_guide_end:
  SIG_MESSAGE("divmon_guide_end (Trace)");
  mcDEBUG_COMP("divmon_guide_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompdivmon_guide_end
  STORE_NEUTRON(52,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[52]++;
  mcPCounter[52] += p;
  mcP2Counter[52] += p*p;
#define mccompcurname  divmon_guide_end
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 52
#define nh mccdivmon_guide_end_nh
#define nv mccdivmon_guide_end_nv
#define Div_N mccdivmon_guide_end_Div_N
#define Div_p mccdivmon_guide_end_Div_p
#define Div_p2 mccdivmon_guide_end_Div_p2
{   /* Declarations of divmon_guide_end=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_guide_end_filename;
MCNUM xmin = mccdivmon_guide_end_xmin;
MCNUM xmax = mccdivmon_guide_end_xmax;
MCNUM ymin = mccdivmon_guide_end_ymin;
MCNUM ymax = mccdivmon_guide_end_ymax;
MCNUM xwidth = mccdivmon_guide_end_xwidth;
MCNUM yheight = mccdivmon_guide_end_yheight;
MCNUM maxdiv_h = mccdivmon_guide_end_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_guide_end_maxdiv_v;
MCNUM restore_neutron = mccdivmon_guide_end_restore_neutron;
MCNUM nx = mccdivmon_guide_end_nx;
MCNUM ny = mccdivmon_guide_end_ny;
MCNUM nz = mccdivmon_guide_end_nz;
int nowritefile = mccdivmon_guide_end_nowritefile;
/* 'divmon_guide_end=Divergence_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 89 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    int i,j;
    double h_div, v_div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      h_div = RAD2DEG*atan2(vx,vn);
      v_div = RAD2DEG*atan2(vy,vn);
      if (h_div < maxdiv_h && h_div > -maxdiv_h &&
          v_div < maxdiv_v && v_div > -maxdiv_v)
      {
        i = floor((h_div + maxdiv_h)*nh/(2.0*maxdiv_h));
        j = floor((v_div + maxdiv_v)*nv/(2.0*maxdiv_v));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 48673 "RITA-II.c"
}   /* End of divmon_guide_end=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompdivmon_guide_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(52,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component focus_mono [53] */
  mccoordschange(mcposrfocus_mono, mcrotrfocus_mono,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component focus_mono (without coords transformations) */
  mcJumpTrace_focus_mono:
  SIG_MESSAGE("focus_mono (Trace)");
  mcDEBUG_COMP("focus_mono")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompfocus_mono
  STORE_NEUTRON(53,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[53]++;
  mcPCounter[53] += p;
  mcP2Counter[53] += p*p;
#define mccompcurname  focus_mono
#define mccompcurtype  Arm
#define mccompcurindex 53
/* 'focus_mono=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

/* 'focus_mono=Arm()' component instance extend code */
    SIG_MESSAGE("focus_mono (Trace:Extend)");
if (( ! mcipVIRTUALIN )) {

#line 1208 "RITA-II.instr"
  Mono_order=-1;
#line 48790 "RITA-II.c"
}

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompfocus_mono:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(53,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator_curved [54] */
  mccoordschange(mcposrmonochromator_curved, mcrotrmonochromator_curved,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator_curved (without coords transformations) */
  mcJumpTrace_monochromator_curved:
  SIG_MESSAGE("monochromator_curved (Trace)");
  mcDEBUG_COMP("monochromator_curved")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator_curved
  if (!mcSplit_monochromator_curved) {                   /* STORE only the first time */
    if (floor(SPLITMREP) > 1) p /= floor(SPLITMREP); /* adapt weight for SPLITed neutron */
    STORE_NEUTRON(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp);
  } else {
    RESTORE_NEUTRON(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp);
  }
  mcSplit_monochromator_curved++; /* SPLIT number */
  mcScattered=0;
  mcRestore=0;
  mcNCounter[54]++;
  mcPCounter[54] += p;
  mcP2Counter[54] += p*p;
#define mccompcurname  monochromator_curved
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 54
#define mos_rms_y mccmonochromator_curved_mos_rms_y
#define mos_rms_z mccmonochromator_curved_mos_rms_z
#define mos_rms_max mccmonochromator_curved_mos_rms_max
#define mono_Q mccmonochromator_curved_mono_Q
#define SlabWidth mccmonochromator_curved_SlabWidth
#define SlabHeight mccmonochromator_curved_SlabHeight
#define rTable mccmonochromator_curved_rTable
#define tTable mccmonochromator_curved_tTable
#define row mccmonochromator_curved_row
#define col mccmonochromator_curved_col
#define tiltH mccmonochromator_curved_tiltH
#define tiltV mccmonochromator_curved_tiltV
{   /* Declarations of monochromator_curved=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator_curved_reflect;
char* transmit = mccmonochromator_curved_transmit;
MCNUM zwidth = mccmonochromator_curved_zwidth;
MCNUM yheight = mccmonochromator_curved_yheight;
MCNUM gap = mccmonochromator_curved_gap;
MCNUM NH = mccmonochromator_curved_NH;
MCNUM NV = mccmonochromator_curved_NV;
MCNUM mosaich = mccmonochromator_curved_mosaich;
MCNUM mosaicv = mccmonochromator_curved_mosaicv;
MCNUM r0 = mccmonochromator_curved_r0;
MCNUM t0 = mccmonochromator_curved_t0;
MCNUM Q = mccmonochromator_curved_Q;
MCNUM RV = mccmonochromator_curved_RV;
MCNUM RH = mccmonochromator_curved_RH;
MCNUM DM = mccmonochromator_curved_DM;
MCNUM mosaic = mccmonochromator_curved_mosaic;
MCNUM width = mccmonochromator_curved_width;
MCNUM height = mccmonochromator_curved_height;
MCNUM verbose = mccmonochromator_curved_verbose;
MCNUM order = mccmonochromator_curved_order;
/* 'monochromator_curved=Monochromator_curved()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 230 "/usr/share/mcstas/2.5/optics/Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;
      /* Visualise scattering point in proper, component frame 
	 - but only if the neutron is reflected, that is none of:
	 * transmitted
	 * falling outside the slab material */	
      if(!do_transmit) SCATTER;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 49176 "RITA-II.c"
/* 'monochromator_curved=Monochromator_curved()' component instance extend code */
    SIG_MESSAGE("monochromator_curved (Trace:Extend)");
if (( ! mcipVIRTUALIN )) {

#line 1218 "RITA-II.instr"
  if(SCATTERED) Mono_order=order;
#line 49182 "RITA-II.c"
}

}   /* End of monochromator_curved=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator_curved:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component a2 [55] */
  mccoordschange(mcposra2, mcrotra2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component a2 (without coords transformations) */
  mcJumpTrace_a2:
  SIG_MESSAGE("a2 (Trace)");
  mcDEBUG_COMP("a2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompa2
  STORE_NEUTRON(55,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[55]++;
  mcPCounter[55] += p;
  mcP2Counter[55] += p*p;
#define mccompcurname  a2
#define mccompcurtype  Arm
#define mccompcurindex 55
/* 'a2=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompa2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(55,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component slitShutter [56] */
  mccoordschange(mcposrslitShutter, mcrotrslitShutter,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component slitShutter (without coords transformations) */
  mcJumpTrace_slitShutter:
  SIG_MESSAGE("slitShutter (Trace)");
  mcDEBUG_COMP("slitShutter")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompslitShutter
  STORE_NEUTRON(56,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[56]++;
  mcPCounter[56] += p;
  mcP2Counter[56] += p*p;
#define mccompcurname  slitShutter
#define mccompcurtype  Slit
#define mccompcurindex 56
{   /* Declarations of slitShutter=Slit() SETTING parameters. */
MCNUM xmin = mccslitShutter_xmin;
MCNUM xmax = mccslitShutter_xmax;
MCNUM ymin = mccslitShutter_ymin;
MCNUM ymax = mccslitShutter_ymax;
MCNUM radius = mccslitShutter_radius;
MCNUM xwidth = mccslitShutter_xwidth;
MCNUM yheight = mccslitShutter_yheight;
/* 'slitShutter=Slit()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 71 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 49424 "RITA-II.c"
}   /* End of slitShutter=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompslitShutter:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(56,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component MSCollimator [57] */
  mccoordschange(mcposrMSCollimator, mcrotrMSCollimator,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component MSCollimator (without coords transformations) */
  mcJumpTrace_MSCollimator:
  SIG_MESSAGE("MSCollimator (Trace)");
  mcDEBUG_COMP("MSCollimator")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompMSCollimator
  STORE_NEUTRON(57,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[57]++;
  mcPCounter[57] += p;
  mcP2Counter[57] += p*p;
#define mccompcurname  MSCollimator
#define mccompcurtype  Collimator_linear
#define mccompcurindex 57
#define slope mccMSCollimator_slope
#define slopeV mccMSCollimator_slopeV
{   /* Declarations of MSCollimator=Collimator_linear() SETTING parameters. */
MCNUM xmin = mccMSCollimator_xmin;
MCNUM xmax = mccMSCollimator_xmax;
MCNUM ymin = mccMSCollimator_ymin;
MCNUM ymax = mccMSCollimator_ymax;
MCNUM xwidth = mccMSCollimator_xwidth;
MCNUM yheight = mccMSCollimator_yheight;
MCNUM length = mccMSCollimator_length;
MCNUM divergence = mccMSCollimator_divergence;
MCNUM transmission = mccMSCollimator_transmission;
MCNUM divergenceV = mccMSCollimator_divergenceV;
/* 'MSCollimator=Collimator_linear()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 69 "/usr/share/mcstas/2.5/optics/Collimator_linear.comp"
{
    double phi, dt;

    PROP_Z0;
    if (x<xmin || x>xmax || y<ymin || y>ymax)
      ABSORB;
    dt = length/vz;
    PROP_DT(dt);
    if (x<xmin || x>xmax || y<ymin || y>ymax)
      ABSORB;

    if(slope > 0.0)
    {
      phi = fabs(vx/vz);
      if (phi > slope)
        ABSORB;
      else
        p *= transmission*(1.0 - phi/slope);
      SCATTER;
    }
    if (slopeV > 0) {
      phi = fabs(vy/vz);
      if (phi > slopeV)
        ABSORB;
      else
        p *= transmission*(1.0 - phi/slopeV);
      SCATTER;
    }
}
#line 49574 "RITA-II.c"
}   /* End of MSCollimator=Collimator_linear() SETTING parameter declarations. */
#undef slopeV
#undef slope
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompMSCollimator:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(57,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component infilter [58] */
  mccoordschange(mcposrinfilter, mcrotrinfilter,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component infilter (without coords transformations) */
  mcJumpTrace_infilter:
  SIG_MESSAGE("infilter (Trace)");
  mcDEBUG_COMP("infilter")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompinfilter
  STORE_NEUTRON(58,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[58]++;
  mcPCounter[58] += p;
  mcP2Counter[58] += p*p;
#define mccompcurname  infilter
#define mccompcurtype  Filter_gen
#define mccompcurindex 58
#define pTable mccinfilter_pTable
#define Mode_Table mccinfilter_Mode_Table
#define Type_Table mccinfilter_Type_Table
{   /* Declarations of infilter=Filter_gen() SETTING parameters. */
char* filename = mccinfilter_filename;
char* options = mccinfilter_options;
MCNUM xmin = mccinfilter_xmin;
MCNUM xmax = mccinfilter_xmax;
MCNUM ymin = mccinfilter_ymin;
MCNUM ymax = mccinfilter_ymax;
MCNUM xwidth = mccinfilter_xwidth;
MCNUM yheight = mccinfilter_yheight;
MCNUM thickness = mccinfilter_thickness;
MCNUM scaling = mccinfilter_scaling;
MCNUM verbose = mccinfilter_verbose;
/* 'infilter=Filter_gen()' component instance has conditional execution */
if (( mcipINFILTER > 0 && ! mcipVIRTUALIN ))

#line 167 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  double v2, K, L, E, X, new_p;

  PROP_Z0;
  if (Type_Table && (x>xmin && x<xmax && y>ymin && y<ymax))
  {
    v2 = (vx*vx + vy*vy + vz*vz);
    K = V2K*sqrt(v2);        /* k */
    L = (2*PI/K);        /* lambda */
    E = VS2E*v2;        /* energy */
    if (Type_Table == ENERGY_TABLE)     X=E;
    if (Type_Table == WAVEVECTOR_TABLE) X=K;
    if (Type_Table == WAVELENGTH_TABLE) X=L;
    /* table look up */
    if (pTable.data != NULL)
    {
      double y1, y2, x1;
      long   Index;
      Index = floor((X - pTable.min_x)/pTable.step_x);
      y1 = Table_Index(pTable, Index,   1); /* 2nd column */
      x1 = Table_Index(pTable, Index,   0); /* 1st column */
      y2 = Table_Index(pTable, Index+1, 1); /* 2nd column */
      new_p = scaling*(y1+(X - x1)*(y2-y1)/pTable.step_x); /* 2nd column */
      if (thickness != 1) new_p = pow(new_p, thickness);
    }
    else new_p = 1;

    if (Mode_Table == FLUX_ADAPT_MULT) p *= new_p;
    else p = new_p;
    SCATTER;
  }
  else
    if (Type_Table) ABSORB;
}
#line 49733 "RITA-II.c"
}   /* End of infilter=Filter_gen() SETTING parameter declarations. */
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompinfilter:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(58,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_virt [59] */
  mccoordschange(mcposrpsd_virt, mcrotrpsd_virt,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_virt (without coords transformations) */
  mcJumpTrace_psd_virt:
  SIG_MESSAGE("psd_virt (Trace)");
  mcDEBUG_COMP("psd_virt")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_virt
  STORE_NEUTRON(59,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[59]++;
  mcPCounter[59] += p;
  mcP2Counter[59] += p*p;
#define mccompcurname  psd_virt
#define mccompcurtype  PSD_monitor
#define mccompcurindex 59
#define nx mccpsd_virt_nx
#define ny mccpsd_virt_ny
#define PSD_N mccpsd_virt_PSD_N
#define PSD_p mccpsd_virt_PSD_p
#define PSD_p2 mccpsd_virt_PSD_p2
{   /* Declarations of psd_virt=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_virt_filename;
MCNUM xmin = mccpsd_virt_xmin;
MCNUM xmax = mccpsd_virt_xmax;
MCNUM ymin = mccpsd_virt_ymin;
MCNUM ymax = mccpsd_virt_ymax;
MCNUM xwidth = mccpsd_virt_xwidth;
MCNUM yheight = mccpsd_virt_yheight;
MCNUM restore_neutron = mccpsd_virt_restore_neutron;
int nowritefile = mccpsd_virt_nowritefile;
/* 'psd_virt=PSD_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 83 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 49876 "RITA-II.c"
}   /* End of psd_virt=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_virt:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(59,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component lmon_virt [60] */
  mccoordschange(mcposrlmon_virt, mcrotrlmon_virt,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component lmon_virt (without coords transformations) */
  mcJumpTrace_lmon_virt:
  SIG_MESSAGE("lmon_virt (Trace)");
  mcDEBUG_COMP("lmon_virt")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComplmon_virt
  STORE_NEUTRON(60,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[60]++;
  mcPCounter[60] += p;
  mcP2Counter[60] += p*p;
#define mccompcurname  lmon_virt
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mcclmon_virt_nL
#define L_N mcclmon_virt_L_N
#define L_p mcclmon_virt_L_p
#define L_p2 mcclmon_virt_L_p2
{   /* Declarations of lmon_virt=L_monitor() SETTING parameters. */
char* filename = mcclmon_virt_filename;
MCNUM xmin = mcclmon_virt_xmin;
MCNUM xmax = mcclmon_virt_xmax;
MCNUM ymin = mcclmon_virt_ymin;
MCNUM ymax = mcclmon_virt_ymax;
MCNUM xwidth = mcclmon_virt_xwidth;
MCNUM yheight = mcclmon_virt_yheight;
MCNUM Lmin = mcclmon_virt_Lmin;
MCNUM Lmax = mcclmon_virt_Lmax;
MCNUM restore_neutron = mcclmon_virt_restore_neutron;
int nowritefile = mcclmon_virt_nowritefile;
/* 'lmon_virt=L_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#line 84 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 50026 "RITA-II.c"
}   /* End of lmon_virt=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComplmon_virt:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(60,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component aa2 [61] */
  mccoordschange(mcposraa2, mcrotraa2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component aa2 (without coords transformations) */
  mcJumpTrace_aa2:
  SIG_MESSAGE("aa2 (Trace)");
  mcDEBUG_COMP("aa2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompaa2
  STORE_NEUTRON(61,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[61]++;
  mcPCounter[61] += p;
  mcP2Counter[61] += p*p;
#define mccompcurname  aa2
#define mccompcurtype  Arm
#define mccompcurindex 61
/* 'aa2=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALIN ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompaa2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(61,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component virtualout [62] */
  mccoordschange(mcposrvirtualout, mcrotrvirtualout,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component virtualout (without coords transformations) */
  mcJumpTrace_virtualout:
  SIG_MESSAGE("virtualout (Trace)");
  mcDEBUG_COMP("virtualout")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompvirtualout
  STORE_NEUTRON(62,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[62]++;
  mcPCounter[62] += p;
  mcP2Counter[62] += p*p;
#define mccompcurname  virtualout
#define mccompcurtype  Virtual_output
#define mccompcurindex 62
#define DEFS mccvirtualout_DEFS
#define Vars mccvirtualout_Vars
{   /* Declarations of virtualout=Virtual_output() SETTING parameters. */
char* filename = mccvirtualout_filename;
MCNUM bufsize = mccvirtualout_bufsize;
/* 'virtualout=Virtual_output()' component instance has conditional execution */
if (( ! mcipVIRTUALIN && mcipVIRTUALOUT ))

#line 116 "/usr/share/mcstas/2.5/sources/Virtual_output.comp"
{
  double pp=0;

  /* PROP_Z0; */
  /* transfer current neutron to Monitor_nD vars */
  Vars.cp  = p;
  Vars.cx  = x;
  Vars.cvx = vx;
  Vars.csx = sx;
  Vars.cy  = y;
  Vars.cvy = vy;
  Vars.csy = sy;
  Vars.cz  = z;
  Vars.cvz = vz;
  Vars.csz = sz;
  Vars.ct  = t;

  pp = Monitor_nD_Trace(&DEFS, &Vars);

  SCATTER;
}
#line 50269 "RITA-II.c"
}   /* End of virtualout=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompvirtualout:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(62,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component virtualsource [63] */
  mccoordschange(mcposrvirtualsource, mcrotrvirtualsource,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component virtualsource (without coords transformations) */
  mcJumpTrace_virtualsource:
  SIG_MESSAGE("virtualsource (Trace)");
  mcDEBUG_COMP("virtualsource")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompvirtualsource
  STORE_NEUTRON(63,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[63]++;
  mcPCounter[63] += p;
  mcP2Counter[63] += p*p;
#define mccompcurname  virtualsource
#define mccompcurtype  Virtual_input
#define mccompcurindex 63
#define read_block mccvirtualsource_read_block
#define pos mccvirtualsource_pos
#define nrows mccvirtualsource_nrows
#define Offset mccvirtualsource_Offset
#define rTable mccvirtualsource_rTable
#define repeat_number mccvirtualsource_repeat_number
#define filename_ncount mccvirtualsource_filename_ncount
#define mean_vx mccvirtualsource_mean_vx
#define mean_vy mccvirtualsource_mean_vy
#define mean_vz mccvirtualsource_mean_vz
#define mean_dx mccvirtualsource_mean_dx
#define mean_dy mccvirtualsource_mean_dy
#define mean_dz mccvirtualsource_mean_dz
#define n_neutrons mccvirtualsource_n_neutrons
#define min_x mccvirtualsource_min_x
#define min_y mccvirtualsource_min_y
#define min_z mccvirtualsource_min_z
#define max_x mccvirtualsource_max_x
#define max_y mccvirtualsource_max_y
#define max_z mccvirtualsource_max_z
#define min_vx mccvirtualsource_min_vx
#define min_vy mccvirtualsource_min_vy
#define min_vz mccvirtualsource_min_vz
#define max_vx mccvirtualsource_max_vx
#define max_vy mccvirtualsource_max_vy
#define max_vz mccvirtualsource_max_vz
#define first_block mccvirtualsource_first_block
#define mean_x mccvirtualsource_mean_x
#define mean_y mccvirtualsource_mean_y
#define mean_z mccvirtualsource_mean_z
#define end_reading mccvirtualsource_end_reading
#define n_count_extrapolated mccvirtualsource_n_count_extrapolated
#define repeat_cnt mccvirtualsource_repeat_cnt
{   /* Declarations of virtualsource=Virtual_input() SETTING parameters. */
char* filename = mccvirtualsource_filename;
MCNUM verbose = mccvirtualsource_verbose;
MCNUM repeat_count = mccvirtualsource_repeat_count;
MCNUM smooth = mccvirtualsource_smooth;
MCNUM display = mccvirtualsource_display;
/* 'virtualsource=Virtual_input()' component instance has conditional execution */
if (( mcipVIRTUALIN && ! mcipVIRTUALOUT ))

#line 202 "/usr/share/mcstas/2.5/sources/Virtual_input.comp"
{
  if (filename && strlen(filename) && strcmp(filename, "NULL") && strcmp(filename,"0")) {
    while (read_block && !end_reading) {
      /* read block and increase Offset for next reading */
      nrows = Virtual_input_Read_Input(filename, type, &rTable, &Offset);

      if (!nrows) { /* nrows is 0 if end of filename/no filename */
        if (!filename_ncount) {
          filename_ncount = (double)mcget_run_num();  /* ncount in filename */
          if (verbose)
            printf("Virtual_input: %s: filename '%s' contains %g events\n", NAME_CURRENT_COMP, filename, filename_ncount);
          /* set ncount from filename length */
          mcset_ncount(filename_ncount*repeat_cnt);
        }
        Offset = 0;       /* reposition to begining of filename */
        repeat_number++;  /* we start a new repeat_cnt loop */

        /* end of simulation if ... */
        if (repeat_number > repeat_cnt) {
          if (verbose)
            printf("Virtual_input: %s: Ending after %g events (%li repeat count)\n", NAME_CURRENT_COMP, (double)mcget_run_num(), (long)repeat_cnt);
          read_block=0; mcset_ncount(mcget_run_num()); pos=0;
          end_reading = 1;
        }
        /* else continue reading blocks */

      } else { /* block at Offset could be read */
        pos = 0;  /* position at begining of new block */
        read_block = 0;
      }
    }

      /* &p, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz */
    if (!end_reading) {
      /* BEWARE! This is a non-standard way of using mcrestore_neutron, order of parameters
	 MUST be  &p, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy,  &sz
         to match the data format from the Virtual_input files */
      mcrestore_neutron(rTable.data,pos, &p, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy,  &sz);

      if (first_block) {
        double v;
        mean_x  += p*x;  mean_y  += p*y;  mean_z  += p*z;
        mean_vx += p*vx; mean_vy += p*vy; mean_vz += p*vz;
        v = sqrt(vx*vx+vy*vy+vz*vz);
        if (v)
          { mean_dx += p*fabs(vx/v); mean_dy += p*fabs(vy/v); mean_dz += p*fabs(vz/v); }
        if (x  < min_x)  min_x  = x;
        if (y  < min_y)  min_y  = y;
        if (z  < min_z)  min_z  = z;
        if (vx < min_vx) min_vx = vx;
        if (vy < min_vy) min_vy = vy;
        if (vz < min_vz) min_vz = z;
        if (x  > max_x)  max_x  = x;
        if (y  > max_y)  max_y  = y;
        if (z  > max_z)  max_z  = z;
        if (vx > max_vx) max_vx = vx;
        if (vy > max_vy) max_vy = vy;
        if (vz > max_vz) max_vz = z;
        n_neutrons += p;
      }

      pos++;
      p /= repeat_cnt;
#ifdef USE_MPI
      /* We always repeat by the number of nodes in an MPI run */
      p /= mpi_node_count;
#endif

      SCATTER;

      if (pos >= nrows) { /* reached end of block */
        read_block = 1;
        if (first_block) {
          double mean_v;
          /* display statitics for 1st block */
          mean_x  /= n_neutrons;
          mean_y  /= n_neutrons;
          mean_z  /= n_neutrons;
          mean_vx /= n_neutrons;
          mean_vy /= n_neutrons;
          mean_vz /= n_neutrons;
          mean_dx /= n_neutrons;
          mean_dy /= n_neutrons;
          mean_dz /= n_neutrons;
          /* now estimates total ncount */
          mean_v = sqrt(mean_vx*mean_vx+mean_vy*mean_vy+mean_vz*mean_vz);
          n_count_extrapolated = (double)nrows*rTable.filesize/Offset;
          if (verbose) {
            double mean_k, mean_w=0, mean_L=0;

            mean_k = V2K*mean_v;
            if (mean_k) mean_L = 2*PI/mean_k;
            mean_w = VS2E*mean_v*mean_v;
            printf("McStas Virtual Source filename %s\nContains about %g events, intensity=%g\n", filename, n_count_extrapolated, n_neutrons*rTable.filesize/Offset);

            printf("  Source size (full width in [m]):      ");
            printf("    dX=%g dY=%g dZ=%g\n", max_x-min_x, max_y-min_y, max_z-min_z);
            printf("  Source center (in [m]):               ");
            printf("    X0=%g Y0=%g Z0=%g\n", mean_x, mean_y, mean_z);
            printf("  Beam divergence (full width in [deg]):");
            printf("    dVx=%g dVy=%g dVz=%g\n",
              atan(mean_dx)*RAD2DEG,
              atan(mean_dy)*RAD2DEG,
              atan(mean_dz)*RAD2DEG);
            printf("  Beam speed (in [m/s]):                ");
            printf("    Vx=%g Vy=%g Vz=%g\n", mean_vx, mean_vy, mean_vz);
            printf("  Beam mean energy:\n");
            printf("    speed=%g [m/s] energy=%g [meV]\n    wavelength=%g [Angs] wavevector=%g [Angs-1]\n", mean_v, mean_w, mean_L, mean_k);
          }
          /* set ncount from estimate with security margin 10 % */
          mcset_ncount(n_count_extrapolated*repeat_cnt*1.1);
        }
        first_block= 0;
      }
  #if defined (USE_MPI)
      if (smooth && n_count_extrapolated)
  #else
      if (smooth && repeat_number>1 && n_count_extrapolated)
  #endif
      {
        /* apply smmothing */
        x += randnorm()*(max_x-min_x)/n_count_extrapolated/2;
        y += randnorm()*(max_y-min_y)/n_count_extrapolated/2;
        z += randnorm()*(max_z-min_z)/n_count_extrapolated/2;
        vx += randnorm()*min_vx/n_count_extrapolated/2;
        vy += randnorm()*min_vx/n_count_extrapolated/2;
        vx += randnorm()*min_vx/n_count_extrapolated/2;
      }
    } else { ABSORB; }
  }
}
#line 50549 "RITA-II.c"
}   /* End of virtualsource=Virtual_input() SETTING parameter declarations. */
#undef repeat_cnt
#undef n_count_extrapolated
#undef end_reading
#undef mean_z
#undef mean_y
#undef mean_x
#undef first_block
#undef max_vz
#undef max_vy
#undef max_vx
#undef min_vz
#undef min_vy
#undef min_vx
#undef max_z
#undef max_y
#undef max_x
#undef min_z
#undef min_y
#undef min_x
#undef n_neutrons
#undef mean_dz
#undef mean_dy
#undef mean_dx
#undef mean_vz
#undef mean_vy
#undef mean_vx
#undef filename_ncount
#undef repeat_number
#undef rTable
#undef Offset
#undef nrows
#undef pos
#undef read_block
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompvirtualsource:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(63,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component OrderMon [64] */
  mccoordschange(mcposrOrderMon, mcrotrOrderMon,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component OrderMon (without coords transformations) */
  mcJumpTrace_OrderMon:
  SIG_MESSAGE("OrderMon (Trace)");
  mcDEBUG_COMP("OrderMon")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompOrderMon
  STORE_NEUTRON(64,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[64]++;
  mcPCounter[64] += p;
  mcP2Counter[64] += p*p;
#define mccompcurname  OrderMon
#define mccompcurtype  Monitor_nD
#define mccompcurindex 64
#define user1 mccOrderMon_user1
#define user2 mccOrderMon_user2
#define user3 mccOrderMon_user3
#define DEFS mccOrderMon_DEFS
#define Vars mccOrderMon_Vars
#define detector mccOrderMon_detector
#define offdata mccOrderMon_offdata
{   /* Declarations of OrderMon=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccOrderMon_xwidth;
MCNUM yheight = mccOrderMon_yheight;
MCNUM zdepth = mccOrderMon_zdepth;
MCNUM xmin = mccOrderMon_xmin;
MCNUM xmax = mccOrderMon_xmax;
MCNUM ymin = mccOrderMon_ymin;
MCNUM ymax = mccOrderMon_ymax;
MCNUM zmin = mccOrderMon_zmin;
MCNUM zmax = mccOrderMon_zmax;
MCNUM bins = mccOrderMon_bins;
MCNUM min = mccOrderMon_min;
MCNUM max = mccOrderMon_max;
MCNUM restore_neutron = mccOrderMon_restore_neutron;
MCNUM radius = mccOrderMon_radius;
char* options = mccOrderMon_options;
char* filename = mccOrderMon_filename;
char* geometry = mccOrderMon_geometry;
char* username1 = mccOrderMon_username1;
char* username2 = mccOrderMon_username2;
char* username3 = mccOrderMon_username3;
int nowritefile = mccOrderMon_nowritefile;
/* 'OrderMon=Monitor_nD()' component instance has conditional execution */
if (( Mono_order && ! mcipVIRTUALOUT ))

#line 310 "/usr/share/mcstas/2.5/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 50887 "RITA-II.c"
}   /* End of OrderMon=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompOrderMon:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(64,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component kMoni [65] */
  mccoordschange(mcposrkMoni, mcrotrkMoni,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component kMoni (without coords transformations) */
  mcJumpTrace_kMoni:
  SIG_MESSAGE("kMoni (Trace)");
  mcDEBUG_COMP("kMoni")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompkMoni
  STORE_NEUTRON(65,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[65]++;
  mcPCounter[65] += p;
  mcP2Counter[65] += p*p;
#define mccompcurname  kMoni
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 65
#define nx mcckMoni_nx
#define ny mcckMoni_ny
#define filename mcckMoni_filename
#define PSD_N mcckMoni_PSD_N
#define PSD_p mcckMoni_PSD_p
#define PSD_p2 mcckMoni_PSD_p2
#define weight mcckMoni_weight
{   /* Declarations of kMoni=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni_xmin;
MCNUM xmax = mcckMoni_xmax;
MCNUM ymin = mcckMoni_ymin;
MCNUM ymax = mcckMoni_ymax;
MCNUM xwidth = mcckMoni_xwidth;
MCNUM yheight = mcckMoni_yheight;
MCNUM psf = mcckMoni_psf;
MCNUM k0 = mcckMoni_k0;
MCNUM eff = mcckMoni_eff;
MCNUM restore_neutron = mcckMoni_restore_neutron;
int nowritefile = mcckMoni_nowritefile;
/* 'kMoni=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 51044 "RITA-II.c"
}   /* End of kMoni=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompkMoni:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(65,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component kMoni1st [66] */
  mccoordschange(mcposrkMoni1st, mcrotrkMoni1st,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component kMoni1st (without coords transformations) */
  mcJumpTrace_kMoni1st:
  SIG_MESSAGE("kMoni1st (Trace)");
  mcDEBUG_COMP("kMoni1st")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompkMoni1st
  STORE_NEUTRON(66,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[66]++;
  mcPCounter[66] += p;
  mcP2Counter[66] += p*p;
#define mccompcurname  kMoni1st
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 66
#define nx mcckMoni1st_nx
#define ny mcckMoni1st_ny
#define filename mcckMoni1st_filename
#define PSD_N mcckMoni1st_PSD_N
#define PSD_p mcckMoni1st_PSD_p
#define PSD_p2 mcckMoni1st_PSD_p2
#define weight mcckMoni1st_weight
{   /* Declarations of kMoni1st=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni1st_xmin;
MCNUM xmax = mcckMoni1st_xmax;
MCNUM ymin = mcckMoni1st_ymin;
MCNUM ymax = mcckMoni1st_ymax;
MCNUM xwidth = mcckMoni1st_xwidth;
MCNUM yheight = mcckMoni1st_yheight;
MCNUM psf = mcckMoni1st_psf;
MCNUM k0 = mcckMoni1st_k0;
MCNUM eff = mcckMoni1st_eff;
MCNUM restore_neutron = mcckMoni1st_restore_neutron;
int nowritefile = mcckMoni1st_nowritefile;
/* 'kMoni1st=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( Mono_order == 1 && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 51201 "RITA-II.c"
}   /* End of kMoni1st=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompkMoni1st:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(66,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component kMoni2nd [67] */
  mccoordschange(mcposrkMoni2nd, mcrotrkMoni2nd,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component kMoni2nd (without coords transformations) */
  mcJumpTrace_kMoni2nd:
  SIG_MESSAGE("kMoni2nd (Trace)");
  mcDEBUG_COMP("kMoni2nd")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompkMoni2nd
  STORE_NEUTRON(67,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[67]++;
  mcPCounter[67] += p;
  mcP2Counter[67] += p*p;
#define mccompcurname  kMoni2nd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 67
#define nx mcckMoni2nd_nx
#define ny mcckMoni2nd_ny
#define filename mcckMoni2nd_filename
#define PSD_N mcckMoni2nd_PSD_N
#define PSD_p mcckMoni2nd_PSD_p
#define PSD_p2 mcckMoni2nd_PSD_p2
#define weight mcckMoni2nd_weight
{   /* Declarations of kMoni2nd=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni2nd_xmin;
MCNUM xmax = mcckMoni2nd_xmax;
MCNUM ymin = mcckMoni2nd_ymin;
MCNUM ymax = mcckMoni2nd_ymax;
MCNUM xwidth = mcckMoni2nd_xwidth;
MCNUM yheight = mcckMoni2nd_yheight;
MCNUM psf = mcckMoni2nd_psf;
MCNUM k0 = mcckMoni2nd_k0;
MCNUM eff = mcckMoni2nd_eff;
MCNUM restore_neutron = mcckMoni2nd_restore_neutron;
int nowritefile = mcckMoni2nd_nowritefile;
/* 'kMoni2nd=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( Mono_order == 2 && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 51358 "RITA-II.c"
}   /* End of kMoni2nd=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompkMoni2nd:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(67,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component kMoni3rd [68] */
  mccoordschange(mcposrkMoni3rd, mcrotrkMoni3rd,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component kMoni3rd (without coords transformations) */
  mcJumpTrace_kMoni3rd:
  SIG_MESSAGE("kMoni3rd (Trace)");
  mcDEBUG_COMP("kMoni3rd")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompkMoni3rd
  STORE_NEUTRON(68,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[68]++;
  mcPCounter[68] += p;
  mcP2Counter[68] += p*p;
#define mccompcurname  kMoni3rd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 68
#define nx mcckMoni3rd_nx
#define ny mcckMoni3rd_ny
#define filename mcckMoni3rd_filename
#define PSD_N mcckMoni3rd_PSD_N
#define PSD_p mcckMoni3rd_PSD_p
#define PSD_p2 mcckMoni3rd_PSD_p2
#define weight mcckMoni3rd_weight
{   /* Declarations of kMoni3rd=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni3rd_xmin;
MCNUM xmax = mcckMoni3rd_xmax;
MCNUM ymin = mcckMoni3rd_ymin;
MCNUM ymax = mcckMoni3rd_ymax;
MCNUM xwidth = mcckMoni3rd_xwidth;
MCNUM yheight = mcckMoni3rd_yheight;
MCNUM psf = mcckMoni3rd_psf;
MCNUM k0 = mcckMoni3rd_k0;
MCNUM eff = mcckMoni3rd_eff;
MCNUM restore_neutron = mcckMoni3rd_restore_neutron;
int nowritefile = mcckMoni3rd_nowritefile;
/* 'kMoni3rd=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( Mono_order == 3 && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 51515 "RITA-II.c"
}   /* End of kMoni3rd=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompkMoni3rd:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(68,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component slitMonochromator [69] */
  mccoordschange(mcposrslitMonochromator, mcrotrslitMonochromator,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component slitMonochromator (without coords transformations) */
  mcJumpTrace_slitMonochromator:
  SIG_MESSAGE("slitMonochromator (Trace)");
  mcDEBUG_COMP("slitMonochromator")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompslitMonochromator
  STORE_NEUTRON(69,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[69]++;
  mcPCounter[69] += p;
  mcP2Counter[69] += p*p;
#define mccompcurname  slitMonochromator
#define mccompcurtype  Slit
#define mccompcurindex 69
{   /* Declarations of slitMonochromator=Slit() SETTING parameters. */
MCNUM xmin = mccslitMonochromator_xmin;
MCNUM xmax = mccslitMonochromator_xmax;
MCNUM ymin = mccslitMonochromator_ymin;
MCNUM ymax = mccslitMonochromator_ymax;
MCNUM radius = mccslitMonochromator_radius;
MCNUM xwidth = mccslitMonochromator_xwidth;
MCNUM yheight = mccslitMonochromator_yheight;
/* 'slitMonochromator=Slit()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 71 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 51646 "RITA-II.c"
}   /* End of slitMonochromator=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompslitMonochromator:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(69,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Perspex [70] */
  mccoordschange(mcposrPerspex, mcrotrPerspex,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Perspex (without coords transformations) */
  mcJumpTrace_Perspex:
  SIG_MESSAGE("Perspex (Trace)");
  mcDEBUG_COMP("Perspex")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPerspex
  STORE_NEUTRON(70,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[70]++;
  mcPCounter[70] += p;
  mcP2Counter[70] += p*p;
#define mccompcurname  Perspex
#define mccompcurtype  Incoherent
#define mccompcurindex 70
#define VarsInc mccPerspex_VarsInc
#define offdata mccPerspex_offdata
{   /* Declarations of Perspex=Incoherent() SETTING parameters. */
char* geometry = mccPerspex_geometry;
MCNUM radius = mccPerspex_radius;
MCNUM xwidth = mccPerspex_xwidth;
MCNUM yheight = mccPerspex_yheight;
MCNUM zdepth = mccPerspex_zdepth;
MCNUM thickness = mccPerspex_thickness;
MCNUM target_x = mccPerspex_target_x;
MCNUM target_y = mccPerspex_target_y;
MCNUM target_z = mccPerspex_target_z;
MCNUM focus_r = mccPerspex_focus_r;
MCNUM focus_xw = mccPerspex_focus_xw;
MCNUM focus_yh = mccPerspex_focus_yh;
MCNUM focus_aw = mccPerspex_focus_aw;
MCNUM focus_ah = mccPerspex_focus_ah;
int target_index = mccPerspex_target_index;
MCNUM pack = mccPerspex_pack;
MCNUM p_interact = mccPerspex_p_interact;
MCNUM f_QE = mccPerspex_f_QE;
MCNUM gamma = mccPerspex_gamma;
MCNUM Etrans = mccPerspex_Etrans;
MCNUM deltaE = mccPerspex_deltaE;
MCNUM sigma_abs = mccPerspex_sigma_abs;
MCNUM sigma_inc = mccPerspex_sigma_inc;
MCNUM Vc = mccPerspex_Vc;
MCNUM concentric = mccPerspex_concentric;
MCNUM order = mccPerspex_order;
/* 'Perspex=Incoherent()' component instance has conditional execution */
if (( mcipPERSPEX > 0 && ! mcipVIRTUALOUT ))

#line 232 "/usr/share/mcstas/2.5/samples/Incoherent.comp"
{
  double t0, t3;                /* Entry/exit time for outer surface */
  double t1, t2;                /* Entry/exit time for inner surface */
  double dt0, dt1, dt2, dt;     /* Flight times through sample */
  double v=0;                   /* Neutron velocity */
  double d_path;                /* Flight path length for non-scattered neutron */
  double l_i, l_o=0;            /* Flight path lenght in/out for scattered neutron */
  double my_a=0,my_t=0;         /* Velocity-dependent attenuation factor and total Xsec */
  double solid_angle=0;         /* Solid angle of target as seen from scattering point */
  double aim_x=0, aim_y=0, aim_z=1;   /* Position of target relative to scattering point */
  double v_i, v_f, E_i, E_f; /* initial and final energies and velocities */
  double dE;                 /* Energy transfer */
  int    intersect=0;
  int    flag_concentric=0;
  int    flag=0;
  double mc_trans, p_trans, mc_scatt, p_scatt, ws;
  double p_mult=1;

  do { /* Main interaction loop. Ends with intersect=0 */

    /* Intersection neutron trajectory / sample (sample surface) */
    if (VarsInc.shape == 0)
      intersect = cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius, yheight);
    else if (VarsInc.shape == 1)
      intersect = box_intersect(&t0, &t3, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);
    else if (VarsInc.shape == 2)
      intersect = sphere_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius);
    else if (VarsInc.shape == 3)
      intersect = off_intersect(&t0, &t3, NULL, NULL, x, y, z, vx, vy, vz, offdata );
    if (intersect) {
      int flag_ishollow = 0;
      if (thickness>0) {
        if (VarsInc.shape==0 && cylinder_intersect(&t1,&t2, x,y,z,vx,vy,vz, radius-thickness,yheight-2*thickness))
          flag_ishollow=1;
        else if (VarsInc.shape==2 && sphere_intersect   (&t1,&t2, x,y,z,vx,vy,vz, radius-thickness))
          flag_ishollow=1;
        else if (VarsInc.shape==1 && box_intersect(&t1,&t2, x,y,z,vx,vy,vz, xwidth-2*thickness, yheight-2*thickness, zdepth-2*thickness))
          flag_ishollow = 1;
      }
      if (!flag_ishollow) t1 = t2 = t3; /* no empty space inside */

      dt0 = t1-t0;                /* Time in sample, ingoing */
      dt1 = t2-t1;                /* Time in hole */
      dt2 = t3-t2;                /* Time in sample, outgoing */

      if (t0 > 0) {  /* we are before the sample */
        PROP_DT(t0); /* propagates neutron to the entry of the sample */
      } else if (t1 > 0 && t1 > t0) { /* we are inside first part of the sample */
        /* no propagation, stay inside */
      } else if (t2 > 0 && t2 > t1) { /* we are in the hole */
        PROP_DT(t2); /* propagate to inner surface of 2nd part of sample */
      } else if (t3 > 0 && t3 > t2) { /* we are in the 2nd part of sample */
        /* no propagation, stay inside */
      }

      dt0=t1-(t0 > 0 ? t0 : 0); /* Time in first part of hollow/cylinder/box */
      dt1=t2-(t1 > 0 ? t1 : 0); /* Time in hole */
      dt2=t3-(t2 > 0 ? t2 : 0); /* Time in 2nd part of hollow cylinder */

      if (dt0 < 0) dt0 = 0;
      if (dt1 < 0) dt1 = 0;
      if (dt2 < 0) dt2 = 0;

      /* initialize concentric mode */
      if (concentric && !flag_concentric && t0 >= 0
       && VarsInc.shape==0 && thickness>0) {
        flag_concentric=1;
      }

      if (flag_concentric == 1) {
        dt1=dt2=0; /* force exit when reaching hole/2nd part */
      }

      if (!dt0 && !dt2) {
        intersect = 0; /* the sample was passed entirely */
        break;
      }

      p_mult = 1;
      if (!v) v = sqrt(vx*vx + vy*vy + vz*vz);
      if (v) my_a = VarsInc.my_a_v*(2200/v);
      else {
        printf("Incoherent: %s: ERROR: Null velocity\n",NAME_CURRENT_COMP);
        ABSORB; /* should never occur */
      }

      my_t = my_a + VarsInc.my_s;  /* total scattering Xsect (tmp var) */
      if (my_t <= 0) {
        printf("Incoherent: %s: ERROR: Null total cross section %g. Removing event.\n",
          NAME_CURRENT_COMP, my_t);
        ABSORB; /* should never occur */
      }
      d_path = v * (dt0 + dt2);   /* Length of full path through sample */
      /* Proba of scattering vs absorption (integrating along the whole trajectory) */
      ws = VarsInc.my_s/my_t;  /* (inc+coh)/(inc+coh+abs) */
      /* Proba of transmission along length d_path */
      p_trans = exp(-my_t*d_path);
      p_scatt = 1 - p_trans; /* portion of beam which scatters */
      flag = 0; /* flag used for propagation to exit point before ending */
      /* are we next to the exit ? probably no scattering (avoid rounding errors) */
      if (VarsInc.my_s*d_path <= 4e-7) {
        flag = 1;           /* No interaction before the exit */
      }
      /* force a given fraction of the beam to scatter */
      if (p_interact>0 && p_interact<=1) {
        /* we force a portion of the beam to interact */
        /* This is used to improve statistics on single scattering (and multiple) */
        if (!SCATTERED) mc_trans = 1-p_interact;
        else            mc_trans = 1-p_interact/(4*SCATTERED+1); /* reduce effect on multi scatt */
      } else {
        mc_trans = p_trans; /* 1 - p_scatt */
      }
      mc_scatt = 1 - mc_trans; /* portion of beam to scatter (or force to) */
      if (mc_scatt <= 0 || mc_scatt>1) flag=1;
      /* MC choice: Interaction or transmission ? */
      if (!flag && mc_scatt > 0 && (mc_scatt >= 1 || (rand01()) < mc_scatt)) { /* Interaction neutron/sample */
        p_mult *= ws; /* Update weight ; account for absorption and retain scattered fraction */
        if (!mc_scatt) ABSORB;
        /* we have chosen portion mc_scatt of beam instead of p_scatt, so we compensate */
        p_mult *= fabs(p_scatt/mc_scatt); /* lower than 1 */
      } else {
        flag = 1; /* Transmission : no interaction neutron/sample */
        if (!mc_trans) ABSORB;
        p_mult *= fabs(p_trans/mc_trans);  /* attenuate beam by portion which is scattered (and left along) */
      }

      if (flag) { /* propagate to exit of sample and finish */
        intersect = 0;
        p *= p_mult; /* apply absorption correction */
        PROP_DT(dt0+dt2);
        break; /* exit main multi scatt while loop */
      }
      if (my_t*d_path < 1e-6)
      /* For very weak scattering, use simple uniform sampling of scattering
         point to avoid rounding errors. */
        dt = rand0max(d_path); /* length */
      else
        dt = -log(1 - rand0max((1 - exp(-my_t*d_path)))) / my_t; /* length */
      l_i = dt;/* Penetration in sample: scattering+abs */
      dt /= v; /* Time from present position to scattering point */

      /* If t0 is in hole, propagate to next part of the hollow cylinder */
      if (dt1 > 0 && dt0 > 0 && dt > dt0) dt += dt1;

      PROP_DT(dt);                /* Point of scattering */

      if ((VarsInc.tx || VarsInc.ty || VarsInc.tz)) {
        aim_x = VarsInc.tx-x;       /* Vector pointing at target (anal./det.) */
        aim_y = VarsInc.ty-y;
        aim_z = VarsInc.tz-z;
      }
      if(VarsInc.aw && VarsInc.ah) {
        randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
          aim_x, aim_y, aim_z, VarsInc.aw, VarsInc.ah, ROT_A_CURRENT_COMP);
      } else if(VarsInc.xw && VarsInc.yh) {
        randvec_target_rect(&vx, &vy, &vz, &solid_angle,
          aim_x, aim_y, aim_z, VarsInc.xw, VarsInc.yh, ROT_A_CURRENT_COMP);
      } else {
        randvec_target_circle(&vx, &vy, &vz, &solid_angle, aim_x, aim_y, aim_z, focus_r);
      }
      NORM(vx, vy, vz);

      v_i = v;          /* Store initial velocity in case of quasielastic */
      E_i = VS2E*v_i*v_i;
      if (deltaE==0) { 
	if (rand01()<f_QE)	/* Quasielastic contribution */
	  {
	    dE = gamma*tan(PI/2*randpm1());
	    E_f = E_i + dE;
	    if (E_f <= 0)
	      ABSORB;
	    v_f = SE2V*sqrt(E_f);
	    v = v_f;
	    /*          printf("vi: %g Ei: %g dE: %g Ef %g vf: %g v: %g \n",
			v_i,E_i,dE,E_f,v_f,v); */
	  }
      } else {
	E_f = E_i - Etrans + deltaE*randpm1(); // E_f=E0;
	v_f = SE2V*sqrt(E_f);
	v = v_f;
      }

      vx *= v;
      vy *= v;
      vz *= v;

      /* We do not consider scattering from 2nd part (outgoing) */
      p_mult *= solid_angle/4/PI;
      p *= p_mult;

      /* Polarisation part (1/3 NSF, 2/3 SF) */
      sx *= -1.0/3.0;
      sy *= -1.0/3.0;
      sz *= -1.0/3.0;

      SCATTER;

      /* test for a given multiple order */
      if (order && SCATTERED >= order) {
        intersect=0; /* reached required number of SCATTERing */
        break;       /* finish multiple scattering loop */
      }
    } /* end if intersect */
  } while (intersect); /* end do (intersect) (multiple scattering loop) */
}
#line 51988 "RITA-II.c"
}   /* End of Perspex=Incoherent() SETTING parameter declarations. */
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPerspex:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(70,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_samplepos_1cm2 [71] */
  mccoordschange(mcposrpsd_samplepos_1cm2, mcrotrpsd_samplepos_1cm2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_samplepos_1cm2 (without coords transformations) */
  mcJumpTrace_psd_samplepos_1cm2:
  SIG_MESSAGE("psd_samplepos_1cm2 (Trace)");
  mcDEBUG_COMP("psd_samplepos_1cm2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_samplepos_1cm2
  STORE_NEUTRON(71,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[71]++;
  mcPCounter[71] += p;
  mcP2Counter[71] += p*p;
#define mccompcurname  psd_samplepos_1cm2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 71
#define nx mccpsd_samplepos_1cm2_nx
#define ny mccpsd_samplepos_1cm2_ny
#define PSD_N mccpsd_samplepos_1cm2_PSD_N
#define PSD_p mccpsd_samplepos_1cm2_PSD_p
#define PSD_p2 mccpsd_samplepos_1cm2_PSD_p2
{   /* Declarations of psd_samplepos_1cm2=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_samplepos_1cm2_filename;
MCNUM xmin = mccpsd_samplepos_1cm2_xmin;
MCNUM xmax = mccpsd_samplepos_1cm2_xmax;
MCNUM ymin = mccpsd_samplepos_1cm2_ymin;
MCNUM ymax = mccpsd_samplepos_1cm2_ymax;
MCNUM xwidth = mccpsd_samplepos_1cm2_xwidth;
MCNUM yheight = mccpsd_samplepos_1cm2_yheight;
MCNUM restore_neutron = mccpsd_samplepos_1cm2_restore_neutron;
int nowritefile = mccpsd_samplepos_1cm2_nowritefile;
/* 'psd_samplepos_1cm2=PSD_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 83 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 52130 "RITA-II.c"
}   /* End of psd_samplepos_1cm2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_samplepos_1cm2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(71,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_samplepos_1cm2 [72] */
  mccoordschange(mcposremon_samplepos_1cm2, mcrotremon_samplepos_1cm2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_samplepos_1cm2 (without coords transformations) */
  mcJumpTrace_emon_samplepos_1cm2:
  SIG_MESSAGE("emon_samplepos_1cm2 (Trace)");
  mcDEBUG_COMP("emon_samplepos_1cm2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_samplepos_1cm2
  STORE_NEUTRON(72,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[72]++;
  mcPCounter[72] += p;
  mcP2Counter[72] += p*p;
#define mccompcurname  emon_samplepos_1cm2
#define mccompcurtype  E_monitor
#define mccompcurindex 72
#define nE mccemon_samplepos_1cm2_nE
#define E_N mccemon_samplepos_1cm2_E_N
#define E_p mccemon_samplepos_1cm2_E_p
#define E_p2 mccemon_samplepos_1cm2_E_p2
#define S_p mccemon_samplepos_1cm2_S_p
#define S_pE mccemon_samplepos_1cm2_S_pE
#define S_pE2 mccemon_samplepos_1cm2_S_pE2
{   /* Declarations of emon_samplepos_1cm2=E_monitor() SETTING parameters. */
char* filename = mccemon_samplepos_1cm2_filename;
MCNUM xmin = mccemon_samplepos_1cm2_xmin;
MCNUM xmax = mccemon_samplepos_1cm2_xmax;
MCNUM ymin = mccemon_samplepos_1cm2_ymin;
MCNUM ymax = mccemon_samplepos_1cm2_ymax;
MCNUM xwidth = mccemon_samplepos_1cm2_xwidth;
MCNUM yheight = mccemon_samplepos_1cm2_yheight;
MCNUM Emin = mccemon_samplepos_1cm2_Emin;
MCNUM Emax = mccemon_samplepos_1cm2_Emax;
MCNUM restore_neutron = mccemon_samplepos_1cm2_restore_neutron;
int nowritefile = mccemon_samplepos_1cm2_nowritefile;
/* 'emon_samplepos_1cm2=E_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 52288 "RITA-II.c"
}   /* End of emon_samplepos_1cm2=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_samplepos_1cm2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(72,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component divmon_samplepos_1cm2 [73] */
  mccoordschange(mcposrdivmon_samplepos_1cm2, mcrotrdivmon_samplepos_1cm2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component divmon_samplepos_1cm2 (without coords transformations) */
  mcJumpTrace_divmon_samplepos_1cm2:
  SIG_MESSAGE("divmon_samplepos_1cm2 (Trace)");
  mcDEBUG_COMP("divmon_samplepos_1cm2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompdivmon_samplepos_1cm2
  STORE_NEUTRON(73,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[73]++;
  mcPCounter[73] += p;
  mcP2Counter[73] += p*p;
#define mccompcurname  divmon_samplepos_1cm2
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 73
#define nh mccdivmon_samplepos_1cm2_nh
#define nv mccdivmon_samplepos_1cm2_nv
#define Div_N mccdivmon_samplepos_1cm2_Div_N
#define Div_p mccdivmon_samplepos_1cm2_Div_p
#define Div_p2 mccdivmon_samplepos_1cm2_Div_p2
{   /* Declarations of divmon_samplepos_1cm2=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_samplepos_1cm2_filename;
MCNUM xmin = mccdivmon_samplepos_1cm2_xmin;
MCNUM xmax = mccdivmon_samplepos_1cm2_xmax;
MCNUM ymin = mccdivmon_samplepos_1cm2_ymin;
MCNUM ymax = mccdivmon_samplepos_1cm2_ymax;
MCNUM xwidth = mccdivmon_samplepos_1cm2_xwidth;
MCNUM yheight = mccdivmon_samplepos_1cm2_yheight;
MCNUM maxdiv_h = mccdivmon_samplepos_1cm2_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_samplepos_1cm2_maxdiv_v;
MCNUM restore_neutron = mccdivmon_samplepos_1cm2_restore_neutron;
MCNUM nx = mccdivmon_samplepos_1cm2_nx;
MCNUM ny = mccdivmon_samplepos_1cm2_ny;
MCNUM nz = mccdivmon_samplepos_1cm2_nz;
int nowritefile = mccdivmon_samplepos_1cm2_nowritefile;
/* 'divmon_samplepos_1cm2=Divergence_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    int i,j;
    double h_div, v_div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      h_div = RAD2DEG*atan2(vx,vn);
      v_div = RAD2DEG*atan2(vy,vn);
      if (h_div < maxdiv_h && h_div > -maxdiv_h &&
          v_div < maxdiv_v && v_div > -maxdiv_v)
      {
        i = floor((h_div + maxdiv_h)*nh/(2.0*maxdiv_h));
        j = floor((v_div + maxdiv_v)*nv/(2.0*maxdiv_v));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 52450 "RITA-II.c"
}   /* End of divmon_samplepos_1cm2=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompdivmon_samplepos_1cm2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(73,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_samplepos_large [74] */
  mccoordschange(mcposrpsd_samplepos_large, mcrotrpsd_samplepos_large,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_samplepos_large (without coords transformations) */
  mcJumpTrace_psd_samplepos_large:
  SIG_MESSAGE("psd_samplepos_large (Trace)");
  mcDEBUG_COMP("psd_samplepos_large")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_samplepos_large
  STORE_NEUTRON(74,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[74]++;
  mcPCounter[74] += p;
  mcP2Counter[74] += p*p;
#define mccompcurname  psd_samplepos_large
#define mccompcurtype  PSD_monitor
#define mccompcurindex 74
#define nx mccpsd_samplepos_large_nx
#define ny mccpsd_samplepos_large_ny
#define PSD_N mccpsd_samplepos_large_PSD_N
#define PSD_p mccpsd_samplepos_large_PSD_p
#define PSD_p2 mccpsd_samplepos_large_PSD_p2
{   /* Declarations of psd_samplepos_large=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_samplepos_large_filename;
MCNUM xmin = mccpsd_samplepos_large_xmin;
MCNUM xmax = mccpsd_samplepos_large_xmax;
MCNUM ymin = mccpsd_samplepos_large_ymin;
MCNUM ymax = mccpsd_samplepos_large_ymax;
MCNUM xwidth = mccpsd_samplepos_large_xwidth;
MCNUM yheight = mccpsd_samplepos_large_yheight;
MCNUM restore_neutron = mccpsd_samplepos_large_restore_neutron;
int nowritefile = mccpsd_samplepos_large_nowritefile;
/* 'psd_samplepos_large=PSD_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 83 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 52595 "RITA-II.c"
}   /* End of psd_samplepos_large=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_samplepos_large:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(74,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component a3 [75] */
  mccoordschange(mcposra3, mcrotra3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component a3 (without coords transformations) */
  mcJumpTrace_a3:
  SIG_MESSAGE("a3 (Trace)");
  mcDEBUG_COMP("a3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompa3
  if (!mcSplit_a3) {                   /* STORE only the first time */
    if (floor(SPLITREP) > 1) p /= floor(SPLITREP); /* adapt weight for SPLITed neutron */
    STORE_NEUTRON(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp);
  } else {
    RESTORE_NEUTRON(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp);
  }
  mcSplit_a3++; /* SPLIT number */
  mcScattered=0;
  mcRestore=0;
  mcNCounter[75]++;
  mcPCounter[75] += p;
  mcP2Counter[75] += p*p;
#define mccompcurname  a3
#define mccompcurtype  Arm
#define mccompcurindex 75
/* 'a3=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompa3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component aa3 [76] */
  mccoordschange(mcposraa3, mcrotraa3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component aa3 (without coords transformations) */
  mcJumpTrace_aa3:
  SIG_MESSAGE("aa3 (Trace)");
  mcDEBUG_COMP("aa3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompaa3
  STORE_NEUTRON(76,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[76]++;
  mcPCounter[76] += p;
  mcP2Counter[76] += p*p;
#define mccompcurname  aa3
#define mccompcurtype  Arm
#define mccompcurindex 76
/* 'aa3=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompaa3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(76,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component incohSample [77] */
  mccoordschange(mcposrincohSample, mcrotrincohSample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component incohSample (without coords transformations) */
  mcJumpTrace_incohSample:
  SIG_MESSAGE("incohSample (Trace)");
  mcDEBUG_COMP("incohSample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompincohSample
  STORE_NEUTRON(77,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[77]++;
  mcPCounter[77] += p;
  mcP2Counter[77] += p*p;
#define mccompcurname  incohSample
#define mccompcurtype  Incoherent
#define mccompcurindex 77
#define VarsInc mccincohSample_VarsInc
#define offdata mccincohSample_offdata
{   /* Declarations of incohSample=Incoherent() SETTING parameters. */
char* geometry = mccincohSample_geometry;
MCNUM radius = mccincohSample_radius;
MCNUM xwidth = mccincohSample_xwidth;
MCNUM yheight = mccincohSample_yheight;
MCNUM zdepth = mccincohSample_zdepth;
MCNUM thickness = mccincohSample_thickness;
MCNUM target_x = mccincohSample_target_x;
MCNUM target_y = mccincohSample_target_y;
MCNUM target_z = mccincohSample_target_z;
MCNUM focus_r = mccincohSample_focus_r;
MCNUM focus_xw = mccincohSample_focus_xw;
MCNUM focus_yh = mccincohSample_focus_yh;
MCNUM focus_aw = mccincohSample_focus_aw;
MCNUM focus_ah = mccincohSample_focus_ah;
int target_index = mccincohSample_target_index;
MCNUM pack = mccincohSample_pack;
MCNUM p_interact = mccincohSample_p_interact;
MCNUM f_QE = mccincohSample_f_QE;
MCNUM gamma = mccincohSample_gamma;
MCNUM Etrans = mccincohSample_Etrans;
MCNUM deltaE = mccincohSample_deltaE;
MCNUM sigma_abs = mccincohSample_sigma_abs;
MCNUM sigma_inc = mccincohSample_sigma_inc;
MCNUM Vc = mccincohSample_Vc;
MCNUM concentric = mccincohSample_concentric;
MCNUM order = mccincohSample_order;
/* 'incohSample=Incoherent()' component instance has conditional execution */
if (( mcipSAMPLE == 1 && ! mcipVIRTUALOUT ))

#line 232 "/usr/share/mcstas/2.5/samples/Incoherent.comp"
{
  double t0, t3;                /* Entry/exit time for outer surface */
  double t1, t2;                /* Entry/exit time for inner surface */
  double dt0, dt1, dt2, dt;     /* Flight times through sample */
  double v=0;                   /* Neutron velocity */
  double d_path;                /* Flight path length for non-scattered neutron */
  double l_i, l_o=0;            /* Flight path lenght in/out for scattered neutron */
  double my_a=0,my_t=0;         /* Velocity-dependent attenuation factor and total Xsec */
  double solid_angle=0;         /* Solid angle of target as seen from scattering point */
  double aim_x=0, aim_y=0, aim_z=1;   /* Position of target relative to scattering point */
  double v_i, v_f, E_i, E_f; /* initial and final energies and velocities */
  double dE;                 /* Energy transfer */
  int    intersect=0;
  int    flag_concentric=0;
  int    flag=0;
  double mc_trans, p_trans, mc_scatt, p_scatt, ws;
  double p_mult=1;

  do { /* Main interaction loop. Ends with intersect=0 */

    /* Intersection neutron trajectory / sample (sample surface) */
    if (VarsInc.shape == 0)
      intersect = cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius, yheight);
    else if (VarsInc.shape == 1)
      intersect = box_intersect(&t0, &t3, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);
    else if (VarsInc.shape == 2)
      intersect = sphere_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius);
    else if (VarsInc.shape == 3)
      intersect = off_intersect(&t0, &t3, NULL, NULL, x, y, z, vx, vy, vz, offdata );
    if (intersect) {
      int flag_ishollow = 0;
      if (thickness>0) {
        if (VarsInc.shape==0 && cylinder_intersect(&t1,&t2, x,y,z,vx,vy,vz, radius-thickness,yheight-2*thickness))
          flag_ishollow=1;
        else if (VarsInc.shape==2 && sphere_intersect   (&t1,&t2, x,y,z,vx,vy,vz, radius-thickness))
          flag_ishollow=1;
        else if (VarsInc.shape==1 && box_intersect(&t1,&t2, x,y,z,vx,vy,vz, xwidth-2*thickness, yheight-2*thickness, zdepth-2*thickness))
          flag_ishollow = 1;
      }
      if (!flag_ishollow) t1 = t2 = t3; /* no empty space inside */

      dt0 = t1-t0;                /* Time in sample, ingoing */
      dt1 = t2-t1;                /* Time in hole */
      dt2 = t3-t2;                /* Time in sample, outgoing */

      if (t0 > 0) {  /* we are before the sample */
        PROP_DT(t0); /* propagates neutron to the entry of the sample */
      } else if (t1 > 0 && t1 > t0) { /* we are inside first part of the sample */
        /* no propagation, stay inside */
      } else if (t2 > 0 && t2 > t1) { /* we are in the hole */
        PROP_DT(t2); /* propagate to inner surface of 2nd part of sample */
      } else if (t3 > 0 && t3 > t2) { /* we are in the 2nd part of sample */
        /* no propagation, stay inside */
      }

      dt0=t1-(t0 > 0 ? t0 : 0); /* Time in first part of hollow/cylinder/box */
      dt1=t2-(t1 > 0 ? t1 : 0); /* Time in hole */
      dt2=t3-(t2 > 0 ? t2 : 0); /* Time in 2nd part of hollow cylinder */

      if (dt0 < 0) dt0 = 0;
      if (dt1 < 0) dt1 = 0;
      if (dt2 < 0) dt2 = 0;

      /* initialize concentric mode */
      if (concentric && !flag_concentric && t0 >= 0
       && VarsInc.shape==0 && thickness>0) {
        flag_concentric=1;
      }

      if (flag_concentric == 1) {
        dt1=dt2=0; /* force exit when reaching hole/2nd part */
      }

      if (!dt0 && !dt2) {
        intersect = 0; /* the sample was passed entirely */
        break;
      }

      p_mult = 1;
      if (!v) v = sqrt(vx*vx + vy*vy + vz*vz);
      if (v) my_a = VarsInc.my_a_v*(2200/v);
      else {
        printf("Incoherent: %s: ERROR: Null velocity\n",NAME_CURRENT_COMP);
        ABSORB; /* should never occur */
      }

      my_t = my_a + VarsInc.my_s;  /* total scattering Xsect (tmp var) */
      if (my_t <= 0) {
        printf("Incoherent: %s: ERROR: Null total cross section %g. Removing event.\n",
          NAME_CURRENT_COMP, my_t);
        ABSORB; /* should never occur */
      }
      d_path = v * (dt0 + dt2);   /* Length of full path through sample */
      /* Proba of scattering vs absorption (integrating along the whole trajectory) */
      ws = VarsInc.my_s/my_t;  /* (inc+coh)/(inc+coh+abs) */
      /* Proba of transmission along length d_path */
      p_trans = exp(-my_t*d_path);
      p_scatt = 1 - p_trans; /* portion of beam which scatters */
      flag = 0; /* flag used for propagation to exit point before ending */
      /* are we next to the exit ? probably no scattering (avoid rounding errors) */
      if (VarsInc.my_s*d_path <= 4e-7) {
        flag = 1;           /* No interaction before the exit */
      }
      /* force a given fraction of the beam to scatter */
      if (p_interact>0 && p_interact<=1) {
        /* we force a portion of the beam to interact */
        /* This is used to improve statistics on single scattering (and multiple) */
        if (!SCATTERED) mc_trans = 1-p_interact;
        else            mc_trans = 1-p_interact/(4*SCATTERED+1); /* reduce effect on multi scatt */
      } else {
        mc_trans = p_trans; /* 1 - p_scatt */
      }
      mc_scatt = 1 - mc_trans; /* portion of beam to scatter (or force to) */
      if (mc_scatt <= 0 || mc_scatt>1) flag=1;
      /* MC choice: Interaction or transmission ? */
      if (!flag && mc_scatt > 0 && (mc_scatt >= 1 || (rand01()) < mc_scatt)) { /* Interaction neutron/sample */
        p_mult *= ws; /* Update weight ; account for absorption and retain scattered fraction */
        if (!mc_scatt) ABSORB;
        /* we have chosen portion mc_scatt of beam instead of p_scatt, so we compensate */
        p_mult *= fabs(p_scatt/mc_scatt); /* lower than 1 */
      } else {
        flag = 1; /* Transmission : no interaction neutron/sample */
        if (!mc_trans) ABSORB;
        p_mult *= fabs(p_trans/mc_trans);  /* attenuate beam by portion which is scattered (and left along) */
      }

      if (flag) { /* propagate to exit of sample and finish */
        intersect = 0;
        p *= p_mult; /* apply absorption correction */
        PROP_DT(dt0+dt2);
        break; /* exit main multi scatt while loop */
      }
      if (my_t*d_path < 1e-6)
      /* For very weak scattering, use simple uniform sampling of scattering
         point to avoid rounding errors. */
        dt = rand0max(d_path); /* length */
      else
        dt = -log(1 - rand0max((1 - exp(-my_t*d_path)))) / my_t; /* length */
      l_i = dt;/* Penetration in sample: scattering+abs */
      dt /= v; /* Time from present position to scattering point */

      /* If t0 is in hole, propagate to next part of the hollow cylinder */
      if (dt1 > 0 && dt0 > 0 && dt > dt0) dt += dt1;

      PROP_DT(dt);                /* Point of scattering */

      if ((VarsInc.tx || VarsInc.ty || VarsInc.tz)) {
        aim_x = VarsInc.tx-x;       /* Vector pointing at target (anal./det.) */
        aim_y = VarsInc.ty-y;
        aim_z = VarsInc.tz-z;
      }
      if(VarsInc.aw && VarsInc.ah) {
        randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
          aim_x, aim_y, aim_z, VarsInc.aw, VarsInc.ah, ROT_A_CURRENT_COMP);
      } else if(VarsInc.xw && VarsInc.yh) {
        randvec_target_rect(&vx, &vy, &vz, &solid_angle,
          aim_x, aim_y, aim_z, VarsInc.xw, VarsInc.yh, ROT_A_CURRENT_COMP);
      } else {
        randvec_target_circle(&vx, &vy, &vz, &solid_angle, aim_x, aim_y, aim_z, focus_r);
      }
      NORM(vx, vy, vz);

      v_i = v;          /* Store initial velocity in case of quasielastic */
      E_i = VS2E*v_i*v_i;
      if (deltaE==0) { 
	if (rand01()<f_QE)	/* Quasielastic contribution */
	  {
	    dE = gamma*tan(PI/2*randpm1());
	    E_f = E_i + dE;
	    if (E_f <= 0)
	      ABSORB;
	    v_f = SE2V*sqrt(E_f);
	    v = v_f;
	    /*          printf("vi: %g Ei: %g dE: %g Ef %g vf: %g v: %g \n",
			v_i,E_i,dE,E_f,v_f,v); */
	  }
      } else {
	E_f = E_i - Etrans + deltaE*randpm1(); // E_f=E0;
	v_f = SE2V*sqrt(E_f);
	v = v_f;
      }

      vx *= v;
      vy *= v;
      vz *= v;

      /* We do not consider scattering from 2nd part (outgoing) */
      p_mult *= solid_angle/4/PI;
      p *= p_mult;

      /* Polarisation part (1/3 NSF, 2/3 SF) */
      sx *= -1.0/3.0;
      sy *= -1.0/3.0;
      sz *= -1.0/3.0;

      SCATTER;

      /* test for a given multiple order */
      if (order && SCATTERED >= order) {
        intersect=0; /* reached required number of SCATTERing */
        break;       /* finish multiple scattering loop */
      }
    } /* end if intersect */
  } while (intersect); /* end do (intersect) (multiple scattering loop) */
}
#line 53169 "RITA-II.c"
}   /* End of incohSample=Incoherent() SETTING parameter declarations. */
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompincohSample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(77,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component powderSample [78] */
  mccoordschange(mcposrpowderSample, mcrotrpowderSample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component powderSample (without coords transformations) */
  mcJumpTrace_powderSample:
  SIG_MESSAGE("powderSample (Trace)");
  mcDEBUG_COMP("powderSample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppowderSample
  STORE_NEUTRON(78,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[78]++;
  mcPCounter[78] += p;
  mcP2Counter[78] += p*p;
#define mccompcurname  powderSample
#define mccompcurtype  PowderN
#define mccompcurindex 78
#define format mccpowderSample_format
#define line_info mccpowderSample_line_info
#define columns mccpowderSample_columns
#define offdata mccpowderSample_offdata
{   /* Declarations of powderSample=PowderN() SETTING parameters. */
char* reflections = mccpowderSample_reflections;
char* geometry = mccpowderSample_geometry;
MCNUM radius = mccpowderSample_radius;
MCNUM yheight = mccpowderSample_yheight;
MCNUM xwidth = mccpowderSample_xwidth;
MCNUM zdepth = mccpowderSample_zdepth;
MCNUM thickness = mccpowderSample_thickness;
MCNUM pack = mccpowderSample_pack;
MCNUM Vc = mccpowderSample_Vc;
MCNUM sigma_abs = mccpowderSample_sigma_abs;
MCNUM sigma_inc = mccpowderSample_sigma_inc;
MCNUM delta_d_d = mccpowderSample_delta_d_d;
MCNUM p_inc = mccpowderSample_p_inc;
MCNUM p_transmit = mccpowderSample_p_transmit;
MCNUM DW = mccpowderSample_DW;
MCNUM nb_atoms = mccpowderSample_nb_atoms;
MCNUM d_omega = mccpowderSample_d_omega;
MCNUM d_phi = mccpowderSample_d_phi;
MCNUM tth_sign = mccpowderSample_tth_sign;
MCNUM p_interact = mccpowderSample_p_interact;
MCNUM concentric = mccpowderSample_concentric;
MCNUM density = mccpowderSample_density;
MCNUM weight = mccpowderSample_weight;
MCNUM barns = mccpowderSample_barns;
MCNUM Strain = mccpowderSample_Strain;
MCNUM focus_flip = mccpowderSample_focus_flip;
int target_index = mccpowderSample_target_index;
/* 'powderSample=PowderN()' component instance has conditional execution */
if (( mcipSAMPLE == 2 && ! mcipVIRTUALOUT ))

#line 774 "/usr/share/mcstas/2.5/samples/PowderN.comp"
{
  double t0, t1, t2, t3, v, v1,l_full, l, l_1, dt, alpha0, alpha, theta, my_s, my_s_n, sg;
  double solid_angle, neutrontype;
  double arg, tmp_vx, tmp_vy, tmp_vz, vout_x, vout_y, vout_z, nx, ny, nz, pmul=1;
  int    line;
  char   intersect=0;
  char   intersecti=0;
  line_info.type = '\0';
  line_info.itype = 0;

  if (line_info.V_0 > 0 && (line_info.count || line_info.my_inc)) {
    if (line_info.shape == 1) {
      intersect  = box_intersect(&t0, &t3, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);
      intersecti = box_intersect(&t1, &t2, x, y, z, vx, vy, vz, line_info.xwidth_i, line_info.yheight_i, line_info.zdepth_i);
    } else if (line_info.shape == 0) {
      intersect  = cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius, yheight);
      intersecti = cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, line_info.radius_i, line_info.yheight_i);
    } else if (line_info.shape == 2) {
      intersect  = sphere_intersect  (&t0, &t3, x,y,z, vx,vy,vz, radius);
      intersecti = sphere_intersect  (&t1, &t2, x,y,z, vx,vy,vz, line_info.radius_i);
    } else if (line_info.shape == 3) {
      intersect  = off_intersect  (&t0, &t3, NULL, NULL, x,y,z, vx,vy,vz, offdata);
      intersecti = 0;
    }
  }

  if(intersect && t3 >0) {

    if (concentric) {
      /* Set up for concentric case */
      /* 'Remove' the backside of this comp */
      if (!intersecti) {
        t1 = (t3 + t0) /2;
      }
      t2 = t1;
      t3 = t1;
      dt = -1.0*rand01(); /* In case of scattering we will scatter on 'forward' part of sample */
    } else {
      if (!intersecti) {
        t1 = (t3 + t0) /2;
        t2 = t1;
      }
      dt = randpm1(); /* Possibility to scatter at all points in line of sight */
    }

    /* Neutron enters at t=t0. */
    if(t0 < 0) t0=0; /* already in sample */
    if(t1 < 0) t1=0; /* already in inner hollow */
    if(t2 < 0) t2=0; /* already past inner hollow */
    v = sqrt(vx*vx + vy*vy + vz*vz);
    l_full = v * (t3 - t2 + t1 - t0);

    if (line_info.neutron_passed < CHAR_BUF_LENGTH) {
      if (v < line_info.v_min) line_info.v_min = v;
      if (v > line_info.v_max) line_info.v_max = v;
      line_info.neutron_passed++;
    }

    /* Calculate total scattering cross section at relevant velocity */
    if ( fabs(v - line_info.v) < 1e-6) {
        line_info.nb_reuses++;
      } else {
        line_info.Nq = calc_xsect(v, line_info.q_v, line_info.my_s_v2, line_info.count, &line_info.my_s_v2_sum, &line_info);
        line_info.v = v;
        line_info.nb_refl += line_info.Nq;
        line_info.nb_refl_count++;
      }

    if (t3 < 0) {
      t3=0; /* Already past sample?! */
      if (line_info.flag_warning < 100)
      printf("PowderN: %s: Warning: Neutron has already passed us? (Skipped).\n"
             "         In concentric geometry, this may be caused by a missing concentric=0 option in 2nd enclosing instance.\n", NAME_CURRENT_COMP);
      line_info.flag_warning++;
    } else {
      if (dt<0) { /* Calculate scattering point position */
        dt = fabs(dt)*(t1 - t0); /* 'Forward' part */
      } else {
        dt = dt * (t3 - t2) + (t2-t0) ; /* Possibly also 'backside' part */
      }

      my_s = line_info.my_s_v2_sum/(v*v)+line_info.my_inc;
      /* Total attenuation from scattering */
	  line_info.lfree=0;
      neutrontype = rand01();
      /* How to handle this one? Transmit (1) / Incoherent (2) / Coherent (3) ? */
      if (neutrontype < p_transmit) {
        neutrontype = 1;
        l = l_full; /* Passing through, full length */
        PROP_DT(t3);
      } else if (neutrontype >= p_transmit && neutrontype < (p_transmit + p_inc)) {
        neutrontype = 2;
        l = v*dt;       /* Penetration in sample */
        PROP_DT(dt+t0); /* Point of scattering */
        SCATTER;
      } else if (neutrontype >= p_transmit + p_inc) {
        neutrontype = 3;
        l = v*dt;       /* Penetration in sample */
        PROP_DT(dt+t0); /* Point of scattering */
        SCATTER;
      } else {
        exit(fprintf(stderr,"PowderN %s: DEAD - this shouldn't happen!\n", NAME_CURRENT_COMP));
      }

      if (neutrontype == 3) { /* Make coherent scattering event */
        if (line_info.count > 0) {
          /* choose line */
			if (line_info.Nq > 1) line=floor(line_info.Nq*rand01());  /* Select between Nq powder lines */
			else line = 0;
			if (line_info.w_v[line])
				arg = line_info.q_v[line]*(1+line_info.w_v[line]*randnorm())/(2.0*v);
			else
				arg = line_info.q_v[line]/(2.0*v);
			my_s_n = line_info.my_s_v2[line]/(v*v);
			if(fabs(arg) > 1)
				ABSORB;                   /* No bragg scattering possible*/
			if (tth_sign == 0) {
				sg = randpm1();
				if (sg > 0) sg = 1; else sg=-1;
			}
			else
				sg = tth_sign/fabs(tth_sign);
			theta = asin(arg);          /* Bragg scattering law */
			  /* Choose point on Debye-Scherrer cone */
			if (d_phi)
			{ /* relate height of detector to the height on DS cone */
				arg = sin(d_phi*DEG2RAD/2)/sin(2*theta);
				/* If full Debye-Scherrer cone is within d_phi, don't focus */
				if (arg < -1 || arg > 1) d_phi = 0;
				/* Otherwise, determine alpha to rotate from scattering plane
				   into d_phi focusing area*/
				else alpha = 2*asin(arg);
			}
			if (d_phi) {
				/* Focusing */
				alpha = fabs(alpha);
				alpha0 = 0.5*randpm1()*alpha;
				if(focus_flip){
					alpha0+=M_PI_2;
				}
			}
			else
				alpha0 = PI*randpm1();

          /* now find a nearly vertical rotation axis:
           * Either
           *  (v along Z) x (X axis) -> nearly Y axis
           * Or
           *  (v along X) x (Z axis) -> nearly Y axis
           */
		   
  /* update JS, 1/7/2017
    If a target is defined, try to define vertical axis as a normal to the plane 
	defined by the incident neutron velocity and target position. 
	Check that v is not ~ parallel to the target direction.
  */
			double vnorm=0.0;
			if (target_index) {
				vec_prod(tmp_vx, tmp_vy, tmp_vz, vx,vy,vz, tgt_x, tgt_y, tgt_z);
				vnorm = sqrt(tmp_vx*tmp_vx+tmp_vy*tmp_vy+tmp_vz*tmp_vz)/v;
			}
			// no target or direction is nearly parallel to v:
			if (vnorm<0.01) {
				if (fabs(vx/v) < fabs(vz/v)) {
					nx = 1; ny = 0; nz = 0;
				} else {
					nx = 0; ny = 0; nz = 1;
				}
				vec_prod(tmp_vx,tmp_vy,tmp_vz, vx,vy,vz, nx,ny,nz);
			}

			  /* v_out = rotate 'v' by 2*theta around tmp_v: Bragg angle */
			rotate(vout_x,vout_y,vout_z, vx,vy,vz, 2*sg*theta, tmp_vx,tmp_vy,tmp_vz);
			
			/* tmp_v = rotate v_out by alpha0 around 'v' (Debye-Scherrer cone) */
			rotate(tmp_vx,tmp_vy,tmp_vz, vout_x,vout_y,vout_z, alpha0, vx, vy, vz);
			vx = tmp_vx;
			vy = tmp_vy;
			vz = tmp_vz;
			  
			  /* Since now scattered and new direction given, calculate path to exit */
			if (line_info.shape == 1) {
				intersect  = box_intersect(&t0, &t3, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);
				intersecti = box_intersect(&t1, &t2, x, y, z, vx, vy, vz, line_info.xwidth_i, line_info.yheight_i, line_info.zdepth_i);
			} else if (line_info.shape == 0) {
				intersect  = cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius, yheight);
				intersecti = cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, line_info.radius_i, line_info.yheight_i);
			} else if (line_info.shape == 2) {
				intersect  = sphere_intersect  (&t0, &t3, x,y,z, vx,vy,vz, radius);
				intersecti = sphere_intersect  (&t1, &t2, x,y,z, vx,vy,vz, line_info.radius_i);
			} else if (line_info.shape == 3) {
				intersect  = off_intersect  (&t0, &t3, NULL, NULL, x,y,z, vx,vy,vz, offdata);
				intersecti = 0;
			}

			if (!intersect) {
				/* Strange error: did not hit cylinder */
				if (line_info.flag_warning < 100)
				  printf("PowderN: %s: WARNING: Did not hit sample from inside (coh). ABSORB.\n", NAME_CURRENT_COMP);
				line_info.flag_warning++;
				ABSORB;
			}

			if (!intersecti) {
				t1 = (t3 + t0) /2;
				t2 = t1;
			}

			if (concentric && intersecti) {
				/* In case of concentricity, 'remove' backward wall of sample */
				t2 = t1;
				t3 = t1;
			}

			if(t0 < 0) t0=0; /* already in sample */
			if(t1 < 0) t1=0; /* already in inner hollow */
			if(t2 < 0) t2=0; /* already past inner hollow */


			l_1 = v*(t3 - t2 + t1 - t0); /* Length to exit */

			pmul  = line_info.Nq*l_full*my_s_n*exp(-(line_info.my_a_v/v+my_s)*(l+l_1))
									  /(1-(p_inc+p_transmit));
			  /* Correction in case of d_phi focusing - BUT only when d_phi != 0 */
			if (d_phi) pmul *= alpha/PI;

			line_info.type = 'c';
			line_info.itype = 1;
			line_info.dq = line_info.q_v[line]*V2K;
			line_info.lfree=1/(line_info.my_a_v/v+my_s);
        } /* else transmit <-- No powder lines in file */
      }  /* Coherent scattering event */
      else if (neutrontype == 2) {  /* Make incoherent scattering event */
		if (d_omega && d_phi) {
			randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
			  tgt_x, tgt_y, tgt_z, d_omega*DEG2RAD, d_phi*DEG2RAD, ROT_A_CURRENT_COMP);
		} else if (d_phi) {
			randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
                                      tgt_x, tgt_y, tgt_z,
                                      2*PI, d_phi*DEG2RAD, ROT_A_CURRENT_COMP);
        } else {
          randvec_target_circle(&vx, &vy, &vz,
                                &solid_angle, 0, 0, 1, 0);
        }
        v1 = sqrt(vx*vx+vy*vy+vz*vz);
        vx *= v/v1;
        vy *= v/v1;
        vz *= v/v1;

        /* Since now scattered and new direction given, calculate path to exit */
        if (line_info.shape == 1) {
          intersect  = box_intersect(&t0, &t3, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);
          intersecti = box_intersect(&t1, &t2, x, y, z, vx, vy, vz, line_info.xwidth_i, line_info.yheight_i, line_info.zdepth_i);
        } else if (line_info.shape == 0) {
          intersect  = cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius, yheight);
          intersecti = cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, line_info.radius_i, line_info.yheight_i);
        } else if (line_info.shape == 2) {
          intersect  = sphere_intersect  (&t0, &t3, x,y,z, vx,vy,vz, radius);
          intersecti = sphere_intersect  (&t1, &t2, x,y,z, vx,vy,vz, line_info.radius_i);
        } else if (line_info.shape == 3) {
          intersect  = off_intersect  (&t0, &t3, NULL, NULL, x,y,z, vx,vy,vz, offdata);
          intersecti = 0;
        }

        if (!intersect) {
          /* Strange error: did not hit cylinder */
          if (line_info.flag_warning < 100)
            printf("PowderN: %s: WARNING: Did not hit sample from inside (inc). ABSORB.\n", NAME_CURRENT_COMP);
          line_info.flag_warning++;
          ABSORB;
        }

        if (!intersecti) {
          t1 = (t3 + t0) /2;
          t2 = t1;
        }

        if (concentric && intersecti) {
          /* In case of concentricity, 'remove' backward wall of sample */
          t2 = t1;
          t3 = t1;
        }

        if(t0 < 0) t0=0; /* already in sample */
        if(t1 < 0) t1=0; /* already in inner hollow */
        if(t2 < 0) t2=0; /* already past inner hollow */


        l_1 = v*(t3 - t2 + t1 - t0); /* Length to exit */

        pmul = l_full*line_info.my_inc*exp(-(line_info.my_a_v/v+my_s)*(l+l_1))/(p_inc);
        pmul *= solid_angle/(4*PI);
		line_info.lfree=1/(line_info.my_a_v/v+my_s);
        line_info.type = 'i';
		line_info.itype = 2;

      }  /* Incoherent scattering event */
      else if (neutrontype == 1) {
        /* Make transmitted (absorption-corrected) event */
        /* No coordinate changes here, simply change neutron weight */
        pmul = exp(-(line_info.my_a_v/v+my_s)*(l))/(p_transmit);
        line_info.lfree=1/(line_info.my_a_v/v+my_s);
        line_info.type = 't';
		line_info.itype = 3;
      }
      p *= pmul;
    } /* Neutron leaving since it has passed already */
  } /* else transmit non interacting neutrons */

}
#line 53621 "RITA-II.c"
}   /* End of powderSample=PowderN() SETTING parameter declarations. */
#undef offdata
#undef columns
#undef line_info
#undef format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppowderSample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(78,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component crystalSample [79] */
  mccoordschange(mcposrcrystalSample, mcrotrcrystalSample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component crystalSample (without coords transformations) */
  mcJumpTrace_crystalSample:
  SIG_MESSAGE("crystalSample (Trace)");
  mcDEBUG_COMP("crystalSample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcrystalSample
  STORE_NEUTRON(79,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[79]++;
  mcPCounter[79] += p;
  mcP2Counter[79] += p*p;
#define mccompcurname  crystalSample
#define mccompcurtype  Single_crystal
#define mccompcurindex 79
#define mosaic_AB mcccrystalSample_mosaic_AB
#define hkl_info mcccrystalSample_hkl_info
#define offdata mcccrystalSample_offdata
{   /* Declarations of crystalSample=Single_crystal() SETTING parameters. */
char* reflections = mcccrystalSample_reflections;
char* geometry = mcccrystalSample_geometry;
MCNUM xwidth = mcccrystalSample_xwidth;
MCNUM yheight = mcccrystalSample_yheight;
MCNUM zdepth = mcccrystalSample_zdepth;
MCNUM radius = mcccrystalSample_radius;
MCNUM delta_d_d = mcccrystalSample_delta_d_d;
MCNUM mosaic = mcccrystalSample_mosaic;
MCNUM mosaic_a = mcccrystalSample_mosaic_a;
MCNUM mosaic_b = mcccrystalSample_mosaic_b;
MCNUM mosaic_c = mcccrystalSample_mosaic_c;
MCNUM recip_cell = mcccrystalSample_recip_cell;
MCNUM barns = mcccrystalSample_barns;
MCNUM ax = mcccrystalSample_ax;
MCNUM ay = mcccrystalSample_ay;
MCNUM az = mcccrystalSample_az;
MCNUM bx = mcccrystalSample_bx;
MCNUM by = mcccrystalSample_by;
MCNUM bz = mcccrystalSample_bz;
MCNUM cx = mcccrystalSample_cx;
MCNUM cy = mcccrystalSample_cy;
MCNUM cz = mcccrystalSample_cz;
MCNUM p_transmit = mcccrystalSample_p_transmit;
MCNUM sigma_abs = mcccrystalSample_sigma_abs;
MCNUM sigma_inc = mcccrystalSample_sigma_inc;
MCNUM aa = mcccrystalSample_aa;
MCNUM bb = mcccrystalSample_bb;
MCNUM cc = mcccrystalSample_cc;
MCNUM order = mcccrystalSample_order;
MCNUM RX = mcccrystalSample_RX;
MCNUM RY = mcccrystalSample_RY;
MCNUM powder = mcccrystalSample_powder;
MCNUM PG = mcccrystalSample_PG;
MCNUM deltak = mcccrystalSample_deltak;
/* 'crystalSample=Single_crystal()' component instance has conditional execution */
if (( mcipSAMPLE == 3 && ! mcipVIRTUALOUT ))

#line 1057 "/usr/share/mcstas/2.5/samples/Single_crystal.comp"
{
  double t1, t2=0;                /* Entry and exit times in sample */
  struct hkl_data *L;           /* Structure factor list */
  int i;                        /* Index into structure factor list */
  struct tau_data *T;           /* List of reflections close to Ewald sphere */
  int j;                        /* Index into reflection list */
  int event_counter;            /* scattering event counter */
  double kix, kiy, kiz, ki;     /* Initial wave vector [1/AA] */
  double kfx, kfy, kfz;         /* Final wave vector */
  double v;                     /* Neutron velocity */
  double rho_x, rho_y, rho_z;   /* the vector ki - tau */
  double rho;
  double diff;                  /* Deviation from Bragg condition */
  double ox, oy, oz;            /* Origin of Ewald sphere tangent plane */
  double b1x, b1y, b1z;         /* First vector spanning tangent plane */
  double b2x, b2y, b2z;         /* Second vector spanning tangent plane */
  double n11, n12, n22;         /* 2D Gauss description matrix N */
  double det_N;                 /* Determinant of N */
  double inv_n11, inv_n12, inv_n22; /* Inverse of N */
  double l11, l12, l22;         /* Cholesky decomposition L of 1/2*inv(N) */
  double det_L;                 /* Determinant of L */
  double Bt_D_O_x, Bt_D_O_y;    /* Temporaries */
  double y0x, y0y;              /* Center of 2D Gauss in plane coordinates */
  double alpha;                 /* Offset of 2D Gauss center from 3D center */
  double V0;                    /* Volume of unit cell */
  double l_full;                /* Neutron path length for transmission */
  double l;                     /* Path length to scattering event */
  double abs_xsect, abs_xlen;   /* Absorption cross section and length */
  double inc_xsect, inc_xlen;   /* Incoherent scattering cross section and length */
  double coh_xlen;              /* Coherent cross section and length */
  double tot_xsect, tot_xlen;   /* Total cross section and length */
  double z1, z2, y1, y2;        /* Temporaries to choose kf from 2D Gauss */
  double adjust, r, sum;        /* Temporaries */

  double p_trans;               /* Transmission probability */
  double mc_trans, mc_interact; /* Transmission, interaction MC choices */
  int    intersect=0;
  double theta, phi;            /* rotation angles for curved lattice option */

  double curv_xangle;
  double curv_yangle;

  double _vx;
  double _vy;
  double _vz;


  /* Intersection neutron trajectory / sample (sample surface) */
  if (hkl_info.shape == 0)
    intersect = cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius, yheight);
  else if (hkl_info.shape == 1)
    intersect = box_intersect(&t1, &t2, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);
  else if (hkl_info.shape == 2)
    intersect = sphere_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius);
  else if (hkl_info.shape == 3)
    intersect = off_intersect(&t1, &t2, NULL, NULL, x, y, z, vx, vy, vz, offdata );

  if (t2 < 0) intersect=0;  /* we passed sample volume already */

  if(intersect)
  {                         /* Neutron intersects crystal */
    if(t1 > 0)
      PROP_DT(t1);          /* Move to crystal surface if not inside */
    v  = sqrt(vx*vx + vy*vy + vz*vz);
    ki = V2K*v;
    event_counter = 0;
    abs_xsect = hkl_info.sigma_a*2200/v;
    inc_xsect = hkl_info.sigma_i;
    V0= hkl_info.V0;
    abs_xlen  = abs_xsect/V0;
    inc_xlen  = inc_xsect/V0;

    /* Scalar cross sections for inc/abs are given in barns, so we need a scaling factor of 100
       to get scattering lengths in m, since V0 is assumed to be in AA*/
    abs_xlen *= 100; inc_xlen *= 100;

    L = hkl_info.list;
    T = hkl_info.tau_list;
    hkl_info.type = '\0';

    do {  /* Loop over multiple scattering events */
      /* Angles for powder randomization */
      double Alpha, Beta;

      if (hkl_info.shape == 0)
        intersect = cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius, yheight);
      else if (hkl_info.shape == 1)
        intersect = box_intersect(&t1, &t2, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);
      else if (hkl_info.shape == 2)
        intersect = sphere_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius);
      else if (hkl_info.shape == 3)
        intersect = off_intersect(&t1, &t2, NULL, NULL, x, y, z, vx, vy, vz, offdata );
      if(!intersect || t2*v < -1e-9 || t1*v > 1e-9)
      {
        /* neutron is leaving the sample */
        if (hkl_info.flag_warning < 100)
          fprintf(stderr,
                "Single_crystal: %s: Warning: neutron has unexpectedly left the crystal!\n"
                "                t1=%g t2=%g x=%g y=%g z=%g vx=%g vy=%g vz=%g\n",
                NAME_CURRENT_COMP, t1, t2, x, y, z, vx, vy, vz);
        hkl_info.flag_warning++;
        break;
      }

      l_full = t2*v;

      /* (1). Compute incoming wave vector ki */
      if (powder) { /* orientation of crystallite is random */
	Alpha = randpm1()*PI*powder;
	Beta = randpm1()*PI/2;
	randrotate(&vx, &vy, &vz, Alpha, Beta);
      }
      if (PG) { /* orientation of crystallite is random */
	Alpha = rand01()*2*PI*PG;
	PGrotate(&vx, &vy, &vz, Alpha, hkl_info.csx, hkl_info.csy, hkl_info.csz);
      }



      /* ------------------------------------------------------------------------- */
      /* lattice curvature option: rotate neutron velocity */
      /* WARNING: cannot be used together with the PG c-rotation! */
      curv_xangle = 0;
      curv_yangle = 0;

      _vx = vx;
      _vy = vy;
      _vz = vz;

      if(RY) { /* rotate v around x axis based on y pos, for vertical focus */
          curv_yangle = atan2(y, RY);
          vec_rotate_2d(&vy,&vz, curv_yangle);
          vec_rotate_2d(&sy,&sz, curv_yangle);

          /*changing y,z actually curves the crystal, not only the planes*/
          /*comment out if only curvature of the lattice planes is needed*/
          vec_rotate_2d(&y,&z, curv_yangle);
      }
      if(RX) { /* rotate v around y axis based on x pos, for horizontal focus */
          curv_xangle = atan2(x, RX);
          vec_rotate_2d(&vx,&vz, curv_xangle);
          vec_rotate_2d(&sx,&sz, curv_xangle);

          /*changing x,z actually curves the crystal, not only the planes*/
          /*comment out if only curvature of the lattice planes is needed*/
          vec_rotate_2d(&x,&z, curv_xangle);
      }

      kix = V2K*vx;
      kiy = V2K*vy;
      kiz = V2K*vz;
      vx = _vx;
      vy = _vy;
      vz = _vz;
      /* ------------------------------------------------------------------------- */



      /* (2). Intersection of Ewald sphere with reciprocal lattice points */

      /* in case we use 'SPLIT' then consecutive neutrons can be identical when entering here
         and we may skip the hkl_search call */
      if ( fabs(kix - hkl_info.kix) < deltak
        && fabs(kiy - hkl_info.kiy) < deltak
        && fabs(kiz - hkl_info.kiz) < deltak) {
        hkl_info.nb_reuses++;
      } else {
        /* Max possible tau for this ki with 5*sigma delta-d/d cutoff. */
        double tau_max   = 2*ki/(1 - 5*hkl_info.m_delta_d_d);
        double coh_xsect = 0, coh_refl = 0;

        /* call hkl_search */
        hkl_info.tau_count = hkl_search(L, T, hkl_info.count, hkl_info.V0,
              kix, kiy, kiz, tau_max,
              &coh_refl, &coh_xsect); /* CPU consuming */

        /* store ki so that we can check for further SPLIT iterations */
        if (event_counter == 0 ) { /* only for incoming neutron */
          hkl_info.kix = kix;
          hkl_info.kiy = kiy;
          hkl_info.kiz = kiz;
        }

        hkl_info.coh_refl  = coh_refl;
        hkl_info.coh_xsect = coh_xsect;
        hkl_info.nb_refl += hkl_info.tau_count;
        hkl_info.nb_refl_count++;
      }

      /* (3). Probabilities of the different possible interactions. */
      /* Cross-sections are in barns = 10**-28 m**2, and unit cell volumes are
         in AA**3 = 10**-30 m**2. Hence a factor of 100 is used to convert
         scattering lengths to m**-1 */
      coh_xlen = hkl_info.coh_xsect/V0;
      if (barns) {
        coh_xlen *= 100;
      } /* else assume fm^2 */
      tot_xlen = abs_xlen + inc_xlen + coh_xlen;

      /* (5). Transmission */
      p_trans = exp(-tot_xlen*l_full);
      if(!event_counter && p_transmit >= 0 && p_transmit <= 1) {
        mc_trans = p_transmit; /* first event */
      } else {
        mc_trans = p_trans;
      }
      hkl_info.type = 't';
      mc_interact = 1 - mc_trans;
      if(mc_trans > 0 && (mc_trans >= 1 || rand01() < mc_trans))  /* Transmit */
      {
        p *= p_trans/mc_trans;
        intersect=0;
	if (powder) { /* orientation of crystallite is longer random */
	  randderotate(&vx, &vy, &vz, Alpha, Beta);
	}
	if (PG) { /* orientation of crystallite is longer random */
	  PGderotate(&vx, &vy, &vz, Alpha, hkl_info.m_cx, hkl_info.m_cz, hkl_info.m_cz);
	}
	break;
      }
      if(tot_xlen <= 0){
        ABSORB;
      }
      if(mc_interact <= 0)        /* Protect against rounding errors */
        { intersect=0;
	  if (powder) { /* orientation of crystallite is no longer random */
	    randderotate(&vx, &vy, &vz, Alpha, Beta);
	  }
	  if (PG) { /* orientation of crystallite is longer random */
	    PGderotate(&vx, &vy, &vz, Alpha, hkl_info.csx, hkl_info.csy, hkl_info.csz);
	  }
	  break;
	}
      if (!event_counter) p *= fabs(1 - p_trans)/mc_interact;
      /* Select a point at which to scatter the neutron, taking
         secondary extinction into account. */
      /* dP(l) = exp(-tot_xlen*l)dl
         P(l<l_0) = [-1/tot_xlen*exp(-tot_xlen*l)]_0^l_0
                  = (1 - exp(-tot_xlen*l0))/tot_xlen
         l = -log(1 - tot_xlen*rand0max(P(l<l_full)))/tot_xlen
       */
      if(tot_xlen*l_full < 1e-6)
        /* For very weak scattering, use simple uniform sampling of scattering
           point to avoid rounding errors. */
        l = rand0max(l_full);
      else
        l = -log(1 - rand0max((1 - exp(-tot_xlen*l_full))))/tot_xlen;
      PROP_DT(l/v);
      event_counter++;

      /* (4). Account for the probability of sigma_abs */
      p *= (coh_xlen + inc_xlen)/tot_xlen;
      /* Choose between coherent and incoherent scattering */
      if(coh_xlen == 0 || rand0max(coh_xlen + inc_xlen) <= inc_xlen)
      {
        /* (6). Incoherent scattering */
        randvec_target_circle(&kix, &kiy, &kiz, NULL, vx, vy, vz, 0);
        vx = kix; /* ki vector is used as tmp var with norm v */
        vy = kiy;
        vz = kiz; /* Go for next scattering event */
        hkl_info.type = 'i';
      } else {
        /* 7. Coherent scattering. Select reciprocal lattice point. */
        if(hkl_info.coh_refl <= 0){
          ABSORB;
        }
        sum = 0;
        j = hkl_select(T, hkl_info.tau_count, hkl_info.coh_refl, &sum);

        if(j >= hkl_info.tau_count)
        {
          if (hkl_info.flag_warning < 100)
            fprintf(stderr, "Single_crystal: Error: Illegal tau search "
              "(r=%g, sum=%g, j=%i, tau_count=%i).\n", r, sum, j , hkl_info.tau_count);
          hkl_info.flag_warning++;
          j = hkl_info.tau_count - 1;
        }
        i = T[j].index;
        /* (8). Pick scattered wavevector kf from 2D Gauss distribution. */
        z1 = randnorm();
        z2 = randnorm();
        y1 = T[j].l11*z1 + T[j].y0x;
        y2 = T[j].l12*z1 + T[j].l22*z2 + T[j].y0y;
        kfx = T[j].rho_x + T[j].ox + T[j].b1x*y1 + T[j].b2x*y2;
        kfy = T[j].rho_y + T[j].oy + T[j].b1y*y1 + T[j].b2y*y2;
        kfz = T[j].rho_z + T[j].oz + T[j].b1z*y1 + T[j].b2z*y2;
        /* Normalize kf to length of ki, to account for planer
          approximation of the Ewald sphere. */
        adjust = ki/sqrt(kfx*kfx + kfy*kfy + kfz*kfz);
        kfx *= adjust;
        kfy *= adjust;
        kfz *= adjust;
        /* Adjust neutron weight (see manual for explanation). */
        p *= T[j].xsect*hkl_info.coh_refl/(hkl_info.coh_xsect*T[j].refl);

        vx = K2V*(L[i].u1x*kfx + L[i].u2x*kfy + L[i].u3x*kfz);
        vy = K2V*(L[i].u1y*kfx + L[i].u2y*kfy + L[i].u3y*kfz);
        vz = K2V*(L[i].u1z*kfx + L[i].u2z*kfy + L[i].u3z*kfz);
        hkl_info.type = 'c';
        hkl_info.h    = L[i].h;
        hkl_info.k    = L[i].k;
        hkl_info.l    = L[i].l;
      }



      /* ------------------------------------------------------------------------- */
      /* lattice curvature option: rotate back neutron velocity */
      if(RX) {
          vec_rotate_2d(&vx,&vz, -curv_xangle);
          vec_rotate_2d(&sx,&sz, -curv_xangle);

          /*changing x,z actually curves the crystal, not only the planes*/
          /*comment out if only curvature of the lattice planes is needed*/
          vec_rotate_2d(&x,&z, -curv_xangle);
      }
      if(RY) {
          vec_rotate_2d(&vy,&vz, -curv_yangle);
          vec_rotate_2d(&sy,&sz, -curv_yangle);

          /*changing y,z actually curves the crystal, not only the planes*/
          /*comment out if only curvature of the lattice planes is needed*/
          vec_rotate_2d(&y,&z, -curv_yangle);
      }
      /* ------------------------------------------------------------------------- */



      SCATTER;
      if (powder) { /* orientation of crystallite is no longer random */
	  randderotate(&vx, &vy, &vz, Alpha, Beta);
      }
      if (PG) { /* orientation of crystallite is longer random */
	PGderotate(&vx, &vy, &vz, Alpha, hkl_info.csx, hkl_info.csy, hkl_info.csz);
      }
      /* exit if multiple scattering order has been reached */
      if (order && event_counter >= order) { intersect=0; break; }
      /* Repeat loop for next scattering event. */
    } while (intersect); /* end do (intersect) (multiple scattering loop) */
  } /* if intersect */
}
#line 54112 "RITA-II.c"
/* 'crystalSample=Single_crystal()' component instance extend code */
    SIG_MESSAGE("crystalSample (Trace:Extend)");
if (( mcipSAMPLE == 3 && ! mcipVIRTUALOUT )) {

#line 1337 "RITA-II.instr"
  if(!SCATTERED) ABSORB;
#line 54118 "RITA-II.c"
}

}   /* End of crystalSample=Single_crystal() SETTING parameter declarations. */
#undef offdata
#undef hkl_info
#undef mosaic_AB
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcrystalSample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(79,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component phononSample [80] */
  mccoordschange(mcposrphononSample, mcrotrphononSample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component phononSample (without coords transformations) */
  mcJumpTrace_phononSample:
  SIG_MESSAGE("phononSample (Trace)");
  mcDEBUG_COMP("phononSample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompphononSample
  STORE_NEUTRON(80,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[80]++;
  mcPCounter[80] += p;
  mcP2Counter[80] += p*p;
#define mccompcurname  phononSample
#define mccompcurtype  Phonon_simple
#define mccompcurindex 80
#define V_rho mccphononSample_V_rho
#define V_my_s mccphononSample_V_my_s
#define V_my_a_v mccphononSample_V_my_a_v
#define DV mccphononSample_DV
#define parms mccphononSample_parms
{   /* Declarations of phononSample=Phonon_simple() SETTING parameters. */
MCNUM radius = mccphononSample_radius;
MCNUM yheight = mccphononSample_yheight;
MCNUM sigma_abs = mccphononSample_sigma_abs;
MCNUM sigma_inc = mccphononSample_sigma_inc;
MCNUM a = mccphononSample_a;
MCNUM b = mccphononSample_b;
MCNUM M = mccphononSample_M;
MCNUM c = mccphononSample_c;
MCNUM DW = mccphononSample_DW;
MCNUM T = mccphononSample_T;
MCNUM target_x = mccphononSample_target_x;
MCNUM target_y = mccphononSample_target_y;
MCNUM target_z = mccphononSample_target_z;
int target_index = mccphononSample_target_index;
MCNUM focus_r = mccphononSample_focus_r;
MCNUM focus_xw = mccphononSample_focus_xw;
MCNUM focus_yh = mccphononSample_focus_yh;
MCNUM focus_aw = mccphononSample_focus_aw;
MCNUM focus_ah = mccphononSample_focus_ah;
MCNUM gap = mccphononSample_gap;
/* 'phononSample=Phonon_simple()' component instance has conditional execution */
if (( mcipSAMPLE == 4 && ! mcipVIRTUALOUT ))

#line 262 "/usr/share/mcstas/2.5/samples/Phonon_simple.comp"
{
  double t0, t1;                /* Entry/exit time for cylinder */
  double v_i, v_f;               /* Neutron velocities: initial, final */
  double vx_i, vy_i, vz_i;  /* Neutron initial velocity vector */
  double dt0, dt;             /* Flight times through sample */
  double l_full;                /* Flight path length for non-scattered neutron */
  double l_i, l_o;              /* Flight path lenght in/out for scattered neutron */
  double my_a_i;                  /* Initial attenuation factor */
  double my_a_f;                  /* Final attenuation factor */
  double solid_angle;           /* Solid angle of target as seen from scattering point */
  double aim_x=0, aim_y=0, aim_z=1;   /* Position of target relative to scattering point */
  double kappa_x, kappa_y, kappa_z;   /* Scattering vector */
  double kappa2;             /* Square of the scattering vector */
  double bose_factor;        /* Calculated value of the Bose factor */
  double omega;              /* energy transfer */
  int nf, index;                   /* Number of allowed final velocities */
  double vf_list[2];             /* List of allowed final velocities */
  double J_factor;            /* Jacobian from delta fnc.s in cross section */
  double f1, f2;            /* probed values of omega_q minus omega */
  double p1,p2,p3,p4,p5;    /* temporary multipliers */

  if(cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, yheight))
  {
    if(t0 < 0)
      ABSORB; /* Neutron came from the sample or begins inside */

    /* Neutron enters at t=t0. */
    dt0 = t1-t0;                /* Time in sample */
    v_i = sqrt(vx*vx + vy*vy + vz*vz);
    l_full = v_i * dt0;   /* Length of path through sample if not scattered */
    dt = rand01()*dt0;    /* Time of scattering (relative to t0) */
    l_i = v_i*dt;                 /* Penetration in sample at scattering */
    vx_i=vx;
    vy_i=vy;
    vz_i=vz;
    PROP_DT(dt+t0);             /* Point of scattering */

    aim_x = target_x-x;         /* Vector pointing at target (e.g. analyzer) */
    aim_y = target_y-y;
    aim_z = target_z-z;

    if(focus_aw && focus_ah) {
      randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
        aim_x, aim_y, aim_z, focus_aw, focus_ah, ROT_A_CURRENT_COMP);
    } else if(focus_xw && focus_yh) {
      randvec_target_rect(&vx, &vy, &vz, &solid_angle,
        aim_x, aim_y, aim_z, focus_xw, focus_yh, ROT_A_CURRENT_COMP);
    } else {
      randvec_target_sphere(&vx,&vy,&vz,&solid_angle,aim_x,aim_y,aim_z, focus_r);
    }
    NORM(vx, vy, vz);
/*    printf("focussed direction (vx,vy,vz=(%g %g %g) \n",vx,vy,vz); */
    nf=0;
      parms[0]=-1;
      parms[1]=v_i;
      parms[2]=vx;
      parms[3]=vy;
      parms[4]=vz;
      parms[5]=vx_i;
      parms[6]=vy_i;
      parms[7]=vz_i;
      parms[8]=a;
      parms[9]=c;
      parms[10]=gap;
    findroots(0, v_i, v_i+2*c*V2K/VS2E, vf_list, &nf, omega_q, parms);
    index=(int)floor(rand01()*nf);
/*    printf("Root index: %i %g \n", index, vf_list[index]); */
    v_f=vf_list[index];
    parms[0]=v_f-DV;
    f1=omega_q(parms);
    parms[0]=v_f+DV;
    f2=omega_q(parms);
    J_factor = fabs(f2-f1)/(2*DV*K2V);
/*    printf("f1,f2: %g %g , J factor %g \n",f1,f2,J_factor); */
    omega=VS2E*(v_i*v_i-v_f*v_f);
/*    printf("nf, omega: %i %g v_i index, v_f: %g %i %g \n", nf,omega,v_i,index,v_f); */
    vx *= v_f;
    vy *= v_f;
    vz *= v_f;
/* printf("vi= %g (vi_x,vi_y,vi_z)= (%g %g %g); vf= %g (vx,vy,vz)=(%g %g %g) \n",
         v_i,vx_i,vy_i,vz_i,v_f,vx,vy,vz); */
    kappa_x=V2K*(vx_i-vx);
    kappa_y=V2K*(vy_i-vy);
    kappa_z=V2K*(vz_i-vz);
    kappa2=kappa_z*kappa_z+kappa_y*kappa_y+kappa_x*kappa_x;

    if(!cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, yheight))
    {
      /* ??? did not hit cylinder */
      printf("FATAL ERROR: Did not hit cylinder from inside.\n");
      exit(1);
    }
    dt = t1;
    l_o = v_f*dt;

    my_a_i = V_my_a_v/v_i;
    my_a_f = V_my_a_v/v_f;
    bose_factor=nbose(omega,T);
    p1 = exp(-(V_my_s*(l_i+l_o)+my_a_i*l_i+my_a_f*l_o)); /* Absorption factor */
    p2 = nf*solid_angle*l_full*V_rho/(4*PI);     /* Focusing factors; assume random choice of n_f possibilities */
    p3 = (v_f/v_i)*DW*(kappa2*K2V*K2V*VS2E)/fabs(omega)*bose_factor;   /* Cross section factor 1 */
    p4 = 2*VS2E*v_f/J_factor;  /* Jacobian of delta functions in cross section */
    p5 = b*b/M;  /* Cross section factor 2 */
    p *= p1*p2*p3*p4*p5;
    SCATTER;

/*    printf("p factors : %g %g %g %g %g Omega: %g \n", p1, p2, p3, p4, p5, omega);
      printf("J_factor %g l_full %g, v_f/v_i %g, DW %g, kappa2 %g, bose_factor%g, fabs(omega) %g \n",
              J_factor, l_full, v_f/v_i, DW, kappa2, bose_factor, fabs(omega)); */

  } /* else transmit: Neutron did not hit the sample */
}
#line 54368 "RITA-II.c"
}   /* End of phononSample=Phonon_simple() SETTING parameter declarations. */
#undef parms
#undef DV
#undef V_my_a_v
#undef V_my_s
#undef V_rho
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompphononSample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(80,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_4pi [81] */
  mccoordschange(mcposrpsd_4pi, mcrotrpsd_4pi,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_4pi (without coords transformations) */
  mcJumpTrace_psd_4pi:
  SIG_MESSAGE("psd_4pi (Trace)");
  mcDEBUG_COMP("psd_4pi")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_4pi
  STORE_NEUTRON(81,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[81]++;
  mcPCounter[81] += p;
  mcP2Counter[81] += p*p;
#define mccompcurname  psd_4pi
#define mccompcurtype  PSD_monitor_4PI
#define mccompcurindex 81
#define nx mccpsd_4pi_nx
#define ny mccpsd_4pi_ny
#define PSD_N mccpsd_4pi_PSD_N
#define PSD_p mccpsd_4pi_PSD_p
#define PSD_p2 mccpsd_4pi_PSD_p2
{   /* Declarations of psd_4pi=PSD_monitor_4PI() SETTING parameters. */
char* filename = mccpsd_4pi_filename;
MCNUM radius = mccpsd_4pi_radius;
MCNUM restore_neutron = mccpsd_4pi_restore_neutron;
int nowritefile = mccpsd_4pi_nowritefile;
/* 'psd_4pi=PSD_monitor_4PI()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 74 "/usr/share/mcstas/2.5/monitors/PSD_monitor_4PI.comp"
{
  double t0, t1, phi, theta;
  int i,j;

  if(sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius) && t1 > 0)
  {
    if(t0 < 0)
      t0 = t1;
    /* t0 is now time of intersection with the sphere. */
    PROP_DT(t0);
    phi = atan2(x,z);
    i = floor(nx*(phi/(2*PI)+0.5));
    if(i >= nx)
      i = nx-1;                      /* Special case for phi = PI. */
    else if(i < 0)
      i = 0;
    theta=asin(y/radius);
    j = floor(ny*(theta+PI/2)/PI+0.5);
    if(j >= ny)
      j = ny-1;                      /* Special case for y = radius. */
    else if(j < 0)
      j = 0;
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 54522 "RITA-II.c"
}   /* End of psd_4pi=PSD_monitor_4PI() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_4pi:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(81,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component a4 [82] */
  mccoordschange(mcposra4, mcrotra4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component a4 (without coords transformations) */
  mcJumpTrace_a4:
  SIG_MESSAGE("a4 (Trace)");
  mcDEBUG_COMP("a4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompa4
  STORE_NEUTRON(82,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[82]++;
  mcPCounter[82] += p;
  mcP2Counter[82] += p*p;
#define mccompcurname  a4
#define mccompcurtype  Arm
#define mccompcurindex 82
/* 'a4=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompa4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(82,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component slitSample [83] */
  mccoordschange(mcposrslitSample, mcrotrslitSample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component slitSample (without coords transformations) */
  mcJumpTrace_slitSample:
  SIG_MESSAGE("slitSample (Trace)");
  mcDEBUG_COMP("slitSample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompslitSample
  STORE_NEUTRON(83,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[83]++;
  mcPCounter[83] += p;
  mcP2Counter[83] += p*p;
#define mccompcurname  slitSample
#define mccompcurtype  Slit
#define mccompcurindex 83
{   /* Declarations of slitSample=Slit() SETTING parameters. */
MCNUM xmin = mccslitSample_xmin;
MCNUM xmax = mccslitSample_xmax;
MCNUM ymin = mccslitSample_ymin;
MCNUM ymax = mccslitSample_ymax;
MCNUM radius = mccslitSample_radius;
MCNUM xwidth = mccslitSample_xwidth;
MCNUM yheight = mccslitSample_yheight;
/* 'slitSample=Slit()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 71 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 54756 "RITA-II.c"
}   /* End of slitSample=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompslitSample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(83,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component filter_coll [84] */
  mccoordschange(mcposrfilter_coll, mcrotrfilter_coll,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component filter_coll (without coords transformations) */
  mcJumpTrace_filter_coll:
  SIG_MESSAGE("filter_coll (Trace)");
  mcDEBUG_COMP("filter_coll")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompfilter_coll
  STORE_NEUTRON(84,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[84]++;
  mcPCounter[84] += p;
  mcP2Counter[84] += p*p;
#define mccompcurname  filter_coll
#define mccompcurtype  Exact_radial_coll
#define mccompcurindex 84
#define alpha_in mccfilter_coll_alpha_in
#define alpha_out mccfilter_coll_alpha_out
#define out_radius mccfilter_coll_out_radius
#define beta_in mccfilter_coll_beta_in
#define beta_out mccfilter_coll_beta_out
#define iw mccfilter_coll_iw
#define ow mccfilter_coll_ow
#define divergence mccfilter_coll_divergence
#define theta mccfilter_coll_theta
{   /* Declarations of filter_coll=Exact_radial_coll() SETTING parameters. */
MCNUM theta_min = mccfilter_coll_theta_min;
MCNUM theta_max = mccfilter_coll_theta_max;
MCNUM nslit = mccfilter_coll_nslit;
MCNUM radius = mccfilter_coll_radius;
MCNUM length = mccfilter_coll_length;
MCNUM h_in = mccfilter_coll_h_in;
MCNUM h_out = mccfilter_coll_h_out;
MCNUM d = mccfilter_coll_d;
MCNUM verbose = mccfilter_coll_verbose;
/* 'filter_coll=Exact_radial_coll()' component instance has conditional execution */
if (( mcipOUTFILTER > 0 && ! mcipVIRTUALOUT ))

#line 97 "/usr/share/mcstas/2.5/contrib/Exact_radial_coll.comp"
{
  double phi, t0, t1, t2, t3;
  int    intersect;
  long   input_chan,  output_chan;
  double input_theta, output_theta;
  double input_center,output_center;
  double window_theta;
  char   ok=0;

  /* first compute intersection time with input cylinder */
  intersect=cylinder_intersect(&t0,&t3,x,y,z,vx,vy,vz,radius,h_in);
  if (!intersect) ABSORB;
  else if (t3 > t0) t0 = t3;

  intersect=cylinder_intersect(&t1,&t2,x,y,z,vx,vy,vz,out_radius,h_out);
  if (!intersect) ABSORB;
  else if (t2 > t1) t1 = t2;

  /* get index of input slit */
  if (t0 > 0 && t1 > t0) {
      PROP_DT(t0);
      input_theta = atan2(x, z);
     /* channel number (start at 0) */
      window_theta = (theta_max - theta_min)/nslit;
      input_chan  = floor((input_theta - theta_min)/window_theta);
      if (input_chan >= 0 && input_chan < nslit && fabs(y) < h_in/2) ok=1;
    if (ok) {
        input_center= theta_min + input_chan*window_theta + (window_theta)/2;
        /* are we outside the soller or in the foil? */
        phi = input_theta - input_center;
        if (fabs(phi) > alpha_in/2) ABSORB; /* inside the foil*/
        SCATTER;

      /* propagate to output radius */
      PROP_DT(t1-t0);
      SCATTER;
        output_theta = atan2(x, z);
        /* channel number (start at 0) */
        output_chan  = floor((output_theta - theta_min)/window_theta);
        /* did we change channel ? */
        if (output_chan != input_chan) ABSORB; /* changed slit */
        output_center= theta_min + output_chan*window_theta
                    + (window_theta)/2;
        /* are we outside the soller */
        phi = output_theta -output_center;
        if (fabs(phi) > alpha_out/2 || fabs(y) > h_out/2) ABSORB; /* outside output slit */

    } /* else we pass aside the entrance window of radial collimator */
    else {
      /* propagate to output radius */
      PROP_DT(t1-t0);
      SCATTER;
        output_theta = atan2(x, z);
        /* channel number (start at 0) */
        output_chan  = floor((output_theta - theta_min)/window_theta);
       /* are we come from outside into the soller or in the foil?*/
        if (output_chan >= 0 || output_chan < nslit) ABSORB;
    } /* else we pass aside the exit window of radial collimator */
  }   /* else did not encounter collimator */

}
#line 54944 "RITA-II.c"
}   /* End of filter_coll=Exact_radial_coll() SETTING parameter declarations. */
#undef theta
#undef divergence
#undef ow
#undef iw
#undef beta_out
#undef beta_in
#undef out_radius
#undef alpha_out
#undef alpha_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompfilter_coll:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(84,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component filter [85] */
  mccoordschange(mcposrfilter, mcrotrfilter,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component filter (without coords transformations) */
  mcJumpTrace_filter:
  SIG_MESSAGE("filter (Trace)");
  mcDEBUG_COMP("filter")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompfilter
  STORE_NEUTRON(85,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[85]++;
  mcPCounter[85] += p;
  mcP2Counter[85] += p*p;
#define mccompcurname  filter
#define mccompcurtype  Filter_gen
#define mccompcurindex 85
#define pTable mccfilter_pTable
#define Mode_Table mccfilter_Mode_Table
#define Type_Table mccfilter_Type_Table
{   /* Declarations of filter=Filter_gen() SETTING parameters. */
char* filename = mccfilter_filename;
char* options = mccfilter_options;
MCNUM xmin = mccfilter_xmin;
MCNUM xmax = mccfilter_xmax;
MCNUM ymin = mccfilter_ymin;
MCNUM ymax = mccfilter_ymax;
MCNUM xwidth = mccfilter_xwidth;
MCNUM yheight = mccfilter_yheight;
MCNUM thickness = mccfilter_thickness;
MCNUM scaling = mccfilter_scaling;
MCNUM verbose = mccfilter_verbose;
/* 'filter=Filter_gen()' component instance has conditional execution */
if (( mcipOUTFILTER > 0 && ! mcipVIRTUALOUT ))

#line 167 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  double v2, K, L, E, X, new_p;

  PROP_Z0;
  if (Type_Table && (x>xmin && x<xmax && y>ymin && y<ymax))
  {
    v2 = (vx*vx + vy*vy + vz*vz);
    K = V2K*sqrt(v2);        /* k */
    L = (2*PI/K);        /* lambda */
    E = VS2E*v2;        /* energy */
    if (Type_Table == ENERGY_TABLE)     X=E;
    if (Type_Table == WAVEVECTOR_TABLE) X=K;
    if (Type_Table == WAVELENGTH_TABLE) X=L;
    /* table look up */
    if (pTable.data != NULL)
    {
      double y1, y2, x1;
      long   Index;
      Index = floor((X - pTable.min_x)/pTable.step_x);
      y1 = Table_Index(pTable, Index,   1); /* 2nd column */
      x1 = Table_Index(pTable, Index,   0); /* 1st column */
      y2 = Table_Index(pTable, Index+1, 1); /* 2nd column */
      new_p = scaling*(y1+(X - x1)*(y2-y1)/pTable.step_x); /* 2nd column */
      if (thickness != 1) new_p = pow(new_p, thickness);
    }
    else new_p = 1;

    if (Mode_Table == FLUX_ADAPT_MULT) p *= new_p;
    else p = new_p;
    SCATTER;
  }
  else
    if (Type_Table) ABSORB;
}
#line 55110 "RITA-II.c"
}   /* End of filter=Filter_gen() SETTING parameter declarations. */
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompfilter:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(85,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ana_slit1 [86] */
  mccoordschange(mcposrana_slit1, mcrotrana_slit1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ana_slit1 (without coords transformations) */
  mcJumpTrace_ana_slit1:
  SIG_MESSAGE("ana_slit1 (Trace)");
  mcDEBUG_COMP("ana_slit1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompana_slit1
  STORE_NEUTRON(86,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[86]++;
  mcPCounter[86] += p;
  mcP2Counter[86] += p*p;
#define mccompcurname  ana_slit1
#define mccompcurtype  Slit
#define mccompcurindex 86
{   /* Declarations of ana_slit1=Slit() SETTING parameters. */
MCNUM xmin = mccana_slit1_xmin;
MCNUM xmax = mccana_slit1_xmax;
MCNUM ymin = mccana_slit1_ymin;
MCNUM ymax = mccana_slit1_ymax;
MCNUM radius = mccana_slit1_radius;
MCNUM xwidth = mccana_slit1_xwidth;
MCNUM yheight = mccana_slit1_yheight;
/* 'ana_slit1=Slit()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 71 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 55237 "RITA-II.c"
}   /* End of ana_slit1=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompana_slit1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(86,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ana_slit2 [87] */
  mccoordschange(mcposrana_slit2, mcrotrana_slit2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ana_slit2 (without coords transformations) */
  mcJumpTrace_ana_slit2:
  SIG_MESSAGE("ana_slit2 (Trace)");
  mcDEBUG_COMP("ana_slit2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompana_slit2
  STORE_NEUTRON(87,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[87]++;
  mcPCounter[87] += p;
  mcP2Counter[87] += p*p;
#define mccompcurname  ana_slit2
#define mccompcurtype  Slit
#define mccompcurindex 87
{   /* Declarations of ana_slit2=Slit() SETTING parameters. */
MCNUM xmin = mccana_slit2_xmin;
MCNUM xmax = mccana_slit2_xmax;
MCNUM ymin = mccana_slit2_ymin;
MCNUM ymax = mccana_slit2_ymax;
MCNUM radius = mccana_slit2_radius;
MCNUM xwidth = mccana_slit2_xwidth;
MCNUM yheight = mccana_slit2_yheight;
/* 'ana_slit2=Slit()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 71 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 55361 "RITA-II.c"
}   /* End of ana_slit2=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompana_slit2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(87,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_before_ana [88] */
  mccoordschange(mcposremon_before_ana, mcrotremon_before_ana,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_before_ana (without coords transformations) */
  mcJumpTrace_emon_before_ana:
  SIG_MESSAGE("emon_before_ana (Trace)");
  mcDEBUG_COMP("emon_before_ana")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_before_ana
  STORE_NEUTRON(88,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[88]++;
  mcPCounter[88] += p;
  mcP2Counter[88] += p*p;
#define mccompcurname  emon_before_ana
#define mccompcurtype  E_monitor
#define mccompcurindex 88
#define nE mccemon_before_ana_nE
#define E_N mccemon_before_ana_E_N
#define E_p mccemon_before_ana_E_p
#define E_p2 mccemon_before_ana_E_p2
#define S_p mccemon_before_ana_S_p
#define S_pE mccemon_before_ana_S_pE
#define S_pE2 mccemon_before_ana_S_pE2
{   /* Declarations of emon_before_ana=E_monitor() SETTING parameters. */
char* filename = mccemon_before_ana_filename;
MCNUM xmin = mccemon_before_ana_xmin;
MCNUM xmax = mccemon_before_ana_xmax;
MCNUM ymin = mccemon_before_ana_ymin;
MCNUM ymax = mccemon_before_ana_ymax;
MCNUM xwidth = mccemon_before_ana_xwidth;
MCNUM yheight = mccemon_before_ana_yheight;
MCNUM Emin = mccemon_before_ana_Emin;
MCNUM Emax = mccemon_before_ana_Emax;
MCNUM restore_neutron = mccemon_before_ana_restore_neutron;
int nowritefile = mccemon_before_ana_nowritefile;
/* 'emon_before_ana=E_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55514 "RITA-II.c"
}   /* End of emon_before_ana=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_before_ana:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(88,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_before_ana [89] */
  mccoordschange(mcposrpsd_before_ana, mcrotrpsd_before_ana,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_before_ana (without coords transformations) */
  mcJumpTrace_psd_before_ana:
  SIG_MESSAGE("psd_before_ana (Trace)");
  mcDEBUG_COMP("psd_before_ana")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_before_ana
  STORE_NEUTRON(89,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[89]++;
  mcPCounter[89] += p;
  mcP2Counter[89] += p*p;
#define mccompcurname  psd_before_ana
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define nx mccpsd_before_ana_nx
#define ny mccpsd_before_ana_ny
#define PSD_N mccpsd_before_ana_PSD_N
#define PSD_p mccpsd_before_ana_PSD_p
#define PSD_p2 mccpsd_before_ana_PSD_p2
{   /* Declarations of psd_before_ana=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_before_ana_filename;
MCNUM xmin = mccpsd_before_ana_xmin;
MCNUM xmax = mccpsd_before_ana_xmax;
MCNUM ymin = mccpsd_before_ana_ymin;
MCNUM ymax = mccpsd_before_ana_ymax;
MCNUM xwidth = mccpsd_before_ana_xwidth;
MCNUM yheight = mccpsd_before_ana_yheight;
MCNUM restore_neutron = mccpsd_before_ana_restore_neutron;
int nowritefile = mccpsd_before_ana_nowritefile;
/* 'psd_before_ana=PSD_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 83 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55661 "RITA-II.c"
}   /* End of psd_before_ana=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_before_ana:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(89,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component divmon_before_ana [90] */
  mccoordschange(mcposrdivmon_before_ana, mcrotrdivmon_before_ana,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component divmon_before_ana (without coords transformations) */
  mcJumpTrace_divmon_before_ana:
  SIG_MESSAGE("divmon_before_ana (Trace)");
  mcDEBUG_COMP("divmon_before_ana")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompdivmon_before_ana
  STORE_NEUTRON(90,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[90]++;
  mcPCounter[90] += p;
  mcP2Counter[90] += p*p;
#define mccompcurname  divmon_before_ana
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 90
#define nh mccdivmon_before_ana_nh
#define nv mccdivmon_before_ana_nv
#define Div_N mccdivmon_before_ana_Div_N
#define Div_p mccdivmon_before_ana_Div_p
#define Div_p2 mccdivmon_before_ana_Div_p2
{   /* Declarations of divmon_before_ana=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_before_ana_filename;
MCNUM xmin = mccdivmon_before_ana_xmin;
MCNUM xmax = mccdivmon_before_ana_xmax;
MCNUM ymin = mccdivmon_before_ana_ymin;
MCNUM ymax = mccdivmon_before_ana_ymax;
MCNUM xwidth = mccdivmon_before_ana_xwidth;
MCNUM yheight = mccdivmon_before_ana_yheight;
MCNUM maxdiv_h = mccdivmon_before_ana_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_before_ana_maxdiv_v;
MCNUM restore_neutron = mccdivmon_before_ana_restore_neutron;
MCNUM nx = mccdivmon_before_ana_nx;
MCNUM ny = mccdivmon_before_ana_ny;
MCNUM nz = mccdivmon_before_ana_nz;
int nowritefile = mccdivmon_before_ana_nowritefile;
/* 'divmon_before_ana=Divergence_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    int i,j;
    double h_div, v_div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      h_div = RAD2DEG*atan2(vx,vn);
      v_div = RAD2DEG*atan2(vy,vn);
      if (h_div < maxdiv_h && h_div > -maxdiv_h &&
          v_div < maxdiv_v && v_div > -maxdiv_v)
      {
        i = floor((h_div + maxdiv_h)*nh/(2.0*maxdiv_h));
        j = floor((v_div + maxdiv_v)*nv/(2.0*maxdiv_v));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55821 "RITA-II.c"
}   /* End of divmon_before_ana=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompdivmon_before_ana:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(90,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component focus_ana [91] */
  mccoordschange(mcposrfocus_ana, mcrotrfocus_ana,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component focus_ana (without coords transformations) */
  mcJumpTrace_focus_ana:
  SIG_MESSAGE("focus_ana (Trace)");
  mcDEBUG_COMP("focus_ana")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompfocus_ana
  if (!mcSplit_focus_ana) {                   /* STORE only the first time */
    if (floor(SPLITAREP) > 1) p /= floor(SPLITAREP); /* adapt weight for SPLITed neutron */
    STORE_NEUTRON(91,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp);
  } else {
    RESTORE_NEUTRON(91,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp);
  }
  mcSplit_focus_ana++; /* SPLIT number */
  mcScattered=0;
  mcRestore=0;
  mcNCounter[91]++;
  mcPCounter[91] += p;
  mcP2Counter[91] += p*p;
#define mccompcurname  focus_ana
#define mccompcurtype  Arm
#define mccompcurindex 91
/* 'focus_ana=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

/* 'focus_ana=Arm()' component instance extend code */
    SIG_MESSAGE("focus_ana (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1410 "RITA-II.instr"
  AnaBlade=0;
#line 55955 "RITA-II.c"
}

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompfocus_ana:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(91,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an1l [92] */
  mccoordschange(mcposran1l, mcrotran1l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an1l (without coords transformations) */
  mcJumpTrace_an1l:
  SIG_MESSAGE("an1l (Trace)");
  mcDEBUG_COMP("an1l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan1l
  STORE_NEUTRON(92,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[92]++;
  mcPCounter[92] += p;
  mcP2Counter[92] += p*p;
#define mccompcurname  an1l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 92
#define mos_rms_y mccan1l_mos_rms_y
#define mos_rms_z mccan1l_mos_rms_z
#define mos_rms_max mccan1l_mos_rms_max
#define mono_Q mccan1l_mono_Q
{   /* Declarations of an1l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan1l_zmin;
MCNUM zmax = mccan1l_zmax;
MCNUM ymin = mccan1l_ymin;
MCNUM ymax = mccan1l_ymax;
MCNUM zwidth = mccan1l_zwidth;
MCNUM yheight = mccan1l_yheight;
MCNUM mosaich = mccan1l_mosaich;
MCNUM mosaicv = mccan1l_mosaicv;
MCNUM r0 = mccan1l_r0;
MCNUM Q = mccan1l_Q;
MCNUM DM = mccan1l_DM;
/* 'an1l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 56213 "RITA-II.c"
/* 'an1l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an1l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1421 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 1;
#line 56219 "RITA-II.c"
}

}   /* End of an1l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan1l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(92,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an1u [93] */
  mccoordschange(mcposran1u, mcrotran1u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an1u (without coords transformations) */
  mcJumpTrace_an1u:
  SIG_MESSAGE("an1u (Trace)");
  mcDEBUG_COMP("an1u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan1u
  STORE_NEUTRON(93,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[93]++;
  mcPCounter[93] += p;
  mcP2Counter[93] += p*p;
#define mccompcurname  an1u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 93
#define mos_rms_y mccan1u_mos_rms_y
#define mos_rms_z mccan1u_mos_rms_z
#define mos_rms_max mccan1u_mos_rms_max
#define mono_Q mccan1u_mono_Q
{   /* Declarations of an1u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan1u_zmin;
MCNUM zmax = mccan1u_zmax;
MCNUM ymin = mccan1u_ymin;
MCNUM ymax = mccan1u_ymax;
MCNUM zwidth = mccan1u_zwidth;
MCNUM yheight = mccan1u_yheight;
MCNUM mosaich = mccan1u_mosaich;
MCNUM mosaicv = mccan1u_mosaicv;
MCNUM r0 = mccan1u_r0;
MCNUM Q = mccan1u_Q;
MCNUM DM = mccan1u_DM;
/* 'an1u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 56482 "RITA-II.c"
/* 'an1u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an1u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1432 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 1;
#line 56488 "RITA-II.c"
}

}   /* End of an1u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan1u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(93,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an2l [94] */
  mccoordschange(mcposran2l, mcrotran2l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an2l (without coords transformations) */
  mcJumpTrace_an2l:
  SIG_MESSAGE("an2l (Trace)");
  mcDEBUG_COMP("an2l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan2l
  STORE_NEUTRON(94,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[94]++;
  mcPCounter[94] += p;
  mcP2Counter[94] += p*p;
#define mccompcurname  an2l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 94
#define mos_rms_y mccan2l_mos_rms_y
#define mos_rms_z mccan2l_mos_rms_z
#define mos_rms_max mccan2l_mos_rms_max
#define mono_Q mccan2l_mono_Q
{   /* Declarations of an2l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan2l_zmin;
MCNUM zmax = mccan2l_zmax;
MCNUM ymin = mccan2l_ymin;
MCNUM ymax = mccan2l_ymax;
MCNUM zwidth = mccan2l_zwidth;
MCNUM yheight = mccan2l_yheight;
MCNUM mosaich = mccan2l_mosaich;
MCNUM mosaicv = mccan2l_mosaicv;
MCNUM r0 = mccan2l_r0;
MCNUM Q = mccan2l_Q;
MCNUM DM = mccan2l_DM;
/* 'an2l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 56751 "RITA-II.c"
/* 'an2l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an2l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1444 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 2;
#line 56757 "RITA-II.c"
}

}   /* End of an2l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan2l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(94,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an2u [95] */
  mccoordschange(mcposran2u, mcrotran2u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an2u (without coords transformations) */
  mcJumpTrace_an2u:
  SIG_MESSAGE("an2u (Trace)");
  mcDEBUG_COMP("an2u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan2u
  STORE_NEUTRON(95,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[95]++;
  mcPCounter[95] += p;
  mcP2Counter[95] += p*p;
#define mccompcurname  an2u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 95
#define mos_rms_y mccan2u_mos_rms_y
#define mos_rms_z mccan2u_mos_rms_z
#define mos_rms_max mccan2u_mos_rms_max
#define mono_Q mccan2u_mono_Q
{   /* Declarations of an2u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan2u_zmin;
MCNUM zmax = mccan2u_zmax;
MCNUM ymin = mccan2u_ymin;
MCNUM ymax = mccan2u_ymax;
MCNUM zwidth = mccan2u_zwidth;
MCNUM yheight = mccan2u_yheight;
MCNUM mosaich = mccan2u_mosaich;
MCNUM mosaicv = mccan2u_mosaicv;
MCNUM r0 = mccan2u_r0;
MCNUM Q = mccan2u_Q;
MCNUM DM = mccan2u_DM;
/* 'an2u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 57020 "RITA-II.c"
/* 'an2u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an2u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1455 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 2;
#line 57026 "RITA-II.c"
}

}   /* End of an2u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan2u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(95,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an3l [96] */
  mccoordschange(mcposran3l, mcrotran3l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an3l (without coords transformations) */
  mcJumpTrace_an3l:
  SIG_MESSAGE("an3l (Trace)");
  mcDEBUG_COMP("an3l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan3l
  STORE_NEUTRON(96,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[96]++;
  mcPCounter[96] += p;
  mcP2Counter[96] += p*p;
#define mccompcurname  an3l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 96
#define mos_rms_y mccan3l_mos_rms_y
#define mos_rms_z mccan3l_mos_rms_z
#define mos_rms_max mccan3l_mos_rms_max
#define mono_Q mccan3l_mono_Q
{   /* Declarations of an3l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan3l_zmin;
MCNUM zmax = mccan3l_zmax;
MCNUM ymin = mccan3l_ymin;
MCNUM ymax = mccan3l_ymax;
MCNUM zwidth = mccan3l_zwidth;
MCNUM yheight = mccan3l_yheight;
MCNUM mosaich = mccan3l_mosaich;
MCNUM mosaicv = mccan3l_mosaicv;
MCNUM r0 = mccan3l_r0;
MCNUM Q = mccan3l_Q;
MCNUM DM = mccan3l_DM;
/* 'an3l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 57289 "RITA-II.c"
/* 'an3l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an3l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1466 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 3;
#line 57295 "RITA-II.c"
}

}   /* End of an3l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan3l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(96,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an3u [97] */
  mccoordschange(mcposran3u, mcrotran3u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an3u (without coords transformations) */
  mcJumpTrace_an3u:
  SIG_MESSAGE("an3u (Trace)");
  mcDEBUG_COMP("an3u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan3u
  STORE_NEUTRON(97,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[97]++;
  mcPCounter[97] += p;
  mcP2Counter[97] += p*p;
#define mccompcurname  an3u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 97
#define mos_rms_y mccan3u_mos_rms_y
#define mos_rms_z mccan3u_mos_rms_z
#define mos_rms_max mccan3u_mos_rms_max
#define mono_Q mccan3u_mono_Q
{   /* Declarations of an3u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan3u_zmin;
MCNUM zmax = mccan3u_zmax;
MCNUM ymin = mccan3u_ymin;
MCNUM ymax = mccan3u_ymax;
MCNUM zwidth = mccan3u_zwidth;
MCNUM yheight = mccan3u_yheight;
MCNUM mosaich = mccan3u_mosaich;
MCNUM mosaicv = mccan3u_mosaicv;
MCNUM r0 = mccan3u_r0;
MCNUM Q = mccan3u_Q;
MCNUM DM = mccan3u_DM;
/* 'an3u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 57558 "RITA-II.c"
/* 'an3u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an3u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1477 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 3;
#line 57564 "RITA-II.c"
}

}   /* End of an3u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan3u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(97,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an4l [98] */
  mccoordschange(mcposran4l, mcrotran4l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an4l (without coords transformations) */
  mcJumpTrace_an4l:
  SIG_MESSAGE("an4l (Trace)");
  mcDEBUG_COMP("an4l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan4l
  STORE_NEUTRON(98,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[98]++;
  mcPCounter[98] += p;
  mcP2Counter[98] += p*p;
#define mccompcurname  an4l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 98
#define mos_rms_y mccan4l_mos_rms_y
#define mos_rms_z mccan4l_mos_rms_z
#define mos_rms_max mccan4l_mos_rms_max
#define mono_Q mccan4l_mono_Q
{   /* Declarations of an4l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan4l_zmin;
MCNUM zmax = mccan4l_zmax;
MCNUM ymin = mccan4l_ymin;
MCNUM ymax = mccan4l_ymax;
MCNUM zwidth = mccan4l_zwidth;
MCNUM yheight = mccan4l_yheight;
MCNUM mosaich = mccan4l_mosaich;
MCNUM mosaicv = mccan4l_mosaicv;
MCNUM r0 = mccan4l_r0;
MCNUM Q = mccan4l_Q;
MCNUM DM = mccan4l_DM;
/* 'an4l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 57827 "RITA-II.c"
/* 'an4l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an4l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1489 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 4;
#line 57833 "RITA-II.c"
}

}   /* End of an4l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan4l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(98,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an4u [99] */
  mccoordschange(mcposran4u, mcrotran4u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an4u (without coords transformations) */
  mcJumpTrace_an4u:
  SIG_MESSAGE("an4u (Trace)");
  mcDEBUG_COMP("an4u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan4u
  STORE_NEUTRON(99,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[99]++;
  mcPCounter[99] += p;
  mcP2Counter[99] += p*p;
#define mccompcurname  an4u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 99
#define mos_rms_y mccan4u_mos_rms_y
#define mos_rms_z mccan4u_mos_rms_z
#define mos_rms_max mccan4u_mos_rms_max
#define mono_Q mccan4u_mono_Q
{   /* Declarations of an4u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan4u_zmin;
MCNUM zmax = mccan4u_zmax;
MCNUM ymin = mccan4u_ymin;
MCNUM ymax = mccan4u_ymax;
MCNUM zwidth = mccan4u_zwidth;
MCNUM yheight = mccan4u_yheight;
MCNUM mosaich = mccan4u_mosaich;
MCNUM mosaicv = mccan4u_mosaicv;
MCNUM r0 = mccan4u_r0;
MCNUM Q = mccan4u_Q;
MCNUM DM = mccan4u_DM;
/* 'an4u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 58096 "RITA-II.c"
/* 'an4u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an4u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1500 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 4;
#line 58102 "RITA-II.c"
}

}   /* End of an4u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan4u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(99,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an5l [100] */
  mccoordschange(mcposran5l, mcrotran5l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an5l (without coords transformations) */
  mcJumpTrace_an5l:
  SIG_MESSAGE("an5l (Trace)");
  mcDEBUG_COMP("an5l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan5l
  STORE_NEUTRON(100,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[100]++;
  mcPCounter[100] += p;
  mcP2Counter[100] += p*p;
#define mccompcurname  an5l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 100
#define mos_rms_y mccan5l_mos_rms_y
#define mos_rms_z mccan5l_mos_rms_z
#define mos_rms_max mccan5l_mos_rms_max
#define mono_Q mccan5l_mono_Q
{   /* Declarations of an5l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan5l_zmin;
MCNUM zmax = mccan5l_zmax;
MCNUM ymin = mccan5l_ymin;
MCNUM ymax = mccan5l_ymax;
MCNUM zwidth = mccan5l_zwidth;
MCNUM yheight = mccan5l_yheight;
MCNUM mosaich = mccan5l_mosaich;
MCNUM mosaicv = mccan5l_mosaicv;
MCNUM r0 = mccan5l_r0;
MCNUM Q = mccan5l_Q;
MCNUM DM = mccan5l_DM;
/* 'an5l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 58365 "RITA-II.c"
/* 'an5l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an5l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1511 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 5;
#line 58371 "RITA-II.c"
}

}   /* End of an5l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan5l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(100,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an5u [101] */
  mccoordschange(mcposran5u, mcrotran5u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an5u (without coords transformations) */
  mcJumpTrace_an5u:
  SIG_MESSAGE("an5u (Trace)");
  mcDEBUG_COMP("an5u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan5u
  STORE_NEUTRON(101,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[101]++;
  mcPCounter[101] += p;
  mcP2Counter[101] += p*p;
#define mccompcurname  an5u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 101
#define mos_rms_y mccan5u_mos_rms_y
#define mos_rms_z mccan5u_mos_rms_z
#define mos_rms_max mccan5u_mos_rms_max
#define mono_Q mccan5u_mono_Q
{   /* Declarations of an5u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan5u_zmin;
MCNUM zmax = mccan5u_zmax;
MCNUM ymin = mccan5u_ymin;
MCNUM ymax = mccan5u_ymax;
MCNUM zwidth = mccan5u_zwidth;
MCNUM yheight = mccan5u_yheight;
MCNUM mosaich = mccan5u_mosaich;
MCNUM mosaicv = mccan5u_mosaicv;
MCNUM r0 = mccan5u_r0;
MCNUM Q = mccan5u_Q;
MCNUM DM = mccan5u_DM;
/* 'an5u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 58634 "RITA-II.c"
/* 'an5u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an5u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1522 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 5;
#line 58640 "RITA-II.c"
}

}   /* End of an5u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan5u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(101,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an6l [102] */
  mccoordschange(mcposran6l, mcrotran6l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an6l (without coords transformations) */
  mcJumpTrace_an6l:
  SIG_MESSAGE("an6l (Trace)");
  mcDEBUG_COMP("an6l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan6l
  STORE_NEUTRON(102,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[102]++;
  mcPCounter[102] += p;
  mcP2Counter[102] += p*p;
#define mccompcurname  an6l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 102
#define mos_rms_y mccan6l_mos_rms_y
#define mos_rms_z mccan6l_mos_rms_z
#define mos_rms_max mccan6l_mos_rms_max
#define mono_Q mccan6l_mono_Q
{   /* Declarations of an6l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan6l_zmin;
MCNUM zmax = mccan6l_zmax;
MCNUM ymin = mccan6l_ymin;
MCNUM ymax = mccan6l_ymax;
MCNUM zwidth = mccan6l_zwidth;
MCNUM yheight = mccan6l_yheight;
MCNUM mosaich = mccan6l_mosaich;
MCNUM mosaicv = mccan6l_mosaicv;
MCNUM r0 = mccan6l_r0;
MCNUM Q = mccan6l_Q;
MCNUM DM = mccan6l_DM;
/* 'an6l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 58903 "RITA-II.c"
/* 'an6l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an6l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1533 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 6;
#line 58909 "RITA-II.c"
}

}   /* End of an6l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan6l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(102,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an6u [103] */
  mccoordschange(mcposran6u, mcrotran6u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an6u (without coords transformations) */
  mcJumpTrace_an6u:
  SIG_MESSAGE("an6u (Trace)");
  mcDEBUG_COMP("an6u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan6u
  STORE_NEUTRON(103,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[103]++;
  mcPCounter[103] += p;
  mcP2Counter[103] += p*p;
#define mccompcurname  an6u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 103
#define mos_rms_y mccan6u_mos_rms_y
#define mos_rms_z mccan6u_mos_rms_z
#define mos_rms_max mccan6u_mos_rms_max
#define mono_Q mccan6u_mono_Q
{   /* Declarations of an6u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan6u_zmin;
MCNUM zmax = mccan6u_zmax;
MCNUM ymin = mccan6u_ymin;
MCNUM ymax = mccan6u_ymax;
MCNUM zwidth = mccan6u_zwidth;
MCNUM yheight = mccan6u_yheight;
MCNUM mosaich = mccan6u_mosaich;
MCNUM mosaicv = mccan6u_mosaicv;
MCNUM r0 = mccan6u_r0;
MCNUM Q = mccan6u_Q;
MCNUM DM = mccan6u_DM;
/* 'an6u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 59172 "RITA-II.c"
/* 'an6u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an6u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1544 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 6;
#line 59178 "RITA-II.c"
}

}   /* End of an6u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan6u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(103,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an7l [104] */
  mccoordschange(mcposran7l, mcrotran7l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an7l (without coords transformations) */
  mcJumpTrace_an7l:
  SIG_MESSAGE("an7l (Trace)");
  mcDEBUG_COMP("an7l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan7l
  STORE_NEUTRON(104,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[104]++;
  mcPCounter[104] += p;
  mcP2Counter[104] += p*p;
#define mccompcurname  an7l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 104
#define mos_rms_y mccan7l_mos_rms_y
#define mos_rms_z mccan7l_mos_rms_z
#define mos_rms_max mccan7l_mos_rms_max
#define mono_Q mccan7l_mono_Q
{   /* Declarations of an7l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan7l_zmin;
MCNUM zmax = mccan7l_zmax;
MCNUM ymin = mccan7l_ymin;
MCNUM ymax = mccan7l_ymax;
MCNUM zwidth = mccan7l_zwidth;
MCNUM yheight = mccan7l_yheight;
MCNUM mosaich = mccan7l_mosaich;
MCNUM mosaicv = mccan7l_mosaicv;
MCNUM r0 = mccan7l_r0;
MCNUM Q = mccan7l_Q;
MCNUM DM = mccan7l_DM;
/* 'an7l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 59441 "RITA-II.c"
/* 'an7l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an7l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1556 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 7;
#line 59447 "RITA-II.c"
}

}   /* End of an7l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan7l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(104,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an7u [105] */
  mccoordschange(mcposran7u, mcrotran7u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an7u (without coords transformations) */
  mcJumpTrace_an7u:
  SIG_MESSAGE("an7u (Trace)");
  mcDEBUG_COMP("an7u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan7u
  STORE_NEUTRON(105,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[105]++;
  mcPCounter[105] += p;
  mcP2Counter[105] += p*p;
#define mccompcurname  an7u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 105
#define mos_rms_y mccan7u_mos_rms_y
#define mos_rms_z mccan7u_mos_rms_z
#define mos_rms_max mccan7u_mos_rms_max
#define mono_Q mccan7u_mono_Q
{   /* Declarations of an7u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan7u_zmin;
MCNUM zmax = mccan7u_zmax;
MCNUM ymin = mccan7u_ymin;
MCNUM ymax = mccan7u_ymax;
MCNUM zwidth = mccan7u_zwidth;
MCNUM yheight = mccan7u_yheight;
MCNUM mosaich = mccan7u_mosaich;
MCNUM mosaicv = mccan7u_mosaicv;
MCNUM r0 = mccan7u_r0;
MCNUM Q = mccan7u_Q;
MCNUM DM = mccan7u_DM;
/* 'an7u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 59710 "RITA-II.c"
/* 'an7u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an7u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1567 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 7;
#line 59716 "RITA-II.c"
}

}   /* End of an7u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan7u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(105,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an8l [106] */
  mccoordschange(mcposran8l, mcrotran8l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an8l (without coords transformations) */
  mcJumpTrace_an8l:
  SIG_MESSAGE("an8l (Trace)");
  mcDEBUG_COMP("an8l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan8l
  STORE_NEUTRON(106,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[106]++;
  mcPCounter[106] += p;
  mcP2Counter[106] += p*p;
#define mccompcurname  an8l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 106
#define mos_rms_y mccan8l_mos_rms_y
#define mos_rms_z mccan8l_mos_rms_z
#define mos_rms_max mccan8l_mos_rms_max
#define mono_Q mccan8l_mono_Q
{   /* Declarations of an8l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan8l_zmin;
MCNUM zmax = mccan8l_zmax;
MCNUM ymin = mccan8l_ymin;
MCNUM ymax = mccan8l_ymax;
MCNUM zwidth = mccan8l_zwidth;
MCNUM yheight = mccan8l_yheight;
MCNUM mosaich = mccan8l_mosaich;
MCNUM mosaicv = mccan8l_mosaicv;
MCNUM r0 = mccan8l_r0;
MCNUM Q = mccan8l_Q;
MCNUM DM = mccan8l_DM;
/* 'an8l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 59979 "RITA-II.c"
/* 'an8l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an8l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1578 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 8;
#line 59985 "RITA-II.c"
}

}   /* End of an8l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan8l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(106,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an8u [107] */
  mccoordschange(mcposran8u, mcrotran8u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an8u (without coords transformations) */
  mcJumpTrace_an8u:
  SIG_MESSAGE("an8u (Trace)");
  mcDEBUG_COMP("an8u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan8u
  STORE_NEUTRON(107,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[107]++;
  mcPCounter[107] += p;
  mcP2Counter[107] += p*p;
#define mccompcurname  an8u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 107
#define mos_rms_y mccan8u_mos_rms_y
#define mos_rms_z mccan8u_mos_rms_z
#define mos_rms_max mccan8u_mos_rms_max
#define mono_Q mccan8u_mono_Q
{   /* Declarations of an8u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan8u_zmin;
MCNUM zmax = mccan8u_zmax;
MCNUM ymin = mccan8u_ymin;
MCNUM ymax = mccan8u_ymax;
MCNUM zwidth = mccan8u_zwidth;
MCNUM yheight = mccan8u_yheight;
MCNUM mosaich = mccan8u_mosaich;
MCNUM mosaicv = mccan8u_mosaicv;
MCNUM r0 = mccan8u_r0;
MCNUM Q = mccan8u_Q;
MCNUM DM = mccan8u_DM;
/* 'an8u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 60248 "RITA-II.c"
/* 'an8u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an8u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1589 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 8;
#line 60254 "RITA-II.c"
}

}   /* End of an8u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan8u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(107,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an9l [108] */
  mccoordschange(mcposran9l, mcrotran9l,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an9l (without coords transformations) */
  mcJumpTrace_an9l:
  SIG_MESSAGE("an9l (Trace)");
  mcDEBUG_COMP("an9l")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan9l
  STORE_NEUTRON(108,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[108]++;
  mcPCounter[108] += p;
  mcP2Counter[108] += p*p;
#define mccompcurname  an9l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 108
#define mos_rms_y mccan9l_mos_rms_y
#define mos_rms_z mccan9l_mos_rms_z
#define mos_rms_max mccan9l_mos_rms_max
#define mono_Q mccan9l_mono_Q
{   /* Declarations of an9l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan9l_zmin;
MCNUM zmax = mccan9l_zmax;
MCNUM ymin = mccan9l_ymin;
MCNUM ymax = mccan9l_ymax;
MCNUM zwidth = mccan9l_zwidth;
MCNUM yheight = mccan9l_yheight;
MCNUM mosaich = mccan9l_mosaich;
MCNUM mosaicv = mccan9l_mosaicv;
MCNUM r0 = mccan9l_r0;
MCNUM Q = mccan9l_Q;
MCNUM DM = mccan9l_DM;
/* 'an9l=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 60517 "RITA-II.c"
/* 'an9l=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an9l (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1600 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 9;
#line 60523 "RITA-II.c"
}

}   /* End of an9l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan9l:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(108,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component an9u [109] */
  mccoordschange(mcposran9u, mcrotran9u,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component an9u (without coords transformations) */
  mcJumpTrace_an9u:
  SIG_MESSAGE("an9u (Trace)");
  mcDEBUG_COMP("an9u")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompan9u
  STORE_NEUTRON(109,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[109]++;
  mcPCounter[109] += p;
  mcP2Counter[109] += p*p;
#define mccompcurname  an9u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 109
#define mos_rms_y mccan9u_mos_rms_y
#define mos_rms_z mccan9u_mos_rms_z
#define mos_rms_max mccan9u_mos_rms_max
#define mono_Q mccan9u_mono_Q
{   /* Declarations of an9u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan9u_zmin;
MCNUM zmax = mccan9u_zmax;
MCNUM ymin = mccan9u_ymin;
MCNUM ymax = mccan9u_ymax;
MCNUM zwidth = mccan9u_zwidth;
MCNUM yheight = mccan9u_yheight;
MCNUM mosaich = mccan9u_mosaich;
MCNUM mosaicv = mccan9u_mosaicv;
MCNUM r0 = mccan9u_r0;
MCNUM Q = mccan9u_Q;
MCNUM DM = mccan9u_DM;
/* 'an9u=Monochromator_flat()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 118 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,k,q0,theta;
  double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
  double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
  double delta,p_reflect,total,c1x,c1y,c1z,width,mos_sample;
  int i;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {                             /* Moving towards crystal? */
    y1 = y + vy*dt;             /* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {                           /* Intersect the crystal? */
      kix = V2K*vx;             /* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*kix/mono_Q;
      order = floor(ratio + .5);
      if(order == 0.0)
        order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      if(order < 0)
        order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      kux = kix/k;              /* Unit vector along ki */
      kuy = kiy/k;
      kuz = kiz/k;
      if(order > 2*k/mono_Q)
        order--;
      if(order > 0)             /* Bragg scattering possible? */
      {
        q0 = order*mono_Q;
        q0x = ratio < 0 ? -q0 : q0;
        theta = asin(q0/(2*k)); /* Actual bragg angle */
        /* Make MC choice: reflect or transmit? */
        delta = asin(fabs(kux)) - theta;
        p_reflect = r0*exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_y*mos_rms_y))*
                       exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                           (2*mos_rms_z*mos_rms_z));
        if(rand01() < p_reflect)
        {                       /* Reflect */
          cos_2theta = cos(2*theta);
          k_sin_2theta = k*sin(2*theta);
          /* Get unit normal to plane containing ki and most probable kf */
          vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
          NORM(bx,by,bz);
          bx *= k_sin_2theta;
          by *= k_sin_2theta;
          bz *= k_sin_2theta;
          /* Get unit vector normal to ki and b */
          vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
          /* Compute the total scattering probability at this ki */
          total = 0;
          /* Choose width of Gaussian distribution to sample the angle
           * phi on the Debye-Scherrer cone for the scattered neutron.
           * The radius of the Debye-Scherrer cone is smaller by a
           * factor 1/cos(theta) than the radius of the (partial) sphere
           * describing the possible orientations of Q due to mosaicity, so we
           * start with a width 1/cos(theta) greater than the largest of
           * the two mosaics. */
          mos_sample = mos_rms_max/cos(theta);
          c1x = kix*(cos_2theta-1);
          c1y = kiy*(cos_2theta-1);
          c1z = kiz*(cos_2theta-1);
          /* Loop, repeatedly reducing the sample width until it is small
           * enough to avoid sampling scattering directions with
           * ridiculously low scattering probability.
           * Use a cut-off at 5 times the gauss width for considering
           * scattering probability as well as for integration limits
           * when integrating the sampled distribution below. */
          for(i=0; i<100; i++) {
            width = 5*mos_sample;
            cos_phi = cos(width);
            sin_phi = sin(width);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_y;
            q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_z;
            /* Stop when we get near a factor of 25=5^2. */
            if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
              break;
            mos_sample *= (2.0/3.0);
          }
          /* Now integrate the chosen sampling distribution, using a
           * cut-off at five times sigma. */
          for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
          {
            phi = width*Gauss_X[i];
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                        GAUSS((q_z/q_x),0,mos_rms_z);
            total += Gauss_W[i]*p_reflect;
          }
          total *= width;
          /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
           * width 1/cos(theta) greater than the mosaic and correct for any
           * error by adjusting the neutron weight later. */
          phi = mos_sample*randnorm();
          /* Compute final wave vector kf and scattering vector q = ki - kf */
          cos_phi = cos(phi);
          sin_phi = sin(phi);
          q_x = c1x + cos_phi*ax + sin_phi*bx;
          q_y = c1y + cos_phi*ay + sin_phi*by;
          q_z = c1z + cos_phi*az + sin_phi*bz;
          p_reflect = GAUSS((q_y/q_x),0,mos_rms_y)*
                      GAUSS((q_z/q_x),0,mos_rms_z);
          x = 0;
          y = y1;
          z = z1;
          t = t1;
          vx = K2V*(kix+q_x);
          vy = K2V*(kiy+q_y);
          vz = K2V*(kiz+q_z);
          p_reflect /= total*GAUSS(phi,0,mos_sample);
          if (p_reflect <= 0) ABSORB;
          if (p_reflect > 1)  p_reflect = 1;
          p *= p_reflect;
          SCATTER;
        } /* End MC choice to reflect or transmit neutron */
      } /* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
}
#line 60786 "RITA-II.c"
/* 'an9u=Monochromator_flat()' component instance extend code */
    SIG_MESSAGE("an9u (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1611 "RITA-II.instr"
  if(SCATTERED) AnaBlade = 9;
#line 60792 "RITA-II.c"
}

}   /* End of an9u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompan9u:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(109,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component a6 [110] */
  mccoordschange(mcposra6, mcrotra6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component a6 (without coords transformations) */
  mcJumpTrace_a6:
  SIG_MESSAGE("a6 (Trace)");
  mcDEBUG_COMP("a6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompa6
  STORE_NEUTRON(110,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[110]++;
  mcPCounter[110] += p;
  mcP2Counter[110] += p*p;
#define mccompcurname  a6
#define mccompcurtype  Arm
#define mccompcurindex 110
/* 'a6=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompa6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(110,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_before_coarse [111] */
  mccoordschange(mcposremon_before_coarse, mcrotremon_before_coarse,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_before_coarse (without coords transformations) */
  mcJumpTrace_emon_before_coarse:
  SIG_MESSAGE("emon_before_coarse (Trace)");
  mcDEBUG_COMP("emon_before_coarse")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_before_coarse
  STORE_NEUTRON(111,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[111]++;
  mcPCounter[111] += p;
  mcP2Counter[111] += p*p;
#define mccompcurname  emon_before_coarse
#define mccompcurtype  E_monitor
#define mccompcurindex 111
#define nE mccemon_before_coarse_nE
#define E_N mccemon_before_coarse_E_N
#define E_p mccemon_before_coarse_E_p
#define E_p2 mccemon_before_coarse_E_p2
#define S_p mccemon_before_coarse_S_p
#define S_pE mccemon_before_coarse_S_pE
#define S_pE2 mccemon_before_coarse_S_pE2
{   /* Declarations of emon_before_coarse=E_monitor() SETTING parameters. */
char* filename = mccemon_before_coarse_filename;
MCNUM xmin = mccemon_before_coarse_xmin;
MCNUM xmax = mccemon_before_coarse_xmax;
MCNUM ymin = mccemon_before_coarse_ymin;
MCNUM ymax = mccemon_before_coarse_ymax;
MCNUM xwidth = mccemon_before_coarse_xwidth;
MCNUM yheight = mccemon_before_coarse_yheight;
MCNUM Emin = mccemon_before_coarse_Emin;
MCNUM Emax = mccemon_before_coarse_Emax;
MCNUM restore_neutron = mccemon_before_coarse_restore_neutron;
int nowritefile = mccemon_before_coarse_nowritefile;
/* 'emon_before_coarse=E_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 61055 "RITA-II.c"
}   /* End of emon_before_coarse=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_before_coarse:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(111,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_before_coarse [112] */
  mccoordschange(mcposrpsd_before_coarse, mcrotrpsd_before_coarse,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_before_coarse (without coords transformations) */
  mcJumpTrace_psd_before_coarse:
  SIG_MESSAGE("psd_before_coarse (Trace)");
  mcDEBUG_COMP("psd_before_coarse")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_before_coarse
  STORE_NEUTRON(112,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[112]++;
  mcPCounter[112] += p;
  mcP2Counter[112] += p*p;
#define mccompcurname  psd_before_coarse
#define mccompcurtype  PSD_monitor
#define mccompcurindex 112
#define nx mccpsd_before_coarse_nx
#define ny mccpsd_before_coarse_ny
#define PSD_N mccpsd_before_coarse_PSD_N
#define PSD_p mccpsd_before_coarse_PSD_p
#define PSD_p2 mccpsd_before_coarse_PSD_p2
{   /* Declarations of psd_before_coarse=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_before_coarse_filename;
MCNUM xmin = mccpsd_before_coarse_xmin;
MCNUM xmax = mccpsd_before_coarse_xmax;
MCNUM ymin = mccpsd_before_coarse_ymin;
MCNUM ymax = mccpsd_before_coarse_ymax;
MCNUM xwidth = mccpsd_before_coarse_xwidth;
MCNUM yheight = mccpsd_before_coarse_yheight;
MCNUM restore_neutron = mccpsd_before_coarse_restore_neutron;
int nowritefile = mccpsd_before_coarse_nowritefile;
/* 'psd_before_coarse=PSD_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 83 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 61202 "RITA-II.c"
}   /* End of psd_before_coarse=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_before_coarse:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(112,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmR1 [113] */
  mccoordschange(mcposrArmR1, mcrotrArmR1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmR1 (without coords transformations) */
  mcJumpTrace_ArmR1:
  SIG_MESSAGE("ArmR1 (Trace)");
  mcDEBUG_COMP("ArmR1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmR1
  STORE_NEUTRON(113,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[113]++;
  mcPCounter[113] += p;
  mcP2Counter[113] += p*p;
#define mccompcurname  ArmR1
#define mccompcurtype  Arm
#define mccompcurindex 113
/* 'ArmR1=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmR1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(113,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeR1 [114] */
  mccoordschange(mcposrBladeR1, mcrotrBladeR1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeR1 (without coords transformations) */
  mcJumpTrace_BladeR1:
  SIG_MESSAGE("BladeR1 (Trace)");
  mcDEBUG_COMP("BladeR1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeR1
  STORE_NEUTRON(114,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[114]++;
  mcPCounter[114] += p;
  mcP2Counter[114] += p*p;
#define mccompcurname  BladeR1
#define mccompcurtype  Absorber
#define mccompcurindex 114
#define xw mccBladeR1_xw
#define yh mccBladeR1_yh
#define zt mccBladeR1_zt
#define xm mccBladeR1_xm
#define ym mccBladeR1_ym
#define zm mccBladeR1_zm
{   /* Declarations of BladeR1=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR1_xmin;
MCNUM xmax = mccBladeR1_xmax;
MCNUM ymin = mccBladeR1_ymin;
MCNUM ymax = mccBladeR1_ymax;
MCNUM zmin = mccBladeR1_zmin;
MCNUM zmax = mccBladeR1_zmax;
/* 'BladeR1=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 61445 "RITA-II.c"
/* 'BladeR1=Absorber()' component instance extend code */
    SIG_MESSAGE("BladeR1 (Trace:Extend)");
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT )) {

#line 1642 "RITA-II.instr"
  if (SCATTERED) printf("Absorption in R1\n");
#line 61451 "RITA-II.c"
}

}   /* End of BladeR1=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeR1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(114,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmR2 [115] */
  mccoordschange(mcposrArmR2, mcrotrArmR2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmR2 (without coords transformations) */
  mcJumpTrace_ArmR2:
  SIG_MESSAGE("ArmR2 (Trace)");
  mcDEBUG_COMP("ArmR2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmR2
  STORE_NEUTRON(115,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[115]++;
  mcPCounter[115] += p;
  mcP2Counter[115] += p*p;
#define mccompcurname  ArmR2
#define mccompcurtype  Arm
#define mccompcurindex 115
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmR2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(115,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeR2 [116] */
  mccoordschange(mcposrBladeR2, mcrotrBladeR2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeR2 (without coords transformations) */
  mcJumpTrace_BladeR2:
  SIG_MESSAGE("BladeR2 (Trace)");
  mcDEBUG_COMP("BladeR2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeR2
  STORE_NEUTRON(116,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[116]++;
  mcPCounter[116] += p;
  mcP2Counter[116] += p*p;
#define mccompcurname  BladeR2
#define mccompcurtype  Absorber
#define mccompcurindex 116
#define xw mccBladeR2_xw
#define yh mccBladeR2_yh
#define zt mccBladeR2_zt
#define xm mccBladeR2_xm
#define ym mccBladeR2_ym
#define zm mccBladeR2_zm
{   /* Declarations of BladeR2=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR2_xmin;
MCNUM xmax = mccBladeR2_xmax;
MCNUM ymin = mccBladeR2_ymin;
MCNUM ymax = mccBladeR2_ymax;
MCNUM zmin = mccBladeR2_zmin;
MCNUM zmax = mccBladeR2_zmax;
/* 'BladeR2=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 61694 "RITA-II.c"
}   /* End of BladeR2=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeR2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(116,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmR3 [117] */
  mccoordschange(mcposrArmR3, mcrotrArmR3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmR3 (without coords transformations) */
  mcJumpTrace_ArmR3:
  SIG_MESSAGE("ArmR3 (Trace)");
  mcDEBUG_COMP("ArmR3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmR3
  STORE_NEUTRON(117,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[117]++;
  mcPCounter[117] += p;
  mcP2Counter[117] += p*p;
#define mccompcurname  ArmR3
#define mccompcurtype  Arm
#define mccompcurindex 117
/* 'ArmR3=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmR3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(117,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeR3 [118] */
  mccoordschange(mcposrBladeR3, mcrotrBladeR3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeR3 (without coords transformations) */
  mcJumpTrace_BladeR3:
  SIG_MESSAGE("BladeR3 (Trace)");
  mcDEBUG_COMP("BladeR3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeR3
  STORE_NEUTRON(118,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[118]++;
  mcPCounter[118] += p;
  mcP2Counter[118] += p*p;
#define mccompcurname  BladeR3
#define mccompcurtype  Absorber
#define mccompcurindex 118
#define xw mccBladeR3_xw
#define yh mccBladeR3_yh
#define zt mccBladeR3_zt
#define xm mccBladeR3_xm
#define ym mccBladeR3_ym
#define zm mccBladeR3_zm
{   /* Declarations of BladeR3=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR3_xmin;
MCNUM xmax = mccBladeR3_xmax;
MCNUM ymin = mccBladeR3_ymin;
MCNUM ymax = mccBladeR3_ymax;
MCNUM zmin = mccBladeR3_zmin;
MCNUM zmax = mccBladeR3_zmax;
/* 'BladeR3=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 61938 "RITA-II.c"
}   /* End of BladeR3=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeR3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(118,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmR4 [119] */
  mccoordschange(mcposrArmR4, mcrotrArmR4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmR4 (without coords transformations) */
  mcJumpTrace_ArmR4:
  SIG_MESSAGE("ArmR4 (Trace)");
  mcDEBUG_COMP("ArmR4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmR4
  STORE_NEUTRON(119,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[119]++;
  mcPCounter[119] += p;
  mcP2Counter[119] += p*p;
#define mccompcurname  ArmR4
#define mccompcurtype  Arm
#define mccompcurindex 119
/* 'ArmR4=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmR4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(119,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeR4 [120] */
  mccoordschange(mcposrBladeR4, mcrotrBladeR4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeR4 (without coords transformations) */
  mcJumpTrace_BladeR4:
  SIG_MESSAGE("BladeR4 (Trace)");
  mcDEBUG_COMP("BladeR4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeR4
  STORE_NEUTRON(120,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[120]++;
  mcPCounter[120] += p;
  mcP2Counter[120] += p*p;
#define mccompcurname  BladeR4
#define mccompcurtype  Absorber
#define mccompcurindex 120
#define xw mccBladeR4_xw
#define yh mccBladeR4_yh
#define zt mccBladeR4_zt
#define xm mccBladeR4_xm
#define ym mccBladeR4_ym
#define zm mccBladeR4_zm
{   /* Declarations of BladeR4=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR4_xmin;
MCNUM xmax = mccBladeR4_xmax;
MCNUM ymin = mccBladeR4_ymin;
MCNUM ymax = mccBladeR4_ymax;
MCNUM zmin = mccBladeR4_zmin;
MCNUM zmax = mccBladeR4_zmax;
/* 'BladeR4=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 62182 "RITA-II.c"
}   /* End of BladeR4=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeR4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(120,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmR5 [121] */
  mccoordschange(mcposrArmR5, mcrotrArmR5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmR5 (without coords transformations) */
  mcJumpTrace_ArmR5:
  SIG_MESSAGE("ArmR5 (Trace)");
  mcDEBUG_COMP("ArmR5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmR5
  STORE_NEUTRON(121,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[121]++;
  mcPCounter[121] += p;
  mcP2Counter[121] += p*p;
#define mccompcurname  ArmR5
#define mccompcurtype  Arm
#define mccompcurindex 121
/* 'ArmR5=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmR5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(121,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeR5 [122] */
  mccoordschange(mcposrBladeR5, mcrotrBladeR5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeR5 (without coords transformations) */
  mcJumpTrace_BladeR5:
  SIG_MESSAGE("BladeR5 (Trace)");
  mcDEBUG_COMP("BladeR5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeR5
  STORE_NEUTRON(122,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[122]++;
  mcPCounter[122] += p;
  mcP2Counter[122] += p*p;
#define mccompcurname  BladeR5
#define mccompcurtype  Absorber
#define mccompcurindex 122
#define xw mccBladeR5_xw
#define yh mccBladeR5_yh
#define zt mccBladeR5_zt
#define xm mccBladeR5_xm
#define ym mccBladeR5_ym
#define zm mccBladeR5_zm
{   /* Declarations of BladeR5=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR5_xmin;
MCNUM xmax = mccBladeR5_xmax;
MCNUM ymin = mccBladeR5_ymin;
MCNUM ymax = mccBladeR5_ymax;
MCNUM zmin = mccBladeR5_zmin;
MCNUM zmax = mccBladeR5_zmax;
/* 'BladeR5=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 62426 "RITA-II.c"
}   /* End of BladeR5=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeR5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(122,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmL1 [123] */
  mccoordschange(mcposrArmL1, mcrotrArmL1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmL1 (without coords transformations) */
  mcJumpTrace_ArmL1:
  SIG_MESSAGE("ArmL1 (Trace)");
  mcDEBUG_COMP("ArmL1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmL1
  STORE_NEUTRON(123,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[123]++;
  mcPCounter[123] += p;
  mcP2Counter[123] += p*p;
#define mccompcurname  ArmL1
#define mccompcurtype  Arm
#define mccompcurindex 123
/* 'ArmL1=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmL1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(123,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeL1 [124] */
  mccoordschange(mcposrBladeL1, mcrotrBladeL1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeL1 (without coords transformations) */
  mcJumpTrace_BladeL1:
  SIG_MESSAGE("BladeL1 (Trace)");
  mcDEBUG_COMP("BladeL1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeL1
  STORE_NEUTRON(124,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[124]++;
  mcPCounter[124] += p;
  mcP2Counter[124] += p*p;
#define mccompcurname  BladeL1
#define mccompcurtype  Absorber
#define mccompcurindex 124
#define xw mccBladeL1_xw
#define yh mccBladeL1_yh
#define zt mccBladeL1_zt
#define xm mccBladeL1_xm
#define ym mccBladeL1_ym
#define zm mccBladeL1_zm
{   /* Declarations of BladeL1=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL1_xmin;
MCNUM xmax = mccBladeL1_xmax;
MCNUM ymin = mccBladeL1_ymin;
MCNUM ymax = mccBladeL1_ymax;
MCNUM zmin = mccBladeL1_zmin;
MCNUM zmax = mccBladeL1_zmax;
/* 'BladeL1=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 62670 "RITA-II.c"
}   /* End of BladeL1=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeL1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(124,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmL2 [125] */
  mccoordschange(mcposrArmL2, mcrotrArmL2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmL2 (without coords transformations) */
  mcJumpTrace_ArmL2:
  SIG_MESSAGE("ArmL2 (Trace)");
  mcDEBUG_COMP("ArmL2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmL2
  STORE_NEUTRON(125,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[125]++;
  mcPCounter[125] += p;
  mcP2Counter[125] += p*p;
#define mccompcurname  ArmL2
#define mccompcurtype  Arm
#define mccompcurindex 125
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmL2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(125,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeL2 [126] */
  mccoordschange(mcposrBladeL2, mcrotrBladeL2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeL2 (without coords transformations) */
  mcJumpTrace_BladeL2:
  SIG_MESSAGE("BladeL2 (Trace)");
  mcDEBUG_COMP("BladeL2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeL2
  STORE_NEUTRON(126,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[126]++;
  mcPCounter[126] += p;
  mcP2Counter[126] += p*p;
#define mccompcurname  BladeL2
#define mccompcurtype  Absorber
#define mccompcurindex 126
#define xw mccBladeL2_xw
#define yh mccBladeL2_yh
#define zt mccBladeL2_zt
#define xm mccBladeL2_xm
#define ym mccBladeL2_ym
#define zm mccBladeL2_zm
{   /* Declarations of BladeL2=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL2_xmin;
MCNUM xmax = mccBladeL2_xmax;
MCNUM ymin = mccBladeL2_ymin;
MCNUM ymax = mccBladeL2_ymax;
MCNUM zmin = mccBladeL2_zmin;
MCNUM zmax = mccBladeL2_zmax;
/* 'BladeL2=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 62912 "RITA-II.c"
}   /* End of BladeL2=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeL2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(126,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmL3 [127] */
  mccoordschange(mcposrArmL3, mcrotrArmL3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmL3 (without coords transformations) */
  mcJumpTrace_ArmL3:
  SIG_MESSAGE("ArmL3 (Trace)");
  mcDEBUG_COMP("ArmL3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmL3
  STORE_NEUTRON(127,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[127]++;
  mcPCounter[127] += p;
  mcP2Counter[127] += p*p;
#define mccompcurname  ArmL3
#define mccompcurtype  Arm
#define mccompcurindex 127
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmL3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(127,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeL3 [128] */
  mccoordschange(mcposrBladeL3, mcrotrBladeL3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeL3 (without coords transformations) */
  mcJumpTrace_BladeL3:
  SIG_MESSAGE("BladeL3 (Trace)");
  mcDEBUG_COMP("BladeL3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeL3
  STORE_NEUTRON(128,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[128]++;
  mcPCounter[128] += p;
  mcP2Counter[128] += p*p;
#define mccompcurname  BladeL3
#define mccompcurtype  Absorber
#define mccompcurindex 128
#define xw mccBladeL3_xw
#define yh mccBladeL3_yh
#define zt mccBladeL3_zt
#define xm mccBladeL3_xm
#define ym mccBladeL3_ym
#define zm mccBladeL3_zm
{   /* Declarations of BladeL3=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL3_xmin;
MCNUM xmax = mccBladeL3_xmax;
MCNUM ymin = mccBladeL3_ymin;
MCNUM ymax = mccBladeL3_ymax;
MCNUM zmin = mccBladeL3_zmin;
MCNUM zmax = mccBladeL3_zmax;
/* 'BladeL3=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 63154 "RITA-II.c"
}   /* End of BladeL3=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeL3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(128,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmL4 [129] */
  mccoordschange(mcposrArmL4, mcrotrArmL4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmL4 (without coords transformations) */
  mcJumpTrace_ArmL4:
  SIG_MESSAGE("ArmL4 (Trace)");
  mcDEBUG_COMP("ArmL4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmL4
  STORE_NEUTRON(129,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[129]++;
  mcPCounter[129] += p;
  mcP2Counter[129] += p*p;
#define mccompcurname  ArmL4
#define mccompcurtype  Arm
#define mccompcurindex 129
/* 'ArmL4=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmL4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(129,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeL4 [130] */
  mccoordschange(mcposrBladeL4, mcrotrBladeL4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeL4 (without coords transformations) */
  mcJumpTrace_BladeL4:
  SIG_MESSAGE("BladeL4 (Trace)");
  mcDEBUG_COMP("BladeL4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeL4
  STORE_NEUTRON(130,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[130]++;
  mcPCounter[130] += p;
  mcP2Counter[130] += p*p;
#define mccompcurname  BladeL4
#define mccompcurtype  Absorber
#define mccompcurindex 130
#define xw mccBladeL4_xw
#define yh mccBladeL4_yh
#define zt mccBladeL4_zt
#define xm mccBladeL4_xm
#define ym mccBladeL4_ym
#define zm mccBladeL4_zm
{   /* Declarations of BladeL4=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL4_xmin;
MCNUM xmax = mccBladeL4_xmax;
MCNUM ymin = mccBladeL4_ymin;
MCNUM ymax = mccBladeL4_ymax;
MCNUM zmin = mccBladeL4_zmin;
MCNUM zmax = mccBladeL4_zmax;
/* 'BladeL4=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 63398 "RITA-II.c"
}   /* End of BladeL4=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeL4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(130,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmL5 [131] */
  mccoordschange(mcposrArmL5, mcrotrArmL5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmL5 (without coords transformations) */
  mcJumpTrace_ArmL5:
  SIG_MESSAGE("ArmL5 (Trace)");
  mcDEBUG_COMP("ArmL5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmL5
  STORE_NEUTRON(131,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[131]++;
  mcPCounter[131] += p;
  mcP2Counter[131] += p*p;
#define mccompcurname  ArmL5
#define mccompcurtype  Arm
#define mccompcurindex 131
/* 'ArmL5=Arm()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

/* 'ArmL5=Arm()' component instance extend code */
    SIG_MESSAGE("ArmL5 (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1724 "RITA-II.instr"
  BinX = 0; BinY=0;
#line 63516 "RITA-II.c"
}

#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmL5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(131,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BladeL5 [132] */
  mccoordschange(mcposrBladeL5, mcrotrBladeL5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BladeL5 (without coords transformations) */
  mcJumpTrace_BladeL5:
  SIG_MESSAGE("BladeL5 (Trace)");
  mcDEBUG_COMP("BladeL5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBladeL5
  STORE_NEUTRON(132,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[132]++;
  mcPCounter[132] += p;
  mcP2Counter[132] += p*p;
#define mccompcurname  BladeL5
#define mccompcurtype  Absorber
#define mccompcurindex 132
#define xw mccBladeL5_xw
#define yh mccBladeL5_yh
#define zt mccBladeL5_zt
#define xm mccBladeL5_xm
#define ym mccBladeL5_ym
#define zm mccBladeL5_zm
{   /* Declarations of BladeL5=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL5_xmin;
MCNUM xmax = mccBladeL5_xmax;
MCNUM ymin = mccBladeL5_ymin;
MCNUM ymax = mccBladeL5_ymax;
MCNUM zmin = mccBladeL5_zmin;
MCNUM zmax = mccBladeL5_zmax;
/* 'BladeL5=Absorber()' component instance has conditional execution */
if (( mcipCOARSE > 0 && ! mcipVIRTUALOUT ))

#line 59 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  xp = x - xm;
  yp = y - ym;
  zp = z - zm;
  if (box_intersect(&t0, &t1, xp, yp, zp, vx, vy, vz, xw, yh, zt)) {
    if (t1>=0) {
      PROP_DT((t1+t0)/2);
      SCATTER;
      ABSORB;
    }
  }
}
#line 63649 "RITA-II.c"
}   /* End of BladeL5=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBladeL5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(132,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_detector [133] */
  mccoordschange(mcposrpsd_detector, mcrotrpsd_detector,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_detector (without coords transformations) */
  mcJumpTrace_psd_detector:
  SIG_MESSAGE("psd_detector (Trace)");
  mcDEBUG_COMP("psd_detector")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_detector
  STORE_NEUTRON(133,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[133]++;
  mcPCounter[133] += p;
  mcP2Counter[133] += p*p;
#define mccompcurname  psd_detector
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 133
#define nx mccpsd_detector_nx
#define ny mccpsd_detector_ny
#define filename mccpsd_detector_filename
#define PSD_N mccpsd_detector_PSD_N
#define PSD_p mccpsd_detector_PSD_p
#define PSD_p2 mccpsd_detector_PSD_p2
#define weight mccpsd_detector_weight
{   /* Declarations of psd_detector=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_detector_xmin;
MCNUM xmax = mccpsd_detector_xmax;
MCNUM ymin = mccpsd_detector_ymin;
MCNUM ymax = mccpsd_detector_ymax;
MCNUM xwidth = mccpsd_detector_xwidth;
MCNUM yheight = mccpsd_detector_yheight;
MCNUM psf = mccpsd_detector_psf;
MCNUM k0 = mccpsd_detector_k0;
MCNUM eff = mccpsd_detector_eff;
MCNUM restore_neutron = mccpsd_detector_restore_neutron;
int nowritefile = mccpsd_detector_nowritefile;
/* 'psd_detector=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63805 "RITA-II.c"
/* 'psd_detector=PSD_monitor_psf_eff()' component instance extend code */
    SIG_MESSAGE("psd_detector (Trace:Extend)");
if (( ! mcipVIRTUALOUT )) {

#line 1738 "RITA-II.instr"
  BinX = floor((x - xmin)*nx/(xmax - xmin)); BinY = floor((y - ymin)*ny/(ymax - ymin));
#line 63811 "RITA-II.c"
}

}   /* End of psd_detector=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_detector:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(133,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_detector [134] */
  mccoordschange(mcposremon_detector, mcrotremon_detector,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_detector (without coords transformations) */
  mcJumpTrace_emon_detector:
  SIG_MESSAGE("emon_detector (Trace)");
  mcDEBUG_COMP("emon_detector")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_detector
  STORE_NEUTRON(134,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[134]++;
  mcPCounter[134] += p;
  mcP2Counter[134] += p*p;
#define mccompcurname  emon_detector
#define mccompcurtype  E_monitor
#define mccompcurindex 134
#define nE mccemon_detector_nE
#define E_N mccemon_detector_E_N
#define E_p mccemon_detector_E_p
#define E_p2 mccemon_detector_E_p2
#define S_p mccemon_detector_S_p
#define S_pE mccemon_detector_S_pE
#define S_pE2 mccemon_detector_S_pE2
{   /* Declarations of emon_detector=E_monitor() SETTING parameters. */
char* filename = mccemon_detector_filename;
MCNUM xmin = mccemon_detector_xmin;
MCNUM xmax = mccemon_detector_xmax;
MCNUM ymin = mccemon_detector_ymin;
MCNUM ymax = mccemon_detector_ymax;
MCNUM xwidth = mccemon_detector_xwidth;
MCNUM yheight = mccemon_detector_yheight;
MCNUM Emin = mccemon_detector_Emin;
MCNUM Emax = mccemon_detector_Emax;
MCNUM restore_neutron = mccemon_detector_restore_neutron;
int nowritefile = mccemon_detector_nowritefile;
/* 'emon_detector=E_monitor()' component instance has conditional execution */
if (( ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63972 "RITA-II.c"
}   /* End of emon_detector=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_detector:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(134,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window1 [135] */
  mccoordschange(mcposrpsd_window1, mcrotrpsd_window1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window1 (without coords transformations) */
  mcJumpTrace_psd_window1:
  SIG_MESSAGE("psd_window1 (Trace)");
  mcDEBUG_COMP("psd_window1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window1
  STORE_NEUTRON(135,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[135]++;
  mcPCounter[135] += p;
  mcP2Counter[135] += p*p;
#define mccompcurname  psd_window1
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 135
#define nx mccpsd_window1_nx
#define ny mccpsd_window1_ny
#define filename mccpsd_window1_filename
#define PSD_N mccpsd_window1_PSD_N
#define PSD_p mccpsd_window1_PSD_p
#define PSD_p2 mccpsd_window1_PSD_p2
#define weight mccpsd_window1_weight
{   /* Declarations of psd_window1=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window1_xmin;
MCNUM xmax = mccpsd_window1_xmax;
MCNUM ymin = mccpsd_window1_ymin;
MCNUM ymax = mccpsd_window1_ymax;
MCNUM xwidth = mccpsd_window1_xwidth;
MCNUM yheight = mccpsd_window1_yheight;
MCNUM psf = mccpsd_window1_psf;
MCNUM k0 = mccpsd_window1_k0;
MCNUM eff = mccpsd_window1_eff;
MCNUM restore_neutron = mccpsd_window1_restore_neutron;
int nowritefile = mccpsd_window1_nowritefile;
/* 'psd_window1=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 1 ] && BinX <= XwinMax [ 1 ] && BinY >= YwinMin [ 1 ] && BinY <= YwinMax [ 1 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64129 "RITA-II.c"
}   /* End of psd_window1=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(135,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window1 [136] */
  mccoordschange(mcposremon_window1, mcrotremon_window1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window1 (without coords transformations) */
  mcJumpTrace_emon_window1:
  SIG_MESSAGE("emon_window1 (Trace)");
  mcDEBUG_COMP("emon_window1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window1
  STORE_NEUTRON(136,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[136]++;
  mcPCounter[136] += p;
  mcP2Counter[136] += p*p;
#define mccompcurname  emon_window1
#define mccompcurtype  E_monitor
#define mccompcurindex 136
#define nE mccemon_window1_nE
#define E_N mccemon_window1_E_N
#define E_p mccemon_window1_E_p
#define E_p2 mccemon_window1_E_p2
#define S_p mccemon_window1_S_p
#define S_pE mccemon_window1_S_pE
#define S_pE2 mccemon_window1_S_pE2
{   /* Declarations of emon_window1=E_monitor() SETTING parameters. */
char* filename = mccemon_window1_filename;
MCNUM xmin = mccemon_window1_xmin;
MCNUM xmax = mccemon_window1_xmax;
MCNUM ymin = mccemon_window1_ymin;
MCNUM ymax = mccemon_window1_ymax;
MCNUM xwidth = mccemon_window1_xwidth;
MCNUM yheight = mccemon_window1_yheight;
MCNUM Emin = mccemon_window1_Emin;
MCNUM Emax = mccemon_window1_Emax;
MCNUM restore_neutron = mccemon_window1_restore_neutron;
int nowritefile = mccemon_window1_nowritefile;
/* 'emon_window1=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 1 ] && BinX <= XwinMax [ 1 ] && BinY >= YwinMin [ 1 ] && BinY <= YwinMax [ 1 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64289 "RITA-II.c"
}   /* End of emon_window1=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(136,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window2 [137] */
  mccoordschange(mcposrpsd_window2, mcrotrpsd_window2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window2 (without coords transformations) */
  mcJumpTrace_psd_window2:
  SIG_MESSAGE("psd_window2 (Trace)");
  mcDEBUG_COMP("psd_window2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window2
  STORE_NEUTRON(137,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[137]++;
  mcPCounter[137] += p;
  mcP2Counter[137] += p*p;
#define mccompcurname  psd_window2
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 137
#define nx mccpsd_window2_nx
#define ny mccpsd_window2_ny
#define filename mccpsd_window2_filename
#define PSD_N mccpsd_window2_PSD_N
#define PSD_p mccpsd_window2_PSD_p
#define PSD_p2 mccpsd_window2_PSD_p2
#define weight mccpsd_window2_weight
{   /* Declarations of psd_window2=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window2_xmin;
MCNUM xmax = mccpsd_window2_xmax;
MCNUM ymin = mccpsd_window2_ymin;
MCNUM ymax = mccpsd_window2_ymax;
MCNUM xwidth = mccpsd_window2_xwidth;
MCNUM yheight = mccpsd_window2_yheight;
MCNUM psf = mccpsd_window2_psf;
MCNUM k0 = mccpsd_window2_k0;
MCNUM eff = mccpsd_window2_eff;
MCNUM restore_neutron = mccpsd_window2_restore_neutron;
int nowritefile = mccpsd_window2_nowritefile;
/* 'psd_window2=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 2 ] && BinX <= XwinMax [ 2 ] && BinY >= YwinMin [ 2 ] && BinY <= YwinMax [ 2 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64446 "RITA-II.c"
}   /* End of psd_window2=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(137,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window2 [138] */
  mccoordschange(mcposremon_window2, mcrotremon_window2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window2 (without coords transformations) */
  mcJumpTrace_emon_window2:
  SIG_MESSAGE("emon_window2 (Trace)");
  mcDEBUG_COMP("emon_window2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window2
  STORE_NEUTRON(138,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[138]++;
  mcPCounter[138] += p;
  mcP2Counter[138] += p*p;
#define mccompcurname  emon_window2
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccemon_window2_nE
#define E_N mccemon_window2_E_N
#define E_p mccemon_window2_E_p
#define E_p2 mccemon_window2_E_p2
#define S_p mccemon_window2_S_p
#define S_pE mccemon_window2_S_pE
#define S_pE2 mccemon_window2_S_pE2
{   /* Declarations of emon_window2=E_monitor() SETTING parameters. */
char* filename = mccemon_window2_filename;
MCNUM xmin = mccemon_window2_xmin;
MCNUM xmax = mccemon_window2_xmax;
MCNUM ymin = mccemon_window2_ymin;
MCNUM ymax = mccemon_window2_ymax;
MCNUM xwidth = mccemon_window2_xwidth;
MCNUM yheight = mccemon_window2_yheight;
MCNUM Emin = mccemon_window2_Emin;
MCNUM Emax = mccemon_window2_Emax;
MCNUM restore_neutron = mccemon_window2_restore_neutron;
int nowritefile = mccemon_window2_nowritefile;
/* 'emon_window2=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 2 ] && BinX <= XwinMax [ 2 ] && BinY >= YwinMin [ 2 ] && BinY <= YwinMax [ 2 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64606 "RITA-II.c"
}   /* End of emon_window2=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(138,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window3 [139] */
  mccoordschange(mcposrpsd_window3, mcrotrpsd_window3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window3 (without coords transformations) */
  mcJumpTrace_psd_window3:
  SIG_MESSAGE("psd_window3 (Trace)");
  mcDEBUG_COMP("psd_window3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window3
  STORE_NEUTRON(139,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[139]++;
  mcPCounter[139] += p;
  mcP2Counter[139] += p*p;
#define mccompcurname  psd_window3
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 139
#define nx mccpsd_window3_nx
#define ny mccpsd_window3_ny
#define filename mccpsd_window3_filename
#define PSD_N mccpsd_window3_PSD_N
#define PSD_p mccpsd_window3_PSD_p
#define PSD_p2 mccpsd_window3_PSD_p2
#define weight mccpsd_window3_weight
{   /* Declarations of psd_window3=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window3_xmin;
MCNUM xmax = mccpsd_window3_xmax;
MCNUM ymin = mccpsd_window3_ymin;
MCNUM ymax = mccpsd_window3_ymax;
MCNUM xwidth = mccpsd_window3_xwidth;
MCNUM yheight = mccpsd_window3_yheight;
MCNUM psf = mccpsd_window3_psf;
MCNUM k0 = mccpsd_window3_k0;
MCNUM eff = mccpsd_window3_eff;
MCNUM restore_neutron = mccpsd_window3_restore_neutron;
int nowritefile = mccpsd_window3_nowritefile;
/* 'psd_window3=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 3 ] && BinX <= XwinMax [ 3 ] && BinY >= YwinMin [ 3 ] && BinY <= YwinMax [ 3 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64763 "RITA-II.c"
}   /* End of psd_window3=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(139,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window3 [140] */
  mccoordschange(mcposremon_window3, mcrotremon_window3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window3 (without coords transformations) */
  mcJumpTrace_emon_window3:
  SIG_MESSAGE("emon_window3 (Trace)");
  mcDEBUG_COMP("emon_window3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window3
  STORE_NEUTRON(140,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[140]++;
  mcPCounter[140] += p;
  mcP2Counter[140] += p*p;
#define mccompcurname  emon_window3
#define mccompcurtype  E_monitor
#define mccompcurindex 140
#define nE mccemon_window3_nE
#define E_N mccemon_window3_E_N
#define E_p mccemon_window3_E_p
#define E_p2 mccemon_window3_E_p2
#define S_p mccemon_window3_S_p
#define S_pE mccemon_window3_S_pE
#define S_pE2 mccemon_window3_S_pE2
{   /* Declarations of emon_window3=E_monitor() SETTING parameters. */
char* filename = mccemon_window3_filename;
MCNUM xmin = mccemon_window3_xmin;
MCNUM xmax = mccemon_window3_xmax;
MCNUM ymin = mccemon_window3_ymin;
MCNUM ymax = mccemon_window3_ymax;
MCNUM xwidth = mccemon_window3_xwidth;
MCNUM yheight = mccemon_window3_yheight;
MCNUM Emin = mccemon_window3_Emin;
MCNUM Emax = mccemon_window3_Emax;
MCNUM restore_neutron = mccemon_window3_restore_neutron;
int nowritefile = mccemon_window3_nowritefile;
/* 'emon_window3=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 3 ] && BinX <= XwinMax [ 3 ] && BinY >= YwinMin [ 3 ] && BinY <= YwinMax [ 3 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64923 "RITA-II.c"
}   /* End of emon_window3=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(140,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window4 [141] */
  mccoordschange(mcposrpsd_window4, mcrotrpsd_window4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window4 (without coords transformations) */
  mcJumpTrace_psd_window4:
  SIG_MESSAGE("psd_window4 (Trace)");
  mcDEBUG_COMP("psd_window4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window4
  STORE_NEUTRON(141,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[141]++;
  mcPCounter[141] += p;
  mcP2Counter[141] += p*p;
#define mccompcurname  psd_window4
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 141
#define nx mccpsd_window4_nx
#define ny mccpsd_window4_ny
#define filename mccpsd_window4_filename
#define PSD_N mccpsd_window4_PSD_N
#define PSD_p mccpsd_window4_PSD_p
#define PSD_p2 mccpsd_window4_PSD_p2
#define weight mccpsd_window4_weight
{   /* Declarations of psd_window4=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window4_xmin;
MCNUM xmax = mccpsd_window4_xmax;
MCNUM ymin = mccpsd_window4_ymin;
MCNUM ymax = mccpsd_window4_ymax;
MCNUM xwidth = mccpsd_window4_xwidth;
MCNUM yheight = mccpsd_window4_yheight;
MCNUM psf = mccpsd_window4_psf;
MCNUM k0 = mccpsd_window4_k0;
MCNUM eff = mccpsd_window4_eff;
MCNUM restore_neutron = mccpsd_window4_restore_neutron;
int nowritefile = mccpsd_window4_nowritefile;
/* 'psd_window4=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 4 ] && BinX <= XwinMax [ 4 ] && BinY >= YwinMin [ 4 ] && BinY <= YwinMax [ 4 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65080 "RITA-II.c"
}   /* End of psd_window4=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(141,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window4 [142] */
  mccoordschange(mcposremon_window4, mcrotremon_window4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window4 (without coords transformations) */
  mcJumpTrace_emon_window4:
  SIG_MESSAGE("emon_window4 (Trace)");
  mcDEBUG_COMP("emon_window4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window4
  STORE_NEUTRON(142,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[142]++;
  mcPCounter[142] += p;
  mcP2Counter[142] += p*p;
#define mccompcurname  emon_window4
#define mccompcurtype  E_monitor
#define mccompcurindex 142
#define nE mccemon_window4_nE
#define E_N mccemon_window4_E_N
#define E_p mccemon_window4_E_p
#define E_p2 mccemon_window4_E_p2
#define S_p mccemon_window4_S_p
#define S_pE mccemon_window4_S_pE
#define S_pE2 mccemon_window4_S_pE2
{   /* Declarations of emon_window4=E_monitor() SETTING parameters. */
char* filename = mccemon_window4_filename;
MCNUM xmin = mccemon_window4_xmin;
MCNUM xmax = mccemon_window4_xmax;
MCNUM ymin = mccemon_window4_ymin;
MCNUM ymax = mccemon_window4_ymax;
MCNUM xwidth = mccemon_window4_xwidth;
MCNUM yheight = mccemon_window4_yheight;
MCNUM Emin = mccemon_window4_Emin;
MCNUM Emax = mccemon_window4_Emax;
MCNUM restore_neutron = mccemon_window4_restore_neutron;
int nowritefile = mccemon_window4_nowritefile;
/* 'emon_window4=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 4 ] && BinX <= XwinMax [ 4 ] && BinY >= YwinMin [ 4 ] && BinY <= YwinMax [ 4 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65240 "RITA-II.c"
}   /* End of emon_window4=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(142,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window5 [143] */
  mccoordschange(mcposrpsd_window5, mcrotrpsd_window5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window5 (without coords transformations) */
  mcJumpTrace_psd_window5:
  SIG_MESSAGE("psd_window5 (Trace)");
  mcDEBUG_COMP("psd_window5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window5
  STORE_NEUTRON(143,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[143]++;
  mcPCounter[143] += p;
  mcP2Counter[143] += p*p;
#define mccompcurname  psd_window5
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 143
#define nx mccpsd_window5_nx
#define ny mccpsd_window5_ny
#define filename mccpsd_window5_filename
#define PSD_N mccpsd_window5_PSD_N
#define PSD_p mccpsd_window5_PSD_p
#define PSD_p2 mccpsd_window5_PSD_p2
#define weight mccpsd_window5_weight
{   /* Declarations of psd_window5=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window5_xmin;
MCNUM xmax = mccpsd_window5_xmax;
MCNUM ymin = mccpsd_window5_ymin;
MCNUM ymax = mccpsd_window5_ymax;
MCNUM xwidth = mccpsd_window5_xwidth;
MCNUM yheight = mccpsd_window5_yheight;
MCNUM psf = mccpsd_window5_psf;
MCNUM k0 = mccpsd_window5_k0;
MCNUM eff = mccpsd_window5_eff;
MCNUM restore_neutron = mccpsd_window5_restore_neutron;
int nowritefile = mccpsd_window5_nowritefile;
/* 'psd_window5=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 5 ] && BinX <= XwinMax [ 5 ] && BinY >= YwinMin [ 5 ] && BinY <= YwinMax [ 5 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65397 "RITA-II.c"
}   /* End of psd_window5=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(143,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window5 [144] */
  mccoordschange(mcposremon_window5, mcrotremon_window5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window5 (without coords transformations) */
  mcJumpTrace_emon_window5:
  SIG_MESSAGE("emon_window5 (Trace)");
  mcDEBUG_COMP("emon_window5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window5
  STORE_NEUTRON(144,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[144]++;
  mcPCounter[144] += p;
  mcP2Counter[144] += p*p;
#define mccompcurname  emon_window5
#define mccompcurtype  E_monitor
#define mccompcurindex 144
#define nE mccemon_window5_nE
#define E_N mccemon_window5_E_N
#define E_p mccemon_window5_E_p
#define E_p2 mccemon_window5_E_p2
#define S_p mccemon_window5_S_p
#define S_pE mccemon_window5_S_pE
#define S_pE2 mccemon_window5_S_pE2
{   /* Declarations of emon_window5=E_monitor() SETTING parameters. */
char* filename = mccemon_window5_filename;
MCNUM xmin = mccemon_window5_xmin;
MCNUM xmax = mccemon_window5_xmax;
MCNUM ymin = mccemon_window5_ymin;
MCNUM ymax = mccemon_window5_ymax;
MCNUM xwidth = mccemon_window5_xwidth;
MCNUM yheight = mccemon_window5_yheight;
MCNUM Emin = mccemon_window5_Emin;
MCNUM Emax = mccemon_window5_Emax;
MCNUM restore_neutron = mccemon_window5_restore_neutron;
int nowritefile = mccemon_window5_nowritefile;
/* 'emon_window5=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 5 ] && BinX <= XwinMax [ 5 ] && BinY >= YwinMin [ 5 ] && BinY <= YwinMax [ 5 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65557 "RITA-II.c"
}   /* End of emon_window5=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(144,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window6 [145] */
  mccoordschange(mcposrpsd_window6, mcrotrpsd_window6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window6 (without coords transformations) */
  mcJumpTrace_psd_window6:
  SIG_MESSAGE("psd_window6 (Trace)");
  mcDEBUG_COMP("psd_window6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window6
  STORE_NEUTRON(145,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[145]++;
  mcPCounter[145] += p;
  mcP2Counter[145] += p*p;
#define mccompcurname  psd_window6
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 145
#define nx mccpsd_window6_nx
#define ny mccpsd_window6_ny
#define filename mccpsd_window6_filename
#define PSD_N mccpsd_window6_PSD_N
#define PSD_p mccpsd_window6_PSD_p
#define PSD_p2 mccpsd_window6_PSD_p2
#define weight mccpsd_window6_weight
{   /* Declarations of psd_window6=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window6_xmin;
MCNUM xmax = mccpsd_window6_xmax;
MCNUM ymin = mccpsd_window6_ymin;
MCNUM ymax = mccpsd_window6_ymax;
MCNUM xwidth = mccpsd_window6_xwidth;
MCNUM yheight = mccpsd_window6_yheight;
MCNUM psf = mccpsd_window6_psf;
MCNUM k0 = mccpsd_window6_k0;
MCNUM eff = mccpsd_window6_eff;
MCNUM restore_neutron = mccpsd_window6_restore_neutron;
int nowritefile = mccpsd_window6_nowritefile;
/* 'psd_window6=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 6 ] && BinX <= XwinMax [ 6 ] && BinY >= YwinMin [ 6 ] && BinY <= YwinMax [ 6 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65714 "RITA-II.c"
}   /* End of psd_window6=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(145,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window6 [146] */
  mccoordschange(mcposremon_window6, mcrotremon_window6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window6 (without coords transformations) */
  mcJumpTrace_emon_window6:
  SIG_MESSAGE("emon_window6 (Trace)");
  mcDEBUG_COMP("emon_window6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window6
  STORE_NEUTRON(146,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[146]++;
  mcPCounter[146] += p;
  mcP2Counter[146] += p*p;
#define mccompcurname  emon_window6
#define mccompcurtype  E_monitor
#define mccompcurindex 146
#define nE mccemon_window6_nE
#define E_N mccemon_window6_E_N
#define E_p mccemon_window6_E_p
#define E_p2 mccemon_window6_E_p2
#define S_p mccemon_window6_S_p
#define S_pE mccemon_window6_S_pE
#define S_pE2 mccemon_window6_S_pE2
{   /* Declarations of emon_window6=E_monitor() SETTING parameters. */
char* filename = mccemon_window6_filename;
MCNUM xmin = mccemon_window6_xmin;
MCNUM xmax = mccemon_window6_xmax;
MCNUM ymin = mccemon_window6_ymin;
MCNUM ymax = mccemon_window6_ymax;
MCNUM xwidth = mccemon_window6_xwidth;
MCNUM yheight = mccemon_window6_yheight;
MCNUM Emin = mccemon_window6_Emin;
MCNUM Emax = mccemon_window6_Emax;
MCNUM restore_neutron = mccemon_window6_restore_neutron;
int nowritefile = mccemon_window6_nowritefile;
/* 'emon_window6=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 6 ] && BinX <= XwinMax [ 6 ] && BinY >= YwinMin [ 6 ] && BinY <= YwinMax [ 6 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65874 "RITA-II.c"
}   /* End of emon_window6=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(146,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window7 [147] */
  mccoordschange(mcposrpsd_window7, mcrotrpsd_window7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window7 (without coords transformations) */
  mcJumpTrace_psd_window7:
  SIG_MESSAGE("psd_window7 (Trace)");
  mcDEBUG_COMP("psd_window7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window7
  STORE_NEUTRON(147,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[147]++;
  mcPCounter[147] += p;
  mcP2Counter[147] += p*p;
#define mccompcurname  psd_window7
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 147
#define nx mccpsd_window7_nx
#define ny mccpsd_window7_ny
#define filename mccpsd_window7_filename
#define PSD_N mccpsd_window7_PSD_N
#define PSD_p mccpsd_window7_PSD_p
#define PSD_p2 mccpsd_window7_PSD_p2
#define weight mccpsd_window7_weight
{   /* Declarations of psd_window7=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window7_xmin;
MCNUM xmax = mccpsd_window7_xmax;
MCNUM ymin = mccpsd_window7_ymin;
MCNUM ymax = mccpsd_window7_ymax;
MCNUM xwidth = mccpsd_window7_xwidth;
MCNUM yheight = mccpsd_window7_yheight;
MCNUM psf = mccpsd_window7_psf;
MCNUM k0 = mccpsd_window7_k0;
MCNUM eff = mccpsd_window7_eff;
MCNUM restore_neutron = mccpsd_window7_restore_neutron;
int nowritefile = mccpsd_window7_nowritefile;
/* 'psd_window7=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 7 ] && BinX <= XwinMax [ 7 ] && BinY >= YwinMin [ 7 ] && BinY <= YwinMax [ 7 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66031 "RITA-II.c"
}   /* End of psd_window7=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(147,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window7 [148] */
  mccoordschange(mcposremon_window7, mcrotremon_window7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window7 (without coords transformations) */
  mcJumpTrace_emon_window7:
  SIG_MESSAGE("emon_window7 (Trace)");
  mcDEBUG_COMP("emon_window7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window7
  STORE_NEUTRON(148,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[148]++;
  mcPCounter[148] += p;
  mcP2Counter[148] += p*p;
#define mccompcurname  emon_window7
#define mccompcurtype  E_monitor
#define mccompcurindex 148
#define nE mccemon_window7_nE
#define E_N mccemon_window7_E_N
#define E_p mccemon_window7_E_p
#define E_p2 mccemon_window7_E_p2
#define S_p mccemon_window7_S_p
#define S_pE mccemon_window7_S_pE
#define S_pE2 mccemon_window7_S_pE2
{   /* Declarations of emon_window7=E_monitor() SETTING parameters. */
char* filename = mccemon_window7_filename;
MCNUM xmin = mccemon_window7_xmin;
MCNUM xmax = mccemon_window7_xmax;
MCNUM ymin = mccemon_window7_ymin;
MCNUM ymax = mccemon_window7_ymax;
MCNUM xwidth = mccemon_window7_xwidth;
MCNUM yheight = mccemon_window7_yheight;
MCNUM Emin = mccemon_window7_Emin;
MCNUM Emax = mccemon_window7_Emax;
MCNUM restore_neutron = mccemon_window7_restore_neutron;
int nowritefile = mccemon_window7_nowritefile;
/* 'emon_window7=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 7 ] && BinX <= XwinMax [ 7 ] && BinY >= YwinMin [ 7 ] && BinY <= YwinMax [ 7 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66191 "RITA-II.c"
}   /* End of emon_window7=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(148,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window8 [149] */
  mccoordschange(mcposrpsd_window8, mcrotrpsd_window8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window8 (without coords transformations) */
  mcJumpTrace_psd_window8:
  SIG_MESSAGE("psd_window8 (Trace)");
  mcDEBUG_COMP("psd_window8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window8
  STORE_NEUTRON(149,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[149]++;
  mcPCounter[149] += p;
  mcP2Counter[149] += p*p;
#define mccompcurname  psd_window8
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 149
#define nx mccpsd_window8_nx
#define ny mccpsd_window8_ny
#define filename mccpsd_window8_filename
#define PSD_N mccpsd_window8_PSD_N
#define PSD_p mccpsd_window8_PSD_p
#define PSD_p2 mccpsd_window8_PSD_p2
#define weight mccpsd_window8_weight
{   /* Declarations of psd_window8=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window8_xmin;
MCNUM xmax = mccpsd_window8_xmax;
MCNUM ymin = mccpsd_window8_ymin;
MCNUM ymax = mccpsd_window8_ymax;
MCNUM xwidth = mccpsd_window8_xwidth;
MCNUM yheight = mccpsd_window8_yheight;
MCNUM psf = mccpsd_window8_psf;
MCNUM k0 = mccpsd_window8_k0;
MCNUM eff = mccpsd_window8_eff;
MCNUM restore_neutron = mccpsd_window8_restore_neutron;
int nowritefile = mccpsd_window8_nowritefile;
/* 'psd_window8=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 8 ] && BinX <= XwinMax [ 8 ] && BinY >= YwinMin [ 8 ] && BinY <= YwinMax [ 8 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66348 "RITA-II.c"
}   /* End of psd_window8=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window8:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(149,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window8 [150] */
  mccoordschange(mcposremon_window8, mcrotremon_window8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window8 (without coords transformations) */
  mcJumpTrace_emon_window8:
  SIG_MESSAGE("emon_window8 (Trace)");
  mcDEBUG_COMP("emon_window8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window8
  STORE_NEUTRON(150,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[150]++;
  mcPCounter[150] += p;
  mcP2Counter[150] += p*p;
#define mccompcurname  emon_window8
#define mccompcurtype  E_monitor
#define mccompcurindex 150
#define nE mccemon_window8_nE
#define E_N mccemon_window8_E_N
#define E_p mccemon_window8_E_p
#define E_p2 mccemon_window8_E_p2
#define S_p mccemon_window8_S_p
#define S_pE mccemon_window8_S_pE
#define S_pE2 mccemon_window8_S_pE2
{   /* Declarations of emon_window8=E_monitor() SETTING parameters. */
char* filename = mccemon_window8_filename;
MCNUM xmin = mccemon_window8_xmin;
MCNUM xmax = mccemon_window8_xmax;
MCNUM ymin = mccemon_window8_ymin;
MCNUM ymax = mccemon_window8_ymax;
MCNUM xwidth = mccemon_window8_xwidth;
MCNUM yheight = mccemon_window8_yheight;
MCNUM Emin = mccemon_window8_Emin;
MCNUM Emax = mccemon_window8_Emax;
MCNUM restore_neutron = mccemon_window8_restore_neutron;
int nowritefile = mccemon_window8_nowritefile;
/* 'emon_window8=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 8 ] && BinX <= XwinMax [ 8 ] && BinY >= YwinMin [ 8 ] && BinY <= YwinMax [ 8 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66508 "RITA-II.c"
}   /* End of emon_window8=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window8:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(150,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_window9 [151] */
  mccoordschange(mcposrpsd_window9, mcrotrpsd_window9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_window9 (without coords transformations) */
  mcJumpTrace_psd_window9:
  SIG_MESSAGE("psd_window9 (Trace)");
  mcDEBUG_COMP("psd_window9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_window9
  STORE_NEUTRON(151,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[151]++;
  mcPCounter[151] += p;
  mcP2Counter[151] += p*p;
#define mccompcurname  psd_window9
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 151
#define nx mccpsd_window9_nx
#define ny mccpsd_window9_ny
#define filename mccpsd_window9_filename
#define PSD_N mccpsd_window9_PSD_N
#define PSD_p mccpsd_window9_PSD_p
#define PSD_p2 mccpsd_window9_PSD_p2
#define weight mccpsd_window9_weight
{   /* Declarations of psd_window9=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window9_xmin;
MCNUM xmax = mccpsd_window9_xmax;
MCNUM ymin = mccpsd_window9_ymin;
MCNUM ymax = mccpsd_window9_ymax;
MCNUM xwidth = mccpsd_window9_xwidth;
MCNUM yheight = mccpsd_window9_yheight;
MCNUM psf = mccpsd_window9_psf;
MCNUM k0 = mccpsd_window9_k0;
MCNUM eff = mccpsd_window9_eff;
MCNUM restore_neutron = mccpsd_window9_restore_neutron;
int nowritefile = mccpsd_window9_nowritefile;
/* 'psd_window9=PSD_monitor_psf_eff()' component instance has conditional execution */
if (( BinX >= XwinMin [ 9 ] && BinX <= XwinMax [ 9 ] && BinY >= YwinMin [ 9 ] && BinY <= YwinMax [ 9 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    int i,j;
    double xp,yp;

    PROP_Z0;

    xp = x + psf*randnorm();
    yp = y + psf*randnorm();

    if (xp>xmin && xp<xmax && yp>ymin && yp<ymax)
    {
      weight = eff * k0 / (V2K*sqrt(vx*vx + vy*vy + vz*vz));
      i = floor((xp - xmin)*nx/(xmax - xmin));
      j = floor((yp - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p*weight;
      PSD_p2[i][j] += p*p*weight*weight;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66665 "RITA-II.c"
}   /* End of psd_window9=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_window9:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(151,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component emon_window9 [152] */
  mccoordschange(mcposremon_window9, mcrotremon_window9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component emon_window9 (without coords transformations) */
  mcJumpTrace_emon_window9:
  SIG_MESSAGE("emon_window9 (Trace)");
  mcDEBUG_COMP("emon_window9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompemon_window9
  STORE_NEUTRON(152,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[152]++;
  mcPCounter[152] += p;
  mcP2Counter[152] += p*p;
#define mccompcurname  emon_window9
#define mccompcurtype  E_monitor
#define mccompcurindex 152
#define nE mccemon_window9_nE
#define E_N mccemon_window9_E_N
#define E_p mccemon_window9_E_p
#define E_p2 mccemon_window9_E_p2
#define S_p mccemon_window9_S_p
#define S_pE mccemon_window9_S_pE
#define S_pE2 mccemon_window9_S_pE2
{   /* Declarations of emon_window9=E_monitor() SETTING parameters. */
char* filename = mccemon_window9_filename;
MCNUM xmin = mccemon_window9_xmin;
MCNUM xmax = mccemon_window9_xmax;
MCNUM ymin = mccemon_window9_ymin;
MCNUM ymax = mccemon_window9_ymax;
MCNUM xwidth = mccemon_window9_xwidth;
MCNUM yheight = mccemon_window9_yheight;
MCNUM Emin = mccemon_window9_Emin;
MCNUM Emax = mccemon_window9_Emax;
MCNUM restore_neutron = mccemon_window9_restore_neutron;
int nowritefile = mccemon_window9_nowritefile;
/* 'emon_window9=E_monitor()' component instance has conditional execution */
if (( BinX >= XwinMin [ 9 ] && BinX <= XwinMax [ 9 ] && BinY >= YwinMin [ 9 ] && BinY <= YwinMax [ 9 ] && ! mcipVIRTUALOUT ))

#line 89 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66825 "RITA-II.c"
}   /* End of emon_window9=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompemon_window9:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(152,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  mcabsorbAll:
  /* SPLIT loops in reverse order */
  if (mcSplit_focus_ana && mcSplit_focus_ana < (SPLITAREP)) {
    goto mcJumpTrace_focus_ana;
  }
    else mcSplit_focus_ana=0;
  if (mcSplit_a3 && mcSplit_a3 < (SPLITREP)) {
    goto mcJumpTrace_a3;
  }
    else mcSplit_a3=0;
  if (mcSplit_monochromator_curved && mcSplit_monochromator_curved < (SPLITMREP)) {
    goto mcJumpTrace_monochromator_curved;
  }
    else mcSplit_monochromator_curved=0;

  mcDEBUG_LEAVE()
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)
  /* Copy neutron state to global variables. */
  mcnx = mcnlx;
  mcny = mcnly;
  mcnz = mcnlz;
  mcnvx = mcnlvx;
  mcnvy = mcnlvy;
  mcnvz = mcnlvz;
  mcnt = mcnlt;
  mcnsx = mcnlsx;
  mcnsy = mcnlsy;
  mcnsz = mcnlsz;
  mcnp = mcnlp;

} /* end trace */

void mcsave(FILE *handle) {
  if (!handle) mcsiminfo_init(NULL);
  /* User component SAVE code. */

  /* User SAVE code for component 'armSource'. */
  SIG_MESSAGE("armSource (Save)");
#define mccompcurname  armSource
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccarmSource_IntermediateCnts
#define StartTime mccarmSource_StartTime
#define EndTime mccarmSource_EndTime
#define CurrentTime mccarmSource_CurrentTime
{   /* Declarations of armSource=Progress_bar() SETTING parameters. */
char* profile = mccarmSource_profile;
MCNUM percent = mccarmSource_percent;
MCNUM flag_save = mccarmSource_flag_save;
MCNUM minutes = mccarmSource_minutes;
#line 115 "/usr/share/mcstas/2.5/misc/Progress_bar.comp"
{
  MPI_MASTER(fprintf(stdout, "\nSave [%s]\n", mcinstrument_name););
  if (profile && strlen(profile) && strcmp(profile,"NULL") && strcmp(profile,"0")) {
    char filename[256];
    if (!strlen(profile) || !strcmp(profile,"NULL") || !strcmp(profile,"0")) strcpy(filename, mcinstrument_name);
    else strcpy(filename, profile);
    DETECTOR_OUT_1D(
        "Intensity profiler",
        "Component index [1]",
        "Intensity",
        "prof", 1, mcNUMCOMP, mcNUMCOMP-1,
        &mcNCounter[1],&mcPCounter[1],&mcP2Counter[1],
        filename);

  }
}
#line 66942 "RITA-II.c"
}   /* End of armSource=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'lmon_guide_start'. */
  SIG_MESSAGE("lmon_guide_start (Save)");
#define mccompcurname  lmon_guide_start
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mcclmon_guide_start_nL
#define L_N mcclmon_guide_start_L_N
#define L_p mcclmon_guide_start_L_p
#define L_p2 mcclmon_guide_start_L_p2
{   /* Declarations of lmon_guide_start=L_monitor() SETTING parameters. */
char* filename = mcclmon_guide_start_filename;
MCNUM xmin = mcclmon_guide_start_xmin;
MCNUM xmax = mcclmon_guide_start_xmax;
MCNUM ymin = mcclmon_guide_start_ymin;
MCNUM ymax = mcclmon_guide_start_ymax;
MCNUM xwidth = mcclmon_guide_start_xwidth;
MCNUM yheight = mcclmon_guide_start_yheight;
MCNUM Lmin = mcclmon_guide_start_Lmin;
MCNUM Lmax = mcclmon_guide_start_Lmax;
MCNUM restore_neutron = mcclmon_guide_start_restore_neutron;
int nowritefile = mcclmon_guide_start_nowritefile;
#line 107 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 66985 "RITA-II.c"
}   /* End of lmon_guide_start=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_guide_end'. */
  SIG_MESSAGE("psd_guide_end (Save)");
#define mccompcurname  psd_guide_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccpsd_guide_end_nx
#define ny mccpsd_guide_end_ny
#define PSD_N mccpsd_guide_end_PSD_N
#define PSD_p mccpsd_guide_end_PSD_p
#define PSD_p2 mccpsd_guide_end_PSD_p2
{   /* Declarations of psd_guide_end=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_guide_end_filename;
MCNUM xmin = mccpsd_guide_end_xmin;
MCNUM xmax = mccpsd_guide_end_xmax;
MCNUM ymin = mccpsd_guide_end_ymin;
MCNUM ymax = mccpsd_guide_end_ymax;
MCNUM xwidth = mccpsd_guide_end_xwidth;
MCNUM yheight = mccpsd_guide_end_yheight;
MCNUM restore_neutron = mccpsd_guide_end_restore_neutron;
int nowritefile = mccpsd_guide_end_nowritefile;
#line 101 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67028 "RITA-II.c"
}   /* End of psd_guide_end=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_guide_end'. */
  SIG_MESSAGE("emon_guide_end (Save)");
#define mccompcurname  emon_guide_end
#define mccompcurtype  E_monitor
#define mccompcurindex 50
#define nE mccemon_guide_end_nE
#define E_N mccemon_guide_end_E_N
#define E_p mccemon_guide_end_E_p
#define E_p2 mccemon_guide_end_E_p2
#define S_p mccemon_guide_end_S_p
#define S_pE mccemon_guide_end_S_pE
#define S_pE2 mccemon_guide_end_S_pE2
{   /* Declarations of emon_guide_end=E_monitor() SETTING parameters. */
char* filename = mccemon_guide_end_filename;
MCNUM xmin = mccemon_guide_end_xmin;
MCNUM xmax = mccemon_guide_end_xmax;
MCNUM ymin = mccemon_guide_end_ymin;
MCNUM ymax = mccemon_guide_end_ymax;
MCNUM xwidth = mccemon_guide_end_xwidth;
MCNUM yheight = mccemon_guide_end_yheight;
MCNUM Emin = mccemon_guide_end_Emin;
MCNUM Emax = mccemon_guide_end_Emax;
MCNUM restore_neutron = mccemon_guide_end_restore_neutron;
int nowritefile = mccemon_guide_end_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 67077 "RITA-II.c"
}   /* End of emon_guide_end=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'lmon_guide_end'. */
  SIG_MESSAGE("lmon_guide_end (Save)");
#define mccompcurname  lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mcclmon_guide_end_nL
#define L_N mcclmon_guide_end_L_N
#define L_p mcclmon_guide_end_L_p
#define L_p2 mcclmon_guide_end_L_p2
{   /* Declarations of lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mcclmon_guide_end_filename;
MCNUM xmin = mcclmon_guide_end_xmin;
MCNUM xmax = mcclmon_guide_end_xmax;
MCNUM ymin = mcclmon_guide_end_ymin;
MCNUM ymax = mcclmon_guide_end_ymax;
MCNUM xwidth = mcclmon_guide_end_xwidth;
MCNUM yheight = mcclmon_guide_end_yheight;
MCNUM Lmin = mcclmon_guide_end_Lmin;
MCNUM Lmax = mcclmon_guide_end_Lmax;
MCNUM restore_neutron = mcclmon_guide_end_restore_neutron;
int nowritefile = mcclmon_guide_end_nowritefile;
#line 107 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 67123 "RITA-II.c"
}   /* End of lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'divmon_guide_end'. */
  SIG_MESSAGE("divmon_guide_end (Save)");
#define mccompcurname  divmon_guide_end
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 52
#define nh mccdivmon_guide_end_nh
#define nv mccdivmon_guide_end_nv
#define Div_N mccdivmon_guide_end_Div_N
#define Div_p mccdivmon_guide_end_Div_p
#define Div_p2 mccdivmon_guide_end_Div_p2
{   /* Declarations of divmon_guide_end=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_guide_end_filename;
MCNUM xmin = mccdivmon_guide_end_xmin;
MCNUM xmax = mccdivmon_guide_end_xmax;
MCNUM ymin = mccdivmon_guide_end_ymin;
MCNUM ymax = mccdivmon_guide_end_ymax;
MCNUM xwidth = mccdivmon_guide_end_xwidth;
MCNUM yheight = mccdivmon_guide_end_yheight;
MCNUM maxdiv_h = mccdivmon_guide_end_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_guide_end_maxdiv_v;
MCNUM restore_neutron = mccdivmon_guide_end_restore_neutron;
MCNUM nx = mccdivmon_guide_end_nx;
MCNUM ny = mccdivmon_guide_end_ny;
MCNUM nz = mccdivmon_guide_end_nz;
int nowritefile = mccdivmon_guide_end_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_2D(
        "Divergence monitor",
        "X divergence [deg]",
        "Y divergence [deg]",
        -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
        nh, nv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
    }
}
#line 67171 "RITA-II.c"
}   /* End of divmon_guide_end=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_virt'. */
  SIG_MESSAGE("psd_virt (Save)");
#define mccompcurname  psd_virt
#define mccompcurtype  PSD_monitor
#define mccompcurindex 59
#define nx mccpsd_virt_nx
#define ny mccpsd_virt_ny
#define PSD_N mccpsd_virt_PSD_N
#define PSD_p mccpsd_virt_PSD_p
#define PSD_p2 mccpsd_virt_PSD_p2
{   /* Declarations of psd_virt=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_virt_filename;
MCNUM xmin = mccpsd_virt_xmin;
MCNUM xmax = mccpsd_virt_xmax;
MCNUM ymin = mccpsd_virt_ymin;
MCNUM ymax = mccpsd_virt_ymax;
MCNUM xwidth = mccpsd_virt_xwidth;
MCNUM yheight = mccpsd_virt_yheight;
MCNUM restore_neutron = mccpsd_virt_restore_neutron;
int nowritefile = mccpsd_virt_nowritefile;
#line 101 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67215 "RITA-II.c"
}   /* End of psd_virt=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'lmon_virt'. */
  SIG_MESSAGE("lmon_virt (Save)");
#define mccompcurname  lmon_virt
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mcclmon_virt_nL
#define L_N mcclmon_virt_L_N
#define L_p mcclmon_virt_L_p
#define L_p2 mcclmon_virt_L_p2
{   /* Declarations of lmon_virt=L_monitor() SETTING parameters. */
char* filename = mcclmon_virt_filename;
MCNUM xmin = mcclmon_virt_xmin;
MCNUM xmax = mcclmon_virt_xmax;
MCNUM ymin = mcclmon_virt_ymin;
MCNUM ymax = mcclmon_virt_ymax;
MCNUM xwidth = mcclmon_virt_xwidth;
MCNUM yheight = mcclmon_virt_yheight;
MCNUM Lmin = mcclmon_virt_Lmin;
MCNUM Lmax = mcclmon_virt_Lmax;
MCNUM restore_neutron = mcclmon_virt_restore_neutron;
int nowritefile = mcclmon_virt_nowritefile;
#line 107 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 67259 "RITA-II.c"
}   /* End of lmon_virt=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'virtualout'. */
  SIG_MESSAGE("virtualout (Save)");
#define mccompcurname  virtualout
#define mccompcurtype  Virtual_output
#define mccompcurindex 62
#define DEFS mccvirtualout_DEFS
#define Vars mccvirtualout_Vars
{   /* Declarations of virtualout=Virtual_output() SETTING parameters. */
char* filename = mccvirtualout_filename;
MCNUM bufsize = mccvirtualout_bufsize;
#line 139 "/usr/share/mcstas/2.5/sources/Virtual_output.comp"
{

  Monitor_nD_Save(&DEFS, &Vars);

}
#line 67285 "RITA-II.c"
}   /* End of virtualout=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'OrderMon'. */
  SIG_MESSAGE("OrderMon (Save)");
#define mccompcurname  OrderMon
#define mccompcurtype  Monitor_nD
#define mccompcurindex 64
#define user1 mccOrderMon_user1
#define user2 mccOrderMon_user2
#define user3 mccOrderMon_user3
#define DEFS mccOrderMon_DEFS
#define Vars mccOrderMon_Vars
#define detector mccOrderMon_detector
#define offdata mccOrderMon_offdata
{   /* Declarations of OrderMon=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccOrderMon_xwidth;
MCNUM yheight = mccOrderMon_yheight;
MCNUM zdepth = mccOrderMon_zdepth;
MCNUM xmin = mccOrderMon_xmin;
MCNUM xmax = mccOrderMon_xmax;
MCNUM ymin = mccOrderMon_ymin;
MCNUM ymax = mccOrderMon_ymax;
MCNUM zmin = mccOrderMon_zmin;
MCNUM zmax = mccOrderMon_zmax;
MCNUM bins = mccOrderMon_bins;
MCNUM min = mccOrderMon_min;
MCNUM max = mccOrderMon_max;
MCNUM restore_neutron = mccOrderMon_restore_neutron;
MCNUM radius = mccOrderMon_radius;
char* options = mccOrderMon_options;
char* filename = mccOrderMon_filename;
char* geometry = mccOrderMon_geometry;
char* username1 = mccOrderMon_username1;
char* username2 = mccOrderMon_username2;
char* username3 = mccOrderMon_username3;
int nowritefile = mccOrderMon_nowritefile;
#line 480 "/usr/share/mcstas/2.5/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  detector = Monitor_nD_Save(&DEFS, &Vars);
}
#line 67332 "RITA-II.c"
}   /* End of OrderMon=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'kMoni'. */
  SIG_MESSAGE("kMoni (Save)");
#define mccompcurname  kMoni
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 65
#define nx mcckMoni_nx
#define ny mcckMoni_ny
#define filename mcckMoni_filename
#define PSD_N mcckMoni_PSD_N
#define PSD_p mcckMoni_PSD_p
#define PSD_p2 mcckMoni_PSD_p2
#define weight mcckMoni_weight
{   /* Declarations of kMoni=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni_xmin;
MCNUM xmax = mcckMoni_xmax;
MCNUM ymin = mcckMoni_ymin;
MCNUM ymax = mcckMoni_ymax;
MCNUM xwidth = mcckMoni_xwidth;
MCNUM yheight = mcckMoni_yheight;
MCNUM psf = mcckMoni_psf;
MCNUM k0 = mcckMoni_k0;
MCNUM eff = mcckMoni_eff;
MCNUM restore_neutron = mcckMoni_restore_neutron;
int nowritefile = mcckMoni_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67382 "RITA-II.c"
}   /* End of kMoni=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'kMoni1st'. */
  SIG_MESSAGE("kMoni1st (Save)");
#define mccompcurname  kMoni1st
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 66
#define nx mcckMoni1st_nx
#define ny mcckMoni1st_ny
#define filename mcckMoni1st_filename
#define PSD_N mcckMoni1st_PSD_N
#define PSD_p mcckMoni1st_PSD_p
#define PSD_p2 mcckMoni1st_PSD_p2
#define weight mcckMoni1st_weight
{   /* Declarations of kMoni1st=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni1st_xmin;
MCNUM xmax = mcckMoni1st_xmax;
MCNUM ymin = mcckMoni1st_ymin;
MCNUM ymax = mcckMoni1st_ymax;
MCNUM xwidth = mcckMoni1st_xwidth;
MCNUM yheight = mcckMoni1st_yheight;
MCNUM psf = mcckMoni1st_psf;
MCNUM k0 = mcckMoni1st_k0;
MCNUM eff = mcckMoni1st_eff;
MCNUM restore_neutron = mcckMoni1st_restore_neutron;
int nowritefile = mcckMoni1st_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67432 "RITA-II.c"
}   /* End of kMoni1st=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'kMoni2nd'. */
  SIG_MESSAGE("kMoni2nd (Save)");
#define mccompcurname  kMoni2nd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 67
#define nx mcckMoni2nd_nx
#define ny mcckMoni2nd_ny
#define filename mcckMoni2nd_filename
#define PSD_N mcckMoni2nd_PSD_N
#define PSD_p mcckMoni2nd_PSD_p
#define PSD_p2 mcckMoni2nd_PSD_p2
#define weight mcckMoni2nd_weight
{   /* Declarations of kMoni2nd=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni2nd_xmin;
MCNUM xmax = mcckMoni2nd_xmax;
MCNUM ymin = mcckMoni2nd_ymin;
MCNUM ymax = mcckMoni2nd_ymax;
MCNUM xwidth = mcckMoni2nd_xwidth;
MCNUM yheight = mcckMoni2nd_yheight;
MCNUM psf = mcckMoni2nd_psf;
MCNUM k0 = mcckMoni2nd_k0;
MCNUM eff = mcckMoni2nd_eff;
MCNUM restore_neutron = mcckMoni2nd_restore_neutron;
int nowritefile = mcckMoni2nd_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67482 "RITA-II.c"
}   /* End of kMoni2nd=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'kMoni3rd'. */
  SIG_MESSAGE("kMoni3rd (Save)");
#define mccompcurname  kMoni3rd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 68
#define nx mcckMoni3rd_nx
#define ny mcckMoni3rd_ny
#define filename mcckMoni3rd_filename
#define PSD_N mcckMoni3rd_PSD_N
#define PSD_p mcckMoni3rd_PSD_p
#define PSD_p2 mcckMoni3rd_PSD_p2
#define weight mcckMoni3rd_weight
{   /* Declarations of kMoni3rd=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni3rd_xmin;
MCNUM xmax = mcckMoni3rd_xmax;
MCNUM ymin = mcckMoni3rd_ymin;
MCNUM ymax = mcckMoni3rd_ymax;
MCNUM xwidth = mcckMoni3rd_xwidth;
MCNUM yheight = mcckMoni3rd_yheight;
MCNUM psf = mcckMoni3rd_psf;
MCNUM k0 = mcckMoni3rd_k0;
MCNUM eff = mcckMoni3rd_eff;
MCNUM restore_neutron = mcckMoni3rd_restore_neutron;
int nowritefile = mcckMoni3rd_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67532 "RITA-II.c"
}   /* End of kMoni3rd=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_samplepos_1cm2'. */
  SIG_MESSAGE("psd_samplepos_1cm2 (Save)");
#define mccompcurname  psd_samplepos_1cm2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 71
#define nx mccpsd_samplepos_1cm2_nx
#define ny mccpsd_samplepos_1cm2_ny
#define PSD_N mccpsd_samplepos_1cm2_PSD_N
#define PSD_p mccpsd_samplepos_1cm2_PSD_p
#define PSD_p2 mccpsd_samplepos_1cm2_PSD_p2
{   /* Declarations of psd_samplepos_1cm2=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_samplepos_1cm2_filename;
MCNUM xmin = mccpsd_samplepos_1cm2_xmin;
MCNUM xmax = mccpsd_samplepos_1cm2_xmax;
MCNUM ymin = mccpsd_samplepos_1cm2_ymin;
MCNUM ymax = mccpsd_samplepos_1cm2_ymax;
MCNUM xwidth = mccpsd_samplepos_1cm2_xwidth;
MCNUM yheight = mccpsd_samplepos_1cm2_yheight;
MCNUM restore_neutron = mccpsd_samplepos_1cm2_restore_neutron;
int nowritefile = mccpsd_samplepos_1cm2_nowritefile;
#line 101 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67578 "RITA-II.c"
}   /* End of psd_samplepos_1cm2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_samplepos_1cm2'. */
  SIG_MESSAGE("emon_samplepos_1cm2 (Save)");
#define mccompcurname  emon_samplepos_1cm2
#define mccompcurtype  E_monitor
#define mccompcurindex 72
#define nE mccemon_samplepos_1cm2_nE
#define E_N mccemon_samplepos_1cm2_E_N
#define E_p mccemon_samplepos_1cm2_E_p
#define E_p2 mccemon_samplepos_1cm2_E_p2
#define S_p mccemon_samplepos_1cm2_S_p
#define S_pE mccemon_samplepos_1cm2_S_pE
#define S_pE2 mccemon_samplepos_1cm2_S_pE2
{   /* Declarations of emon_samplepos_1cm2=E_monitor() SETTING parameters. */
char* filename = mccemon_samplepos_1cm2_filename;
MCNUM xmin = mccemon_samplepos_1cm2_xmin;
MCNUM xmax = mccemon_samplepos_1cm2_xmax;
MCNUM ymin = mccemon_samplepos_1cm2_ymin;
MCNUM ymax = mccemon_samplepos_1cm2_ymax;
MCNUM xwidth = mccemon_samplepos_1cm2_xwidth;
MCNUM yheight = mccemon_samplepos_1cm2_yheight;
MCNUM Emin = mccemon_samplepos_1cm2_Emin;
MCNUM Emax = mccemon_samplepos_1cm2_Emax;
MCNUM restore_neutron = mccemon_samplepos_1cm2_restore_neutron;
int nowritefile = mccemon_samplepos_1cm2_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 67627 "RITA-II.c"
}   /* End of emon_samplepos_1cm2=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'divmon_samplepos_1cm2'. */
  SIG_MESSAGE("divmon_samplepos_1cm2 (Save)");
#define mccompcurname  divmon_samplepos_1cm2
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 73
#define nh mccdivmon_samplepos_1cm2_nh
#define nv mccdivmon_samplepos_1cm2_nv
#define Div_N mccdivmon_samplepos_1cm2_Div_N
#define Div_p mccdivmon_samplepos_1cm2_Div_p
#define Div_p2 mccdivmon_samplepos_1cm2_Div_p2
{   /* Declarations of divmon_samplepos_1cm2=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_samplepos_1cm2_filename;
MCNUM xmin = mccdivmon_samplepos_1cm2_xmin;
MCNUM xmax = mccdivmon_samplepos_1cm2_xmax;
MCNUM ymin = mccdivmon_samplepos_1cm2_ymin;
MCNUM ymax = mccdivmon_samplepos_1cm2_ymax;
MCNUM xwidth = mccdivmon_samplepos_1cm2_xwidth;
MCNUM yheight = mccdivmon_samplepos_1cm2_yheight;
MCNUM maxdiv_h = mccdivmon_samplepos_1cm2_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_samplepos_1cm2_maxdiv_v;
MCNUM restore_neutron = mccdivmon_samplepos_1cm2_restore_neutron;
MCNUM nx = mccdivmon_samplepos_1cm2_nx;
MCNUM ny = mccdivmon_samplepos_1cm2_ny;
MCNUM nz = mccdivmon_samplepos_1cm2_nz;
int nowritefile = mccdivmon_samplepos_1cm2_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_2D(
        "Divergence monitor",
        "X divergence [deg]",
        "Y divergence [deg]",
        -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
        nh, nv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
    }
}
#line 67678 "RITA-II.c"
}   /* End of divmon_samplepos_1cm2=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_samplepos_large'. */
  SIG_MESSAGE("psd_samplepos_large (Save)");
#define mccompcurname  psd_samplepos_large
#define mccompcurtype  PSD_monitor
#define mccompcurindex 74
#define nx mccpsd_samplepos_large_nx
#define ny mccpsd_samplepos_large_ny
#define PSD_N mccpsd_samplepos_large_PSD_N
#define PSD_p mccpsd_samplepos_large_PSD_p
#define PSD_p2 mccpsd_samplepos_large_PSD_p2
{   /* Declarations of psd_samplepos_large=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_samplepos_large_filename;
MCNUM xmin = mccpsd_samplepos_large_xmin;
MCNUM xmax = mccpsd_samplepos_large_xmax;
MCNUM ymin = mccpsd_samplepos_large_ymin;
MCNUM ymax = mccpsd_samplepos_large_ymax;
MCNUM xwidth = mccpsd_samplepos_large_xwidth;
MCNUM yheight = mccpsd_samplepos_large_yheight;
MCNUM restore_neutron = mccpsd_samplepos_large_restore_neutron;
int nowritefile = mccpsd_samplepos_large_nowritefile;
#line 101 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67722 "RITA-II.c"
}   /* End of psd_samplepos_large=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_4pi'. */
  SIG_MESSAGE("psd_4pi (Save)");
#define mccompcurname  psd_4pi
#define mccompcurtype  PSD_monitor_4PI
#define mccompcurindex 81
#define nx mccpsd_4pi_nx
#define ny mccpsd_4pi_ny
#define PSD_N mccpsd_4pi_PSD_N
#define PSD_p mccpsd_4pi_PSD_p
#define PSD_p2 mccpsd_4pi_PSD_p2
{   /* Declarations of psd_4pi=PSD_monitor_4PI() SETTING parameters. */
char* filename = mccpsd_4pi_filename;
MCNUM radius = mccpsd_4pi_radius;
MCNUM restore_neutron = mccpsd_4pi_restore_neutron;
int nowritefile = mccpsd_4pi_nowritefile;
#line 107 "/usr/share/mcstas/2.5/monitors/PSD_monitor_4PI.comp"
{
  if (!nowritefile) {
    DETECTOR_OUT_2D(
    "4PI PSD monitor",
    "Longitude [deg]",
    "Lattitude [deg]",
    -180, 180, -90, 90,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
  }
}
#line 67761 "RITA-II.c"
}   /* End of psd_4pi=PSD_monitor_4PI() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_before_ana'. */
  SIG_MESSAGE("emon_before_ana (Save)");
#define mccompcurname  emon_before_ana
#define mccompcurtype  E_monitor
#define mccompcurindex 88
#define nE mccemon_before_ana_nE
#define E_N mccemon_before_ana_E_N
#define E_p mccemon_before_ana_E_p
#define E_p2 mccemon_before_ana_E_p2
#define S_p mccemon_before_ana_S_p
#define S_pE mccemon_before_ana_S_pE
#define S_pE2 mccemon_before_ana_S_pE2
{   /* Declarations of emon_before_ana=E_monitor() SETTING parameters. */
char* filename = mccemon_before_ana_filename;
MCNUM xmin = mccemon_before_ana_xmin;
MCNUM xmax = mccemon_before_ana_xmax;
MCNUM ymin = mccemon_before_ana_ymin;
MCNUM ymax = mccemon_before_ana_ymax;
MCNUM xwidth = mccemon_before_ana_xwidth;
MCNUM yheight = mccemon_before_ana_yheight;
MCNUM Emin = mccemon_before_ana_Emin;
MCNUM Emax = mccemon_before_ana_Emax;
MCNUM restore_neutron = mccemon_before_ana_restore_neutron;
int nowritefile = mccemon_before_ana_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 67810 "RITA-II.c"
}   /* End of emon_before_ana=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_before_ana'. */
  SIG_MESSAGE("psd_before_ana (Save)");
#define mccompcurname  psd_before_ana
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define nx mccpsd_before_ana_nx
#define ny mccpsd_before_ana_ny
#define PSD_N mccpsd_before_ana_PSD_N
#define PSD_p mccpsd_before_ana_PSD_p
#define PSD_p2 mccpsd_before_ana_PSD_p2
{   /* Declarations of psd_before_ana=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_before_ana_filename;
MCNUM xmin = mccpsd_before_ana_xmin;
MCNUM xmax = mccpsd_before_ana_xmax;
MCNUM ymin = mccpsd_before_ana_ymin;
MCNUM ymax = mccpsd_before_ana_ymax;
MCNUM xwidth = mccpsd_before_ana_xwidth;
MCNUM yheight = mccpsd_before_ana_yheight;
MCNUM restore_neutron = mccpsd_before_ana_restore_neutron;
int nowritefile = mccpsd_before_ana_nowritefile;
#line 101 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 67856 "RITA-II.c"
}   /* End of psd_before_ana=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'divmon_before_ana'. */
  SIG_MESSAGE("divmon_before_ana (Save)");
#define mccompcurname  divmon_before_ana
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 90
#define nh mccdivmon_before_ana_nh
#define nv mccdivmon_before_ana_nv
#define Div_N mccdivmon_before_ana_Div_N
#define Div_p mccdivmon_before_ana_Div_p
#define Div_p2 mccdivmon_before_ana_Div_p2
{   /* Declarations of divmon_before_ana=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_before_ana_filename;
MCNUM xmin = mccdivmon_before_ana_xmin;
MCNUM xmax = mccdivmon_before_ana_xmax;
MCNUM ymin = mccdivmon_before_ana_ymin;
MCNUM ymax = mccdivmon_before_ana_ymax;
MCNUM xwidth = mccdivmon_before_ana_xwidth;
MCNUM yheight = mccdivmon_before_ana_yheight;
MCNUM maxdiv_h = mccdivmon_before_ana_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_before_ana_maxdiv_v;
MCNUM restore_neutron = mccdivmon_before_ana_restore_neutron;
MCNUM nx = mccdivmon_before_ana_nx;
MCNUM ny = mccdivmon_before_ana_ny;
MCNUM nz = mccdivmon_before_ana_nz;
int nowritefile = mccdivmon_before_ana_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_2D(
        "Divergence monitor",
        "X divergence [deg]",
        "Y divergence [deg]",
        -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
        nh, nv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
    }
}
#line 67905 "RITA-II.c"
}   /* End of divmon_before_ana=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_before_coarse'. */
  SIG_MESSAGE("emon_before_coarse (Save)");
#define mccompcurname  emon_before_coarse
#define mccompcurtype  E_monitor
#define mccompcurindex 111
#define nE mccemon_before_coarse_nE
#define E_N mccemon_before_coarse_E_N
#define E_p mccemon_before_coarse_E_p
#define E_p2 mccemon_before_coarse_E_p2
#define S_p mccemon_before_coarse_S_p
#define S_pE mccemon_before_coarse_S_pE
#define S_pE2 mccemon_before_coarse_S_pE2
{   /* Declarations of emon_before_coarse=E_monitor() SETTING parameters. */
char* filename = mccemon_before_coarse_filename;
MCNUM xmin = mccemon_before_coarse_xmin;
MCNUM xmax = mccemon_before_coarse_xmax;
MCNUM ymin = mccemon_before_coarse_ymin;
MCNUM ymax = mccemon_before_coarse_ymax;
MCNUM xwidth = mccemon_before_coarse_xwidth;
MCNUM yheight = mccemon_before_coarse_yheight;
MCNUM Emin = mccemon_before_coarse_Emin;
MCNUM Emax = mccemon_before_coarse_Emax;
MCNUM restore_neutron = mccemon_before_coarse_restore_neutron;
int nowritefile = mccemon_before_coarse_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 67954 "RITA-II.c"
}   /* End of emon_before_coarse=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_before_coarse'. */
  SIG_MESSAGE("psd_before_coarse (Save)");
#define mccompcurname  psd_before_coarse
#define mccompcurtype  PSD_monitor
#define mccompcurindex 112
#define nx mccpsd_before_coarse_nx
#define ny mccpsd_before_coarse_ny
#define PSD_N mccpsd_before_coarse_PSD_N
#define PSD_p mccpsd_before_coarse_PSD_p
#define PSD_p2 mccpsd_before_coarse_PSD_p2
{   /* Declarations of psd_before_coarse=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_before_coarse_filename;
MCNUM xmin = mccpsd_before_coarse_xmin;
MCNUM xmax = mccpsd_before_coarse_xmax;
MCNUM ymin = mccpsd_before_coarse_ymin;
MCNUM ymax = mccpsd_before_coarse_ymax;
MCNUM xwidth = mccpsd_before_coarse_xwidth;
MCNUM yheight = mccpsd_before_coarse_yheight;
MCNUM restore_neutron = mccpsd_before_coarse_restore_neutron;
int nowritefile = mccpsd_before_coarse_nowritefile;
#line 101 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68000 "RITA-II.c"
}   /* End of psd_before_coarse=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_detector'. */
  SIG_MESSAGE("psd_detector (Save)");
#define mccompcurname  psd_detector
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 133
#define nx mccpsd_detector_nx
#define ny mccpsd_detector_ny
#define filename mccpsd_detector_filename
#define PSD_N mccpsd_detector_PSD_N
#define PSD_p mccpsd_detector_PSD_p
#define PSD_p2 mccpsd_detector_PSD_p2
#define weight mccpsd_detector_weight
{   /* Declarations of psd_detector=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_detector_xmin;
MCNUM xmax = mccpsd_detector_xmax;
MCNUM ymin = mccpsd_detector_ymin;
MCNUM ymax = mccpsd_detector_ymax;
MCNUM xwidth = mccpsd_detector_xwidth;
MCNUM yheight = mccpsd_detector_yheight;
MCNUM psf = mccpsd_detector_psf;
MCNUM k0 = mccpsd_detector_k0;
MCNUM eff = mccpsd_detector_eff;
MCNUM restore_neutron = mccpsd_detector_restore_neutron;
int nowritefile = mccpsd_detector_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68048 "RITA-II.c"
}   /* End of psd_detector=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_detector'. */
  SIG_MESSAGE("emon_detector (Save)");
#define mccompcurname  emon_detector
#define mccompcurtype  E_monitor
#define mccompcurindex 134
#define nE mccemon_detector_nE
#define E_N mccemon_detector_E_N
#define E_p mccemon_detector_E_p
#define E_p2 mccemon_detector_E_p2
#define S_p mccemon_detector_S_p
#define S_pE mccemon_detector_S_pE
#define S_pE2 mccemon_detector_S_pE2
{   /* Declarations of emon_detector=E_monitor() SETTING parameters. */
char* filename = mccemon_detector_filename;
MCNUM xmin = mccemon_detector_xmin;
MCNUM xmax = mccemon_detector_xmax;
MCNUM ymin = mccemon_detector_ymin;
MCNUM ymax = mccemon_detector_ymax;
MCNUM xwidth = mccemon_detector_xwidth;
MCNUM yheight = mccemon_detector_yheight;
MCNUM Emin = mccemon_detector_Emin;
MCNUM Emax = mccemon_detector_Emax;
MCNUM restore_neutron = mccemon_detector_restore_neutron;
int nowritefile = mccemon_detector_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68099 "RITA-II.c"
}   /* End of emon_detector=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window1'. */
  SIG_MESSAGE("psd_window1 (Save)");
#define mccompcurname  psd_window1
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 135
#define nx mccpsd_window1_nx
#define ny mccpsd_window1_ny
#define filename mccpsd_window1_filename
#define PSD_N mccpsd_window1_PSD_N
#define PSD_p mccpsd_window1_PSD_p
#define PSD_p2 mccpsd_window1_PSD_p2
#define weight mccpsd_window1_weight
{   /* Declarations of psd_window1=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window1_xmin;
MCNUM xmax = mccpsd_window1_xmax;
MCNUM ymin = mccpsd_window1_ymin;
MCNUM ymax = mccpsd_window1_ymax;
MCNUM xwidth = mccpsd_window1_xwidth;
MCNUM yheight = mccpsd_window1_yheight;
MCNUM psf = mccpsd_window1_psf;
MCNUM k0 = mccpsd_window1_k0;
MCNUM eff = mccpsd_window1_eff;
MCNUM restore_neutron = mccpsd_window1_restore_neutron;
int nowritefile = mccpsd_window1_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68149 "RITA-II.c"
}   /* End of psd_window1=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window1'. */
  SIG_MESSAGE("emon_window1 (Save)");
#define mccompcurname  emon_window1
#define mccompcurtype  E_monitor
#define mccompcurindex 136
#define nE mccemon_window1_nE
#define E_N mccemon_window1_E_N
#define E_p mccemon_window1_E_p
#define E_p2 mccemon_window1_E_p2
#define S_p mccemon_window1_S_p
#define S_pE mccemon_window1_S_pE
#define S_pE2 mccemon_window1_S_pE2
{   /* Declarations of emon_window1=E_monitor() SETTING parameters. */
char* filename = mccemon_window1_filename;
MCNUM xmin = mccemon_window1_xmin;
MCNUM xmax = mccemon_window1_xmax;
MCNUM ymin = mccemon_window1_ymin;
MCNUM ymax = mccemon_window1_ymax;
MCNUM xwidth = mccemon_window1_xwidth;
MCNUM yheight = mccemon_window1_yheight;
MCNUM Emin = mccemon_window1_Emin;
MCNUM Emax = mccemon_window1_Emax;
MCNUM restore_neutron = mccemon_window1_restore_neutron;
int nowritefile = mccemon_window1_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68200 "RITA-II.c"
}   /* End of emon_window1=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window2'. */
  SIG_MESSAGE("psd_window2 (Save)");
#define mccompcurname  psd_window2
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 137
#define nx mccpsd_window2_nx
#define ny mccpsd_window2_ny
#define filename mccpsd_window2_filename
#define PSD_N mccpsd_window2_PSD_N
#define PSD_p mccpsd_window2_PSD_p
#define PSD_p2 mccpsd_window2_PSD_p2
#define weight mccpsd_window2_weight
{   /* Declarations of psd_window2=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window2_xmin;
MCNUM xmax = mccpsd_window2_xmax;
MCNUM ymin = mccpsd_window2_ymin;
MCNUM ymax = mccpsd_window2_ymax;
MCNUM xwidth = mccpsd_window2_xwidth;
MCNUM yheight = mccpsd_window2_yheight;
MCNUM psf = mccpsd_window2_psf;
MCNUM k0 = mccpsd_window2_k0;
MCNUM eff = mccpsd_window2_eff;
MCNUM restore_neutron = mccpsd_window2_restore_neutron;
int nowritefile = mccpsd_window2_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68250 "RITA-II.c"
}   /* End of psd_window2=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window2'. */
  SIG_MESSAGE("emon_window2 (Save)");
#define mccompcurname  emon_window2
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccemon_window2_nE
#define E_N mccemon_window2_E_N
#define E_p mccemon_window2_E_p
#define E_p2 mccemon_window2_E_p2
#define S_p mccemon_window2_S_p
#define S_pE mccemon_window2_S_pE
#define S_pE2 mccemon_window2_S_pE2
{   /* Declarations of emon_window2=E_monitor() SETTING parameters. */
char* filename = mccemon_window2_filename;
MCNUM xmin = mccemon_window2_xmin;
MCNUM xmax = mccemon_window2_xmax;
MCNUM ymin = mccemon_window2_ymin;
MCNUM ymax = mccemon_window2_ymax;
MCNUM xwidth = mccemon_window2_xwidth;
MCNUM yheight = mccemon_window2_yheight;
MCNUM Emin = mccemon_window2_Emin;
MCNUM Emax = mccemon_window2_Emax;
MCNUM restore_neutron = mccemon_window2_restore_neutron;
int nowritefile = mccemon_window2_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68301 "RITA-II.c"
}   /* End of emon_window2=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window3'. */
  SIG_MESSAGE("psd_window3 (Save)");
#define mccompcurname  psd_window3
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 139
#define nx mccpsd_window3_nx
#define ny mccpsd_window3_ny
#define filename mccpsd_window3_filename
#define PSD_N mccpsd_window3_PSD_N
#define PSD_p mccpsd_window3_PSD_p
#define PSD_p2 mccpsd_window3_PSD_p2
#define weight mccpsd_window3_weight
{   /* Declarations of psd_window3=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window3_xmin;
MCNUM xmax = mccpsd_window3_xmax;
MCNUM ymin = mccpsd_window3_ymin;
MCNUM ymax = mccpsd_window3_ymax;
MCNUM xwidth = mccpsd_window3_xwidth;
MCNUM yheight = mccpsd_window3_yheight;
MCNUM psf = mccpsd_window3_psf;
MCNUM k0 = mccpsd_window3_k0;
MCNUM eff = mccpsd_window3_eff;
MCNUM restore_neutron = mccpsd_window3_restore_neutron;
int nowritefile = mccpsd_window3_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68351 "RITA-II.c"
}   /* End of psd_window3=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window3'. */
  SIG_MESSAGE("emon_window3 (Save)");
#define mccompcurname  emon_window3
#define mccompcurtype  E_monitor
#define mccompcurindex 140
#define nE mccemon_window3_nE
#define E_N mccemon_window3_E_N
#define E_p mccemon_window3_E_p
#define E_p2 mccemon_window3_E_p2
#define S_p mccemon_window3_S_p
#define S_pE mccemon_window3_S_pE
#define S_pE2 mccemon_window3_S_pE2
{   /* Declarations of emon_window3=E_monitor() SETTING parameters. */
char* filename = mccemon_window3_filename;
MCNUM xmin = mccemon_window3_xmin;
MCNUM xmax = mccemon_window3_xmax;
MCNUM ymin = mccemon_window3_ymin;
MCNUM ymax = mccemon_window3_ymax;
MCNUM xwidth = mccemon_window3_xwidth;
MCNUM yheight = mccemon_window3_yheight;
MCNUM Emin = mccemon_window3_Emin;
MCNUM Emax = mccemon_window3_Emax;
MCNUM restore_neutron = mccemon_window3_restore_neutron;
int nowritefile = mccemon_window3_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68402 "RITA-II.c"
}   /* End of emon_window3=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window4'. */
  SIG_MESSAGE("psd_window4 (Save)");
#define mccompcurname  psd_window4
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 141
#define nx mccpsd_window4_nx
#define ny mccpsd_window4_ny
#define filename mccpsd_window4_filename
#define PSD_N mccpsd_window4_PSD_N
#define PSD_p mccpsd_window4_PSD_p
#define PSD_p2 mccpsd_window4_PSD_p2
#define weight mccpsd_window4_weight
{   /* Declarations of psd_window4=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window4_xmin;
MCNUM xmax = mccpsd_window4_xmax;
MCNUM ymin = mccpsd_window4_ymin;
MCNUM ymax = mccpsd_window4_ymax;
MCNUM xwidth = mccpsd_window4_xwidth;
MCNUM yheight = mccpsd_window4_yheight;
MCNUM psf = mccpsd_window4_psf;
MCNUM k0 = mccpsd_window4_k0;
MCNUM eff = mccpsd_window4_eff;
MCNUM restore_neutron = mccpsd_window4_restore_neutron;
int nowritefile = mccpsd_window4_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68452 "RITA-II.c"
}   /* End of psd_window4=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window4'. */
  SIG_MESSAGE("emon_window4 (Save)");
#define mccompcurname  emon_window4
#define mccompcurtype  E_monitor
#define mccompcurindex 142
#define nE mccemon_window4_nE
#define E_N mccemon_window4_E_N
#define E_p mccemon_window4_E_p
#define E_p2 mccemon_window4_E_p2
#define S_p mccemon_window4_S_p
#define S_pE mccemon_window4_S_pE
#define S_pE2 mccemon_window4_S_pE2
{   /* Declarations of emon_window4=E_monitor() SETTING parameters. */
char* filename = mccemon_window4_filename;
MCNUM xmin = mccemon_window4_xmin;
MCNUM xmax = mccemon_window4_xmax;
MCNUM ymin = mccemon_window4_ymin;
MCNUM ymax = mccemon_window4_ymax;
MCNUM xwidth = mccemon_window4_xwidth;
MCNUM yheight = mccemon_window4_yheight;
MCNUM Emin = mccemon_window4_Emin;
MCNUM Emax = mccemon_window4_Emax;
MCNUM restore_neutron = mccemon_window4_restore_neutron;
int nowritefile = mccemon_window4_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68503 "RITA-II.c"
}   /* End of emon_window4=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window5'. */
  SIG_MESSAGE("psd_window5 (Save)");
#define mccompcurname  psd_window5
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 143
#define nx mccpsd_window5_nx
#define ny mccpsd_window5_ny
#define filename mccpsd_window5_filename
#define PSD_N mccpsd_window5_PSD_N
#define PSD_p mccpsd_window5_PSD_p
#define PSD_p2 mccpsd_window5_PSD_p2
#define weight mccpsd_window5_weight
{   /* Declarations of psd_window5=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window5_xmin;
MCNUM xmax = mccpsd_window5_xmax;
MCNUM ymin = mccpsd_window5_ymin;
MCNUM ymax = mccpsd_window5_ymax;
MCNUM xwidth = mccpsd_window5_xwidth;
MCNUM yheight = mccpsd_window5_yheight;
MCNUM psf = mccpsd_window5_psf;
MCNUM k0 = mccpsd_window5_k0;
MCNUM eff = mccpsd_window5_eff;
MCNUM restore_neutron = mccpsd_window5_restore_neutron;
int nowritefile = mccpsd_window5_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68553 "RITA-II.c"
}   /* End of psd_window5=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window5'. */
  SIG_MESSAGE("emon_window5 (Save)");
#define mccompcurname  emon_window5
#define mccompcurtype  E_monitor
#define mccompcurindex 144
#define nE mccemon_window5_nE
#define E_N mccemon_window5_E_N
#define E_p mccemon_window5_E_p
#define E_p2 mccemon_window5_E_p2
#define S_p mccemon_window5_S_p
#define S_pE mccemon_window5_S_pE
#define S_pE2 mccemon_window5_S_pE2
{   /* Declarations of emon_window5=E_monitor() SETTING parameters. */
char* filename = mccemon_window5_filename;
MCNUM xmin = mccemon_window5_xmin;
MCNUM xmax = mccemon_window5_xmax;
MCNUM ymin = mccemon_window5_ymin;
MCNUM ymax = mccemon_window5_ymax;
MCNUM xwidth = mccemon_window5_xwidth;
MCNUM yheight = mccemon_window5_yheight;
MCNUM Emin = mccemon_window5_Emin;
MCNUM Emax = mccemon_window5_Emax;
MCNUM restore_neutron = mccemon_window5_restore_neutron;
int nowritefile = mccemon_window5_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68604 "RITA-II.c"
}   /* End of emon_window5=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window6'. */
  SIG_MESSAGE("psd_window6 (Save)");
#define mccompcurname  psd_window6
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 145
#define nx mccpsd_window6_nx
#define ny mccpsd_window6_ny
#define filename mccpsd_window6_filename
#define PSD_N mccpsd_window6_PSD_N
#define PSD_p mccpsd_window6_PSD_p
#define PSD_p2 mccpsd_window6_PSD_p2
#define weight mccpsd_window6_weight
{   /* Declarations of psd_window6=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window6_xmin;
MCNUM xmax = mccpsd_window6_xmax;
MCNUM ymin = mccpsd_window6_ymin;
MCNUM ymax = mccpsd_window6_ymax;
MCNUM xwidth = mccpsd_window6_xwidth;
MCNUM yheight = mccpsd_window6_yheight;
MCNUM psf = mccpsd_window6_psf;
MCNUM k0 = mccpsd_window6_k0;
MCNUM eff = mccpsd_window6_eff;
MCNUM restore_neutron = mccpsd_window6_restore_neutron;
int nowritefile = mccpsd_window6_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68654 "RITA-II.c"
}   /* End of psd_window6=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window6'. */
  SIG_MESSAGE("emon_window6 (Save)");
#define mccompcurname  emon_window6
#define mccompcurtype  E_monitor
#define mccompcurindex 146
#define nE mccemon_window6_nE
#define E_N mccemon_window6_E_N
#define E_p mccemon_window6_E_p
#define E_p2 mccemon_window6_E_p2
#define S_p mccemon_window6_S_p
#define S_pE mccemon_window6_S_pE
#define S_pE2 mccemon_window6_S_pE2
{   /* Declarations of emon_window6=E_monitor() SETTING parameters. */
char* filename = mccemon_window6_filename;
MCNUM xmin = mccemon_window6_xmin;
MCNUM xmax = mccemon_window6_xmax;
MCNUM ymin = mccemon_window6_ymin;
MCNUM ymax = mccemon_window6_ymax;
MCNUM xwidth = mccemon_window6_xwidth;
MCNUM yheight = mccemon_window6_yheight;
MCNUM Emin = mccemon_window6_Emin;
MCNUM Emax = mccemon_window6_Emax;
MCNUM restore_neutron = mccemon_window6_restore_neutron;
int nowritefile = mccemon_window6_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68705 "RITA-II.c"
}   /* End of emon_window6=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window7'. */
  SIG_MESSAGE("psd_window7 (Save)");
#define mccompcurname  psd_window7
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 147
#define nx mccpsd_window7_nx
#define ny mccpsd_window7_ny
#define filename mccpsd_window7_filename
#define PSD_N mccpsd_window7_PSD_N
#define PSD_p mccpsd_window7_PSD_p
#define PSD_p2 mccpsd_window7_PSD_p2
#define weight mccpsd_window7_weight
{   /* Declarations of psd_window7=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window7_xmin;
MCNUM xmax = mccpsd_window7_xmax;
MCNUM ymin = mccpsd_window7_ymin;
MCNUM ymax = mccpsd_window7_ymax;
MCNUM xwidth = mccpsd_window7_xwidth;
MCNUM yheight = mccpsd_window7_yheight;
MCNUM psf = mccpsd_window7_psf;
MCNUM k0 = mccpsd_window7_k0;
MCNUM eff = mccpsd_window7_eff;
MCNUM restore_neutron = mccpsd_window7_restore_neutron;
int nowritefile = mccpsd_window7_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68755 "RITA-II.c"
}   /* End of psd_window7=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window7'. */
  SIG_MESSAGE("emon_window7 (Save)");
#define mccompcurname  emon_window7
#define mccompcurtype  E_monitor
#define mccompcurindex 148
#define nE mccemon_window7_nE
#define E_N mccemon_window7_E_N
#define E_p mccemon_window7_E_p
#define E_p2 mccemon_window7_E_p2
#define S_p mccemon_window7_S_p
#define S_pE mccemon_window7_S_pE
#define S_pE2 mccemon_window7_S_pE2
{   /* Declarations of emon_window7=E_monitor() SETTING parameters. */
char* filename = mccemon_window7_filename;
MCNUM xmin = mccemon_window7_xmin;
MCNUM xmax = mccemon_window7_xmax;
MCNUM ymin = mccemon_window7_ymin;
MCNUM ymax = mccemon_window7_ymax;
MCNUM xwidth = mccemon_window7_xwidth;
MCNUM yheight = mccemon_window7_yheight;
MCNUM Emin = mccemon_window7_Emin;
MCNUM Emax = mccemon_window7_Emax;
MCNUM restore_neutron = mccemon_window7_restore_neutron;
int nowritefile = mccemon_window7_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68806 "RITA-II.c"
}   /* End of emon_window7=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window8'. */
  SIG_MESSAGE("psd_window8 (Save)");
#define mccompcurname  psd_window8
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 149
#define nx mccpsd_window8_nx
#define ny mccpsd_window8_ny
#define filename mccpsd_window8_filename
#define PSD_N mccpsd_window8_PSD_N
#define PSD_p mccpsd_window8_PSD_p
#define PSD_p2 mccpsd_window8_PSD_p2
#define weight mccpsd_window8_weight
{   /* Declarations of psd_window8=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window8_xmin;
MCNUM xmax = mccpsd_window8_xmax;
MCNUM ymin = mccpsd_window8_ymin;
MCNUM ymax = mccpsd_window8_ymax;
MCNUM xwidth = mccpsd_window8_xwidth;
MCNUM yheight = mccpsd_window8_yheight;
MCNUM psf = mccpsd_window8_psf;
MCNUM k0 = mccpsd_window8_k0;
MCNUM eff = mccpsd_window8_eff;
MCNUM restore_neutron = mccpsd_window8_restore_neutron;
int nowritefile = mccpsd_window8_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68856 "RITA-II.c"
}   /* End of psd_window8=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window8'. */
  SIG_MESSAGE("emon_window8 (Save)");
#define mccompcurname  emon_window8
#define mccompcurtype  E_monitor
#define mccompcurindex 150
#define nE mccemon_window8_nE
#define E_N mccemon_window8_E_N
#define E_p mccemon_window8_E_p
#define E_p2 mccemon_window8_E_p2
#define S_p mccemon_window8_S_p
#define S_pE mccemon_window8_S_pE
#define S_pE2 mccemon_window8_S_pE2
{   /* Declarations of emon_window8=E_monitor() SETTING parameters. */
char* filename = mccemon_window8_filename;
MCNUM xmin = mccemon_window8_xmin;
MCNUM xmax = mccemon_window8_xmax;
MCNUM ymin = mccemon_window8_ymin;
MCNUM ymax = mccemon_window8_ymax;
MCNUM xwidth = mccemon_window8_xwidth;
MCNUM yheight = mccemon_window8_yheight;
MCNUM Emin = mccemon_window8_Emin;
MCNUM Emax = mccemon_window8_Emax;
MCNUM restore_neutron = mccemon_window8_restore_neutron;
int nowritefile = mccemon_window8_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 68907 "RITA-II.c"
}   /* End of emon_window8=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_window9'. */
  SIG_MESSAGE("psd_window9 (Save)");
#define mccompcurname  psd_window9
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 151
#define nx mccpsd_window9_nx
#define ny mccpsd_window9_ny
#define filename mccpsd_window9_filename
#define PSD_N mccpsd_window9_PSD_N
#define PSD_p mccpsd_window9_PSD_p
#define PSD_p2 mccpsd_window9_PSD_p2
#define weight mccpsd_window9_weight
{   /* Declarations of psd_window9=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window9_xmin;
MCNUM xmax = mccpsd_window9_xmax;
MCNUM ymin = mccpsd_window9_ymin;
MCNUM ymax = mccpsd_window9_ymax;
MCNUM xwidth = mccpsd_window9_xwidth;
MCNUM yheight = mccpsd_window9_yheight;
MCNUM psf = mccpsd_window9_psf;
MCNUM k0 = mccpsd_window9_k0;
MCNUM eff = mccpsd_window9_eff;
MCNUM restore_neutron = mccpsd_window9_restore_neutron;
int nowritefile = mccpsd_window9_nowritefile;
#line 114 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
    if (!nowritefile) {
      DETECTOR_OUT_2D(
          "PSD monitor",
          "X position [cm]",
          "Y position [cm]",
          xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
          nx, ny,
          &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
          filename);
    }
}
#line 68957 "RITA-II.c"
}   /* End of psd_window9=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'emon_window9'. */
  SIG_MESSAGE("emon_window9 (Save)");
#define mccompcurname  emon_window9
#define mccompcurtype  E_monitor
#define mccompcurindex 152
#define nE mccemon_window9_nE
#define E_N mccemon_window9_E_N
#define E_p mccemon_window9_E_p
#define E_p2 mccemon_window9_E_p2
#define S_p mccemon_window9_S_p
#define S_pE mccemon_window9_S_pE
#define S_pE2 mccemon_window9_S_pE2
{   /* Declarations of emon_window9=E_monitor() SETTING parameters. */
char* filename = mccemon_window9_filename;
MCNUM xmin = mccemon_window9_xmin;
MCNUM xmax = mccemon_window9_xmax;
MCNUM ymin = mccemon_window9_ymin;
MCNUM ymax = mccemon_window9_ymax;
MCNUM xwidth = mccemon_window9_xwidth;
MCNUM yheight = mccemon_window9_yheight;
MCNUM Emin = mccemon_window9_Emin;
MCNUM Emax = mccemon_window9_Emax;
MCNUM restore_neutron = mccemon_window9_restore_neutron;
int nowritefile = mccemon_window9_nowritefile;
#line 117 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 69008 "RITA-II.c"
}   /* End of emon_window9=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  if (!handle) mcsiminfo_close(); 
} /* end save */
void mcfinally(void) {
  /* User component FINALLY code. */
  mcsiminfo_init(NULL);
  mcsave(mcsiminfo_file); /* save data when simulation ends */

  /* User FINALLY code for component 'armSource'. */
  SIG_MESSAGE("armSource (Finally)");
#define mccompcurname  armSource
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccarmSource_IntermediateCnts
#define StartTime mccarmSource_StartTime
#define EndTime mccarmSource_EndTime
#define CurrentTime mccarmSource_CurrentTime
{   /* Declarations of armSource=Progress_bar() SETTING parameters. */
char* profile = mccarmSource_profile;
MCNUM percent = mccarmSource_percent;
MCNUM flag_save = mccarmSource_flag_save;
MCNUM minutes = mccarmSource_minutes;
#line 133 "/usr/share/mcstas/2.5/misc/Progress_bar.comp"
{
  time_t NowTime;
  time(&NowTime);
  fprintf(stdout, "\nFinally [%s: %s]. Time: ", mcinstrument_name, mcdirname ? mcdirname : ".");
  if (difftime(NowTime,StartTime) < 60.0)
    fprintf(stdout, "%g [s] ", difftime(NowTime,StartTime));
  else if (difftime(NowTime,StartTime) > 3600.0)
    fprintf(stdout, "%g [h] ", difftime(NowTime,StartTime)/3660.0);
  else
    fprintf(stdout, "%g [min] ", difftime(NowTime,StartTime)/60.0);
  fprintf(stdout, "\n");
}
#line 69055 "RITA-II.c"
}   /* End of armSource=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[1]) fprintf(stderr, "Warning: No neutron could reach Component[1] armSource\n");
    if (mcAbsorbProp[1]) fprintf(stderr, "Warning: %g events were removed in Component[1] armSource=Progress_bar()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[1]);
  /* User FINALLY code for component 'source'. */
  SIG_MESSAGE("source (Finally)");
#define mccompcurname  source
#define mccompcurtype  Source_gen4
#define mccompcurindex 2
#define flux_file mccsource_flux_file
#define xdiv_file mccsource_xdiv_file
#define ydiv_file mccsource_ydiv_file
#define p_in mccsource_p_in
#define lambda0 mccsource_lambda0
#define lambda02 mccsource_lambda02
#define L2P mccsource_L2P
#define lambda0b mccsource_lambda0b
#define lambda02b mccsource_lambda02b
#define L2Pb mccsource_L2Pb
#define lambda0c mccsource_lambda0c
#define lambda02c mccsource_lambda02c
#define L2Pc mccsource_L2Pc
#define pTable mccsource_pTable
#define pTable_x mccsource_pTable_x
#define pTable_y mccsource_pTable_y
{   /* Declarations of source=Source_gen4() SETTING parameters. */
MCNUM radius = mccsource_radius;
MCNUM dist = mccsource_dist;
MCNUM xw = mccsource_xw;
MCNUM yh = mccsource_yh;
MCNUM E0 = mccsource_E0;
MCNUM dE = mccsource_dE;
MCNUM Lambda0 = mccsource_Lambda0;
MCNUM dLambda = mccsource_dLambda;
MCNUM I1 = mccsource_I1;
MCNUM h = mccsource_h;
MCNUM w = mccsource_w;
MCNUM gaussian = mccsource_gaussian;
MCNUM verbose = mccsource_verbose;
MCNUM T1 = mccsource_T1;
MCNUM flux_file_perAA = mccsource_flux_file_perAA;
MCNUM flux_file_log = mccsource_flux_file_log;
MCNUM Lmin = mccsource_Lmin;
MCNUM Lmax = mccsource_Lmax;
MCNUM Emin = mccsource_Emin;
MCNUM Emax = mccsource_Emax;
MCNUM T2 = mccsource_T2;
MCNUM I2 = mccsource_I2;
MCNUM T3 = mccsource_T3;
MCNUM I3 = mccsource_I3;
MCNUM length = mccsource_length;
MCNUM phi_init = mccsource_phi_init;
MCNUM theta_init = mccsource_theta_init;
MCNUM HEtailA = mccsource_HEtailA;
MCNUM HEtailL0 = mccsource_HEtailL0;
#line 582 "/usr/share/mcstas/2.5/contrib/Source_gen4.comp"
{
  Table_Free(&pTable);
  Table_Free(&pTable_x);
  Table_Free(&pTable_y);
}
#line 69124 "RITA-II.c"
}   /* End of source=Source_gen4() SETTING parameter declarations. */
#undef pTable_y
#undef pTable_x
#undef pTable
#undef L2Pc
#undef lambda02c
#undef lambda0c
#undef L2Pb
#undef lambda02b
#undef lambda0b
#undef L2P
#undef lambda02
#undef lambda0
#undef p_in
#undef ydiv_file
#undef xdiv_file
#undef flux_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[2]) fprintf(stderr, "Warning: No neutron could reach Component[2] source\n");
    if (mcAbsorbProp[2]) fprintf(stderr, "Warning: %g events were removed in Component[2] source=Source_gen4()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[2]);
    if (!mcNCounter[3]) fprintf(stderr, "Warning: No neutron could reach Component[3] slitGuideBegin\n");
    if (mcAbsorbProp[3]) fprintf(stderr, "Warning: %g events were removed in Component[3] slitGuideBegin=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[3]);
    if (!mcNCounter[4]) fprintf(stderr, "Warning: No neutron could reach Component[4] lmon_guide_start\n");
    if (mcAbsorbProp[4]) fprintf(stderr, "Warning: %g events were removed in Component[4] lmon_guide_start=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[4]);
    if (!mcNCounter[5]) fprintf(stderr, "Warning: No neutron could reach Component[5] guideStraight\n");
    if (mcAbsorbProp[5]) fprintf(stderr, "Warning: %g events were removed in Component[5] guideStraight=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[5]);
    if (!mcNCounter[6]) fprintf(stderr, "Warning: No neutron could reach Component[6] guideCurved1\n");
    if (mcAbsorbProp[6]) fprintf(stderr, "Warning: %g events were removed in Component[6] guideCurved1=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[6]);
    if (!mcNCounter[7]) fprintf(stderr, "Warning: No neutron could reach Component[7] guideCurved2\n");
    if (mcAbsorbProp[7]) fprintf(stderr, "Warning: %g events were removed in Component[7] guideCurved2=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[7]);
    if (!mcNCounter[8]) fprintf(stderr, "Warning: No neutron could reach Component[8] guideCurved3\n");
    if (mcAbsorbProp[8]) fprintf(stderr, "Warning: %g events were removed in Component[8] guideCurved3=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[8]);
    if (!mcNCounter[9]) fprintf(stderr, "Warning: No neutron could reach Component[9] guideCurved4\n");
    if (mcAbsorbProp[9]) fprintf(stderr, "Warning: %g events were removed in Component[9] guideCurved4=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[9]);
    if (!mcNCounter[10]) fprintf(stderr, "Warning: No neutron could reach Component[10] guideCurved5\n");
    if (mcAbsorbProp[10]) fprintf(stderr, "Warning: %g events were removed in Component[10] guideCurved5=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[10]);
    if (!mcNCounter[11]) fprintf(stderr, "Warning: No neutron could reach Component[11] guideCurved6\n");
    if (mcAbsorbProp[11]) fprintf(stderr, "Warning: %g events were removed in Component[11] guideCurved6=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[11]);
    if (!mcNCounter[12]) fprintf(stderr, "Warning: No neutron could reach Component[12] guideCurved7\n");
    if (mcAbsorbProp[12]) fprintf(stderr, "Warning: %g events were removed in Component[12] guideCurved7=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[12]);
    if (!mcNCounter[13]) fprintf(stderr, "Warning: No neutron could reach Component[13] guideCurved8\n");
    if (mcAbsorbProp[13]) fprintf(stderr, "Warning: %g events were removed in Component[13] guideCurved8=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[13]);
    if (!mcNCounter[14]) fprintf(stderr, "Warning: No neutron could reach Component[14] guideCurved9\n");
    if (mcAbsorbProp[14]) fprintf(stderr, "Warning: %g events were removed in Component[14] guideCurved9=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[14]);
    if (!mcNCounter[15]) fprintf(stderr, "Warning: No neutron could reach Component[15] guideCurved10\n");
    if (mcAbsorbProp[15]) fprintf(stderr, "Warning: %g events were removed in Component[15] guideCurved10=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[15]);
    if (!mcNCounter[16]) fprintf(stderr, "Warning: No neutron could reach Component[16] guideCurved11\n");
    if (mcAbsorbProp[16]) fprintf(stderr, "Warning: %g events were removed in Component[16] guideCurved11=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[16]);
    if (!mcNCounter[17]) fprintf(stderr, "Warning: No neutron could reach Component[17] guideCurved12\n");
    if (mcAbsorbProp[17]) fprintf(stderr, "Warning: %g events were removed in Component[17] guideCurved12=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[17]);
    if (!mcNCounter[18]) fprintf(stderr, "Warning: No neutron could reach Component[18] guideCurved13\n");
    if (mcAbsorbProp[18]) fprintf(stderr, "Warning: %g events were removed in Component[18] guideCurved13=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[18]);
    if (!mcNCounter[19]) fprintf(stderr, "Warning: No neutron could reach Component[19] guideCurved14\n");
    if (mcAbsorbProp[19]) fprintf(stderr, "Warning: %g events were removed in Component[19] guideCurved14=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[19]);
    if (!mcNCounter[20]) fprintf(stderr, "Warning: No neutron could reach Component[20] guideCurved15\n");
    if (mcAbsorbProp[20]) fprintf(stderr, "Warning: %g events were removed in Component[20] guideCurved15=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[20]);
    if (!mcNCounter[21]) fprintf(stderr, "Warning: No neutron could reach Component[21] guideCurved16\n");
    if (mcAbsorbProp[21]) fprintf(stderr, "Warning: %g events were removed in Component[21] guideCurved16=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[21]);
    if (!mcNCounter[22]) fprintf(stderr, "Warning: No neutron could reach Component[22] guideCurved17\n");
    if (mcAbsorbProp[22]) fprintf(stderr, "Warning: %g events were removed in Component[22] guideCurved17=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[22]);
    if (!mcNCounter[23]) fprintf(stderr, "Warning: No neutron could reach Component[23] guideCurved18\n");
    if (mcAbsorbProp[23]) fprintf(stderr, "Warning: %g events were removed in Component[23] guideCurved18=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[23]);
    if (!mcNCounter[24]) fprintf(stderr, "Warning: No neutron could reach Component[24] guideCurved19\n");
    if (mcAbsorbProp[24]) fprintf(stderr, "Warning: %g events were removed in Component[24] guideCurved19=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[24]);
    if (!mcNCounter[25]) fprintf(stderr, "Warning: No neutron could reach Component[25] guideCurved20\n");
    if (mcAbsorbProp[25]) fprintf(stderr, "Warning: %g events were removed in Component[25] guideCurved20=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[25]);
    if (!mcNCounter[26]) fprintf(stderr, "Warning: No neutron could reach Component[26] guideCurved21\n");
    if (mcAbsorbProp[26]) fprintf(stderr, "Warning: %g events were removed in Component[26] guideCurved21=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[26]);
    if (!mcNCounter[27]) fprintf(stderr, "Warning: No neutron could reach Component[27] guideCurved22\n");
    if (mcAbsorbProp[27]) fprintf(stderr, "Warning: %g events were removed in Component[27] guideCurved22=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[27]);
    if (!mcNCounter[28]) fprintf(stderr, "Warning: No neutron could reach Component[28] guideCurved23\n");
    if (mcAbsorbProp[28]) fprintf(stderr, "Warning: %g events were removed in Component[28] guideCurved23=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[28]);
    if (!mcNCounter[29]) fprintf(stderr, "Warning: No neutron could reach Component[29] guideCurved24\n");
    if (mcAbsorbProp[29]) fprintf(stderr, "Warning: %g events were removed in Component[29] guideCurved24=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[29]);
    if (!mcNCounter[30]) fprintf(stderr, "Warning: No neutron could reach Component[30] guideCurved25\n");
    if (mcAbsorbProp[30]) fprintf(stderr, "Warning: %g events were removed in Component[30] guideCurved25=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[30]);
    if (!mcNCounter[31]) fprintf(stderr, "Warning: No neutron could reach Component[31] guideCurved26\n");
    if (mcAbsorbProp[31]) fprintf(stderr, "Warning: %g events were removed in Component[31] guideCurved26=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[31]);
    if (!mcNCounter[32]) fprintf(stderr, "Warning: No neutron could reach Component[32] guideCurved27\n");
    if (mcAbsorbProp[32]) fprintf(stderr, "Warning: %g events were removed in Component[32] guideCurved27=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[32]);
    if (!mcNCounter[33]) fprintf(stderr, "Warning: No neutron could reach Component[33] guideCurved28\n");
    if (mcAbsorbProp[33]) fprintf(stderr, "Warning: %g events were removed in Component[33] guideCurved28=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[33]);
    if (!mcNCounter[34]) fprintf(stderr, "Warning: No neutron could reach Component[34] guideCurved29\n");
    if (mcAbsorbProp[34]) fprintf(stderr, "Warning: %g events were removed in Component[34] guideCurved29=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[34]);
    if (!mcNCounter[35]) fprintf(stderr, "Warning: No neutron could reach Component[35] guideCurved30\n");
    if (mcAbsorbProp[35]) fprintf(stderr, "Warning: %g events were removed in Component[35] guideCurved30=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[35]);
    if (!mcNCounter[36]) fprintf(stderr, "Warning: No neutron could reach Component[36] guideCurved31\n");
    if (mcAbsorbProp[36]) fprintf(stderr, "Warning: %g events were removed in Component[36] guideCurved31=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[36]);
    if (!mcNCounter[37]) fprintf(stderr, "Warning: No neutron could reach Component[37] guideCurved32\n");
    if (mcAbsorbProp[37]) fprintf(stderr, "Warning: %g events were removed in Component[37] guideCurved32=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[37]);
    if (!mcNCounter[38]) fprintf(stderr, "Warning: No neutron could reach Component[38] guideCurved33\n");
    if (mcAbsorbProp[38]) fprintf(stderr, "Warning: %g events were removed in Component[38] guideCurved33=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[38]);
    if (!mcNCounter[39]) fprintf(stderr, "Warning: No neutron could reach Component[39] guideCurved34\n");
    if (mcAbsorbProp[39]) fprintf(stderr, "Warning: %g events were removed in Component[39] guideCurved34=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[39]);
    if (!mcNCounter[40]) fprintf(stderr, "Warning: No neutron could reach Component[40] guideCurved35\n");
    if (mcAbsorbProp[40]) fprintf(stderr, "Warning: %g events were removed in Component[40] guideCurved35=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[40]);
    if (!mcNCounter[41]) fprintf(stderr, "Warning: No neutron could reach Component[41] guideCurved36\n");
    if (mcAbsorbProp[41]) fprintf(stderr, "Warning: %g events were removed in Component[41] guideCurved36=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[41]);
    if (!mcNCounter[42]) fprintf(stderr, "Warning: No neutron could reach Component[42] guideCurved37\n");
    if (mcAbsorbProp[42]) fprintf(stderr, "Warning: %g events were removed in Component[42] guideCurved37=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[42]);
    if (!mcNCounter[43]) fprintf(stderr, "Warning: No neutron could reach Component[43] guideCurved38\n");
    if (mcAbsorbProp[43]) fprintf(stderr, "Warning: %g events were removed in Component[43] guideCurved38=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[43]);
    if (!mcNCounter[44]) fprintf(stderr, "Warning: No neutron could reach Component[44] guideCurved39\n");
    if (mcAbsorbProp[44]) fprintf(stderr, "Warning: %g events were removed in Component[44] guideCurved39=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[44]);
    if (!mcNCounter[45]) fprintf(stderr, "Warning: No neutron could reach Component[45] guideCurved40\n");
    if (mcAbsorbProp[45]) fprintf(stderr, "Warning: %g events were removed in Component[45] guideCurved40=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[45]);
    if (!mcNCounter[46]) fprintf(stderr, "Warning: No neutron could reach Component[46] bunker\n");
    if (mcAbsorbProp[46]) fprintf(stderr, "Warning: %g events were removed in Component[46] bunker=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[46]);
    if (!mcNCounter[47]) fprintf(stderr, "Warning: No neutron could reach Component[47] guide3\n");
    if (mcAbsorbProp[47]) fprintf(stderr, "Warning: %g events were removed in Component[47] guide3=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[47]);
    if (!mcNCounter[48]) fprintf(stderr, "Warning: No neutron could reach Component[48] slitGuideEnd\n");
    if (mcAbsorbProp[48]) fprintf(stderr, "Warning: %g events were removed in Component[48] slitGuideEnd=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[48]);
    if (!mcNCounter[49]) fprintf(stderr, "Warning: No neutron could reach Component[49] psd_guide_end\n");
    if (mcAbsorbProp[49]) fprintf(stderr, "Warning: %g events were removed in Component[49] psd_guide_end=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[49]);
    if (!mcNCounter[50]) fprintf(stderr, "Warning: No neutron could reach Component[50] emon_guide_end\n");
    if (mcAbsorbProp[50]) fprintf(stderr, "Warning: %g events were removed in Component[50] emon_guide_end=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[50]);
    if (!mcNCounter[51]) fprintf(stderr, "Warning: No neutron could reach Component[51] lmon_guide_end\n");
    if (mcAbsorbProp[51]) fprintf(stderr, "Warning: %g events were removed in Component[51] lmon_guide_end=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[51]);
    if (!mcNCounter[52]) fprintf(stderr, "Warning: No neutron could reach Component[52] divmon_guide_end\n");
    if (mcAbsorbProp[52]) fprintf(stderr, "Warning: %g events were removed in Component[52] divmon_guide_end=Divergence_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[52]);
    if (!mcNCounter[53]) fprintf(stderr, "Warning: No neutron could reach Component[53] focus_mono\n");
    if (mcAbsorbProp[53]) fprintf(stderr, "Warning: %g events were removed in Component[53] focus_mono=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[53]);
  /* User FINALLY code for component 'monochromator_curved'. */
  SIG_MESSAGE("monochromator_curved (Finally)");
#define mccompcurname  monochromator_curved
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 54
#define mos_rms_y mccmonochromator_curved_mos_rms_y
#define mos_rms_z mccmonochromator_curved_mos_rms_z
#define mos_rms_max mccmonochromator_curved_mos_rms_max
#define mono_Q mccmonochromator_curved_mono_Q
#define SlabWidth mccmonochromator_curved_SlabWidth
#define SlabHeight mccmonochromator_curved_SlabHeight
#define rTable mccmonochromator_curved_rTable
#define tTable mccmonochromator_curved_tTable
#define row mccmonochromator_curved_row
#define col mccmonochromator_curved_col
#define tiltH mccmonochromator_curved_tiltH
#define tiltV mccmonochromator_curved_tiltV
{   /* Declarations of monochromator_curved=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator_curved_reflect;
char* transmit = mccmonochromator_curved_transmit;
MCNUM zwidth = mccmonochromator_curved_zwidth;
MCNUM yheight = mccmonochromator_curved_yheight;
MCNUM gap = mccmonochromator_curved_gap;
MCNUM NH = mccmonochromator_curved_NH;
MCNUM NV = mccmonochromator_curved_NV;
MCNUM mosaich = mccmonochromator_curved_mosaich;
MCNUM mosaicv = mccmonochromator_curved_mosaicv;
MCNUM r0 = mccmonochromator_curved_r0;
MCNUM t0 = mccmonochromator_curved_t0;
MCNUM Q = mccmonochromator_curved_Q;
MCNUM RV = mccmonochromator_curved_RV;
MCNUM RH = mccmonochromator_curved_RH;
MCNUM DM = mccmonochromator_curved_DM;
MCNUM mosaic = mccmonochromator_curved_mosaic;
MCNUM width = mccmonochromator_curved_width;
MCNUM height = mccmonochromator_curved_height;
MCNUM verbose = mccmonochromator_curved_verbose;
MCNUM order = mccmonochromator_curved_order;
#line 460 "/usr/share/mcstas/2.5/optics/Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 69295 "RITA-II.c"
}   /* End of monochromator_curved=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[54]) fprintf(stderr, "Warning: No neutron could reach Component[54] monochromator_curved\n");
    if (mcNCounter[54] < 1000*(SPLITMREP)) fprintf(stderr, 
"Warning: Number of events %g reaching SPLIT position Component[54] monochromator_curved=Monochromator_curved()\n"
"         is probably too low. Increase Ncount.\n", mcNCounter[54]);

    if (mcAbsorbProp[54]) fprintf(stderr, "Warning: %g events were removed in Component[54] monochromator_curved=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[54]);
    if (!mcNCounter[55]) fprintf(stderr, "Warning: No neutron could reach Component[55] a2\n");
    if (mcAbsorbProp[55]) fprintf(stderr, "Warning: %g events were removed in Component[55] a2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[55]);
    if (!mcNCounter[56]) fprintf(stderr, "Warning: No neutron could reach Component[56] slitShutter\n");
    if (mcAbsorbProp[56]) fprintf(stderr, "Warning: %g events were removed in Component[56] slitShutter=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[56]);
    if (!mcNCounter[57]) fprintf(stderr, "Warning: No neutron could reach Component[57] MSCollimator\n");
    if (mcAbsorbProp[57]) fprintf(stderr, "Warning: %g events were removed in Component[57] MSCollimator=Collimator_linear()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[57]);
  /* User FINALLY code for component 'infilter'. */
  SIG_MESSAGE("infilter (Finally)");
#define mccompcurname  infilter
#define mccompcurtype  Filter_gen
#define mccompcurindex 58
#define pTable mccinfilter_pTable
#define Mode_Table mccinfilter_Mode_Table
#define Type_Table mccinfilter_Type_Table
{   /* Declarations of infilter=Filter_gen() SETTING parameters. */
char* filename = mccinfilter_filename;
char* options = mccinfilter_options;
MCNUM xmin = mccinfilter_xmin;
MCNUM xmax = mccinfilter_xmax;
MCNUM ymin = mccinfilter_ymin;
MCNUM ymax = mccinfilter_ymax;
MCNUM xwidth = mccinfilter_xwidth;
MCNUM yheight = mccinfilter_yheight;
MCNUM thickness = mccinfilter_thickness;
MCNUM scaling = mccinfilter_scaling;
MCNUM verbose = mccinfilter_verbose;
#line 203 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  Table_Free(&pTable);
}
#line 69346 "RITA-II.c"
}   /* End of infilter=Filter_gen() SETTING parameter declarations. */
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[58]) fprintf(stderr, "Warning: No neutron could reach Component[58] infilter\n");
    if (mcAbsorbProp[58]) fprintf(stderr, "Warning: %g events were removed in Component[58] infilter=Filter_gen()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[58]);
    if (!mcNCounter[59]) fprintf(stderr, "Warning: No neutron could reach Component[59] psd_virt\n");
    if (mcAbsorbProp[59]) fprintf(stderr, "Warning: %g events were removed in Component[59] psd_virt=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[59]);
    if (!mcNCounter[60]) fprintf(stderr, "Warning: No neutron could reach Component[60] lmon_virt\n");
    if (mcAbsorbProp[60]) fprintf(stderr, "Warning: %g events were removed in Component[60] lmon_virt=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[60]);
    if (!mcNCounter[61]) fprintf(stderr, "Warning: No neutron could reach Component[61] aa2\n");
    if (mcAbsorbProp[61]) fprintf(stderr, "Warning: %g events were removed in Component[61] aa2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[61]);
  /* User FINALLY code for component 'virtualout'. */
  SIG_MESSAGE("virtualout (Finally)");
#define mccompcurname  virtualout
#define mccompcurtype  Virtual_output
#define mccompcurindex 62
#define DEFS mccvirtualout_DEFS
#define Vars mccvirtualout_Vars
{   /* Declarations of virtualout=Virtual_output() SETTING parameters. */
char* filename = mccvirtualout_filename;
MCNUM bufsize = mccvirtualout_bufsize;
#line 146 "/usr/share/mcstas/2.5/sources/Virtual_output.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
  if (bufsize) {
    printf("Virtual_output: %s: Saved %Li events (from buffer) in file %s\n",
           NAME_CURRENT_COMP, Vars.Nsum, Vars.Mon_File);
    if (bufsize < Vars.Nsum)
      printf("WARNING         When using this source, intensities must be multiplied\n"
             "                by a factor %g\n", (double)Vars.Nsum/(double)bufsize);
  } else printf("Virtual_output: %s: Saved %Li events (all) in file %s\n", NAME_CURRENT_COMP, Vars.Nsum, Vars.Mon_File);
}
#line 69385 "RITA-II.c"
}   /* End of virtualout=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[62]) fprintf(stderr, "Warning: No neutron could reach Component[62] virtualout\n");
    if (mcAbsorbProp[62]) fprintf(stderr, "Warning: %g events were removed in Component[62] virtualout=Virtual_output()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[62]);
  /* User FINALLY code for component 'virtualsource'. */
  SIG_MESSAGE("virtualsource (Finally)");
#define mccompcurname  virtualsource
#define mccompcurtype  Virtual_input
#define mccompcurindex 63
#define read_block mccvirtualsource_read_block
#define pos mccvirtualsource_pos
#define nrows mccvirtualsource_nrows
#define Offset mccvirtualsource_Offset
#define rTable mccvirtualsource_rTable
#define repeat_number mccvirtualsource_repeat_number
#define filename_ncount mccvirtualsource_filename_ncount
#define mean_vx mccvirtualsource_mean_vx
#define mean_vy mccvirtualsource_mean_vy
#define mean_vz mccvirtualsource_mean_vz
#define mean_dx mccvirtualsource_mean_dx
#define mean_dy mccvirtualsource_mean_dy
#define mean_dz mccvirtualsource_mean_dz
#define n_neutrons mccvirtualsource_n_neutrons
#define min_x mccvirtualsource_min_x
#define min_y mccvirtualsource_min_y
#define min_z mccvirtualsource_min_z
#define max_x mccvirtualsource_max_x
#define max_y mccvirtualsource_max_y
#define max_z mccvirtualsource_max_z
#define min_vx mccvirtualsource_min_vx
#define min_vy mccvirtualsource_min_vy
#define min_vz mccvirtualsource_min_vz
#define max_vx mccvirtualsource_max_vx
#define max_vy mccvirtualsource_max_vy
#define max_vz mccvirtualsource_max_vz
#define first_block mccvirtualsource_first_block
#define mean_x mccvirtualsource_mean_x
#define mean_y mccvirtualsource_mean_y
#define mean_z mccvirtualsource_mean_z
#define end_reading mccvirtualsource_end_reading
#define n_count_extrapolated mccvirtualsource_n_count_extrapolated
#define repeat_cnt mccvirtualsource_repeat_cnt
{   /* Declarations of virtualsource=Virtual_input() SETTING parameters. */
char* filename = mccvirtualsource_filename;
MCNUM verbose = mccvirtualsource_verbose;
MCNUM repeat_count = mccvirtualsource_repeat_count;
MCNUM smooth = mccvirtualsource_smooth;
MCNUM display = mccvirtualsource_display;
#line 335 "/usr/share/mcstas/2.5/sources/Virtual_input.comp"
{
  Table_Free(&rTable);
  if (!filename_ncount) {
    printf("Warning: Virtual_input: %s: filename '%s' was not used entirely.\n"
           "               Intensities may be wrong. Increase ncount value\n",
           NAME_CURRENT_COMP, filename);
  } else {
    double tmp;
    tmp = (double)mcget_ncount()/filename_ncount;
    if (fabs(rint(tmp)/tmp-1) > 0.02)
      printf("Warning: Virtual_input: %s: simulation finished in the middle of filename '%s'\n"
             "               ncount=%g but filename contains %g events\n"
             "               Intensities may be wrong.\n"
             "               Increase ncount value to %g or higher.\n",
	     NAME_CURRENT_COMP, filename, (double)mcget_ncount(), filename_ncount, filename_ncount*repeat_cnt);
    if (mcget_ncount() < filename_ncount*repeat_cnt)
      printf("Warning: Virtual_input: %s: not all source %s repetitions were generated.\n"
             "               Intensities may be wrong.\n"
             "               Increase ncount value to %g or higher.\n",
             NAME_CURRENT_COMP, filename, filename_ncount*repeat_cnt);
  }
}
#line 69462 "RITA-II.c"
}   /* End of virtualsource=Virtual_input() SETTING parameter declarations. */
#undef repeat_cnt
#undef n_count_extrapolated
#undef end_reading
#undef mean_z
#undef mean_y
#undef mean_x
#undef first_block
#undef max_vz
#undef max_vy
#undef max_vx
#undef min_vz
#undef min_vy
#undef min_vx
#undef max_z
#undef max_y
#undef max_x
#undef min_z
#undef min_y
#undef min_x
#undef n_neutrons
#undef mean_dz
#undef mean_dy
#undef mean_dx
#undef mean_vz
#undef mean_vy
#undef mean_vx
#undef filename_ncount
#undef repeat_number
#undef rTable
#undef Offset
#undef nrows
#undef pos
#undef read_block
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[63]) fprintf(stderr, "Warning: No neutron could reach Component[63] virtualsource\n");
    if (mcAbsorbProp[63]) fprintf(stderr, "Warning: %g events were removed in Component[63] virtualsource=Virtual_input()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[63]);
  /* User FINALLY code for component 'OrderMon'. */
  SIG_MESSAGE("OrderMon (Finally)");
#define mccompcurname  OrderMon
#define mccompcurtype  Monitor_nD
#define mccompcurindex 64
#define user1 mccOrderMon_user1
#define user2 mccOrderMon_user2
#define user3 mccOrderMon_user3
#define DEFS mccOrderMon_DEFS
#define Vars mccOrderMon_Vars
#define detector mccOrderMon_detector
#define offdata mccOrderMon_offdata
{   /* Declarations of OrderMon=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccOrderMon_xwidth;
MCNUM yheight = mccOrderMon_yheight;
MCNUM zdepth = mccOrderMon_zdepth;
MCNUM xmin = mccOrderMon_xmin;
MCNUM xmax = mccOrderMon_xmax;
MCNUM ymin = mccOrderMon_ymin;
MCNUM ymax = mccOrderMon_ymax;
MCNUM zmin = mccOrderMon_zmin;
MCNUM zmax = mccOrderMon_zmax;
MCNUM bins = mccOrderMon_bins;
MCNUM min = mccOrderMon_min;
MCNUM max = mccOrderMon_max;
MCNUM restore_neutron = mccOrderMon_restore_neutron;
MCNUM radius = mccOrderMon_radius;
char* options = mccOrderMon_options;
char* filename = mccOrderMon_filename;
char* geometry = mccOrderMon_geometry;
char* username1 = mccOrderMon_username1;
char* username2 = mccOrderMon_username2;
char* username3 = mccOrderMon_username3;
int nowritefile = mccOrderMon_nowritefile;
#line 486 "/usr/share/mcstas/2.5/monitors/Monitor_nD.comp"
{
  /* free pointers */
  if (!nowritefile) {
    Monitor_nD_Finally(&DEFS, &Vars);
  }
}
#line 69544 "RITA-II.c"
}   /* End of OrderMon=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[64]) fprintf(stderr, "Warning: No neutron could reach Component[64] OrderMon\n");
    if (mcAbsorbProp[64]) fprintf(stderr, "Warning: %g events were removed in Component[64] OrderMon=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[64]);
    if (!mcNCounter[65]) fprintf(stderr, "Warning: No neutron could reach Component[65] kMoni\n");
    if (mcAbsorbProp[65]) fprintf(stderr, "Warning: %g events were removed in Component[65] kMoni=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[65]);
    if (!mcNCounter[66]) fprintf(stderr, "Warning: No neutron could reach Component[66] kMoni1st\n");
    if (mcAbsorbProp[66]) fprintf(stderr, "Warning: %g events were removed in Component[66] kMoni1st=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[66]);
    if (!mcNCounter[67]) fprintf(stderr, "Warning: No neutron could reach Component[67] kMoni2nd\n");
    if (mcAbsorbProp[67]) fprintf(stderr, "Warning: %g events were removed in Component[67] kMoni2nd=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[67]);
    if (!mcNCounter[68]) fprintf(stderr, "Warning: No neutron could reach Component[68] kMoni3rd\n");
    if (mcAbsorbProp[68]) fprintf(stderr, "Warning: %g events were removed in Component[68] kMoni3rd=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[68]);
    if (!mcNCounter[69]) fprintf(stderr, "Warning: No neutron could reach Component[69] slitMonochromator\n");
    if (mcAbsorbProp[69]) fprintf(stderr, "Warning: %g events were removed in Component[69] slitMonochromator=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[69]);
    if (!mcNCounter[70]) fprintf(stderr, "Warning: No neutron could reach Component[70] Perspex\n");
    if (mcAbsorbProp[70]) fprintf(stderr, "Warning: %g events were removed in Component[70] Perspex=Incoherent()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[70]);
    if (!mcNCounter[71]) fprintf(stderr, "Warning: No neutron could reach Component[71] psd_samplepos_1cm2\n");
    if (mcAbsorbProp[71]) fprintf(stderr, "Warning: %g events were removed in Component[71] psd_samplepos_1cm2=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[71]);
    if (!mcNCounter[72]) fprintf(stderr, "Warning: No neutron could reach Component[72] emon_samplepos_1cm2\n");
    if (mcAbsorbProp[72]) fprintf(stderr, "Warning: %g events were removed in Component[72] emon_samplepos_1cm2=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[72]);
    if (!mcNCounter[73]) fprintf(stderr, "Warning: No neutron could reach Component[73] divmon_samplepos_1cm2\n");
    if (mcAbsorbProp[73]) fprintf(stderr, "Warning: %g events were removed in Component[73] divmon_samplepos_1cm2=Divergence_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[73]);
    if (!mcNCounter[74]) fprintf(stderr, "Warning: No neutron could reach Component[74] psd_samplepos_large\n");
    if (mcAbsorbProp[74]) fprintf(stderr, "Warning: %g events were removed in Component[74] psd_samplepos_large=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[74]);
    if (!mcNCounter[75]) fprintf(stderr, "Warning: No neutron could reach Component[75] a3\n");
    if (mcNCounter[75] < 1000*(SPLITREP)) fprintf(stderr, 
"Warning: Number of events %g reaching SPLIT position Component[75] a3=Arm()\n"
"         is probably too low. Increase Ncount.\n", mcNCounter[75]);

    if (mcAbsorbProp[75]) fprintf(stderr, "Warning: %g events were removed in Component[75] a3=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[75]);
    if (!mcNCounter[76]) fprintf(stderr, "Warning: No neutron could reach Component[76] aa3\n");
    if (mcAbsorbProp[76]) fprintf(stderr, "Warning: %g events were removed in Component[76] aa3=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[76]);
    if (!mcNCounter[77]) fprintf(stderr, "Warning: No neutron could reach Component[77] incohSample\n");
    if (mcAbsorbProp[77]) fprintf(stderr, "Warning: %g events were removed in Component[77] incohSample=Incoherent()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[77]);
  /* User FINALLY code for component 'powderSample'. */
  SIG_MESSAGE("powderSample (Finally)");
#define mccompcurname  powderSample
#define mccompcurtype  PowderN
#define mccompcurindex 78
#define format mccpowderSample_format
#define line_info mccpowderSample_line_info
#define columns mccpowderSample_columns
#define offdata mccpowderSample_offdata
{   /* Declarations of powderSample=PowderN() SETTING parameters. */
char* reflections = mccpowderSample_reflections;
char* geometry = mccpowderSample_geometry;
MCNUM radius = mccpowderSample_radius;
MCNUM yheight = mccpowderSample_yheight;
MCNUM xwidth = mccpowderSample_xwidth;
MCNUM zdepth = mccpowderSample_zdepth;
MCNUM thickness = mccpowderSample_thickness;
MCNUM pack = mccpowderSample_pack;
MCNUM Vc = mccpowderSample_Vc;
MCNUM sigma_abs = mccpowderSample_sigma_abs;
MCNUM sigma_inc = mccpowderSample_sigma_inc;
MCNUM delta_d_d = mccpowderSample_delta_d_d;
MCNUM p_inc = mccpowderSample_p_inc;
MCNUM p_transmit = mccpowderSample_p_transmit;
MCNUM DW = mccpowderSample_DW;
MCNUM nb_atoms = mccpowderSample_nb_atoms;
MCNUM d_omega = mccpowderSample_d_omega;
MCNUM d_phi = mccpowderSample_d_phi;
MCNUM tth_sign = mccpowderSample_tth_sign;
MCNUM p_interact = mccpowderSample_p_interact;
MCNUM concentric = mccpowderSample_concentric;
MCNUM density = mccpowderSample_density;
MCNUM weight = mccpowderSample_weight;
MCNUM barns = mccpowderSample_barns;
MCNUM Strain = mccpowderSample_Strain;
MCNUM focus_flip = mccpowderSample_focus_flip;
int target_index = mccpowderSample_target_index;
#line 1086 "/usr/share/mcstas/2.5/samples/PowderN.comp"
{
  free(line_info.list);
  free(line_info.q_v);
  free(line_info.w_v);
  free(line_info.my_s_v2);
  MPI_MASTER(
  if (line_info.flag_warning)
    printf("PowderN: %s: Error messages were repeated %i times with absorbed neutrons.\n",
      NAME_CURRENT_COMP, line_info.flag_warning);

  /* in case this instance is used in a SPLIT, we can recommend the
     optimal iteration value */
  if (line_info.nb_refl_count) {
    double split_iterations = (double)line_info.nb_reuses/line_info.nb_refl_count + 1;
    double split_optimal    = (double)line_info.nb_refl/line_info.nb_refl_count;
    if (split_optimal > split_iterations + 5)
      printf("PowderN: %s: Info: you may highly improve the computation efficiency by using\n"
        "    SPLIT %i COMPONENT %s=PowderN(...)\n"
        "  in the instrument description %s.\n",
        NAME_CURRENT_COMP, (int)split_optimal, NAME_CURRENT_COMP, mcinstrument_source);
  }
  );

}
#line 69648 "RITA-II.c"
}   /* End of powderSample=PowderN() SETTING parameter declarations. */
#undef offdata
#undef columns
#undef line_info
#undef format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[78]) fprintf(stderr, "Warning: No neutron could reach Component[78] powderSample\n");
    if (mcAbsorbProp[78]) fprintf(stderr, "Warning: %g events were removed in Component[78] powderSample=PowderN()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[78]);
  /* User FINALLY code for component 'crystalSample'. */
  SIG_MESSAGE("crystalSample (Finally)");
#define mccompcurname  crystalSample
#define mccompcurtype  Single_crystal
#define mccompcurindex 79
#define mosaic_AB mcccrystalSample_mosaic_AB
#define hkl_info mcccrystalSample_hkl_info
#define offdata mcccrystalSample_offdata
{   /* Declarations of crystalSample=Single_crystal() SETTING parameters. */
char* reflections = mcccrystalSample_reflections;
char* geometry = mcccrystalSample_geometry;
MCNUM xwidth = mcccrystalSample_xwidth;
MCNUM yheight = mcccrystalSample_yheight;
MCNUM zdepth = mcccrystalSample_zdepth;
MCNUM radius = mcccrystalSample_radius;
MCNUM delta_d_d = mcccrystalSample_delta_d_d;
MCNUM mosaic = mcccrystalSample_mosaic;
MCNUM mosaic_a = mcccrystalSample_mosaic_a;
MCNUM mosaic_b = mcccrystalSample_mosaic_b;
MCNUM mosaic_c = mcccrystalSample_mosaic_c;
MCNUM recip_cell = mcccrystalSample_recip_cell;
MCNUM barns = mcccrystalSample_barns;
MCNUM ax = mcccrystalSample_ax;
MCNUM ay = mcccrystalSample_ay;
MCNUM az = mcccrystalSample_az;
MCNUM bx = mcccrystalSample_bx;
MCNUM by = mcccrystalSample_by;
MCNUM bz = mcccrystalSample_bz;
MCNUM cx = mcccrystalSample_cx;
MCNUM cy = mcccrystalSample_cy;
MCNUM cz = mcccrystalSample_cz;
MCNUM p_transmit = mcccrystalSample_p_transmit;
MCNUM sigma_abs = mcccrystalSample_sigma_abs;
MCNUM sigma_inc = mcccrystalSample_sigma_inc;
MCNUM aa = mcccrystalSample_aa;
MCNUM bb = mcccrystalSample_bb;
MCNUM cc = mcccrystalSample_cc;
MCNUM order = mcccrystalSample_order;
MCNUM RX = mcccrystalSample_RX;
MCNUM RY = mcccrystalSample_RY;
MCNUM powder = mcccrystalSample_powder;
MCNUM PG = mcccrystalSample_PG;
MCNUM deltak = mcccrystalSample_deltak;
#line 1400 "/usr/share/mcstas/2.5/samples/Single_crystal.comp"
{
  MPI_MASTER(
  if (hkl_info.flag_warning)
    fprintf(stderr, "Single_crystal: %s: Error message was repeated %i times with absorbed neutrons.\n",
      NAME_CURRENT_COMP, hkl_info.flag_warning);

  /* in case this instance is used in a SPLIT, we can recommend the
     optimal iteration value */
  if (hkl_info.nb_refl_count) {
    double split_iterations = (double)hkl_info.nb_reuses/hkl_info.nb_refl_count + 1;
    double split_optimal    = (double)hkl_info.nb_refl/hkl_info.nb_refl_count;
    if (split_optimal > split_iterations + 2)
      printf("Single_crystal: %s: Info: you may highly improve the computation efficiency by using\n"
        "    SPLIT %i COMPONENT %s=Single_crystal(order=1, ...)\n"
        "  in the instrument description %s.\n",
        NAME_CURRENT_COMP, (int)split_optimal, NAME_CURRENT_COMP, mcinstrument_source);
  }
  );
}
#line 69723 "RITA-II.c"
}   /* End of crystalSample=Single_crystal() SETTING parameter declarations. */
#undef offdata
#undef hkl_info
#undef mosaic_AB
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[79]) fprintf(stderr, "Warning: No neutron could reach Component[79] crystalSample\n");
    if (mcAbsorbProp[79]) fprintf(stderr, "Warning: %g events were removed in Component[79] crystalSample=Single_crystal()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[79]);
    if (!mcNCounter[80]) fprintf(stderr, "Warning: No neutron could reach Component[80] phononSample\n");
    if (mcAbsorbProp[80]) fprintf(stderr, "Warning: %g events were removed in Component[80] phononSample=Phonon_simple()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[80]);
    if (!mcNCounter[81]) fprintf(stderr, "Warning: No neutron could reach Component[81] psd_4pi\n");
    if (mcAbsorbProp[81]) fprintf(stderr, "Warning: %g events were removed in Component[81] psd_4pi=PSD_monitor_4PI()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[81]);
    if (!mcNCounter[82]) fprintf(stderr, "Warning: No neutron could reach Component[82] a4\n");
    if (mcAbsorbProp[82]) fprintf(stderr, "Warning: %g events were removed in Component[82] a4=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[82]);
    if (!mcNCounter[83]) fprintf(stderr, "Warning: No neutron could reach Component[83] slitSample\n");
    if (mcAbsorbProp[83]) fprintf(stderr, "Warning: %g events were removed in Component[83] slitSample=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[83]);
    if (!mcNCounter[84]) fprintf(stderr, "Warning: No neutron could reach Component[84] filter_coll\n");
    if (mcAbsorbProp[84]) fprintf(stderr, "Warning: %g events were removed in Component[84] filter_coll=Exact_radial_coll()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[84]);
  /* User FINALLY code for component 'filter'. */
  SIG_MESSAGE("filter (Finally)");
#define mccompcurname  filter
#define mccompcurtype  Filter_gen
#define mccompcurindex 85
#define pTable mccfilter_pTable
#define Mode_Table mccfilter_Mode_Table
#define Type_Table mccfilter_Type_Table
{   /* Declarations of filter=Filter_gen() SETTING parameters. */
char* filename = mccfilter_filename;
char* options = mccfilter_options;
MCNUM xmin = mccfilter_xmin;
MCNUM xmax = mccfilter_xmax;
MCNUM ymin = mccfilter_ymin;
MCNUM ymax = mccfilter_ymax;
MCNUM xwidth = mccfilter_xwidth;
MCNUM yheight = mccfilter_yheight;
MCNUM thickness = mccfilter_thickness;
MCNUM scaling = mccfilter_scaling;
MCNUM verbose = mccfilter_verbose;
#line 203 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  Table_Free(&pTable);
}
#line 69768 "RITA-II.c"
}   /* End of filter=Filter_gen() SETTING parameter declarations. */
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[85]) fprintf(stderr, "Warning: No neutron could reach Component[85] filter\n");
    if (mcAbsorbProp[85]) fprintf(stderr, "Warning: %g events were removed in Component[85] filter=Filter_gen()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[85]);
    if (!mcNCounter[86]) fprintf(stderr, "Warning: No neutron could reach Component[86] ana_slit1\n");
    if (mcAbsorbProp[86]) fprintf(stderr, "Warning: %g events were removed in Component[86] ana_slit1=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[86]);
    if (!mcNCounter[87]) fprintf(stderr, "Warning: No neutron could reach Component[87] ana_slit2\n");
    if (mcAbsorbProp[87]) fprintf(stderr, "Warning: %g events were removed in Component[87] ana_slit2=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[87]);
    if (!mcNCounter[88]) fprintf(stderr, "Warning: No neutron could reach Component[88] emon_before_ana\n");
    if (mcAbsorbProp[88]) fprintf(stderr, "Warning: %g events were removed in Component[88] emon_before_ana=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[88]);
    if (!mcNCounter[89]) fprintf(stderr, "Warning: No neutron could reach Component[89] psd_before_ana\n");
    if (mcAbsorbProp[89]) fprintf(stderr, "Warning: %g events were removed in Component[89] psd_before_ana=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[89]);
    if (!mcNCounter[90]) fprintf(stderr, "Warning: No neutron could reach Component[90] divmon_before_ana\n");
    if (mcAbsorbProp[90]) fprintf(stderr, "Warning: %g events were removed in Component[90] divmon_before_ana=Divergence_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[90]);
    if (!mcNCounter[91]) fprintf(stderr, "Warning: No neutron could reach Component[91] focus_ana\n");
    if (mcNCounter[91] < 1000*(SPLITAREP)) fprintf(stderr, 
"Warning: Number of events %g reaching SPLIT position Component[91] focus_ana=Arm()\n"
"         is probably too low. Increase Ncount.\n", mcNCounter[91]);

    if (mcAbsorbProp[91]) fprintf(stderr, "Warning: %g events were removed in Component[91] focus_ana=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[91]);
    if (!mcNCounter[92]) fprintf(stderr, "Warning: No neutron could reach Component[92] an1l\n");
    if (mcAbsorbProp[92]) fprintf(stderr, "Warning: %g events were removed in Component[92] an1l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[92]);
    if (!mcNCounter[93]) fprintf(stderr, "Warning: No neutron could reach Component[93] an1u\n");
    if (mcAbsorbProp[93]) fprintf(stderr, "Warning: %g events were removed in Component[93] an1u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[93]);
    if (!mcNCounter[94]) fprintf(stderr, "Warning: No neutron could reach Component[94] an2l\n");
    if (mcAbsorbProp[94]) fprintf(stderr, "Warning: %g events were removed in Component[94] an2l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[94]);
    if (!mcNCounter[95]) fprintf(stderr, "Warning: No neutron could reach Component[95] an2u\n");
    if (mcAbsorbProp[95]) fprintf(stderr, "Warning: %g events were removed in Component[95] an2u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[95]);
    if (!mcNCounter[96]) fprintf(stderr, "Warning: No neutron could reach Component[96] an3l\n");
    if (mcAbsorbProp[96]) fprintf(stderr, "Warning: %g events were removed in Component[96] an3l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[96]);
    if (!mcNCounter[97]) fprintf(stderr, "Warning: No neutron could reach Component[97] an3u\n");
    if (mcAbsorbProp[97]) fprintf(stderr, "Warning: %g events were removed in Component[97] an3u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[97]);
    if (!mcNCounter[98]) fprintf(stderr, "Warning: No neutron could reach Component[98] an4l\n");
    if (mcAbsorbProp[98]) fprintf(stderr, "Warning: %g events were removed in Component[98] an4l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[98]);
    if (!mcNCounter[99]) fprintf(stderr, "Warning: No neutron could reach Component[99] an4u\n");
    if (mcAbsorbProp[99]) fprintf(stderr, "Warning: %g events were removed in Component[99] an4u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[99]);
    if (!mcNCounter[100]) fprintf(stderr, "Warning: No neutron could reach Component[100] an5l\n");
    if (mcAbsorbProp[100]) fprintf(stderr, "Warning: %g events were removed in Component[100] an5l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[100]);
    if (!mcNCounter[101]) fprintf(stderr, "Warning: No neutron could reach Component[101] an5u\n");
    if (mcAbsorbProp[101]) fprintf(stderr, "Warning: %g events were removed in Component[101] an5u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[101]);
    if (!mcNCounter[102]) fprintf(stderr, "Warning: No neutron could reach Component[102] an6l\n");
    if (mcAbsorbProp[102]) fprintf(stderr, "Warning: %g events were removed in Component[102] an6l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[102]);
    if (!mcNCounter[103]) fprintf(stderr, "Warning: No neutron could reach Component[103] an6u\n");
    if (mcAbsorbProp[103]) fprintf(stderr, "Warning: %g events were removed in Component[103] an6u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[103]);
    if (!mcNCounter[104]) fprintf(stderr, "Warning: No neutron could reach Component[104] an7l\n");
    if (mcAbsorbProp[104]) fprintf(stderr, "Warning: %g events were removed in Component[104] an7l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[104]);
    if (!mcNCounter[105]) fprintf(stderr, "Warning: No neutron could reach Component[105] an7u\n");
    if (mcAbsorbProp[105]) fprintf(stderr, "Warning: %g events were removed in Component[105] an7u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[105]);
    if (!mcNCounter[106]) fprintf(stderr, "Warning: No neutron could reach Component[106] an8l\n");
    if (mcAbsorbProp[106]) fprintf(stderr, "Warning: %g events were removed in Component[106] an8l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[106]);
    if (!mcNCounter[107]) fprintf(stderr, "Warning: No neutron could reach Component[107] an8u\n");
    if (mcAbsorbProp[107]) fprintf(stderr, "Warning: %g events were removed in Component[107] an8u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[107]);
    if (!mcNCounter[108]) fprintf(stderr, "Warning: No neutron could reach Component[108] an9l\n");
    if (mcAbsorbProp[108]) fprintf(stderr, "Warning: %g events were removed in Component[108] an9l=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[108]);
    if (!mcNCounter[109]) fprintf(stderr, "Warning: No neutron could reach Component[109] an9u\n");
    if (mcAbsorbProp[109]) fprintf(stderr, "Warning: %g events were removed in Component[109] an9u=Monochromator_flat()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[109]);
    if (!mcNCounter[110]) fprintf(stderr, "Warning: No neutron could reach Component[110] a6\n");
    if (mcAbsorbProp[110]) fprintf(stderr, "Warning: %g events were removed in Component[110] a6=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[110]);
    if (!mcNCounter[111]) fprintf(stderr, "Warning: No neutron could reach Component[111] emon_before_coarse\n");
    if (mcAbsorbProp[111]) fprintf(stderr, "Warning: %g events were removed in Component[111] emon_before_coarse=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[111]);
    if (!mcNCounter[112]) fprintf(stderr, "Warning: No neutron could reach Component[112] psd_before_coarse\n");
    if (mcAbsorbProp[112]) fprintf(stderr, "Warning: %g events were removed in Component[112] psd_before_coarse=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[112]);
    if (!mcNCounter[113]) fprintf(stderr, "Warning: No neutron could reach Component[113] ArmR1\n");
    if (mcAbsorbProp[113]) fprintf(stderr, "Warning: %g events were removed in Component[113] ArmR1=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[113]);
    if (!mcNCounter[114]) fprintf(stderr, "Warning: No neutron could reach Component[114] BladeR1\n");
    if (mcAbsorbProp[114]) fprintf(stderr, "Warning: %g events were removed in Component[114] BladeR1=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[114]);
    if (!mcNCounter[115]) fprintf(stderr, "Warning: No neutron could reach Component[115] ArmR2\n");
    if (mcAbsorbProp[115]) fprintf(stderr, "Warning: %g events were removed in Component[115] ArmR2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[115]);
    if (!mcNCounter[116]) fprintf(stderr, "Warning: No neutron could reach Component[116] BladeR2\n");
    if (mcAbsorbProp[116]) fprintf(stderr, "Warning: %g events were removed in Component[116] BladeR2=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[116]);
    if (!mcNCounter[117]) fprintf(stderr, "Warning: No neutron could reach Component[117] ArmR3\n");
    if (mcAbsorbProp[117]) fprintf(stderr, "Warning: %g events were removed in Component[117] ArmR3=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[117]);
    if (!mcNCounter[118]) fprintf(stderr, "Warning: No neutron could reach Component[118] BladeR3\n");
    if (mcAbsorbProp[118]) fprintf(stderr, "Warning: %g events were removed in Component[118] BladeR3=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[118]);
    if (!mcNCounter[119]) fprintf(stderr, "Warning: No neutron could reach Component[119] ArmR4\n");
    if (mcAbsorbProp[119]) fprintf(stderr, "Warning: %g events were removed in Component[119] ArmR4=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[119]);
    if (!mcNCounter[120]) fprintf(stderr, "Warning: No neutron could reach Component[120] BladeR4\n");
    if (mcAbsorbProp[120]) fprintf(stderr, "Warning: %g events were removed in Component[120] BladeR4=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[120]);
    if (!mcNCounter[121]) fprintf(stderr, "Warning: No neutron could reach Component[121] ArmR5\n");
    if (mcAbsorbProp[121]) fprintf(stderr, "Warning: %g events were removed in Component[121] ArmR5=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[121]);
    if (!mcNCounter[122]) fprintf(stderr, "Warning: No neutron could reach Component[122] BladeR5\n");
    if (mcAbsorbProp[122]) fprintf(stderr, "Warning: %g events were removed in Component[122] BladeR5=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[122]);
    if (!mcNCounter[123]) fprintf(stderr, "Warning: No neutron could reach Component[123] ArmL1\n");
    if (mcAbsorbProp[123]) fprintf(stderr, "Warning: %g events were removed in Component[123] ArmL1=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[123]);
    if (!mcNCounter[124]) fprintf(stderr, "Warning: No neutron could reach Component[124] BladeL1\n");
    if (mcAbsorbProp[124]) fprintf(stderr, "Warning: %g events were removed in Component[124] BladeL1=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[124]);
    if (!mcNCounter[125]) fprintf(stderr, "Warning: No neutron could reach Component[125] ArmL2\n");
    if (mcAbsorbProp[125]) fprintf(stderr, "Warning: %g events were removed in Component[125] ArmL2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[125]);
    if (!mcNCounter[126]) fprintf(stderr, "Warning: No neutron could reach Component[126] BladeL2\n");
    if (mcAbsorbProp[126]) fprintf(stderr, "Warning: %g events were removed in Component[126] BladeL2=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[126]);
    if (!mcNCounter[127]) fprintf(stderr, "Warning: No neutron could reach Component[127] ArmL3\n");
    if (mcAbsorbProp[127]) fprintf(stderr, "Warning: %g events were removed in Component[127] ArmL3=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[127]);
    if (!mcNCounter[128]) fprintf(stderr, "Warning: No neutron could reach Component[128] BladeL3\n");
    if (mcAbsorbProp[128]) fprintf(stderr, "Warning: %g events were removed in Component[128] BladeL3=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[128]);
    if (!mcNCounter[129]) fprintf(stderr, "Warning: No neutron could reach Component[129] ArmL4\n");
    if (mcAbsorbProp[129]) fprintf(stderr, "Warning: %g events were removed in Component[129] ArmL4=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[129]);
    if (!mcNCounter[130]) fprintf(stderr, "Warning: No neutron could reach Component[130] BladeL4\n");
    if (mcAbsorbProp[130]) fprintf(stderr, "Warning: %g events were removed in Component[130] BladeL4=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[130]);
    if (!mcNCounter[131]) fprintf(stderr, "Warning: No neutron could reach Component[131] ArmL5\n");
    if (mcAbsorbProp[131]) fprintf(stderr, "Warning: %g events were removed in Component[131] ArmL5=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[131]);
    if (!mcNCounter[132]) fprintf(stderr, "Warning: No neutron could reach Component[132] BladeL5\n");
    if (mcAbsorbProp[132]) fprintf(stderr, "Warning: %g events were removed in Component[132] BladeL5=Absorber()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[132]);
    if (!mcNCounter[133]) fprintf(stderr, "Warning: No neutron could reach Component[133] psd_detector\n");
    if (mcAbsorbProp[133]) fprintf(stderr, "Warning: %g events were removed in Component[133] psd_detector=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[133]);
    if (!mcNCounter[134]) fprintf(stderr, "Warning: No neutron could reach Component[134] emon_detector\n");
    if (mcAbsorbProp[134]) fprintf(stderr, "Warning: %g events were removed in Component[134] emon_detector=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[134]);
    if (!mcNCounter[135]) fprintf(stderr, "Warning: No neutron could reach Component[135] psd_window1\n");
    if (mcAbsorbProp[135]) fprintf(stderr, "Warning: %g events were removed in Component[135] psd_window1=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[135]);
    if (!mcNCounter[136]) fprintf(stderr, "Warning: No neutron could reach Component[136] emon_window1\n");
    if (mcAbsorbProp[136]) fprintf(stderr, "Warning: %g events were removed in Component[136] emon_window1=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[136]);
    if (!mcNCounter[137]) fprintf(stderr, "Warning: No neutron could reach Component[137] psd_window2\n");
    if (mcAbsorbProp[137]) fprintf(stderr, "Warning: %g events were removed in Component[137] psd_window2=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[137]);
    if (!mcNCounter[138]) fprintf(stderr, "Warning: No neutron could reach Component[138] emon_window2\n");
    if (mcAbsorbProp[138]) fprintf(stderr, "Warning: %g events were removed in Component[138] emon_window2=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[138]);
    if (!mcNCounter[139]) fprintf(stderr, "Warning: No neutron could reach Component[139] psd_window3\n");
    if (mcAbsorbProp[139]) fprintf(stderr, "Warning: %g events were removed in Component[139] psd_window3=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[139]);
    if (!mcNCounter[140]) fprintf(stderr, "Warning: No neutron could reach Component[140] emon_window3\n");
    if (mcAbsorbProp[140]) fprintf(stderr, "Warning: %g events were removed in Component[140] emon_window3=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[140]);
    if (!mcNCounter[141]) fprintf(stderr, "Warning: No neutron could reach Component[141] psd_window4\n");
    if (mcAbsorbProp[141]) fprintf(stderr, "Warning: %g events were removed in Component[141] psd_window4=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[141]);
    if (!mcNCounter[142]) fprintf(stderr, "Warning: No neutron could reach Component[142] emon_window4\n");
    if (mcAbsorbProp[142]) fprintf(stderr, "Warning: %g events were removed in Component[142] emon_window4=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[142]);
    if (!mcNCounter[143]) fprintf(stderr, "Warning: No neutron could reach Component[143] psd_window5\n");
    if (mcAbsorbProp[143]) fprintf(stderr, "Warning: %g events were removed in Component[143] psd_window5=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[143]);
    if (!mcNCounter[144]) fprintf(stderr, "Warning: No neutron could reach Component[144] emon_window5\n");
    if (mcAbsorbProp[144]) fprintf(stderr, "Warning: %g events were removed in Component[144] emon_window5=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[144]);
    if (!mcNCounter[145]) fprintf(stderr, "Warning: No neutron could reach Component[145] psd_window6\n");
    if (mcAbsorbProp[145]) fprintf(stderr, "Warning: %g events were removed in Component[145] psd_window6=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[145]);
    if (!mcNCounter[146]) fprintf(stderr, "Warning: No neutron could reach Component[146] emon_window6\n");
    if (mcAbsorbProp[146]) fprintf(stderr, "Warning: %g events were removed in Component[146] emon_window6=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[146]);
    if (!mcNCounter[147]) fprintf(stderr, "Warning: No neutron could reach Component[147] psd_window7\n");
    if (mcAbsorbProp[147]) fprintf(stderr, "Warning: %g events were removed in Component[147] psd_window7=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[147]);
    if (!mcNCounter[148]) fprintf(stderr, "Warning: No neutron could reach Component[148] emon_window7\n");
    if (mcAbsorbProp[148]) fprintf(stderr, "Warning: %g events were removed in Component[148] emon_window7=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[148]);
    if (!mcNCounter[149]) fprintf(stderr, "Warning: No neutron could reach Component[149] psd_window8\n");
    if (mcAbsorbProp[149]) fprintf(stderr, "Warning: %g events were removed in Component[149] psd_window8=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[149]);
    if (!mcNCounter[150]) fprintf(stderr, "Warning: No neutron could reach Component[150] emon_window8\n");
    if (mcAbsorbProp[150]) fprintf(stderr, "Warning: %g events were removed in Component[150] emon_window8=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[150]);
    if (!mcNCounter[151]) fprintf(stderr, "Warning: No neutron could reach Component[151] psd_window9\n");
    if (mcAbsorbProp[151]) fprintf(stderr, "Warning: %g events were removed in Component[151] psd_window9=PSD_monitor_psf_eff()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[151]);
    if (!mcNCounter[152]) fprintf(stderr, "Warning: No neutron could reach Component[152] emon_window9\n");
    if (mcAbsorbProp[152]) fprintf(stderr, "Warning: %g events were removed in Component[152] emon_window9=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[152]);
  mcsiminfo_close(); 
} /* end finally */
#define magnify mcdis_magnify
#define line mcdis_line
#define dashed_line mcdis_dashed_line
#define multiline mcdis_multiline
#define rectangle mcdis_rectangle
#define box mcdis_box
#define circle mcdis_circle
#define cylinder mcdis_cylinder
#define sphere mcdis_sphere
void mcdisplay(void) {
  printf("MCDISPLAY: start\n");
  /* Components MCDISPLAY code. */

  /* MCDISPLAY code for component 'armSource'. */
  SIG_MESSAGE("armSource (McDisplay)");
  printf("MCDISPLAY: component %s\n", "armSource");
#define mccompcurname  armSource
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccarmSource_IntermediateCnts
#define StartTime mccarmSource_StartTime
#define EndTime mccarmSource_EndTime
#define CurrentTime mccarmSource_CurrentTime
{   /* Declarations of armSource=Progress_bar() SETTING parameters. */
char* profile = mccarmSource_profile;
MCNUM percent = mccarmSource_percent;
MCNUM flag_save = mccarmSource_flag_save;
MCNUM minutes = mccarmSource_minutes;
#line 147 "/usr/share/mcstas/2.5/misc/Progress_bar.comp"
{
  
}
#line 69948 "RITA-II.c"
}   /* End of armSource=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'source'. */
  SIG_MESSAGE("source (McDisplay)");
  printf("MCDISPLAY: component %s\n", "source");
#define mccompcurname  source
#define mccompcurtype  Source_gen4
#define mccompcurindex 2
#define flux_file mccsource_flux_file
#define xdiv_file mccsource_xdiv_file
#define ydiv_file mccsource_ydiv_file
#define p_in mccsource_p_in
#define lambda0 mccsource_lambda0
#define lambda02 mccsource_lambda02
#define L2P mccsource_L2P
#define lambda0b mccsource_lambda0b
#define lambda02b mccsource_lambda02b
#define L2Pb mccsource_L2Pb
#define lambda0c mccsource_lambda0c
#define lambda02c mccsource_lambda02c
#define L2Pc mccsource_L2Pc
#define pTable mccsource_pTable
#define pTable_x mccsource_pTable_x
#define pTable_y mccsource_pTable_y
{   /* Declarations of source=Source_gen4() SETTING parameters. */
MCNUM radius = mccsource_radius;
MCNUM dist = mccsource_dist;
MCNUM xw = mccsource_xw;
MCNUM yh = mccsource_yh;
MCNUM E0 = mccsource_E0;
MCNUM dE = mccsource_dE;
MCNUM Lambda0 = mccsource_Lambda0;
MCNUM dLambda = mccsource_dLambda;
MCNUM I1 = mccsource_I1;
MCNUM h = mccsource_h;
MCNUM w = mccsource_w;
MCNUM gaussian = mccsource_gaussian;
MCNUM verbose = mccsource_verbose;
MCNUM T1 = mccsource_T1;
MCNUM flux_file_perAA = mccsource_flux_file_perAA;
MCNUM flux_file_log = mccsource_flux_file_log;
MCNUM Lmin = mccsource_Lmin;
MCNUM Lmax = mccsource_Lmax;
MCNUM Emin = mccsource_Emin;
MCNUM Emax = mccsource_Emax;
MCNUM T2 = mccsource_T2;
MCNUM I2 = mccsource_I2;
MCNUM T3 = mccsource_T3;
MCNUM I3 = mccsource_I3;
MCNUM length = mccsource_length;
MCNUM phi_init = mccsource_phi_init;
MCNUM theta_init = mccsource_theta_init;
MCNUM HEtailA = mccsource_HEtailA;
MCNUM HEtailL0 = mccsource_HEtailL0;
#line 589 "/usr/share/mcstas/2.5/contrib/Source_gen4.comp"
{
  double xmin;
  double xmax;
  double ymin;
  double ymax;

  if ((h == 0) || (w == 0))
  {
    
    circle("xy",0,0,0,radius);
    if (gaussian)
      circle("xy",0,0,0,radius/2);
  }
  else
  {
    xmin = -w/2; xmax = w/2;
    ymin = -h/2; ymax = h/2;

    
    multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
    if (gaussian)
      circle("xy",0,0,0,sqrt(w*w+h*h)/4);
  }
}
#line 70039 "RITA-II.c"
}   /* End of source=Source_gen4() SETTING parameter declarations. */
#undef pTable_y
#undef pTable_x
#undef pTable
#undef L2Pc
#undef lambda02c
#undef lambda0c
#undef L2Pb
#undef lambda02b
#undef lambda0b
#undef L2P
#undef lambda02
#undef lambda0
#undef p_in
#undef ydiv_file
#undef xdiv_file
#undef flux_file
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'slitGuideBegin'. */
  SIG_MESSAGE("slitGuideBegin (McDisplay)");
  printf("MCDISPLAY: component %s\n", "slitGuideBegin");
#define mccompcurname  slitGuideBegin
#define mccompcurtype  Slit
#define mccompcurindex 3
{   /* Declarations of slitGuideBegin=Slit() SETTING parameters. */
MCNUM xmin = mccslitGuideBegin_xmin;
MCNUM xmax = mccslitGuideBegin_xmax;
MCNUM ymin = mccslitGuideBegin_ymin;
MCNUM ymax = mccslitGuideBegin_ymax;
MCNUM radius = mccslitGuideBegin_radius;
MCNUM xwidth = mccslitGuideBegin_xwidth;
MCNUM yheight = mccslitGuideBegin_yheight;
#line 81 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 70098 "RITA-II.c"
}   /* End of slitGuideBegin=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'lmon_guide_start'. */
  SIG_MESSAGE("lmon_guide_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "lmon_guide_start");
#define mccompcurname  lmon_guide_start
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mcclmon_guide_start_nL
#define L_N mcclmon_guide_start_L_N
#define L_p mcclmon_guide_start_L_p
#define L_p2 mcclmon_guide_start_L_p2
{   /* Declarations of lmon_guide_start=L_monitor() SETTING parameters. */
char* filename = mcclmon_guide_start_filename;
MCNUM xmin = mcclmon_guide_start_xmin;
MCNUM xmax = mcclmon_guide_start_xmax;
MCNUM ymin = mcclmon_guide_start_ymin;
MCNUM ymax = mcclmon_guide_start_ymax;
MCNUM xwidth = mcclmon_guide_start_xwidth;
MCNUM yheight = mcclmon_guide_start_yheight;
MCNUM Lmin = mcclmon_guide_start_Lmin;
MCNUM Lmax = mcclmon_guide_start_Lmax;
MCNUM restore_neutron = mcclmon_guide_start_restore_neutron;
int nowritefile = mcclmon_guide_start_nowritefile;
#line 120 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 70135 "RITA-II.c"
}   /* End of lmon_guide_start=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideStraight'. */
  SIG_MESSAGE("guideStraight (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideStraight");
#define mccompcurname  guideStraight
#define mccompcurtype  Guide
#define mccompcurindex 5
#define pTable mccguideStraight_pTable
{   /* Declarations of guideStraight=Guide() SETTING parameters. */
char* reflect = mccguideStraight_reflect;
MCNUM w1 = mccguideStraight_w1;
MCNUM h1 = mccguideStraight_h1;
MCNUM w2 = mccguideStraight_w2;
MCNUM h2 = mccguideStraight_h2;
MCNUM l = mccguideStraight_l;
MCNUM R0 = mccguideStraight_R0;
MCNUM Qc = mccguideStraight_Qc;
MCNUM alpha = mccguideStraight_alpha;
MCNUM m = mccguideStraight_m;
MCNUM W = mccguideStraight_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70184 "RITA-II.c"
}   /* End of guideStraight=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved1'. */
  SIG_MESSAGE("guideCurved1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved1");
#define mccompcurname  guideCurved1
#define mccompcurtype  Guide
#define mccompcurindex 6
#define pTable mccguideCurved1_pTable
{   /* Declarations of guideCurved1=Guide() SETTING parameters. */
char* reflect = mccguideCurved1_reflect;
MCNUM w1 = mccguideCurved1_w1;
MCNUM h1 = mccguideCurved1_h1;
MCNUM w2 = mccguideCurved1_w2;
MCNUM h2 = mccguideCurved1_h2;
MCNUM l = mccguideCurved1_l;
MCNUM R0 = mccguideCurved1_R0;
MCNUM Qc = mccguideCurved1_Qc;
MCNUM alpha = mccguideCurved1_alpha;
MCNUM m = mccguideCurved1_m;
MCNUM W = mccguideCurved1_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70230 "RITA-II.c"
}   /* End of guideCurved1=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved2'. */
  SIG_MESSAGE("guideCurved2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved2");
#define mccompcurname  guideCurved2
#define mccompcurtype  Guide
#define mccompcurindex 7
#define pTable mccguideCurved2_pTable
{   /* Declarations of guideCurved2=Guide() SETTING parameters. */
char* reflect = mccguideCurved2_reflect;
MCNUM w1 = mccguideCurved2_w1;
MCNUM h1 = mccguideCurved2_h1;
MCNUM w2 = mccguideCurved2_w2;
MCNUM h2 = mccguideCurved2_h2;
MCNUM l = mccguideCurved2_l;
MCNUM R0 = mccguideCurved2_R0;
MCNUM Qc = mccguideCurved2_Qc;
MCNUM alpha = mccguideCurved2_alpha;
MCNUM m = mccguideCurved2_m;
MCNUM W = mccguideCurved2_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70276 "RITA-II.c"
}   /* End of guideCurved2=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved3'. */
  SIG_MESSAGE("guideCurved3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved3");
#define mccompcurname  guideCurved3
#define mccompcurtype  Guide
#define mccompcurindex 8
#define pTable mccguideCurved3_pTable
{   /* Declarations of guideCurved3=Guide() SETTING parameters. */
char* reflect = mccguideCurved3_reflect;
MCNUM w1 = mccguideCurved3_w1;
MCNUM h1 = mccguideCurved3_h1;
MCNUM w2 = mccguideCurved3_w2;
MCNUM h2 = mccguideCurved3_h2;
MCNUM l = mccguideCurved3_l;
MCNUM R0 = mccguideCurved3_R0;
MCNUM Qc = mccguideCurved3_Qc;
MCNUM alpha = mccguideCurved3_alpha;
MCNUM m = mccguideCurved3_m;
MCNUM W = mccguideCurved3_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70322 "RITA-II.c"
}   /* End of guideCurved3=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved4'. */
  SIG_MESSAGE("guideCurved4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved4");
#define mccompcurname  guideCurved4
#define mccompcurtype  Guide
#define mccompcurindex 9
#define pTable mccguideCurved4_pTable
{   /* Declarations of guideCurved4=Guide() SETTING parameters. */
char* reflect = mccguideCurved4_reflect;
MCNUM w1 = mccguideCurved4_w1;
MCNUM h1 = mccguideCurved4_h1;
MCNUM w2 = mccguideCurved4_w2;
MCNUM h2 = mccguideCurved4_h2;
MCNUM l = mccguideCurved4_l;
MCNUM R0 = mccguideCurved4_R0;
MCNUM Qc = mccguideCurved4_Qc;
MCNUM alpha = mccguideCurved4_alpha;
MCNUM m = mccguideCurved4_m;
MCNUM W = mccguideCurved4_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70368 "RITA-II.c"
}   /* End of guideCurved4=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved5'. */
  SIG_MESSAGE("guideCurved5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved5");
#define mccompcurname  guideCurved5
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccguideCurved5_pTable
{   /* Declarations of guideCurved5=Guide() SETTING parameters. */
char* reflect = mccguideCurved5_reflect;
MCNUM w1 = mccguideCurved5_w1;
MCNUM h1 = mccguideCurved5_h1;
MCNUM w2 = mccguideCurved5_w2;
MCNUM h2 = mccguideCurved5_h2;
MCNUM l = mccguideCurved5_l;
MCNUM R0 = mccguideCurved5_R0;
MCNUM Qc = mccguideCurved5_Qc;
MCNUM alpha = mccguideCurved5_alpha;
MCNUM m = mccguideCurved5_m;
MCNUM W = mccguideCurved5_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70414 "RITA-II.c"
}   /* End of guideCurved5=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved6'. */
  SIG_MESSAGE("guideCurved6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved6");
#define mccompcurname  guideCurved6
#define mccompcurtype  Guide
#define mccompcurindex 11
#define pTable mccguideCurved6_pTable
{   /* Declarations of guideCurved6=Guide() SETTING parameters. */
char* reflect = mccguideCurved6_reflect;
MCNUM w1 = mccguideCurved6_w1;
MCNUM h1 = mccguideCurved6_h1;
MCNUM w2 = mccguideCurved6_w2;
MCNUM h2 = mccguideCurved6_h2;
MCNUM l = mccguideCurved6_l;
MCNUM R0 = mccguideCurved6_R0;
MCNUM Qc = mccguideCurved6_Qc;
MCNUM alpha = mccguideCurved6_alpha;
MCNUM m = mccguideCurved6_m;
MCNUM W = mccguideCurved6_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70460 "RITA-II.c"
}   /* End of guideCurved6=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved7'. */
  SIG_MESSAGE("guideCurved7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved7");
#define mccompcurname  guideCurved7
#define mccompcurtype  Guide
#define mccompcurindex 12
#define pTable mccguideCurved7_pTable
{   /* Declarations of guideCurved7=Guide() SETTING parameters. */
char* reflect = mccguideCurved7_reflect;
MCNUM w1 = mccguideCurved7_w1;
MCNUM h1 = mccguideCurved7_h1;
MCNUM w2 = mccguideCurved7_w2;
MCNUM h2 = mccguideCurved7_h2;
MCNUM l = mccguideCurved7_l;
MCNUM R0 = mccguideCurved7_R0;
MCNUM Qc = mccguideCurved7_Qc;
MCNUM alpha = mccguideCurved7_alpha;
MCNUM m = mccguideCurved7_m;
MCNUM W = mccguideCurved7_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70506 "RITA-II.c"
}   /* End of guideCurved7=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved8'. */
  SIG_MESSAGE("guideCurved8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved8");
#define mccompcurname  guideCurved8
#define mccompcurtype  Guide
#define mccompcurindex 13
#define pTable mccguideCurved8_pTable
{   /* Declarations of guideCurved8=Guide() SETTING parameters. */
char* reflect = mccguideCurved8_reflect;
MCNUM w1 = mccguideCurved8_w1;
MCNUM h1 = mccguideCurved8_h1;
MCNUM w2 = mccguideCurved8_w2;
MCNUM h2 = mccguideCurved8_h2;
MCNUM l = mccguideCurved8_l;
MCNUM R0 = mccguideCurved8_R0;
MCNUM Qc = mccguideCurved8_Qc;
MCNUM alpha = mccguideCurved8_alpha;
MCNUM m = mccguideCurved8_m;
MCNUM W = mccguideCurved8_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70552 "RITA-II.c"
}   /* End of guideCurved8=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved9'. */
  SIG_MESSAGE("guideCurved9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved9");
#define mccompcurname  guideCurved9
#define mccompcurtype  Guide
#define mccompcurindex 14
#define pTable mccguideCurved9_pTable
{   /* Declarations of guideCurved9=Guide() SETTING parameters. */
char* reflect = mccguideCurved9_reflect;
MCNUM w1 = mccguideCurved9_w1;
MCNUM h1 = mccguideCurved9_h1;
MCNUM w2 = mccguideCurved9_w2;
MCNUM h2 = mccguideCurved9_h2;
MCNUM l = mccguideCurved9_l;
MCNUM R0 = mccguideCurved9_R0;
MCNUM Qc = mccguideCurved9_Qc;
MCNUM alpha = mccguideCurved9_alpha;
MCNUM m = mccguideCurved9_m;
MCNUM W = mccguideCurved9_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70598 "RITA-II.c"
}   /* End of guideCurved9=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved10'. */
  SIG_MESSAGE("guideCurved10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved10");
#define mccompcurname  guideCurved10
#define mccompcurtype  Guide
#define mccompcurindex 15
#define pTable mccguideCurved10_pTable
{   /* Declarations of guideCurved10=Guide() SETTING parameters. */
char* reflect = mccguideCurved10_reflect;
MCNUM w1 = mccguideCurved10_w1;
MCNUM h1 = mccguideCurved10_h1;
MCNUM w2 = mccguideCurved10_w2;
MCNUM h2 = mccguideCurved10_h2;
MCNUM l = mccguideCurved10_l;
MCNUM R0 = mccguideCurved10_R0;
MCNUM Qc = mccguideCurved10_Qc;
MCNUM alpha = mccguideCurved10_alpha;
MCNUM m = mccguideCurved10_m;
MCNUM W = mccguideCurved10_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70644 "RITA-II.c"
}   /* End of guideCurved10=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved11'. */
  SIG_MESSAGE("guideCurved11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved11");
#define mccompcurname  guideCurved11
#define mccompcurtype  Guide
#define mccompcurindex 16
#define pTable mccguideCurved11_pTable
{   /* Declarations of guideCurved11=Guide() SETTING parameters. */
char* reflect = mccguideCurved11_reflect;
MCNUM w1 = mccguideCurved11_w1;
MCNUM h1 = mccguideCurved11_h1;
MCNUM w2 = mccguideCurved11_w2;
MCNUM h2 = mccguideCurved11_h2;
MCNUM l = mccguideCurved11_l;
MCNUM R0 = mccguideCurved11_R0;
MCNUM Qc = mccguideCurved11_Qc;
MCNUM alpha = mccguideCurved11_alpha;
MCNUM m = mccguideCurved11_m;
MCNUM W = mccguideCurved11_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70690 "RITA-II.c"
}   /* End of guideCurved11=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved12'. */
  SIG_MESSAGE("guideCurved12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved12");
#define mccompcurname  guideCurved12
#define mccompcurtype  Guide
#define mccompcurindex 17
#define pTable mccguideCurved12_pTable
{   /* Declarations of guideCurved12=Guide() SETTING parameters. */
char* reflect = mccguideCurved12_reflect;
MCNUM w1 = mccguideCurved12_w1;
MCNUM h1 = mccguideCurved12_h1;
MCNUM w2 = mccguideCurved12_w2;
MCNUM h2 = mccguideCurved12_h2;
MCNUM l = mccguideCurved12_l;
MCNUM R0 = mccguideCurved12_R0;
MCNUM Qc = mccguideCurved12_Qc;
MCNUM alpha = mccguideCurved12_alpha;
MCNUM m = mccguideCurved12_m;
MCNUM W = mccguideCurved12_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70736 "RITA-II.c"
}   /* End of guideCurved12=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved13'. */
  SIG_MESSAGE("guideCurved13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved13");
#define mccompcurname  guideCurved13
#define mccompcurtype  Guide
#define mccompcurindex 18
#define pTable mccguideCurved13_pTable
{   /* Declarations of guideCurved13=Guide() SETTING parameters. */
char* reflect = mccguideCurved13_reflect;
MCNUM w1 = mccguideCurved13_w1;
MCNUM h1 = mccguideCurved13_h1;
MCNUM w2 = mccguideCurved13_w2;
MCNUM h2 = mccguideCurved13_h2;
MCNUM l = mccguideCurved13_l;
MCNUM R0 = mccguideCurved13_R0;
MCNUM Qc = mccguideCurved13_Qc;
MCNUM alpha = mccguideCurved13_alpha;
MCNUM m = mccguideCurved13_m;
MCNUM W = mccguideCurved13_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70782 "RITA-II.c"
}   /* End of guideCurved13=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved14'. */
  SIG_MESSAGE("guideCurved14 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved14");
#define mccompcurname  guideCurved14
#define mccompcurtype  Guide
#define mccompcurindex 19
#define pTable mccguideCurved14_pTable
{   /* Declarations of guideCurved14=Guide() SETTING parameters. */
char* reflect = mccguideCurved14_reflect;
MCNUM w1 = mccguideCurved14_w1;
MCNUM h1 = mccguideCurved14_h1;
MCNUM w2 = mccguideCurved14_w2;
MCNUM h2 = mccguideCurved14_h2;
MCNUM l = mccguideCurved14_l;
MCNUM R0 = mccguideCurved14_R0;
MCNUM Qc = mccguideCurved14_Qc;
MCNUM alpha = mccguideCurved14_alpha;
MCNUM m = mccguideCurved14_m;
MCNUM W = mccguideCurved14_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70828 "RITA-II.c"
}   /* End of guideCurved14=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved15'. */
  SIG_MESSAGE("guideCurved15 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved15");
#define mccompcurname  guideCurved15
#define mccompcurtype  Guide
#define mccompcurindex 20
#define pTable mccguideCurved15_pTable
{   /* Declarations of guideCurved15=Guide() SETTING parameters. */
char* reflect = mccguideCurved15_reflect;
MCNUM w1 = mccguideCurved15_w1;
MCNUM h1 = mccguideCurved15_h1;
MCNUM w2 = mccguideCurved15_w2;
MCNUM h2 = mccguideCurved15_h2;
MCNUM l = mccguideCurved15_l;
MCNUM R0 = mccguideCurved15_R0;
MCNUM Qc = mccguideCurved15_Qc;
MCNUM alpha = mccguideCurved15_alpha;
MCNUM m = mccguideCurved15_m;
MCNUM W = mccguideCurved15_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70874 "RITA-II.c"
}   /* End of guideCurved15=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved16'. */
  SIG_MESSAGE("guideCurved16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved16");
#define mccompcurname  guideCurved16
#define mccompcurtype  Guide
#define mccompcurindex 21
#define pTable mccguideCurved16_pTable
{   /* Declarations of guideCurved16=Guide() SETTING parameters. */
char* reflect = mccguideCurved16_reflect;
MCNUM w1 = mccguideCurved16_w1;
MCNUM h1 = mccguideCurved16_h1;
MCNUM w2 = mccguideCurved16_w2;
MCNUM h2 = mccguideCurved16_h2;
MCNUM l = mccguideCurved16_l;
MCNUM R0 = mccguideCurved16_R0;
MCNUM Qc = mccguideCurved16_Qc;
MCNUM alpha = mccguideCurved16_alpha;
MCNUM m = mccguideCurved16_m;
MCNUM W = mccguideCurved16_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70920 "RITA-II.c"
}   /* End of guideCurved16=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved17'. */
  SIG_MESSAGE("guideCurved17 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved17");
#define mccompcurname  guideCurved17
#define mccompcurtype  Guide
#define mccompcurindex 22
#define pTable mccguideCurved17_pTable
{   /* Declarations of guideCurved17=Guide() SETTING parameters. */
char* reflect = mccguideCurved17_reflect;
MCNUM w1 = mccguideCurved17_w1;
MCNUM h1 = mccguideCurved17_h1;
MCNUM w2 = mccguideCurved17_w2;
MCNUM h2 = mccguideCurved17_h2;
MCNUM l = mccguideCurved17_l;
MCNUM R0 = mccguideCurved17_R0;
MCNUM Qc = mccguideCurved17_Qc;
MCNUM alpha = mccguideCurved17_alpha;
MCNUM m = mccguideCurved17_m;
MCNUM W = mccguideCurved17_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 70966 "RITA-II.c"
}   /* End of guideCurved17=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved18'. */
  SIG_MESSAGE("guideCurved18 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved18");
#define mccompcurname  guideCurved18
#define mccompcurtype  Guide
#define mccompcurindex 23
#define pTable mccguideCurved18_pTable
{   /* Declarations of guideCurved18=Guide() SETTING parameters. */
char* reflect = mccguideCurved18_reflect;
MCNUM w1 = mccguideCurved18_w1;
MCNUM h1 = mccguideCurved18_h1;
MCNUM w2 = mccguideCurved18_w2;
MCNUM h2 = mccguideCurved18_h2;
MCNUM l = mccguideCurved18_l;
MCNUM R0 = mccguideCurved18_R0;
MCNUM Qc = mccguideCurved18_Qc;
MCNUM alpha = mccguideCurved18_alpha;
MCNUM m = mccguideCurved18_m;
MCNUM W = mccguideCurved18_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71012 "RITA-II.c"
}   /* End of guideCurved18=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved19'. */
  SIG_MESSAGE("guideCurved19 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved19");
#define mccompcurname  guideCurved19
#define mccompcurtype  Guide
#define mccompcurindex 24
#define pTable mccguideCurved19_pTable
{   /* Declarations of guideCurved19=Guide() SETTING parameters. */
char* reflect = mccguideCurved19_reflect;
MCNUM w1 = mccguideCurved19_w1;
MCNUM h1 = mccguideCurved19_h1;
MCNUM w2 = mccguideCurved19_w2;
MCNUM h2 = mccguideCurved19_h2;
MCNUM l = mccguideCurved19_l;
MCNUM R0 = mccguideCurved19_R0;
MCNUM Qc = mccguideCurved19_Qc;
MCNUM alpha = mccguideCurved19_alpha;
MCNUM m = mccguideCurved19_m;
MCNUM W = mccguideCurved19_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71058 "RITA-II.c"
}   /* End of guideCurved19=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved20'. */
  SIG_MESSAGE("guideCurved20 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved20");
#define mccompcurname  guideCurved20
#define mccompcurtype  Guide
#define mccompcurindex 25
#define pTable mccguideCurved20_pTable
{   /* Declarations of guideCurved20=Guide() SETTING parameters. */
char* reflect = mccguideCurved20_reflect;
MCNUM w1 = mccguideCurved20_w1;
MCNUM h1 = mccguideCurved20_h1;
MCNUM w2 = mccguideCurved20_w2;
MCNUM h2 = mccguideCurved20_h2;
MCNUM l = mccguideCurved20_l;
MCNUM R0 = mccguideCurved20_R0;
MCNUM Qc = mccguideCurved20_Qc;
MCNUM alpha = mccguideCurved20_alpha;
MCNUM m = mccguideCurved20_m;
MCNUM W = mccguideCurved20_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71104 "RITA-II.c"
}   /* End of guideCurved20=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved21'. */
  SIG_MESSAGE("guideCurved21 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved21");
#define mccompcurname  guideCurved21
#define mccompcurtype  Guide
#define mccompcurindex 26
#define pTable mccguideCurved21_pTable
{   /* Declarations of guideCurved21=Guide() SETTING parameters. */
char* reflect = mccguideCurved21_reflect;
MCNUM w1 = mccguideCurved21_w1;
MCNUM h1 = mccguideCurved21_h1;
MCNUM w2 = mccguideCurved21_w2;
MCNUM h2 = mccguideCurved21_h2;
MCNUM l = mccguideCurved21_l;
MCNUM R0 = mccguideCurved21_R0;
MCNUM Qc = mccguideCurved21_Qc;
MCNUM alpha = mccguideCurved21_alpha;
MCNUM m = mccguideCurved21_m;
MCNUM W = mccguideCurved21_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71150 "RITA-II.c"
}   /* End of guideCurved21=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved22'. */
  SIG_MESSAGE("guideCurved22 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved22");
#define mccompcurname  guideCurved22
#define mccompcurtype  Guide
#define mccompcurindex 27
#define pTable mccguideCurved22_pTable
{   /* Declarations of guideCurved22=Guide() SETTING parameters. */
char* reflect = mccguideCurved22_reflect;
MCNUM w1 = mccguideCurved22_w1;
MCNUM h1 = mccguideCurved22_h1;
MCNUM w2 = mccguideCurved22_w2;
MCNUM h2 = mccguideCurved22_h2;
MCNUM l = mccguideCurved22_l;
MCNUM R0 = mccguideCurved22_R0;
MCNUM Qc = mccguideCurved22_Qc;
MCNUM alpha = mccguideCurved22_alpha;
MCNUM m = mccguideCurved22_m;
MCNUM W = mccguideCurved22_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71196 "RITA-II.c"
}   /* End of guideCurved22=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved23'. */
  SIG_MESSAGE("guideCurved23 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved23");
#define mccompcurname  guideCurved23
#define mccompcurtype  Guide
#define mccompcurindex 28
#define pTable mccguideCurved23_pTable
{   /* Declarations of guideCurved23=Guide() SETTING parameters. */
char* reflect = mccguideCurved23_reflect;
MCNUM w1 = mccguideCurved23_w1;
MCNUM h1 = mccguideCurved23_h1;
MCNUM w2 = mccguideCurved23_w2;
MCNUM h2 = mccguideCurved23_h2;
MCNUM l = mccguideCurved23_l;
MCNUM R0 = mccguideCurved23_R0;
MCNUM Qc = mccguideCurved23_Qc;
MCNUM alpha = mccguideCurved23_alpha;
MCNUM m = mccguideCurved23_m;
MCNUM W = mccguideCurved23_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71242 "RITA-II.c"
}   /* End of guideCurved23=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved24'. */
  SIG_MESSAGE("guideCurved24 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved24");
#define mccompcurname  guideCurved24
#define mccompcurtype  Guide
#define mccompcurindex 29
#define pTable mccguideCurved24_pTable
{   /* Declarations of guideCurved24=Guide() SETTING parameters. */
char* reflect = mccguideCurved24_reflect;
MCNUM w1 = mccguideCurved24_w1;
MCNUM h1 = mccguideCurved24_h1;
MCNUM w2 = mccguideCurved24_w2;
MCNUM h2 = mccguideCurved24_h2;
MCNUM l = mccguideCurved24_l;
MCNUM R0 = mccguideCurved24_R0;
MCNUM Qc = mccguideCurved24_Qc;
MCNUM alpha = mccguideCurved24_alpha;
MCNUM m = mccguideCurved24_m;
MCNUM W = mccguideCurved24_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71288 "RITA-II.c"
}   /* End of guideCurved24=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved25'. */
  SIG_MESSAGE("guideCurved25 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved25");
#define mccompcurname  guideCurved25
#define mccompcurtype  Guide
#define mccompcurindex 30
#define pTable mccguideCurved25_pTable
{   /* Declarations of guideCurved25=Guide() SETTING parameters. */
char* reflect = mccguideCurved25_reflect;
MCNUM w1 = mccguideCurved25_w1;
MCNUM h1 = mccguideCurved25_h1;
MCNUM w2 = mccguideCurved25_w2;
MCNUM h2 = mccguideCurved25_h2;
MCNUM l = mccguideCurved25_l;
MCNUM R0 = mccguideCurved25_R0;
MCNUM Qc = mccguideCurved25_Qc;
MCNUM alpha = mccguideCurved25_alpha;
MCNUM m = mccguideCurved25_m;
MCNUM W = mccguideCurved25_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71334 "RITA-II.c"
}   /* End of guideCurved25=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved26'. */
  SIG_MESSAGE("guideCurved26 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved26");
#define mccompcurname  guideCurved26
#define mccompcurtype  Guide
#define mccompcurindex 31
#define pTable mccguideCurved26_pTable
{   /* Declarations of guideCurved26=Guide() SETTING parameters. */
char* reflect = mccguideCurved26_reflect;
MCNUM w1 = mccguideCurved26_w1;
MCNUM h1 = mccguideCurved26_h1;
MCNUM w2 = mccguideCurved26_w2;
MCNUM h2 = mccguideCurved26_h2;
MCNUM l = mccguideCurved26_l;
MCNUM R0 = mccguideCurved26_R0;
MCNUM Qc = mccguideCurved26_Qc;
MCNUM alpha = mccguideCurved26_alpha;
MCNUM m = mccguideCurved26_m;
MCNUM W = mccguideCurved26_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71380 "RITA-II.c"
}   /* End of guideCurved26=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved27'. */
  SIG_MESSAGE("guideCurved27 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved27");
#define mccompcurname  guideCurved27
#define mccompcurtype  Guide
#define mccompcurindex 32
#define pTable mccguideCurved27_pTable
{   /* Declarations of guideCurved27=Guide() SETTING parameters. */
char* reflect = mccguideCurved27_reflect;
MCNUM w1 = mccguideCurved27_w1;
MCNUM h1 = mccguideCurved27_h1;
MCNUM w2 = mccguideCurved27_w2;
MCNUM h2 = mccguideCurved27_h2;
MCNUM l = mccguideCurved27_l;
MCNUM R0 = mccguideCurved27_R0;
MCNUM Qc = mccguideCurved27_Qc;
MCNUM alpha = mccguideCurved27_alpha;
MCNUM m = mccguideCurved27_m;
MCNUM W = mccguideCurved27_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71426 "RITA-II.c"
}   /* End of guideCurved27=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved28'. */
  SIG_MESSAGE("guideCurved28 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved28");
#define mccompcurname  guideCurved28
#define mccompcurtype  Guide
#define mccompcurindex 33
#define pTable mccguideCurved28_pTable
{   /* Declarations of guideCurved28=Guide() SETTING parameters. */
char* reflect = mccguideCurved28_reflect;
MCNUM w1 = mccguideCurved28_w1;
MCNUM h1 = mccguideCurved28_h1;
MCNUM w2 = mccguideCurved28_w2;
MCNUM h2 = mccguideCurved28_h2;
MCNUM l = mccguideCurved28_l;
MCNUM R0 = mccguideCurved28_R0;
MCNUM Qc = mccguideCurved28_Qc;
MCNUM alpha = mccguideCurved28_alpha;
MCNUM m = mccguideCurved28_m;
MCNUM W = mccguideCurved28_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71472 "RITA-II.c"
}   /* End of guideCurved28=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved29'. */
  SIG_MESSAGE("guideCurved29 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved29");
#define mccompcurname  guideCurved29
#define mccompcurtype  Guide
#define mccompcurindex 34
#define pTable mccguideCurved29_pTable
{   /* Declarations of guideCurved29=Guide() SETTING parameters. */
char* reflect = mccguideCurved29_reflect;
MCNUM w1 = mccguideCurved29_w1;
MCNUM h1 = mccguideCurved29_h1;
MCNUM w2 = mccguideCurved29_w2;
MCNUM h2 = mccguideCurved29_h2;
MCNUM l = mccguideCurved29_l;
MCNUM R0 = mccguideCurved29_R0;
MCNUM Qc = mccguideCurved29_Qc;
MCNUM alpha = mccguideCurved29_alpha;
MCNUM m = mccguideCurved29_m;
MCNUM W = mccguideCurved29_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71518 "RITA-II.c"
}   /* End of guideCurved29=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved30'. */
  SIG_MESSAGE("guideCurved30 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved30");
#define mccompcurname  guideCurved30
#define mccompcurtype  Guide
#define mccompcurindex 35
#define pTable mccguideCurved30_pTable
{   /* Declarations of guideCurved30=Guide() SETTING parameters. */
char* reflect = mccguideCurved30_reflect;
MCNUM w1 = mccguideCurved30_w1;
MCNUM h1 = mccguideCurved30_h1;
MCNUM w2 = mccguideCurved30_w2;
MCNUM h2 = mccguideCurved30_h2;
MCNUM l = mccguideCurved30_l;
MCNUM R0 = mccguideCurved30_R0;
MCNUM Qc = mccguideCurved30_Qc;
MCNUM alpha = mccguideCurved30_alpha;
MCNUM m = mccguideCurved30_m;
MCNUM W = mccguideCurved30_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71564 "RITA-II.c"
}   /* End of guideCurved30=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved31'. */
  SIG_MESSAGE("guideCurved31 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved31");
#define mccompcurname  guideCurved31
#define mccompcurtype  Guide
#define mccompcurindex 36
#define pTable mccguideCurved31_pTable
{   /* Declarations of guideCurved31=Guide() SETTING parameters. */
char* reflect = mccguideCurved31_reflect;
MCNUM w1 = mccguideCurved31_w1;
MCNUM h1 = mccguideCurved31_h1;
MCNUM w2 = mccguideCurved31_w2;
MCNUM h2 = mccguideCurved31_h2;
MCNUM l = mccguideCurved31_l;
MCNUM R0 = mccguideCurved31_R0;
MCNUM Qc = mccguideCurved31_Qc;
MCNUM alpha = mccguideCurved31_alpha;
MCNUM m = mccguideCurved31_m;
MCNUM W = mccguideCurved31_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71610 "RITA-II.c"
}   /* End of guideCurved31=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved32'. */
  SIG_MESSAGE("guideCurved32 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved32");
#define mccompcurname  guideCurved32
#define mccompcurtype  Guide
#define mccompcurindex 37
#define pTable mccguideCurved32_pTable
{   /* Declarations of guideCurved32=Guide() SETTING parameters. */
char* reflect = mccguideCurved32_reflect;
MCNUM w1 = mccguideCurved32_w1;
MCNUM h1 = mccguideCurved32_h1;
MCNUM w2 = mccguideCurved32_w2;
MCNUM h2 = mccguideCurved32_h2;
MCNUM l = mccguideCurved32_l;
MCNUM R0 = mccguideCurved32_R0;
MCNUM Qc = mccguideCurved32_Qc;
MCNUM alpha = mccguideCurved32_alpha;
MCNUM m = mccguideCurved32_m;
MCNUM W = mccguideCurved32_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71656 "RITA-II.c"
}   /* End of guideCurved32=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved33'. */
  SIG_MESSAGE("guideCurved33 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved33");
#define mccompcurname  guideCurved33
#define mccompcurtype  Guide
#define mccompcurindex 38
#define pTable mccguideCurved33_pTable
{   /* Declarations of guideCurved33=Guide() SETTING parameters. */
char* reflect = mccguideCurved33_reflect;
MCNUM w1 = mccguideCurved33_w1;
MCNUM h1 = mccguideCurved33_h1;
MCNUM w2 = mccguideCurved33_w2;
MCNUM h2 = mccguideCurved33_h2;
MCNUM l = mccguideCurved33_l;
MCNUM R0 = mccguideCurved33_R0;
MCNUM Qc = mccguideCurved33_Qc;
MCNUM alpha = mccguideCurved33_alpha;
MCNUM m = mccguideCurved33_m;
MCNUM W = mccguideCurved33_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71702 "RITA-II.c"
}   /* End of guideCurved33=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved34'. */
  SIG_MESSAGE("guideCurved34 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved34");
#define mccompcurname  guideCurved34
#define mccompcurtype  Guide
#define mccompcurindex 39
#define pTable mccguideCurved34_pTable
{   /* Declarations of guideCurved34=Guide() SETTING parameters. */
char* reflect = mccguideCurved34_reflect;
MCNUM w1 = mccguideCurved34_w1;
MCNUM h1 = mccguideCurved34_h1;
MCNUM w2 = mccguideCurved34_w2;
MCNUM h2 = mccguideCurved34_h2;
MCNUM l = mccguideCurved34_l;
MCNUM R0 = mccguideCurved34_R0;
MCNUM Qc = mccguideCurved34_Qc;
MCNUM alpha = mccguideCurved34_alpha;
MCNUM m = mccguideCurved34_m;
MCNUM W = mccguideCurved34_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71748 "RITA-II.c"
}   /* End of guideCurved34=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved35'. */
  SIG_MESSAGE("guideCurved35 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved35");
#define mccompcurname  guideCurved35
#define mccompcurtype  Guide
#define mccompcurindex 40
#define pTable mccguideCurved35_pTable
{   /* Declarations of guideCurved35=Guide() SETTING parameters. */
char* reflect = mccguideCurved35_reflect;
MCNUM w1 = mccguideCurved35_w1;
MCNUM h1 = mccguideCurved35_h1;
MCNUM w2 = mccguideCurved35_w2;
MCNUM h2 = mccguideCurved35_h2;
MCNUM l = mccguideCurved35_l;
MCNUM R0 = mccguideCurved35_R0;
MCNUM Qc = mccguideCurved35_Qc;
MCNUM alpha = mccguideCurved35_alpha;
MCNUM m = mccguideCurved35_m;
MCNUM W = mccguideCurved35_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71794 "RITA-II.c"
}   /* End of guideCurved35=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved36'. */
  SIG_MESSAGE("guideCurved36 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved36");
#define mccompcurname  guideCurved36
#define mccompcurtype  Guide
#define mccompcurindex 41
#define pTable mccguideCurved36_pTable
{   /* Declarations of guideCurved36=Guide() SETTING parameters. */
char* reflect = mccguideCurved36_reflect;
MCNUM w1 = mccguideCurved36_w1;
MCNUM h1 = mccguideCurved36_h1;
MCNUM w2 = mccguideCurved36_w2;
MCNUM h2 = mccguideCurved36_h2;
MCNUM l = mccguideCurved36_l;
MCNUM R0 = mccguideCurved36_R0;
MCNUM Qc = mccguideCurved36_Qc;
MCNUM alpha = mccguideCurved36_alpha;
MCNUM m = mccguideCurved36_m;
MCNUM W = mccguideCurved36_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71840 "RITA-II.c"
}   /* End of guideCurved36=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved37'. */
  SIG_MESSAGE("guideCurved37 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved37");
#define mccompcurname  guideCurved37
#define mccompcurtype  Guide
#define mccompcurindex 42
#define pTable mccguideCurved37_pTable
{   /* Declarations of guideCurved37=Guide() SETTING parameters. */
char* reflect = mccguideCurved37_reflect;
MCNUM w1 = mccguideCurved37_w1;
MCNUM h1 = mccguideCurved37_h1;
MCNUM w2 = mccguideCurved37_w2;
MCNUM h2 = mccguideCurved37_h2;
MCNUM l = mccguideCurved37_l;
MCNUM R0 = mccguideCurved37_R0;
MCNUM Qc = mccguideCurved37_Qc;
MCNUM alpha = mccguideCurved37_alpha;
MCNUM m = mccguideCurved37_m;
MCNUM W = mccguideCurved37_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71886 "RITA-II.c"
}   /* End of guideCurved37=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved38'. */
  SIG_MESSAGE("guideCurved38 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved38");
#define mccompcurname  guideCurved38
#define mccompcurtype  Guide
#define mccompcurindex 43
#define pTable mccguideCurved38_pTable
{   /* Declarations of guideCurved38=Guide() SETTING parameters. */
char* reflect = mccguideCurved38_reflect;
MCNUM w1 = mccguideCurved38_w1;
MCNUM h1 = mccguideCurved38_h1;
MCNUM w2 = mccguideCurved38_w2;
MCNUM h2 = mccguideCurved38_h2;
MCNUM l = mccguideCurved38_l;
MCNUM R0 = mccguideCurved38_R0;
MCNUM Qc = mccguideCurved38_Qc;
MCNUM alpha = mccguideCurved38_alpha;
MCNUM m = mccguideCurved38_m;
MCNUM W = mccguideCurved38_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71932 "RITA-II.c"
}   /* End of guideCurved38=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved39'. */
  SIG_MESSAGE("guideCurved39 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved39");
#define mccompcurname  guideCurved39
#define mccompcurtype  Guide
#define mccompcurindex 44
#define pTable mccguideCurved39_pTable
{   /* Declarations of guideCurved39=Guide() SETTING parameters. */
char* reflect = mccguideCurved39_reflect;
MCNUM w1 = mccguideCurved39_w1;
MCNUM h1 = mccguideCurved39_h1;
MCNUM w2 = mccguideCurved39_w2;
MCNUM h2 = mccguideCurved39_h2;
MCNUM l = mccguideCurved39_l;
MCNUM R0 = mccguideCurved39_R0;
MCNUM Qc = mccguideCurved39_Qc;
MCNUM alpha = mccguideCurved39_alpha;
MCNUM m = mccguideCurved39_m;
MCNUM W = mccguideCurved39_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 71978 "RITA-II.c"
}   /* End of guideCurved39=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guideCurved40'. */
  SIG_MESSAGE("guideCurved40 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guideCurved40");
#define mccompcurname  guideCurved40
#define mccompcurtype  Guide
#define mccompcurindex 45
#define pTable mccguideCurved40_pTable
{   /* Declarations of guideCurved40=Guide() SETTING parameters. */
char* reflect = mccguideCurved40_reflect;
MCNUM w1 = mccguideCurved40_w1;
MCNUM h1 = mccguideCurved40_h1;
MCNUM w2 = mccguideCurved40_w2;
MCNUM h2 = mccguideCurved40_h2;
MCNUM l = mccguideCurved40_l;
MCNUM R0 = mccguideCurved40_R0;
MCNUM Qc = mccguideCurved40_Qc;
MCNUM alpha = mccguideCurved40_alpha;
MCNUM m = mccguideCurved40_m;
MCNUM W = mccguideCurved40_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 72024 "RITA-II.c"
}   /* End of guideCurved40=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'bunker'. */
  SIG_MESSAGE("bunker (McDisplay)");
  printf("MCDISPLAY: component %s\n", "bunker");
#define mccompcurname  bunker
#define mccompcurtype  Guide
#define mccompcurindex 46
#define pTable mccbunker_pTable
{   /* Declarations of bunker=Guide() SETTING parameters. */
char* reflect = mccbunker_reflect;
MCNUM w1 = mccbunker_w1;
MCNUM h1 = mccbunker_h1;
MCNUM w2 = mccbunker_w2;
MCNUM h2 = mccbunker_h2;
MCNUM l = mccbunker_l;
MCNUM R0 = mccbunker_R0;
MCNUM Qc = mccbunker_Qc;
MCNUM alpha = mccbunker_alpha;
MCNUM m = mccbunker_m;
MCNUM W = mccbunker_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 72070 "RITA-II.c"
}   /* End of bunker=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'guide3'. */
  SIG_MESSAGE("guide3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "guide3");
#define mccompcurname  guide3
#define mccompcurtype  Guide
#define mccompcurindex 47
#define pTable mccguide3_pTable
{   /* Declarations of guide3=Guide() SETTING parameters. */
char* reflect = mccguide3_reflect;
MCNUM w1 = mccguide3_w1;
MCNUM h1 = mccguide3_h1;
MCNUM w2 = mccguide3_w2;
MCNUM h2 = mccguide3_h2;
MCNUM l = mccguide3_l;
MCNUM R0 = mccguide3_R0;
MCNUM Qc = mccguide3_Qc;
MCNUM alpha = mccguide3_alpha;
MCNUM m = mccguide3_m;
MCNUM W = mccguide3_W;
#line 202 "/usr/share/mcstas/2.5/optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 72116 "RITA-II.c"
}   /* End of guide3=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'slitGuideEnd'. */
  SIG_MESSAGE("slitGuideEnd (McDisplay)");
  printf("MCDISPLAY: component %s\n", "slitGuideEnd");
#define mccompcurname  slitGuideEnd
#define mccompcurtype  Slit
#define mccompcurindex 48
{   /* Declarations of slitGuideEnd=Slit() SETTING parameters. */
MCNUM xmin = mccslitGuideEnd_xmin;
MCNUM xmax = mccslitGuideEnd_xmax;
MCNUM ymin = mccslitGuideEnd_ymin;
MCNUM ymax = mccslitGuideEnd_ymax;
MCNUM radius = mccslitGuideEnd_radius;
MCNUM xwidth = mccslitGuideEnd_xwidth;
MCNUM yheight = mccslitGuideEnd_yheight;
#line 81 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 72160 "RITA-II.c"
}   /* End of slitGuideEnd=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_guide_end'. */
  SIG_MESSAGE("psd_guide_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_guide_end");
#define mccompcurname  psd_guide_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccpsd_guide_end_nx
#define ny mccpsd_guide_end_ny
#define PSD_N mccpsd_guide_end_PSD_N
#define PSD_p mccpsd_guide_end_PSD_p
#define PSD_p2 mccpsd_guide_end_PSD_p2
{   /* Declarations of psd_guide_end=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_guide_end_filename;
MCNUM xmin = mccpsd_guide_end_xmin;
MCNUM xmax = mccpsd_guide_end_xmax;
MCNUM ymin = mccpsd_guide_end_ymin;
MCNUM ymax = mccpsd_guide_end_ymax;
MCNUM xwidth = mccpsd_guide_end_xwidth;
MCNUM yheight = mccpsd_guide_end_yheight;
MCNUM restore_neutron = mccpsd_guide_end_restore_neutron;
int nowritefile = mccpsd_guide_end_nowritefile;
#line 115 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72196 "RITA-II.c"
}   /* End of psd_guide_end=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_guide_end'. */
  SIG_MESSAGE("emon_guide_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_guide_end");
#define mccompcurname  emon_guide_end
#define mccompcurtype  E_monitor
#define mccompcurindex 50
#define nE mccemon_guide_end_nE
#define E_N mccemon_guide_end_E_N
#define E_p mccemon_guide_end_E_p
#define E_p2 mccemon_guide_end_E_p2
#define S_p mccemon_guide_end_S_p
#define S_pE mccemon_guide_end_S_pE
#define S_pE2 mccemon_guide_end_S_pE2
{   /* Declarations of emon_guide_end=E_monitor() SETTING parameters. */
char* filename = mccemon_guide_end_filename;
MCNUM xmin = mccemon_guide_end_xmin;
MCNUM xmax = mccemon_guide_end_xmax;
MCNUM ymin = mccemon_guide_end_ymin;
MCNUM ymax = mccemon_guide_end_ymax;
MCNUM xwidth = mccemon_guide_end_xwidth;
MCNUM yheight = mccemon_guide_end_yheight;
MCNUM Emin = mccemon_guide_end_Emin;
MCNUM Emax = mccemon_guide_end_Emax;
MCNUM restore_neutron = mccemon_guide_end_restore_neutron;
int nowritefile = mccemon_guide_end_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72241 "RITA-II.c"
}   /* End of emon_guide_end=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'lmon_guide_end'. */
  SIG_MESSAGE("lmon_guide_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "lmon_guide_end");
#define mccompcurname  lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mcclmon_guide_end_nL
#define L_N mcclmon_guide_end_L_N
#define L_p mcclmon_guide_end_L_p
#define L_p2 mcclmon_guide_end_L_p2
{   /* Declarations of lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mcclmon_guide_end_filename;
MCNUM xmin = mcclmon_guide_end_xmin;
MCNUM xmax = mcclmon_guide_end_xmax;
MCNUM ymin = mcclmon_guide_end_ymin;
MCNUM ymax = mcclmon_guide_end_ymax;
MCNUM xwidth = mcclmon_guide_end_xwidth;
MCNUM yheight = mcclmon_guide_end_yheight;
MCNUM Lmin = mcclmon_guide_end_Lmin;
MCNUM Lmax = mcclmon_guide_end_Lmax;
MCNUM restore_neutron = mcclmon_guide_end_restore_neutron;
int nowritefile = mcclmon_guide_end_nowritefile;
#line 120 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72285 "RITA-II.c"
}   /* End of lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'divmon_guide_end'. */
  SIG_MESSAGE("divmon_guide_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "divmon_guide_end");
#define mccompcurname  divmon_guide_end
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 52
#define nh mccdivmon_guide_end_nh
#define nv mccdivmon_guide_end_nv
#define Div_N mccdivmon_guide_end_Div_N
#define Div_p mccdivmon_guide_end_Div_p
#define Div_p2 mccdivmon_guide_end_Div_p2
{   /* Declarations of divmon_guide_end=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_guide_end_filename;
MCNUM xmin = mccdivmon_guide_end_xmin;
MCNUM xmax = mccdivmon_guide_end_xmax;
MCNUM ymin = mccdivmon_guide_end_ymin;
MCNUM ymax = mccdivmon_guide_end_ymax;
MCNUM xwidth = mccdivmon_guide_end_xwidth;
MCNUM yheight = mccdivmon_guide_end_yheight;
MCNUM maxdiv_h = mccdivmon_guide_end_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_guide_end_maxdiv_v;
MCNUM restore_neutron = mccdivmon_guide_end_restore_neutron;
MCNUM nx = mccdivmon_guide_end_nx;
MCNUM ny = mccdivmon_guide_end_ny;
MCNUM nz = mccdivmon_guide_end_nz;
int nowritefile = mccdivmon_guide_end_nowritefile;
#line 131 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 72330 "RITA-II.c"
}   /* End of divmon_guide_end=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'focus_mono'. */
  SIG_MESSAGE("focus_mono (McDisplay)");
  printf("MCDISPLAY: component %s\n", "focus_mono");
#define mccompcurname  focus_mono
#define mccompcurtype  Arm
#define mccompcurindex 53
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72355 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator_curved'. */
  SIG_MESSAGE("monochromator_curved (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator_curved");
#define mccompcurname  monochromator_curved
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 54
#define mos_rms_y mccmonochromator_curved_mos_rms_y
#define mos_rms_z mccmonochromator_curved_mos_rms_z
#define mos_rms_max mccmonochromator_curved_mos_rms_max
#define mono_Q mccmonochromator_curved_mono_Q
#define SlabWidth mccmonochromator_curved_SlabWidth
#define SlabHeight mccmonochromator_curved_SlabHeight
#define rTable mccmonochromator_curved_rTable
#define tTable mccmonochromator_curved_tTable
#define row mccmonochromator_curved_row
#define col mccmonochromator_curved_col
#define tiltH mccmonochromator_curved_tiltH
#define tiltV mccmonochromator_curved_tiltV
{   /* Declarations of monochromator_curved=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator_curved_reflect;
char* transmit = mccmonochromator_curved_transmit;
MCNUM zwidth = mccmonochromator_curved_zwidth;
MCNUM yheight = mccmonochromator_curved_yheight;
MCNUM gap = mccmonochromator_curved_gap;
MCNUM NH = mccmonochromator_curved_NH;
MCNUM NV = mccmonochromator_curved_NV;
MCNUM mosaich = mccmonochromator_curved_mosaich;
MCNUM mosaicv = mccmonochromator_curved_mosaicv;
MCNUM r0 = mccmonochromator_curved_r0;
MCNUM t0 = mccmonochromator_curved_t0;
MCNUM Q = mccmonochromator_curved_Q;
MCNUM RV = mccmonochromator_curved_RV;
MCNUM RH = mccmonochromator_curved_RH;
MCNUM DM = mccmonochromator_curved_DM;
MCNUM mosaic = mccmonochromator_curved_mosaic;
MCNUM width = mccmonochromator_curved_width;
MCNUM height = mccmonochromator_curved_height;
MCNUM verbose = mccmonochromator_curved_verbose;
MCNUM order = mccmonochromator_curved_order;
#line 468 "/usr/share/mcstas/2.5/optics/Monochromator_curved.comp"
{
  int ih;

  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 72429 "RITA-II.c"
}   /* End of monochromator_curved=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'a2'. */
  SIG_MESSAGE("a2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "a2");
#define mccompcurname  a2
#define mccompcurtype  Arm
#define mccompcurindex 55
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72461 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'slitShutter'. */
  SIG_MESSAGE("slitShutter (McDisplay)");
  printf("MCDISPLAY: component %s\n", "slitShutter");
#define mccompcurname  slitShutter
#define mccompcurtype  Slit
#define mccompcurindex 56
{   /* Declarations of slitShutter=Slit() SETTING parameters. */
MCNUM xmin = mccslitShutter_xmin;
MCNUM xmax = mccslitShutter_xmax;
MCNUM ymin = mccslitShutter_ymin;
MCNUM ymax = mccslitShutter_ymax;
MCNUM radius = mccslitShutter_radius;
MCNUM xwidth = mccslitShutter_xwidth;
MCNUM yheight = mccslitShutter_yheight;
#line 81 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 72503 "RITA-II.c"
}   /* End of slitShutter=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'MSCollimator'. */
  SIG_MESSAGE("MSCollimator (McDisplay)");
  printf("MCDISPLAY: component %s\n", "MSCollimator");
#define mccompcurname  MSCollimator
#define mccompcurtype  Collimator_linear
#define mccompcurindex 57
#define slope mccMSCollimator_slope
#define slopeV mccMSCollimator_slopeV
{   /* Declarations of MSCollimator=Collimator_linear() SETTING parameters. */
MCNUM xmin = mccMSCollimator_xmin;
MCNUM xmax = mccMSCollimator_xmax;
MCNUM ymin = mccMSCollimator_ymin;
MCNUM ymax = mccMSCollimator_ymax;
MCNUM xwidth = mccMSCollimator_xwidth;
MCNUM yheight = mccMSCollimator_yheight;
MCNUM length = mccMSCollimator_length;
MCNUM divergence = mccMSCollimator_divergence;
MCNUM transmission = mccMSCollimator_transmission;
MCNUM divergenceV = mccMSCollimator_divergenceV;
#line 100 "/usr/share/mcstas/2.5/optics/Collimator_linear.comp"
{
  double x;
  int i;

  
  for(x = xmin, i = 0; i <= 3; i++, x += (xmax - xmin)/3.0)
    multiline(5, x, (double)ymin, 0.0, x, (double)ymax, 0.0,
              x, (double)ymax, (double)length, x, (double)ymin, (double)length,
              x, (double)ymin, 0.0);
  line(xmin, ymin, 0,   xmax, ymin, 0);
  line(xmin, ymax, 0,   xmax, ymax, 0);
  line(xmin, ymin, length, xmax, ymin, length);
  line(xmin, ymax, length, xmax, ymax, length);
}
#line 72543 "RITA-II.c"
}   /* End of MSCollimator=Collimator_linear() SETTING parameter declarations. */
#undef slopeV
#undef slope
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'infilter'. */
  SIG_MESSAGE("infilter (McDisplay)");
  printf("MCDISPLAY: component %s\n", "infilter");
#define mccompcurname  infilter
#define mccompcurtype  Filter_gen
#define mccompcurindex 58
#define pTable mccinfilter_pTable
#define Mode_Table mccinfilter_Mode_Table
#define Type_Table mccinfilter_Type_Table
{   /* Declarations of infilter=Filter_gen() SETTING parameters. */
char* filename = mccinfilter_filename;
char* options = mccinfilter_options;
MCNUM xmin = mccinfilter_xmin;
MCNUM xmax = mccinfilter_xmax;
MCNUM ymin = mccinfilter_ymin;
MCNUM ymax = mccinfilter_ymax;
MCNUM xwidth = mccinfilter_xwidth;
MCNUM yheight = mccinfilter_yheight;
MCNUM thickness = mccinfilter_thickness;
MCNUM scaling = mccinfilter_scaling;
MCNUM verbose = mccinfilter_verbose;
#line 208 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72581 "RITA-II.c"
}   /* End of infilter=Filter_gen() SETTING parameter declarations. */
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_virt'. */
  SIG_MESSAGE("psd_virt (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_virt");
#define mccompcurname  psd_virt
#define mccompcurtype  PSD_monitor
#define mccompcurindex 59
#define nx mccpsd_virt_nx
#define ny mccpsd_virt_ny
#define PSD_N mccpsd_virt_PSD_N
#define PSD_p mccpsd_virt_PSD_p
#define PSD_p2 mccpsd_virt_PSD_p2
{   /* Declarations of psd_virt=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_virt_filename;
MCNUM xmin = mccpsd_virt_xmin;
MCNUM xmax = mccpsd_virt_xmax;
MCNUM ymin = mccpsd_virt_ymin;
MCNUM ymax = mccpsd_virt_ymax;
MCNUM xwidth = mccpsd_virt_xwidth;
MCNUM yheight = mccpsd_virt_yheight;
MCNUM restore_neutron = mccpsd_virt_restore_neutron;
int nowritefile = mccpsd_virt_nowritefile;
#line 115 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72620 "RITA-II.c"
}   /* End of psd_virt=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'lmon_virt'. */
  SIG_MESSAGE("lmon_virt (McDisplay)");
  printf("MCDISPLAY: component %s\n", "lmon_virt");
#define mccompcurname  lmon_virt
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mcclmon_virt_nL
#define L_N mcclmon_virt_L_N
#define L_p mcclmon_virt_L_p
#define L_p2 mcclmon_virt_L_p2
{   /* Declarations of lmon_virt=L_monitor() SETTING parameters. */
char* filename = mcclmon_virt_filename;
MCNUM xmin = mcclmon_virt_xmin;
MCNUM xmax = mcclmon_virt_xmax;
MCNUM ymin = mcclmon_virt_ymin;
MCNUM ymax = mcclmon_virt_ymax;
MCNUM xwidth = mcclmon_virt_xwidth;
MCNUM yheight = mcclmon_virt_yheight;
MCNUM Lmin = mcclmon_virt_Lmin;
MCNUM Lmax = mcclmon_virt_Lmax;
MCNUM restore_neutron = mcclmon_virt_restore_neutron;
int nowritefile = mcclmon_virt_nowritefile;
#line 120 "/usr/share/mcstas/2.5/monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72662 "RITA-II.c"
}   /* End of lmon_virt=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'aa2'. */
  SIG_MESSAGE("aa2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "aa2");
#define mccompcurname  aa2
#define mccompcurtype  Arm
#define mccompcurindex 61
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72686 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'virtualout'. */
  SIG_MESSAGE("virtualout (McDisplay)");
  printf("MCDISPLAY: component %s\n", "virtualout");
#define mccompcurname  virtualout
#define mccompcurtype  Virtual_output
#define mccompcurindex 62
#define DEFS mccvirtualout_DEFS
#define Vars mccvirtualout_Vars
{   /* Declarations of virtualout=Virtual_output() SETTING parameters. */
char* filename = mccvirtualout_filename;
MCNUM bufsize = mccvirtualout_bufsize;
#line 159 "/usr/share/mcstas/2.5/sources/Virtual_output.comp"
{
  Monitor_nD_McDisplay(&DEFS, &Vars);
}
#line 72706 "RITA-II.c"
}   /* End of virtualout=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'virtualsource'. */
  SIG_MESSAGE("virtualsource (McDisplay)");
  printf("MCDISPLAY: component %s\n", "virtualsource");
#define mccompcurname  virtualsource
#define mccompcurtype  Virtual_input
#define mccompcurindex 63
#define read_block mccvirtualsource_read_block
#define pos mccvirtualsource_pos
#define nrows mccvirtualsource_nrows
#define Offset mccvirtualsource_Offset
#define rTable mccvirtualsource_rTable
#define repeat_number mccvirtualsource_repeat_number
#define filename_ncount mccvirtualsource_filename_ncount
#define mean_vx mccvirtualsource_mean_vx
#define mean_vy mccvirtualsource_mean_vy
#define mean_vz mccvirtualsource_mean_vz
#define mean_dx mccvirtualsource_mean_dx
#define mean_dy mccvirtualsource_mean_dy
#define mean_dz mccvirtualsource_mean_dz
#define n_neutrons mccvirtualsource_n_neutrons
#define min_x mccvirtualsource_min_x
#define min_y mccvirtualsource_min_y
#define min_z mccvirtualsource_min_z
#define max_x mccvirtualsource_max_x
#define max_y mccvirtualsource_max_y
#define max_z mccvirtualsource_max_z
#define min_vx mccvirtualsource_min_vx
#define min_vy mccvirtualsource_min_vy
#define min_vz mccvirtualsource_min_vz
#define max_vx mccvirtualsource_max_vx
#define max_vy mccvirtualsource_max_vy
#define max_vz mccvirtualsource_max_vz
#define first_block mccvirtualsource_first_block
#define mean_x mccvirtualsource_mean_x
#define mean_y mccvirtualsource_mean_y
#define mean_z mccvirtualsource_mean_z
#define end_reading mccvirtualsource_end_reading
#define n_count_extrapolated mccvirtualsource_n_count_extrapolated
#define repeat_cnt mccvirtualsource_repeat_cnt
{   /* Declarations of virtualsource=Virtual_input() SETTING parameters. */
char* filename = mccvirtualsource_filename;
MCNUM verbose = mccvirtualsource_verbose;
MCNUM repeat_count = mccvirtualsource_repeat_count;
MCNUM smooth = mccvirtualsource_smooth;
MCNUM display = mccvirtualsource_display;
#line 359 "/usr/share/mcstas/2.5/sources/Virtual_input.comp"
{
  if (display) {
    mcdis_box(mean_x, mean_y, mean_z, max_x-min_x, max_y-min_y, max_z-min_z);
    /* a line in the main beam direction */
    line(mean_x, mean_y, mean_z,mean_dx,mean_dy,mean_dz);
  }
}
#line 72767 "RITA-II.c"
}   /* End of virtualsource=Virtual_input() SETTING parameter declarations. */
#undef repeat_cnt
#undef n_count_extrapolated
#undef end_reading
#undef mean_z
#undef mean_y
#undef mean_x
#undef first_block
#undef max_vz
#undef max_vy
#undef max_vx
#undef min_vz
#undef min_vy
#undef min_vx
#undef max_z
#undef max_y
#undef max_x
#undef min_z
#undef min_y
#undef min_x
#undef n_neutrons
#undef mean_dz
#undef mean_dy
#undef mean_dx
#undef mean_vz
#undef mean_vy
#undef mean_vx
#undef filename_ncount
#undef repeat_number
#undef rTable
#undef Offset
#undef nrows
#undef pos
#undef read_block
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'OrderMon'. */
  SIG_MESSAGE("OrderMon (McDisplay)");
  printf("MCDISPLAY: component %s\n", "OrderMon");
#define mccompcurname  OrderMon
#define mccompcurtype  Monitor_nD
#define mccompcurindex 64
#define user1 mccOrderMon_user1
#define user2 mccOrderMon_user2
#define user3 mccOrderMon_user3
#define DEFS mccOrderMon_DEFS
#define Vars mccOrderMon_Vars
#define detector mccOrderMon_detector
#define offdata mccOrderMon_offdata
{   /* Declarations of OrderMon=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccOrderMon_xwidth;
MCNUM yheight = mccOrderMon_yheight;
MCNUM zdepth = mccOrderMon_zdepth;
MCNUM xmin = mccOrderMon_xmin;
MCNUM xmax = mccOrderMon_xmax;
MCNUM ymin = mccOrderMon_ymin;
MCNUM ymax = mccOrderMon_ymax;
MCNUM zmin = mccOrderMon_zmin;
MCNUM zmax = mccOrderMon_zmax;
MCNUM bins = mccOrderMon_bins;
MCNUM min = mccOrderMon_min;
MCNUM max = mccOrderMon_max;
MCNUM restore_neutron = mccOrderMon_restore_neutron;
MCNUM radius = mccOrderMon_radius;
char* options = mccOrderMon_options;
char* filename = mccOrderMon_filename;
char* geometry = mccOrderMon_geometry;
char* username1 = mccOrderMon_username1;
char* username2 = mccOrderMon_username2;
char* username3 = mccOrderMon_username3;
int nowritefile = mccOrderMon_nowritefile;
#line 494 "/usr/share/mcstas/2.5/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 72850 "RITA-II.c"
}   /* End of OrderMon=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'kMoni'. */
  SIG_MESSAGE("kMoni (McDisplay)");
  printf("MCDISPLAY: component %s\n", "kMoni");
#define mccompcurname  kMoni
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 65
#define nx mcckMoni_nx
#define ny mcckMoni_ny
#define filename mcckMoni_filename
#define PSD_N mcckMoni_PSD_N
#define PSD_p mcckMoni_PSD_p
#define PSD_p2 mcckMoni_PSD_p2
#define weight mcckMoni_weight
{   /* Declarations of kMoni=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni_xmin;
MCNUM xmax = mcckMoni_xmax;
MCNUM ymin = mcckMoni_ymin;
MCNUM ymax = mcckMoni_ymax;
MCNUM xwidth = mcckMoni_xwidth;
MCNUM yheight = mcckMoni_yheight;
MCNUM psf = mcckMoni_psf;
MCNUM k0 = mcckMoni_k0;
MCNUM eff = mcckMoni_eff;
MCNUM restore_neutron = mcckMoni_restore_neutron;
int nowritefile = mcckMoni_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72897 "RITA-II.c"
}   /* End of kMoni=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'kMoni1st'. */
  SIG_MESSAGE("kMoni1st (McDisplay)");
  printf("MCDISPLAY: component %s\n", "kMoni1st");
#define mccompcurname  kMoni1st
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 66
#define nx mcckMoni1st_nx
#define ny mcckMoni1st_ny
#define filename mcckMoni1st_filename
#define PSD_N mcckMoni1st_PSD_N
#define PSD_p mcckMoni1st_PSD_p
#define PSD_p2 mcckMoni1st_PSD_p2
#define weight mcckMoni1st_weight
{   /* Declarations of kMoni1st=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni1st_xmin;
MCNUM xmax = mcckMoni1st_xmax;
MCNUM ymin = mcckMoni1st_ymin;
MCNUM ymax = mcckMoni1st_ymax;
MCNUM xwidth = mcckMoni1st_xwidth;
MCNUM yheight = mcckMoni1st_yheight;
MCNUM psf = mcckMoni1st_psf;
MCNUM k0 = mcckMoni1st_k0;
MCNUM eff = mcckMoni1st_eff;
MCNUM restore_neutron = mcckMoni1st_restore_neutron;
int nowritefile = mcckMoni1st_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72944 "RITA-II.c"
}   /* End of kMoni1st=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'kMoni2nd'. */
  SIG_MESSAGE("kMoni2nd (McDisplay)");
  printf("MCDISPLAY: component %s\n", "kMoni2nd");
#define mccompcurname  kMoni2nd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 67
#define nx mcckMoni2nd_nx
#define ny mcckMoni2nd_ny
#define filename mcckMoni2nd_filename
#define PSD_N mcckMoni2nd_PSD_N
#define PSD_p mcckMoni2nd_PSD_p
#define PSD_p2 mcckMoni2nd_PSD_p2
#define weight mcckMoni2nd_weight
{   /* Declarations of kMoni2nd=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni2nd_xmin;
MCNUM xmax = mcckMoni2nd_xmax;
MCNUM ymin = mcckMoni2nd_ymin;
MCNUM ymax = mcckMoni2nd_ymax;
MCNUM xwidth = mcckMoni2nd_xwidth;
MCNUM yheight = mcckMoni2nd_yheight;
MCNUM psf = mcckMoni2nd_psf;
MCNUM k0 = mcckMoni2nd_k0;
MCNUM eff = mcckMoni2nd_eff;
MCNUM restore_neutron = mcckMoni2nd_restore_neutron;
int nowritefile = mcckMoni2nd_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72991 "RITA-II.c"
}   /* End of kMoni2nd=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'kMoni3rd'. */
  SIG_MESSAGE("kMoni3rd (McDisplay)");
  printf("MCDISPLAY: component %s\n", "kMoni3rd");
#define mccompcurname  kMoni3rd
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 68
#define nx mcckMoni3rd_nx
#define ny mcckMoni3rd_ny
#define filename mcckMoni3rd_filename
#define PSD_N mcckMoni3rd_PSD_N
#define PSD_p mcckMoni3rd_PSD_p
#define PSD_p2 mcckMoni3rd_PSD_p2
#define weight mcckMoni3rd_weight
{   /* Declarations of kMoni3rd=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mcckMoni3rd_xmin;
MCNUM xmax = mcckMoni3rd_xmax;
MCNUM ymin = mcckMoni3rd_ymin;
MCNUM ymax = mcckMoni3rd_ymax;
MCNUM xwidth = mcckMoni3rd_xwidth;
MCNUM yheight = mcckMoni3rd_yheight;
MCNUM psf = mcckMoni3rd_psf;
MCNUM k0 = mcckMoni3rd_k0;
MCNUM eff = mcckMoni3rd_eff;
MCNUM restore_neutron = mcckMoni3rd_restore_neutron;
int nowritefile = mcckMoni3rd_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 73038 "RITA-II.c"
}   /* End of kMoni3rd=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'slitMonochromator'. */
  SIG_MESSAGE("slitMonochromator (McDisplay)");
  printf("MCDISPLAY: component %s\n", "slitMonochromator");
#define mccompcurname  slitMonochromator
#define mccompcurtype  Slit
#define mccompcurindex 69
{   /* Declarations of slitMonochromator=Slit() SETTING parameters. */
MCNUM xmin = mccslitMonochromator_xmin;
MCNUM xmax = mccslitMonochromator_xmax;
MCNUM ymin = mccslitMonochromator_ymin;
MCNUM ymax = mccslitMonochromator_ymax;
MCNUM radius = mccslitMonochromator_radius;
MCNUM xwidth = mccslitMonochromator_xwidth;
MCNUM yheight = mccslitMonochromator_yheight;
#line 81 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 73088 "RITA-II.c"
}   /* End of slitMonochromator=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Perspex'. */
  SIG_MESSAGE("Perspex (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Perspex");
#define mccompcurname  Perspex
#define mccompcurtype  Incoherent
#define mccompcurindex 70
#define VarsInc mccPerspex_VarsInc
#define offdata mccPerspex_offdata
{   /* Declarations of Perspex=Incoherent() SETTING parameters. */
char* geometry = mccPerspex_geometry;
MCNUM radius = mccPerspex_radius;
MCNUM xwidth = mccPerspex_xwidth;
MCNUM yheight = mccPerspex_yheight;
MCNUM zdepth = mccPerspex_zdepth;
MCNUM thickness = mccPerspex_thickness;
MCNUM target_x = mccPerspex_target_x;
MCNUM target_y = mccPerspex_target_y;
MCNUM target_z = mccPerspex_target_z;
MCNUM focus_r = mccPerspex_focus_r;
MCNUM focus_xw = mccPerspex_focus_xw;
MCNUM focus_yh = mccPerspex_focus_yh;
MCNUM focus_aw = mccPerspex_focus_aw;
MCNUM focus_ah = mccPerspex_focus_ah;
int target_index = mccPerspex_target_index;
MCNUM pack = mccPerspex_pack;
MCNUM p_interact = mccPerspex_p_interact;
MCNUM f_QE = mccPerspex_f_QE;
MCNUM gamma = mccPerspex_gamma;
MCNUM Etrans = mccPerspex_Etrans;
MCNUM deltaE = mccPerspex_deltaE;
MCNUM sigma_abs = mccPerspex_sigma_abs;
MCNUM sigma_inc = mccPerspex_sigma_inc;
MCNUM Vc = mccPerspex_Vc;
MCNUM concentric = mccPerspex_concentric;
MCNUM order = mccPerspex_order;
#line 439 "/usr/share/mcstas/2.5/samples/Incoherent.comp"
{
  
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {	/* OFF file */
    off_display(offdata);
  }
  else if (radius > 0 &&  yheight) {	/* cylinder */
      cylinder(0,0,0,radius,yheight,0, 0,1,0);
      cylinder(0,0,0,radius-thickness,yheight,0, 0,1,0);
  }
  else if (xwidth && yheight) { 	/* box/rectangle XY */
      box(0,0,0,xwidth, yheight, zdepth);
  }
  else if (radius > 0 && !yheight) {	/* sphere */
      sphere(0,0,0,radius,0);
  }
}
#line 73146 "RITA-II.c"
}   /* End of Perspex=Incoherent() SETTING parameter declarations. */
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_samplepos_1cm2'. */
  SIG_MESSAGE("psd_samplepos_1cm2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_samplepos_1cm2");
#define mccompcurname  psd_samplepos_1cm2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 71
#define nx mccpsd_samplepos_1cm2_nx
#define ny mccpsd_samplepos_1cm2_ny
#define PSD_N mccpsd_samplepos_1cm2_PSD_N
#define PSD_p mccpsd_samplepos_1cm2_PSD_p
#define PSD_p2 mccpsd_samplepos_1cm2_PSD_p2
{   /* Declarations of psd_samplepos_1cm2=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_samplepos_1cm2_filename;
MCNUM xmin = mccpsd_samplepos_1cm2_xmin;
MCNUM xmax = mccpsd_samplepos_1cm2_xmax;
MCNUM ymin = mccpsd_samplepos_1cm2_ymin;
MCNUM ymax = mccpsd_samplepos_1cm2_ymax;
MCNUM xwidth = mccpsd_samplepos_1cm2_xwidth;
MCNUM yheight = mccpsd_samplepos_1cm2_yheight;
MCNUM restore_neutron = mccpsd_samplepos_1cm2_restore_neutron;
int nowritefile = mccpsd_samplepos_1cm2_nowritefile;
#line 115 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 73184 "RITA-II.c"
}   /* End of psd_samplepos_1cm2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_samplepos_1cm2'. */
  SIG_MESSAGE("emon_samplepos_1cm2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_samplepos_1cm2");
#define mccompcurname  emon_samplepos_1cm2
#define mccompcurtype  E_monitor
#define mccompcurindex 72
#define nE mccemon_samplepos_1cm2_nE
#define E_N mccemon_samplepos_1cm2_E_N
#define E_p mccemon_samplepos_1cm2_E_p
#define E_p2 mccemon_samplepos_1cm2_E_p2
#define S_p mccemon_samplepos_1cm2_S_p
#define S_pE mccemon_samplepos_1cm2_S_pE
#define S_pE2 mccemon_samplepos_1cm2_S_pE2
{   /* Declarations of emon_samplepos_1cm2=E_monitor() SETTING parameters. */
char* filename = mccemon_samplepos_1cm2_filename;
MCNUM xmin = mccemon_samplepos_1cm2_xmin;
MCNUM xmax = mccemon_samplepos_1cm2_xmax;
MCNUM ymin = mccemon_samplepos_1cm2_ymin;
MCNUM ymax = mccemon_samplepos_1cm2_ymax;
MCNUM xwidth = mccemon_samplepos_1cm2_xwidth;
MCNUM yheight = mccemon_samplepos_1cm2_yheight;
MCNUM Emin = mccemon_samplepos_1cm2_Emin;
MCNUM Emax = mccemon_samplepos_1cm2_Emax;
MCNUM restore_neutron = mccemon_samplepos_1cm2_restore_neutron;
int nowritefile = mccemon_samplepos_1cm2_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 73229 "RITA-II.c"
}   /* End of emon_samplepos_1cm2=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'divmon_samplepos_1cm2'. */
  SIG_MESSAGE("divmon_samplepos_1cm2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "divmon_samplepos_1cm2");
#define mccompcurname  divmon_samplepos_1cm2
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 73
#define nh mccdivmon_samplepos_1cm2_nh
#define nv mccdivmon_samplepos_1cm2_nv
#define Div_N mccdivmon_samplepos_1cm2_Div_N
#define Div_p mccdivmon_samplepos_1cm2_Div_p
#define Div_p2 mccdivmon_samplepos_1cm2_Div_p2
{   /* Declarations of divmon_samplepos_1cm2=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_samplepos_1cm2_filename;
MCNUM xmin = mccdivmon_samplepos_1cm2_xmin;
MCNUM xmax = mccdivmon_samplepos_1cm2_xmax;
MCNUM ymin = mccdivmon_samplepos_1cm2_ymin;
MCNUM ymax = mccdivmon_samplepos_1cm2_ymax;
MCNUM xwidth = mccdivmon_samplepos_1cm2_xwidth;
MCNUM yheight = mccdivmon_samplepos_1cm2_yheight;
MCNUM maxdiv_h = mccdivmon_samplepos_1cm2_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_samplepos_1cm2_maxdiv_v;
MCNUM restore_neutron = mccdivmon_samplepos_1cm2_restore_neutron;
MCNUM nx = mccdivmon_samplepos_1cm2_nx;
MCNUM ny = mccdivmon_samplepos_1cm2_ny;
MCNUM nz = mccdivmon_samplepos_1cm2_nz;
int nowritefile = mccdivmon_samplepos_1cm2_nowritefile;
#line 131 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 73277 "RITA-II.c"
}   /* End of divmon_samplepos_1cm2=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_samplepos_large'. */
  SIG_MESSAGE("psd_samplepos_large (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_samplepos_large");
#define mccompcurname  psd_samplepos_large
#define mccompcurtype  PSD_monitor
#define mccompcurindex 74
#define nx mccpsd_samplepos_large_nx
#define ny mccpsd_samplepos_large_ny
#define PSD_N mccpsd_samplepos_large_PSD_N
#define PSD_p mccpsd_samplepos_large_PSD_p
#define PSD_p2 mccpsd_samplepos_large_PSD_p2
{   /* Declarations of psd_samplepos_large=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_samplepos_large_filename;
MCNUM xmin = mccpsd_samplepos_large_xmin;
MCNUM xmax = mccpsd_samplepos_large_xmax;
MCNUM ymin = mccpsd_samplepos_large_ymin;
MCNUM ymax = mccpsd_samplepos_large_ymax;
MCNUM xwidth = mccpsd_samplepos_large_xwidth;
MCNUM yheight = mccpsd_samplepos_large_yheight;
MCNUM restore_neutron = mccpsd_samplepos_large_restore_neutron;
int nowritefile = mccpsd_samplepos_large_nowritefile;
#line 115 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 73318 "RITA-II.c"
}   /* End of psd_samplepos_large=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'a3'. */
  SIG_MESSAGE("a3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "a3");
#define mccompcurname  a3
#define mccompcurtype  Arm
#define mccompcurindex 75
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 73343 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'aa3'. */
  SIG_MESSAGE("aa3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "aa3");
#define mccompcurname  aa3
#define mccompcurtype  Arm
#define mccompcurindex 76
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 73362 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'incohSample'. */
  SIG_MESSAGE("incohSample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "incohSample");
#define mccompcurname  incohSample
#define mccompcurtype  Incoherent
#define mccompcurindex 77
#define VarsInc mccincohSample_VarsInc
#define offdata mccincohSample_offdata
{   /* Declarations of incohSample=Incoherent() SETTING parameters. */
char* geometry = mccincohSample_geometry;
MCNUM radius = mccincohSample_radius;
MCNUM xwidth = mccincohSample_xwidth;
MCNUM yheight = mccincohSample_yheight;
MCNUM zdepth = mccincohSample_zdepth;
MCNUM thickness = mccincohSample_thickness;
MCNUM target_x = mccincohSample_target_x;
MCNUM target_y = mccincohSample_target_y;
MCNUM target_z = mccincohSample_target_z;
MCNUM focus_r = mccincohSample_focus_r;
MCNUM focus_xw = mccincohSample_focus_xw;
MCNUM focus_yh = mccincohSample_focus_yh;
MCNUM focus_aw = mccincohSample_focus_aw;
MCNUM focus_ah = mccincohSample_focus_ah;
int target_index = mccincohSample_target_index;
MCNUM pack = mccincohSample_pack;
MCNUM p_interact = mccincohSample_p_interact;
MCNUM f_QE = mccincohSample_f_QE;
MCNUM gamma = mccincohSample_gamma;
MCNUM Etrans = mccincohSample_Etrans;
MCNUM deltaE = mccincohSample_deltaE;
MCNUM sigma_abs = mccincohSample_sigma_abs;
MCNUM sigma_inc = mccincohSample_sigma_inc;
MCNUM Vc = mccincohSample_Vc;
MCNUM concentric = mccincohSample_concentric;
MCNUM order = mccincohSample_order;
#line 439 "/usr/share/mcstas/2.5/samples/Incoherent.comp"
{
  
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {	/* OFF file */
    off_display(offdata);
  }
  else if (radius > 0 &&  yheight) {	/* cylinder */
      cylinder(0,0,0,radius,yheight,0, 0,1,0);
      cylinder(0,0,0,radius-thickness,yheight,0, 0,1,0);
  }
  else if (xwidth && yheight) { 	/* box/rectangle XY */
      box(0,0,0,xwidth, yheight, zdepth);
  }
  else if (radius > 0 && !yheight) {	/* sphere */
      sphere(0,0,0,radius,0);
  }
}
#line 73419 "RITA-II.c"
}   /* End of incohSample=Incoherent() SETTING parameter declarations. */
#undef offdata
#undef VarsInc
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'powderSample'. */
  SIG_MESSAGE("powderSample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "powderSample");
#define mccompcurname  powderSample
#define mccompcurtype  PowderN
#define mccompcurindex 78
#define format mccpowderSample_format
#define line_info mccpowderSample_line_info
#define columns mccpowderSample_columns
#define offdata mccpowderSample_offdata
{   /* Declarations of powderSample=PowderN() SETTING parameters. */
char* reflections = mccpowderSample_reflections;
char* geometry = mccpowderSample_geometry;
MCNUM radius = mccpowderSample_radius;
MCNUM yheight = mccpowderSample_yheight;
MCNUM xwidth = mccpowderSample_xwidth;
MCNUM zdepth = mccpowderSample_zdepth;
MCNUM thickness = mccpowderSample_thickness;
MCNUM pack = mccpowderSample_pack;
MCNUM Vc = mccpowderSample_Vc;
MCNUM sigma_abs = mccpowderSample_sigma_abs;
MCNUM sigma_inc = mccpowderSample_sigma_inc;
MCNUM delta_d_d = mccpowderSample_delta_d_d;
MCNUM p_inc = mccpowderSample_p_inc;
MCNUM p_transmit = mccpowderSample_p_transmit;
MCNUM DW = mccpowderSample_DW;
MCNUM nb_atoms = mccpowderSample_nb_atoms;
MCNUM d_omega = mccpowderSample_d_omega;
MCNUM d_phi = mccpowderSample_d_phi;
MCNUM tth_sign = mccpowderSample_tth_sign;
MCNUM p_interact = mccpowderSample_p_interact;
MCNUM concentric = mccpowderSample_concentric;
MCNUM density = mccpowderSample_density;
MCNUM weight = mccpowderSample_weight;
MCNUM barns = mccpowderSample_barns;
MCNUM Strain = mccpowderSample_Strain;
MCNUM focus_flip = mccpowderSample_focus_flip;
int target_index = mccpowderSample_target_index;
#line 1112 "/usr/share/mcstas/2.5/samples/PowderN.comp"
{
  if (line_info.V_0) {
    magnify("xyz");
    if (line_info.shape == 0) { /* cyl */
      circle("xz", 0,  yheight/2.0, 0, radius);
      circle("xz", 0, -yheight/2.0, 0, radius);
      line(-radius, -yheight/2.0, 0, -radius, +yheight/2.0, 0);
      line(+radius, -yheight/2.0, 0, +radius, +yheight/2.0, 0);
      line(0, -yheight/2.0, -radius, 0, +yheight/2.0, -radius);
      line(0, -yheight/2.0, +radius, 0, +yheight/2.0, +radius);
      if (thickness) {
        double radius_i=radius-thickness;
        circle("xz", 0,  yheight/2.0, 0, radius_i);
        circle("xz", 0, -yheight/2.0, 0, radius_i);
        line(-radius_i, -yheight/2.0, 0, -radius_i, +yheight/2.0, 0);
        line(+radius_i, -yheight/2.0, 0, +radius_i, +yheight/2.0, 0);
        line(0, -yheight/2.0, -radius_i, 0, +yheight/2.0, -radius_i);
        line(0, -yheight/2.0, +radius_i, 0, +yheight/2.0, +radius_i);
      }
    } else if (line_info.shape == 1) {  /* box */
      double xmin = -0.5*xwidth;
      double xmax =  0.5*xwidth;
      double ymin = -0.5*yheight;
      double ymax =  0.5*yheight;
      double zmin = -0.5*zdepth;
      double zmax =  0.5*zdepth;
      multiline(5, xmin, ymin, zmin,
                   xmax, ymin, zmin,
                   xmax, ymax, zmin,
                   xmin, ymax, zmin,
                   xmin, ymin, zmin);
      multiline(5, xmin, ymin, zmax,
                   xmax, ymin, zmax,
                   xmax, ymax, zmax,
                   xmin, ymax, zmax,
                   xmin, ymin, zmax);
      line(xmin, ymin, zmin, xmin, ymin, zmax);
      line(xmax, ymin, zmin, xmax, ymin, zmax);
      line(xmin, ymax, zmin, xmin, ymax, zmax);
      line(xmax, ymax, zmin, xmax, ymax, zmax);
      if (line_info.zdepth_i) {
        xmin = -0.5*line_info.xwidth_i;
        xmax =  0.5*line_info.xwidth_i;
        ymin = -0.5*line_info.yheight_i;
        ymax =  0.5*line_info.yheight_i;
        zmin = -0.5*line_info.zdepth_i;
        zmax =  0.5*line_info.zdepth_i;
        multiline(5, xmin, ymin, zmin,
                  xmax, ymin, zmin,
                  xmax, ymax, zmin,
                  xmin, ymax, zmin,
                  xmin, ymin, zmin);
        multiline(5, xmin, ymin, zmax,
                  xmax, ymin, zmax,
                  xmax, ymax, zmax,
                  xmin, ymax, zmax,
                  xmin, ymin, zmax);
        line(xmin, ymin, zmin, xmin, ymin, zmax);
        line(xmax, ymin, zmin, xmax, ymin, zmax);
        line(xmin, ymax, zmin, xmin, ymax, zmax);
        line(xmax, ymax, zmin, xmax, ymax, zmax);
      }
    } if (line_info.shape == 2) { /* sphere */
      if (line_info.radius_i) {
        circle("xy",0,0,0,line_info.radius_i);
        circle("xz",0,0,0,line_info.radius_i);
        circle("yz",0,0,0,line_info.radius_i);
      }
      circle("xy",0,0,0,radius);
      circle("xz",0,0,0,radius);
      circle("yz",0,0,0,radius);
    } else if (line_info.shape == 3) {	/* OFF file */
      off_display(offdata);
    }
  }
}
#line 73542 "RITA-II.c"
}   /* End of powderSample=PowderN() SETTING parameter declarations. */
#undef offdata
#undef columns
#undef line_info
#undef format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'crystalSample'. */
  SIG_MESSAGE("crystalSample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "crystalSample");
#define mccompcurname  crystalSample
#define mccompcurtype  Single_crystal
#define mccompcurindex 79
#define mosaic_AB mcccrystalSample_mosaic_AB
#define hkl_info mcccrystalSample_hkl_info
#define offdata mcccrystalSample_offdata
{   /* Declarations of crystalSample=Single_crystal() SETTING parameters. */
char* reflections = mcccrystalSample_reflections;
char* geometry = mcccrystalSample_geometry;
MCNUM xwidth = mcccrystalSample_xwidth;
MCNUM yheight = mcccrystalSample_yheight;
MCNUM zdepth = mcccrystalSample_zdepth;
MCNUM radius = mcccrystalSample_radius;
MCNUM delta_d_d = mcccrystalSample_delta_d_d;
MCNUM mosaic = mcccrystalSample_mosaic;
MCNUM mosaic_a = mcccrystalSample_mosaic_a;
MCNUM mosaic_b = mcccrystalSample_mosaic_b;
MCNUM mosaic_c = mcccrystalSample_mosaic_c;
MCNUM recip_cell = mcccrystalSample_recip_cell;
MCNUM barns = mcccrystalSample_barns;
MCNUM ax = mcccrystalSample_ax;
MCNUM ay = mcccrystalSample_ay;
MCNUM az = mcccrystalSample_az;
MCNUM bx = mcccrystalSample_bx;
MCNUM by = mcccrystalSample_by;
MCNUM bz = mcccrystalSample_bz;
MCNUM cx = mcccrystalSample_cx;
MCNUM cy = mcccrystalSample_cy;
MCNUM cz = mcccrystalSample_cz;
MCNUM p_transmit = mcccrystalSample_p_transmit;
MCNUM sigma_abs = mcccrystalSample_sigma_abs;
MCNUM sigma_inc = mcccrystalSample_sigma_inc;
MCNUM aa = mcccrystalSample_aa;
MCNUM bb = mcccrystalSample_bb;
MCNUM cc = mcccrystalSample_cc;
MCNUM order = mcccrystalSample_order;
MCNUM RX = mcccrystalSample_RX;
MCNUM RY = mcccrystalSample_RY;
MCNUM powder = mcccrystalSample_powder;
MCNUM PG = mcccrystalSample_PG;
MCNUM deltak = mcccrystalSample_deltak;
#line 1421 "/usr/share/mcstas/2.5/samples/Single_crystal.comp"
{
  
  if (hkl_info.shape == 0) {	/* cylinder */
    circle("xz", 0,  yheight/2.0, 0, radius);
    circle("xz", 0, -yheight/2.0, 0, radius);
    line(-radius, -yheight/2.0, 0, -radius, +yheight/2.0, 0);
    line(+radius, -yheight/2.0, 0, +radius, +yheight/2.0, 0);
    line(0, -yheight/2.0, -radius, 0, +yheight/2.0, -radius);
    line(0, -yheight/2.0, +radius, 0, +yheight/2.0, +radius);
  }
  else if (hkl_info.shape == 1) { 	/* box */
    double xmin = -0.5*xwidth;
    double xmax =  0.5*xwidth;
    double ymin = -0.5*yheight;
    double ymax =  0.5*yheight;
    double zmin = -0.5*zdepth;
    double zmax =  0.5*zdepth;
    multiline(5, xmin, ymin, zmin,
                 xmax, ymin, zmin,
                 xmax, ymax, zmin,
                 xmin, ymax, zmin,
                 xmin, ymin, zmin);
    multiline(5, xmin, ymin, zmax,
                 xmax, ymin, zmax,
                 xmax, ymax, zmax,
                 xmin, ymax, zmax,
                 xmin, ymin, zmax);
    line(xmin, ymin, zmin, xmin, ymin, zmax);
    line(xmax, ymin, zmin, xmax, ymin, zmax);
    line(xmin, ymax, zmin, xmin, ymax, zmax);
    line(xmax, ymax, zmin, xmax, ymax, zmax);
  }
  else if (hkl_info.shape == 2) {	/* sphere */
    circle("xy", 0,  0.0, 0, radius);
    circle("xz", 0,  0.0, 0, radius);
    circle("yz", 0,  0.0, 0, radius);
  }
  else if (hkl_info.shape == 3) {	/* OFF file */
    off_display(offdata);
  }
}
#line 73638 "RITA-II.c"
}   /* End of crystalSample=Single_crystal() SETTING parameter declarations. */
#undef offdata
#undef hkl_info
#undef mosaic_AB
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'phononSample'. */
  SIG_MESSAGE("phononSample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "phononSample");
#define mccompcurname  phononSample
#define mccompcurtype  Phonon_simple
#define mccompcurindex 80
#define V_rho mccphononSample_V_rho
#define V_my_s mccphononSample_V_my_s
#define V_my_a_v mccphononSample_V_my_a_v
#define DV mccphononSample_DV
#define parms mccphononSample_parms
{   /* Declarations of phononSample=Phonon_simple() SETTING parameters. */
MCNUM radius = mccphononSample_radius;
MCNUM yheight = mccphononSample_yheight;
MCNUM sigma_abs = mccphononSample_sigma_abs;
MCNUM sigma_inc = mccphononSample_sigma_inc;
MCNUM a = mccphononSample_a;
MCNUM b = mccphononSample_b;
MCNUM M = mccphononSample_M;
MCNUM c = mccphononSample_c;
MCNUM DW = mccphononSample_DW;
MCNUM T = mccphononSample_T;
MCNUM target_x = mccphononSample_target_x;
MCNUM target_y = mccphononSample_target_y;
MCNUM target_z = mccphononSample_target_z;
int target_index = mccphononSample_target_index;
MCNUM focus_r = mccphononSample_focus_r;
MCNUM focus_xw = mccphononSample_focus_xw;
MCNUM focus_yh = mccphononSample_focus_yh;
MCNUM focus_aw = mccphononSample_focus_aw;
MCNUM focus_ah = mccphononSample_focus_ah;
MCNUM gap = mccphononSample_gap;
#line 376 "/usr/share/mcstas/2.5/samples/Phonon_simple.comp"
{
  
  circle("xz", 0,  yheight/2.0, 0, radius);
  circle("xz", 0, -yheight/2.0, 0, radius);
  line(-radius, -yheight/2.0, 0, -radius, +yheight/2.0, 0);
  line(+radius, -yheight/2.0, 0, +radius, +yheight/2.0, 0);
  line(0, -yheight/2.0, -radius, 0, +yheight/2.0, -radius);
  line(0, -yheight/2.0, +radius, 0, +yheight/2.0, +radius);
}
#line 73689 "RITA-II.c"
}   /* End of phononSample=Phonon_simple() SETTING parameter declarations. */
#undef parms
#undef DV
#undef V_my_a_v
#undef V_my_s
#undef V_rho
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_4pi'. */
  SIG_MESSAGE("psd_4pi (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_4pi");
#define mccompcurname  psd_4pi
#define mccompcurtype  PSD_monitor_4PI
#define mccompcurindex 81
#define nx mccpsd_4pi_nx
#define ny mccpsd_4pi_ny
#define PSD_N mccpsd_4pi_PSD_N
#define PSD_p mccpsd_4pi_PSD_p
#define PSD_p2 mccpsd_4pi_PSD_p2
{   /* Declarations of psd_4pi=PSD_monitor_4PI() SETTING parameters. */
char* filename = mccpsd_4pi_filename;
MCNUM radius = mccpsd_4pi_radius;
MCNUM restore_neutron = mccpsd_4pi_restore_neutron;
int nowritefile = mccpsd_4pi_nowritefile;
#line 121 "/usr/share/mcstas/2.5/monitors/PSD_monitor_4PI.comp"
{
  
  circle("xy",0,0,0,radius);
  circle("xz",0,0,0,radius);
  circle("yz",0,0,0,radius);
}
#line 73723 "RITA-II.c"
}   /* End of psd_4pi=PSD_monitor_4PI() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'a4'. */
  SIG_MESSAGE("a4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "a4");
#define mccompcurname  a4
#define mccompcurtype  Arm
#define mccompcurindex 82
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 73748 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'slitSample'. */
  SIG_MESSAGE("slitSample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "slitSample");
#define mccompcurname  slitSample
#define mccompcurtype  Slit
#define mccompcurindex 83
{   /* Declarations of slitSample=Slit() SETTING parameters. */
MCNUM xmin = mccslitSample_xmin;
MCNUM xmax = mccslitSample_xmax;
MCNUM ymin = mccslitSample_ymin;
MCNUM ymax = mccslitSample_ymax;
MCNUM radius = mccslitSample_radius;
MCNUM xwidth = mccslitSample_xwidth;
MCNUM yheight = mccslitSample_yheight;
#line 81 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 73790 "RITA-II.c"
}   /* End of slitSample=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'filter_coll'. */
  SIG_MESSAGE("filter_coll (McDisplay)");
  printf("MCDISPLAY: component %s\n", "filter_coll");
#define mccompcurname  filter_coll
#define mccompcurtype  Exact_radial_coll
#define mccompcurindex 84
#define alpha_in mccfilter_coll_alpha_in
#define alpha_out mccfilter_coll_alpha_out
#define out_radius mccfilter_coll_out_radius
#define beta_in mccfilter_coll_beta_in
#define beta_out mccfilter_coll_beta_out
#define iw mccfilter_coll_iw
#define ow mccfilter_coll_ow
#define divergence mccfilter_coll_divergence
#define theta mccfilter_coll_theta
{   /* Declarations of filter_coll=Exact_radial_coll() SETTING parameters. */
MCNUM theta_min = mccfilter_coll_theta_min;
MCNUM theta_max = mccfilter_coll_theta_max;
MCNUM nslit = mccfilter_coll_nslit;
MCNUM radius = mccfilter_coll_radius;
MCNUM length = mccfilter_coll_length;
MCNUM h_in = mccfilter_coll_h_in;
MCNUM h_out = mccfilter_coll_h_out;
MCNUM d = mccfilter_coll_d;
MCNUM verbose = mccfilter_coll_verbose;
#line 160 "/usr/share/mcstas/2.5/contrib/Exact_radial_coll.comp"
{
  int i;
  double theta1, theta2, theta3, theta4;
  double x_in_l,  z_in_l,  x_in_r,  z_in_r;
  double x_out_l, z_out_l, x_out_r, z_out_r;
  double window_theta, y1, y2;

  
  window_theta = alpha_in + beta_in;
  y1 = h_in/2;
  y2 = h_out/2;

  theta1 = theta_min;
  theta3 = theta1+beta_in/2;
  theta4 = theta1+beta_out/2;

  z_in_l = radius*cos(theta1);
  x_in_l = radius*sin(theta1);
  z_in_r = radius*cos(theta3);
  x_in_r = radius*sin(theta3);

  z_out_l = out_radius*cos(theta1);
  x_out_l = out_radius*sin(theta1);
  z_out_r = out_radius*cos(theta4);
  x_out_r = out_radius*sin(theta4);

    multiline(5,
      x_in_l, -y1, z_in_l,
      x_in_l,  y1, z_in_l,
      x_out_l, y2, z_out_l,
      x_out_l,-y2, z_out_l,
      x_in_l, -y1, z_in_l);

   line(x_in_l,   y1, z_in_l,  x_in_r,  y1, z_in_r);
   line(x_in_l,  -y1, z_in_l,  x_in_r, -y1, z_in_r);
   line(x_out_l,  y2, z_out_l, x_out_r, y2, z_out_r);
   line(x_out_l, -y2, z_out_l, x_out_r,-y2, z_out_r);

   multiline(5,
      x_in_r, -y1, z_in_r,
      x_in_r,  y1, z_in_r,
      x_out_r, y2, z_out_r,
      x_out_r,-y2, z_out_r,
      x_in_r, -y1, z_in_r);

  for (i = 1; i < nslit; i++) {
    theta1 = i*window_theta+theta_min-beta_in/2;
    theta2 = i*window_theta+theta_min+beta_in/2;
    theta3 = i*window_theta+theta_min-beta_out/2;
    theta4 = i*window_theta+theta_min+beta_out/2;

    z_in_l = radius*cos(theta1);
    x_in_l = radius*sin(theta1);
    z_in_r = radius*cos(theta2);
    x_in_r = radius*sin(theta2);

    z_out_l = out_radius*cos(theta3);
    x_out_l = out_radius*sin(theta3);
    z_out_r = out_radius*cos(theta4);
    x_out_r = out_radius*sin(theta4);
    /* left side */
    multiline(5,
      x_in_l, -y1, z_in_l,
      x_in_l,  y1, z_in_l,
      x_out_l, y2, z_out_l,
      x_out_l,-y2, z_out_l,
      x_in_l, -y1, z_in_l);
   /* left -> right lines */
   line(x_in_l,   y1, z_in_l,  x_in_r,  y1, z_in_r);
   line(x_in_l,  -y1, z_in_l,  x_in_r, -y1, z_in_r);
   line(x_out_l,  y2, z_out_l, x_out_r, y2, z_out_r);
   line(x_out_l, -y2, z_out_l, x_out_r,-y2, z_out_r);
   /* right side */
   multiline(5,
      x_in_r, -y1, z_in_r,
      x_in_r,  y1, z_in_r,
      x_out_r, y2, z_out_r,
      x_out_r,-y2, z_out_r,
      x_in_r, -y1, z_in_r);
  }

  /* remaining bits */

  theta1 = theta_max;
  theta3 = theta1-beta_in/2;
  theta4 = theta1-beta_out/2;

  z_in_l = radius*cos(theta1);
  x_in_l = radius*sin(theta1);
  z_in_r = radius*cos(theta3);
  x_in_r = radius*sin(theta3);

  z_out_l = out_radius*cos(theta1);
  x_out_l = out_radius*sin(theta1);
  z_out_r = out_radius*cos(theta4);
  x_out_r = out_radius*sin(theta4);

    multiline(5,
      x_in_l, -y1, z_in_l,
      x_in_l,  y1, z_in_l,
      x_out_l, y2, z_out_l,
      x_out_l,-y2, z_out_l,
      x_in_l, -y1, z_in_l);

   line(x_in_l,   y1, z_in_l,  x_in_r,  y1, z_in_r);
   line(x_in_l,  -y1, z_in_l,  x_in_r, -y1, z_in_r);
   line(x_out_l,  y2, z_out_l, x_out_r, y2, z_out_r);
   line(x_out_l, -y2, z_out_l, x_out_r,-y2, z_out_r);

   multiline(5,
      x_in_r, -y1, z_in_r,
      x_in_r,  y1, z_in_r,
      x_out_r, y2, z_out_r,
      x_out_r,-y2, z_out_r,
      x_in_r, -y1, z_in_r);

}
#line 73939 "RITA-II.c"
}   /* End of filter_coll=Exact_radial_coll() SETTING parameter declarations. */
#undef theta
#undef divergence
#undef ow
#undef iw
#undef beta_out
#undef beta_in
#undef out_radius
#undef alpha_out
#undef alpha_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'filter'. */
  SIG_MESSAGE("filter (McDisplay)");
  printf("MCDISPLAY: component %s\n", "filter");
#define mccompcurname  filter
#define mccompcurtype  Filter_gen
#define mccompcurindex 85
#define pTable mccfilter_pTable
#define Mode_Table mccfilter_Mode_Table
#define Type_Table mccfilter_Type_Table
{   /* Declarations of filter=Filter_gen() SETTING parameters. */
char* filename = mccfilter_filename;
char* options = mccfilter_options;
MCNUM xmin = mccfilter_xmin;
MCNUM xmax = mccfilter_xmax;
MCNUM ymin = mccfilter_ymin;
MCNUM ymax = mccfilter_ymax;
MCNUM xwidth = mccfilter_xwidth;
MCNUM yheight = mccfilter_yheight;
MCNUM thickness = mccfilter_thickness;
MCNUM scaling = mccfilter_scaling;
MCNUM verbose = mccfilter_verbose;
#line 208 "/usr/share/mcstas/2.5/optics/Filter_gen.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 73984 "RITA-II.c"
}   /* End of filter=Filter_gen() SETTING parameter declarations. */
#undef Type_Table
#undef Mode_Table
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ana_slit1'. */
  SIG_MESSAGE("ana_slit1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ana_slit1");
#define mccompcurname  ana_slit1
#define mccompcurtype  Slit
#define mccompcurindex 86
{   /* Declarations of ana_slit1=Slit() SETTING parameters. */
MCNUM xmin = mccana_slit1_xmin;
MCNUM xmax = mccana_slit1_xmax;
MCNUM ymin = mccana_slit1_ymin;
MCNUM ymax = mccana_slit1_ymax;
MCNUM radius = mccana_slit1_radius;
MCNUM xwidth = mccana_slit1_xwidth;
MCNUM yheight = mccana_slit1_yheight;
#line 81 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 74030 "RITA-II.c"
}   /* End of ana_slit1=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ana_slit2'. */
  SIG_MESSAGE("ana_slit2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ana_slit2");
#define mccompcurname  ana_slit2
#define mccompcurtype  Slit
#define mccompcurindex 87
{   /* Declarations of ana_slit2=Slit() SETTING parameters. */
MCNUM xmin = mccana_slit2_xmin;
MCNUM xmax = mccana_slit2_xmax;
MCNUM ymin = mccana_slit2_ymin;
MCNUM ymax = mccana_slit2_ymax;
MCNUM radius = mccana_slit2_radius;
MCNUM xwidth = mccana_slit2_xwidth;
MCNUM yheight = mccana_slit2_yheight;
#line 81 "/usr/share/mcstas/2.5/optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 74073 "RITA-II.c"
}   /* End of ana_slit2=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_before_ana'. */
  SIG_MESSAGE("emon_before_ana (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_before_ana");
#define mccompcurname  emon_before_ana
#define mccompcurtype  E_monitor
#define mccompcurindex 88
#define nE mccemon_before_ana_nE
#define E_N mccemon_before_ana_E_N
#define E_p mccemon_before_ana_E_p
#define E_p2 mccemon_before_ana_E_p2
#define S_p mccemon_before_ana_S_p
#define S_pE mccemon_before_ana_S_pE
#define S_pE2 mccemon_before_ana_S_pE2
{   /* Declarations of emon_before_ana=E_monitor() SETTING parameters. */
char* filename = mccemon_before_ana_filename;
MCNUM xmin = mccemon_before_ana_xmin;
MCNUM xmax = mccemon_before_ana_xmax;
MCNUM ymin = mccemon_before_ana_ymin;
MCNUM ymax = mccemon_before_ana_ymax;
MCNUM xwidth = mccemon_before_ana_xwidth;
MCNUM yheight = mccemon_before_ana_yheight;
MCNUM Emin = mccemon_before_ana_Emin;
MCNUM Emax = mccemon_before_ana_Emax;
MCNUM restore_neutron = mccemon_before_ana_restore_neutron;
int nowritefile = mccemon_before_ana_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 74113 "RITA-II.c"
}   /* End of emon_before_ana=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_before_ana'. */
  SIG_MESSAGE("psd_before_ana (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_before_ana");
#define mccompcurname  psd_before_ana
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define nx mccpsd_before_ana_nx
#define ny mccpsd_before_ana_ny
#define PSD_N mccpsd_before_ana_PSD_N
#define PSD_p mccpsd_before_ana_PSD_p
#define PSD_p2 mccpsd_before_ana_PSD_p2
{   /* Declarations of psd_before_ana=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_before_ana_filename;
MCNUM xmin = mccpsd_before_ana_xmin;
MCNUM xmax = mccpsd_before_ana_xmax;
MCNUM ymin = mccpsd_before_ana_ymin;
MCNUM ymax = mccpsd_before_ana_ymax;
MCNUM xwidth = mccpsd_before_ana_xwidth;
MCNUM yheight = mccpsd_before_ana_yheight;
MCNUM restore_neutron = mccpsd_before_ana_restore_neutron;
int nowritefile = mccpsd_before_ana_nowritefile;
#line 115 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 74156 "RITA-II.c"
}   /* End of psd_before_ana=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'divmon_before_ana'. */
  SIG_MESSAGE("divmon_before_ana (McDisplay)");
  printf("MCDISPLAY: component %s\n", "divmon_before_ana");
#define mccompcurname  divmon_before_ana
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 90
#define nh mccdivmon_before_ana_nh
#define nv mccdivmon_before_ana_nv
#define Div_N mccdivmon_before_ana_Div_N
#define Div_p mccdivmon_before_ana_Div_p
#define Div_p2 mccdivmon_before_ana_Div_p2
{   /* Declarations of divmon_before_ana=Divergence_monitor() SETTING parameters. */
char* filename = mccdivmon_before_ana_filename;
MCNUM xmin = mccdivmon_before_ana_xmin;
MCNUM xmax = mccdivmon_before_ana_xmax;
MCNUM ymin = mccdivmon_before_ana_ymin;
MCNUM ymax = mccdivmon_before_ana_ymax;
MCNUM xwidth = mccdivmon_before_ana_xwidth;
MCNUM yheight = mccdivmon_before_ana_yheight;
MCNUM maxdiv_h = mccdivmon_before_ana_maxdiv_h;
MCNUM maxdiv_v = mccdivmon_before_ana_maxdiv_v;
MCNUM restore_neutron = mccdivmon_before_ana_restore_neutron;
MCNUM nx = mccdivmon_before_ana_nx;
MCNUM ny = mccdivmon_before_ana_ny;
MCNUM nz = mccdivmon_before_ana_nz;
int nowritefile = mccdivmon_before_ana_nowritefile;
#line 131 "/usr/share/mcstas/2.5/monitors/Divergence_monitor.comp"
{
    
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 74202 "RITA-II.c"
}   /* End of divmon_before_ana=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'focus_ana'. */
  SIG_MESSAGE("focus_ana (McDisplay)");
  printf("MCDISPLAY: component %s\n", "focus_ana");
#define mccompcurname  focus_ana
#define mccompcurtype  Arm
#define mccompcurindex 91
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 74227 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an1l'. */
  SIG_MESSAGE("an1l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an1l");
#define mccompcurname  an1l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 92
#define mos_rms_y mccan1l_mos_rms_y
#define mos_rms_z mccan1l_mos_rms_z
#define mos_rms_max mccan1l_mos_rms_max
#define mono_Q mccan1l_mono_Q
{   /* Declarations of an1l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan1l_zmin;
MCNUM zmax = mccan1l_zmax;
MCNUM ymin = mccan1l_ymin;
MCNUM ymax = mccan1l_ymax;
MCNUM zwidth = mccan1l_zwidth;
MCNUM yheight = mccan1l_yheight;
MCNUM mosaich = mccan1l_mosaich;
MCNUM mosaicv = mccan1l_mosaicv;
MCNUM r0 = mccan1l_r0;
MCNUM Q = mccan1l_Q;
MCNUM DM = mccan1l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74263 "RITA-II.c"
}   /* End of an1l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an1u'. */
  SIG_MESSAGE("an1u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an1u");
#define mccompcurname  an1u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 93
#define mos_rms_y mccan1u_mos_rms_y
#define mos_rms_z mccan1u_mos_rms_z
#define mos_rms_max mccan1u_mos_rms_max
#define mono_Q mccan1u_mono_Q
{   /* Declarations of an1u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan1u_zmin;
MCNUM zmax = mccan1u_zmax;
MCNUM ymin = mccan1u_ymin;
MCNUM ymax = mccan1u_ymax;
MCNUM zwidth = mccan1u_zwidth;
MCNUM yheight = mccan1u_yheight;
MCNUM mosaich = mccan1u_mosaich;
MCNUM mosaicv = mccan1u_mosaicv;
MCNUM r0 = mccan1u_r0;
MCNUM Q = mccan1u_Q;
MCNUM DM = mccan1u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74304 "RITA-II.c"
}   /* End of an1u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an2l'. */
  SIG_MESSAGE("an2l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an2l");
#define mccompcurname  an2l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 94
#define mos_rms_y mccan2l_mos_rms_y
#define mos_rms_z mccan2l_mos_rms_z
#define mos_rms_max mccan2l_mos_rms_max
#define mono_Q mccan2l_mono_Q
{   /* Declarations of an2l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan2l_zmin;
MCNUM zmax = mccan2l_zmax;
MCNUM ymin = mccan2l_ymin;
MCNUM ymax = mccan2l_ymax;
MCNUM zwidth = mccan2l_zwidth;
MCNUM yheight = mccan2l_yheight;
MCNUM mosaich = mccan2l_mosaich;
MCNUM mosaicv = mccan2l_mosaicv;
MCNUM r0 = mccan2l_r0;
MCNUM Q = mccan2l_Q;
MCNUM DM = mccan2l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74345 "RITA-II.c"
}   /* End of an2l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an2u'. */
  SIG_MESSAGE("an2u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an2u");
#define mccompcurname  an2u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 95
#define mos_rms_y mccan2u_mos_rms_y
#define mos_rms_z mccan2u_mos_rms_z
#define mos_rms_max mccan2u_mos_rms_max
#define mono_Q mccan2u_mono_Q
{   /* Declarations of an2u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan2u_zmin;
MCNUM zmax = mccan2u_zmax;
MCNUM ymin = mccan2u_ymin;
MCNUM ymax = mccan2u_ymax;
MCNUM zwidth = mccan2u_zwidth;
MCNUM yheight = mccan2u_yheight;
MCNUM mosaich = mccan2u_mosaich;
MCNUM mosaicv = mccan2u_mosaicv;
MCNUM r0 = mccan2u_r0;
MCNUM Q = mccan2u_Q;
MCNUM DM = mccan2u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74386 "RITA-II.c"
}   /* End of an2u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an3l'. */
  SIG_MESSAGE("an3l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an3l");
#define mccompcurname  an3l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 96
#define mos_rms_y mccan3l_mos_rms_y
#define mos_rms_z mccan3l_mos_rms_z
#define mos_rms_max mccan3l_mos_rms_max
#define mono_Q mccan3l_mono_Q
{   /* Declarations of an3l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan3l_zmin;
MCNUM zmax = mccan3l_zmax;
MCNUM ymin = mccan3l_ymin;
MCNUM ymax = mccan3l_ymax;
MCNUM zwidth = mccan3l_zwidth;
MCNUM yheight = mccan3l_yheight;
MCNUM mosaich = mccan3l_mosaich;
MCNUM mosaicv = mccan3l_mosaicv;
MCNUM r0 = mccan3l_r0;
MCNUM Q = mccan3l_Q;
MCNUM DM = mccan3l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74427 "RITA-II.c"
}   /* End of an3l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an3u'. */
  SIG_MESSAGE("an3u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an3u");
#define mccompcurname  an3u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 97
#define mos_rms_y mccan3u_mos_rms_y
#define mos_rms_z mccan3u_mos_rms_z
#define mos_rms_max mccan3u_mos_rms_max
#define mono_Q mccan3u_mono_Q
{   /* Declarations of an3u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan3u_zmin;
MCNUM zmax = mccan3u_zmax;
MCNUM ymin = mccan3u_ymin;
MCNUM ymax = mccan3u_ymax;
MCNUM zwidth = mccan3u_zwidth;
MCNUM yheight = mccan3u_yheight;
MCNUM mosaich = mccan3u_mosaich;
MCNUM mosaicv = mccan3u_mosaicv;
MCNUM r0 = mccan3u_r0;
MCNUM Q = mccan3u_Q;
MCNUM DM = mccan3u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74468 "RITA-II.c"
}   /* End of an3u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an4l'. */
  SIG_MESSAGE("an4l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an4l");
#define mccompcurname  an4l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 98
#define mos_rms_y mccan4l_mos_rms_y
#define mos_rms_z mccan4l_mos_rms_z
#define mos_rms_max mccan4l_mos_rms_max
#define mono_Q mccan4l_mono_Q
{   /* Declarations of an4l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan4l_zmin;
MCNUM zmax = mccan4l_zmax;
MCNUM ymin = mccan4l_ymin;
MCNUM ymax = mccan4l_ymax;
MCNUM zwidth = mccan4l_zwidth;
MCNUM yheight = mccan4l_yheight;
MCNUM mosaich = mccan4l_mosaich;
MCNUM mosaicv = mccan4l_mosaicv;
MCNUM r0 = mccan4l_r0;
MCNUM Q = mccan4l_Q;
MCNUM DM = mccan4l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74509 "RITA-II.c"
}   /* End of an4l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an4u'. */
  SIG_MESSAGE("an4u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an4u");
#define mccompcurname  an4u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 99
#define mos_rms_y mccan4u_mos_rms_y
#define mos_rms_z mccan4u_mos_rms_z
#define mos_rms_max mccan4u_mos_rms_max
#define mono_Q mccan4u_mono_Q
{   /* Declarations of an4u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan4u_zmin;
MCNUM zmax = mccan4u_zmax;
MCNUM ymin = mccan4u_ymin;
MCNUM ymax = mccan4u_ymax;
MCNUM zwidth = mccan4u_zwidth;
MCNUM yheight = mccan4u_yheight;
MCNUM mosaich = mccan4u_mosaich;
MCNUM mosaicv = mccan4u_mosaicv;
MCNUM r0 = mccan4u_r0;
MCNUM Q = mccan4u_Q;
MCNUM DM = mccan4u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74550 "RITA-II.c"
}   /* End of an4u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an5l'. */
  SIG_MESSAGE("an5l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an5l");
#define mccompcurname  an5l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 100
#define mos_rms_y mccan5l_mos_rms_y
#define mos_rms_z mccan5l_mos_rms_z
#define mos_rms_max mccan5l_mos_rms_max
#define mono_Q mccan5l_mono_Q
{   /* Declarations of an5l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan5l_zmin;
MCNUM zmax = mccan5l_zmax;
MCNUM ymin = mccan5l_ymin;
MCNUM ymax = mccan5l_ymax;
MCNUM zwidth = mccan5l_zwidth;
MCNUM yheight = mccan5l_yheight;
MCNUM mosaich = mccan5l_mosaich;
MCNUM mosaicv = mccan5l_mosaicv;
MCNUM r0 = mccan5l_r0;
MCNUM Q = mccan5l_Q;
MCNUM DM = mccan5l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74591 "RITA-II.c"
}   /* End of an5l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an5u'. */
  SIG_MESSAGE("an5u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an5u");
#define mccompcurname  an5u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 101
#define mos_rms_y mccan5u_mos_rms_y
#define mos_rms_z mccan5u_mos_rms_z
#define mos_rms_max mccan5u_mos_rms_max
#define mono_Q mccan5u_mono_Q
{   /* Declarations of an5u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan5u_zmin;
MCNUM zmax = mccan5u_zmax;
MCNUM ymin = mccan5u_ymin;
MCNUM ymax = mccan5u_ymax;
MCNUM zwidth = mccan5u_zwidth;
MCNUM yheight = mccan5u_yheight;
MCNUM mosaich = mccan5u_mosaich;
MCNUM mosaicv = mccan5u_mosaicv;
MCNUM r0 = mccan5u_r0;
MCNUM Q = mccan5u_Q;
MCNUM DM = mccan5u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74632 "RITA-II.c"
}   /* End of an5u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an6l'. */
  SIG_MESSAGE("an6l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an6l");
#define mccompcurname  an6l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 102
#define mos_rms_y mccan6l_mos_rms_y
#define mos_rms_z mccan6l_mos_rms_z
#define mos_rms_max mccan6l_mos_rms_max
#define mono_Q mccan6l_mono_Q
{   /* Declarations of an6l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan6l_zmin;
MCNUM zmax = mccan6l_zmax;
MCNUM ymin = mccan6l_ymin;
MCNUM ymax = mccan6l_ymax;
MCNUM zwidth = mccan6l_zwidth;
MCNUM yheight = mccan6l_yheight;
MCNUM mosaich = mccan6l_mosaich;
MCNUM mosaicv = mccan6l_mosaicv;
MCNUM r0 = mccan6l_r0;
MCNUM Q = mccan6l_Q;
MCNUM DM = mccan6l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74673 "RITA-II.c"
}   /* End of an6l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an6u'. */
  SIG_MESSAGE("an6u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an6u");
#define mccompcurname  an6u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 103
#define mos_rms_y mccan6u_mos_rms_y
#define mos_rms_z mccan6u_mos_rms_z
#define mos_rms_max mccan6u_mos_rms_max
#define mono_Q mccan6u_mono_Q
{   /* Declarations of an6u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan6u_zmin;
MCNUM zmax = mccan6u_zmax;
MCNUM ymin = mccan6u_ymin;
MCNUM ymax = mccan6u_ymax;
MCNUM zwidth = mccan6u_zwidth;
MCNUM yheight = mccan6u_yheight;
MCNUM mosaich = mccan6u_mosaich;
MCNUM mosaicv = mccan6u_mosaicv;
MCNUM r0 = mccan6u_r0;
MCNUM Q = mccan6u_Q;
MCNUM DM = mccan6u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74714 "RITA-II.c"
}   /* End of an6u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an7l'. */
  SIG_MESSAGE("an7l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an7l");
#define mccompcurname  an7l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 104
#define mos_rms_y mccan7l_mos_rms_y
#define mos_rms_z mccan7l_mos_rms_z
#define mos_rms_max mccan7l_mos_rms_max
#define mono_Q mccan7l_mono_Q
{   /* Declarations of an7l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan7l_zmin;
MCNUM zmax = mccan7l_zmax;
MCNUM ymin = mccan7l_ymin;
MCNUM ymax = mccan7l_ymax;
MCNUM zwidth = mccan7l_zwidth;
MCNUM yheight = mccan7l_yheight;
MCNUM mosaich = mccan7l_mosaich;
MCNUM mosaicv = mccan7l_mosaicv;
MCNUM r0 = mccan7l_r0;
MCNUM Q = mccan7l_Q;
MCNUM DM = mccan7l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74755 "RITA-II.c"
}   /* End of an7l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an7u'. */
  SIG_MESSAGE("an7u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an7u");
#define mccompcurname  an7u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 105
#define mos_rms_y mccan7u_mos_rms_y
#define mos_rms_z mccan7u_mos_rms_z
#define mos_rms_max mccan7u_mos_rms_max
#define mono_Q mccan7u_mono_Q
{   /* Declarations of an7u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan7u_zmin;
MCNUM zmax = mccan7u_zmax;
MCNUM ymin = mccan7u_ymin;
MCNUM ymax = mccan7u_ymax;
MCNUM zwidth = mccan7u_zwidth;
MCNUM yheight = mccan7u_yheight;
MCNUM mosaich = mccan7u_mosaich;
MCNUM mosaicv = mccan7u_mosaicv;
MCNUM r0 = mccan7u_r0;
MCNUM Q = mccan7u_Q;
MCNUM DM = mccan7u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74796 "RITA-II.c"
}   /* End of an7u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an8l'. */
  SIG_MESSAGE("an8l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an8l");
#define mccompcurname  an8l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 106
#define mos_rms_y mccan8l_mos_rms_y
#define mos_rms_z mccan8l_mos_rms_z
#define mos_rms_max mccan8l_mos_rms_max
#define mono_Q mccan8l_mono_Q
{   /* Declarations of an8l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan8l_zmin;
MCNUM zmax = mccan8l_zmax;
MCNUM ymin = mccan8l_ymin;
MCNUM ymax = mccan8l_ymax;
MCNUM zwidth = mccan8l_zwidth;
MCNUM yheight = mccan8l_yheight;
MCNUM mosaich = mccan8l_mosaich;
MCNUM mosaicv = mccan8l_mosaicv;
MCNUM r0 = mccan8l_r0;
MCNUM Q = mccan8l_Q;
MCNUM DM = mccan8l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74837 "RITA-II.c"
}   /* End of an8l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an8u'. */
  SIG_MESSAGE("an8u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an8u");
#define mccompcurname  an8u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 107
#define mos_rms_y mccan8u_mos_rms_y
#define mos_rms_z mccan8u_mos_rms_z
#define mos_rms_max mccan8u_mos_rms_max
#define mono_Q mccan8u_mono_Q
{   /* Declarations of an8u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan8u_zmin;
MCNUM zmax = mccan8u_zmax;
MCNUM ymin = mccan8u_ymin;
MCNUM ymax = mccan8u_ymax;
MCNUM zwidth = mccan8u_zwidth;
MCNUM yheight = mccan8u_yheight;
MCNUM mosaich = mccan8u_mosaich;
MCNUM mosaicv = mccan8u_mosaicv;
MCNUM r0 = mccan8u_r0;
MCNUM Q = mccan8u_Q;
MCNUM DM = mccan8u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74878 "RITA-II.c"
}   /* End of an8u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an9l'. */
  SIG_MESSAGE("an9l (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an9l");
#define mccompcurname  an9l
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 108
#define mos_rms_y mccan9l_mos_rms_y
#define mos_rms_z mccan9l_mos_rms_z
#define mos_rms_max mccan9l_mos_rms_max
#define mono_Q mccan9l_mono_Q
{   /* Declarations of an9l=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan9l_zmin;
MCNUM zmax = mccan9l_zmax;
MCNUM ymin = mccan9l_ymin;
MCNUM ymax = mccan9l_ymax;
MCNUM zwidth = mccan9l_zwidth;
MCNUM yheight = mccan9l_yheight;
MCNUM mosaich = mccan9l_mosaich;
MCNUM mosaicv = mccan9l_mosaicv;
MCNUM r0 = mccan9l_r0;
MCNUM Q = mccan9l_Q;
MCNUM DM = mccan9l_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74919 "RITA-II.c"
}   /* End of an9l=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'an9u'. */
  SIG_MESSAGE("an9u (McDisplay)");
  printf("MCDISPLAY: component %s\n", "an9u");
#define mccompcurname  an9u
#define mccompcurtype  Monochromator_flat
#define mccompcurindex 109
#define mos_rms_y mccan9u_mos_rms_y
#define mos_rms_z mccan9u_mos_rms_z
#define mos_rms_max mccan9u_mos_rms_max
#define mono_Q mccan9u_mono_Q
{   /* Declarations of an9u=Monochromator_flat() SETTING parameters. */
MCNUM zmin = mccan9u_zmin;
MCNUM zmax = mccan9u_zmax;
MCNUM ymin = mccan9u_ymin;
MCNUM ymax = mccan9u_ymax;
MCNUM zwidth = mccan9u_zwidth;
MCNUM yheight = mccan9u_yheight;
MCNUM mosaich = mccan9u_mosaich;
MCNUM mosaicv = mccan9u_mosaicv;
MCNUM r0 = mccan9u_r0;
MCNUM Q = mccan9u_Q;
MCNUM DM = mccan9u_DM;
#line 254 "/usr/share/mcstas/2.5/optics/Monochromator_flat.comp"
{
  
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
}
#line 74960 "RITA-II.c"
}   /* End of an9u=Monochromator_flat() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'a6'. */
  SIG_MESSAGE("a6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "a6");
#define mccompcurname  a6
#define mccompcurtype  Arm
#define mccompcurindex 110
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 74984 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_before_coarse'. */
  SIG_MESSAGE("emon_before_coarse (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_before_coarse");
#define mccompcurname  emon_before_coarse
#define mccompcurtype  E_monitor
#define mccompcurindex 111
#define nE mccemon_before_coarse_nE
#define E_N mccemon_before_coarse_E_N
#define E_p mccemon_before_coarse_E_p
#define E_p2 mccemon_before_coarse_E_p2
#define S_p mccemon_before_coarse_S_p
#define S_pE mccemon_before_coarse_S_pE
#define S_pE2 mccemon_before_coarse_S_pE2
{   /* Declarations of emon_before_coarse=E_monitor() SETTING parameters. */
char* filename = mccemon_before_coarse_filename;
MCNUM xmin = mccemon_before_coarse_xmin;
MCNUM xmax = mccemon_before_coarse_xmax;
MCNUM ymin = mccemon_before_coarse_ymin;
MCNUM ymax = mccemon_before_coarse_ymax;
MCNUM xwidth = mccemon_before_coarse_xwidth;
MCNUM yheight = mccemon_before_coarse_yheight;
MCNUM Emin = mccemon_before_coarse_Emin;
MCNUM Emax = mccemon_before_coarse_Emax;
MCNUM restore_neutron = mccemon_before_coarse_restore_neutron;
int nowritefile = mccemon_before_coarse_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75023 "RITA-II.c"
}   /* End of emon_before_coarse=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_before_coarse'. */
  SIG_MESSAGE("psd_before_coarse (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_before_coarse");
#define mccompcurname  psd_before_coarse
#define mccompcurtype  PSD_monitor
#define mccompcurindex 112
#define nx mccpsd_before_coarse_nx
#define ny mccpsd_before_coarse_ny
#define PSD_N mccpsd_before_coarse_PSD_N
#define PSD_p mccpsd_before_coarse_PSD_p
#define PSD_p2 mccpsd_before_coarse_PSD_p2
{   /* Declarations of psd_before_coarse=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_before_coarse_filename;
MCNUM xmin = mccpsd_before_coarse_xmin;
MCNUM xmax = mccpsd_before_coarse_xmax;
MCNUM ymin = mccpsd_before_coarse_ymin;
MCNUM ymax = mccpsd_before_coarse_ymax;
MCNUM xwidth = mccpsd_before_coarse_xwidth;
MCNUM yheight = mccpsd_before_coarse_yheight;
MCNUM restore_neutron = mccpsd_before_coarse_restore_neutron;
int nowritefile = mccpsd_before_coarse_nowritefile;
#line 115 "/usr/share/mcstas/2.5/monitors/PSD_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75066 "RITA-II.c"
}   /* End of psd_before_coarse=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmR1'. */
  SIG_MESSAGE("ArmR1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmR1");
#define mccompcurname  ArmR1
#define mccompcurtype  Arm
#define mccompcurindex 113
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75091 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeR1'. */
  SIG_MESSAGE("BladeR1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeR1");
#define mccompcurname  BladeR1
#define mccompcurtype  Absorber
#define mccompcurindex 114
#define xw mccBladeR1_xw
#define yh mccBladeR1_yh
#define zt mccBladeR1_zt
#define xm mccBladeR1_xm
#define ym mccBladeR1_ym
#define zm mccBladeR1_zm
{   /* Declarations of BladeR1=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR1_xmin;
MCNUM xmax = mccBladeR1_xmax;
MCNUM ymin = mccBladeR1_ymin;
MCNUM ymax = mccBladeR1_ymax;
MCNUM zmin = mccBladeR1_zmin;
MCNUM zmax = mccBladeR1_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75120 "RITA-II.c"
}   /* End of BladeR1=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmR2'. */
  SIG_MESSAGE("ArmR2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmR2");
#define mccompcurname  ArmR2
#define mccompcurtype  Arm
#define mccompcurindex 115
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75146 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeR2'. */
  SIG_MESSAGE("BladeR2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeR2");
#define mccompcurname  BladeR2
#define mccompcurtype  Absorber
#define mccompcurindex 116
#define xw mccBladeR2_xw
#define yh mccBladeR2_yh
#define zt mccBladeR2_zt
#define xm mccBladeR2_xm
#define ym mccBladeR2_ym
#define zm mccBladeR2_zm
{   /* Declarations of BladeR2=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR2_xmin;
MCNUM xmax = mccBladeR2_xmax;
MCNUM ymin = mccBladeR2_ymin;
MCNUM ymax = mccBladeR2_ymax;
MCNUM zmin = mccBladeR2_zmin;
MCNUM zmax = mccBladeR2_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75175 "RITA-II.c"
}   /* End of BladeR2=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmR3'. */
  SIG_MESSAGE("ArmR3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmR3");
#define mccompcurname  ArmR3
#define mccompcurtype  Arm
#define mccompcurindex 117
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75201 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeR3'. */
  SIG_MESSAGE("BladeR3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeR3");
#define mccompcurname  BladeR3
#define mccompcurtype  Absorber
#define mccompcurindex 118
#define xw mccBladeR3_xw
#define yh mccBladeR3_yh
#define zt mccBladeR3_zt
#define xm mccBladeR3_xm
#define ym mccBladeR3_ym
#define zm mccBladeR3_zm
{   /* Declarations of BladeR3=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR3_xmin;
MCNUM xmax = mccBladeR3_xmax;
MCNUM ymin = mccBladeR3_ymin;
MCNUM ymax = mccBladeR3_ymax;
MCNUM zmin = mccBladeR3_zmin;
MCNUM zmax = mccBladeR3_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75230 "RITA-II.c"
}   /* End of BladeR3=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmR4'. */
  SIG_MESSAGE("ArmR4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmR4");
#define mccompcurname  ArmR4
#define mccompcurtype  Arm
#define mccompcurindex 119
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75256 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeR4'. */
  SIG_MESSAGE("BladeR4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeR4");
#define mccompcurname  BladeR4
#define mccompcurtype  Absorber
#define mccompcurindex 120
#define xw mccBladeR4_xw
#define yh mccBladeR4_yh
#define zt mccBladeR4_zt
#define xm mccBladeR4_xm
#define ym mccBladeR4_ym
#define zm mccBladeR4_zm
{   /* Declarations of BladeR4=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR4_xmin;
MCNUM xmax = mccBladeR4_xmax;
MCNUM ymin = mccBladeR4_ymin;
MCNUM ymax = mccBladeR4_ymax;
MCNUM zmin = mccBladeR4_zmin;
MCNUM zmax = mccBladeR4_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75285 "RITA-II.c"
}   /* End of BladeR4=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmR5'. */
  SIG_MESSAGE("ArmR5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmR5");
#define mccompcurname  ArmR5
#define mccompcurtype  Arm
#define mccompcurindex 121
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75311 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeR5'. */
  SIG_MESSAGE("BladeR5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeR5");
#define mccompcurname  BladeR5
#define mccompcurtype  Absorber
#define mccompcurindex 122
#define xw mccBladeR5_xw
#define yh mccBladeR5_yh
#define zt mccBladeR5_zt
#define xm mccBladeR5_xm
#define ym mccBladeR5_ym
#define zm mccBladeR5_zm
{   /* Declarations of BladeR5=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeR5_xmin;
MCNUM xmax = mccBladeR5_xmax;
MCNUM ymin = mccBladeR5_ymin;
MCNUM ymax = mccBladeR5_ymax;
MCNUM zmin = mccBladeR5_zmin;
MCNUM zmax = mccBladeR5_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75340 "RITA-II.c"
}   /* End of BladeR5=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmL1'. */
  SIG_MESSAGE("ArmL1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmL1");
#define mccompcurname  ArmL1
#define mccompcurtype  Arm
#define mccompcurindex 123
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75366 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeL1'. */
  SIG_MESSAGE("BladeL1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeL1");
#define mccompcurname  BladeL1
#define mccompcurtype  Absorber
#define mccompcurindex 124
#define xw mccBladeL1_xw
#define yh mccBladeL1_yh
#define zt mccBladeL1_zt
#define xm mccBladeL1_xm
#define ym mccBladeL1_ym
#define zm mccBladeL1_zm
{   /* Declarations of BladeL1=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL1_xmin;
MCNUM xmax = mccBladeL1_xmax;
MCNUM ymin = mccBladeL1_ymin;
MCNUM ymax = mccBladeL1_ymax;
MCNUM zmin = mccBladeL1_zmin;
MCNUM zmax = mccBladeL1_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75395 "RITA-II.c"
}   /* End of BladeL1=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmL2'. */
  SIG_MESSAGE("ArmL2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmL2");
#define mccompcurname  ArmL2
#define mccompcurtype  Arm
#define mccompcurindex 125
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75421 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeL2'. */
  SIG_MESSAGE("BladeL2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeL2");
#define mccompcurname  BladeL2
#define mccompcurtype  Absorber
#define mccompcurindex 126
#define xw mccBladeL2_xw
#define yh mccBladeL2_yh
#define zt mccBladeL2_zt
#define xm mccBladeL2_xm
#define ym mccBladeL2_ym
#define zm mccBladeL2_zm
{   /* Declarations of BladeL2=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL2_xmin;
MCNUM xmax = mccBladeL2_xmax;
MCNUM ymin = mccBladeL2_ymin;
MCNUM ymax = mccBladeL2_ymax;
MCNUM zmin = mccBladeL2_zmin;
MCNUM zmax = mccBladeL2_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75450 "RITA-II.c"
}   /* End of BladeL2=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmL3'. */
  SIG_MESSAGE("ArmL3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmL3");
#define mccompcurname  ArmL3
#define mccompcurtype  Arm
#define mccompcurindex 127
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75476 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeL3'. */
  SIG_MESSAGE("BladeL3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeL3");
#define mccompcurname  BladeL3
#define mccompcurtype  Absorber
#define mccompcurindex 128
#define xw mccBladeL3_xw
#define yh mccBladeL3_yh
#define zt mccBladeL3_zt
#define xm mccBladeL3_xm
#define ym mccBladeL3_ym
#define zm mccBladeL3_zm
{   /* Declarations of BladeL3=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL3_xmin;
MCNUM xmax = mccBladeL3_xmax;
MCNUM ymin = mccBladeL3_ymin;
MCNUM ymax = mccBladeL3_ymax;
MCNUM zmin = mccBladeL3_zmin;
MCNUM zmax = mccBladeL3_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75505 "RITA-II.c"
}   /* End of BladeL3=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmL4'. */
  SIG_MESSAGE("ArmL4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmL4");
#define mccompcurname  ArmL4
#define mccompcurtype  Arm
#define mccompcurindex 129
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75531 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeL4'. */
  SIG_MESSAGE("BladeL4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeL4");
#define mccompcurname  BladeL4
#define mccompcurtype  Absorber
#define mccompcurindex 130
#define xw mccBladeL4_xw
#define yh mccBladeL4_yh
#define zt mccBladeL4_zt
#define xm mccBladeL4_xm
#define ym mccBladeL4_ym
#define zm mccBladeL4_zm
{   /* Declarations of BladeL4=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL4_xmin;
MCNUM xmax = mccBladeL4_xmax;
MCNUM ymin = mccBladeL4_ymin;
MCNUM ymax = mccBladeL4_ymax;
MCNUM zmin = mccBladeL4_zmin;
MCNUM zmax = mccBladeL4_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75560 "RITA-II.c"
}   /* End of BladeL4=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmL5'. */
  SIG_MESSAGE("ArmL5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmL5");
#define mccompcurname  ArmL5
#define mccompcurtype  Arm
#define mccompcurindex 131
#line 40 "/usr/share/mcstas/2.5/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 75586 "RITA-II.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BladeL5'. */
  SIG_MESSAGE("BladeL5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BladeL5");
#define mccompcurname  BladeL5
#define mccompcurtype  Absorber
#define mccompcurindex 132
#define xw mccBladeL5_xw
#define yh mccBladeL5_yh
#define zt mccBladeL5_zt
#define xm mccBladeL5_xm
#define ym mccBladeL5_ym
#define zm mccBladeL5_zm
{   /* Declarations of BladeL5=Absorber() SETTING parameters. */
MCNUM xmin = mccBladeL5_xmin;
MCNUM xmax = mccBladeL5_xmax;
MCNUM ymin = mccBladeL5_ymin;
MCNUM ymax = mccBladeL5_ymax;
MCNUM zmin = mccBladeL5_zmin;
MCNUM zmax = mccBladeL5_zmax;
#line 73 "/usr/share/mcstas/2.5/optics/Absorber.comp"
{
  
  box(xm, ym, zm, xw, yh, zt);
}
#line 75615 "RITA-II.c"
}   /* End of BladeL5=Absorber() SETTING parameter declarations. */
#undef zm
#undef ym
#undef xm
#undef zt
#undef yh
#undef xw
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_detector'. */
  SIG_MESSAGE("psd_detector (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_detector");
#define mccompcurname  psd_detector
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 133
#define nx mccpsd_detector_nx
#define ny mccpsd_detector_ny
#define filename mccpsd_detector_filename
#define PSD_N mccpsd_detector_PSD_N
#define PSD_p mccpsd_detector_PSD_p
#define PSD_p2 mccpsd_detector_PSD_p2
#define weight mccpsd_detector_weight
{   /* Declarations of psd_detector=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_detector_xmin;
MCNUM xmax = mccpsd_detector_xmax;
MCNUM ymin = mccpsd_detector_ymin;
MCNUM ymax = mccpsd_detector_ymax;
MCNUM xwidth = mccpsd_detector_xwidth;
MCNUM yheight = mccpsd_detector_yheight;
MCNUM psf = mccpsd_detector_psf;
MCNUM k0 = mccpsd_detector_k0;
MCNUM eff = mccpsd_detector_eff;
MCNUM restore_neutron = mccpsd_detector_restore_neutron;
int nowritefile = mccpsd_detector_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75661 "RITA-II.c"
}   /* End of psd_detector=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_detector'. */
  SIG_MESSAGE("emon_detector (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_detector");
#define mccompcurname  emon_detector
#define mccompcurtype  E_monitor
#define mccompcurindex 134
#define nE mccemon_detector_nE
#define E_N mccemon_detector_E_N
#define E_p mccemon_detector_E_p
#define E_p2 mccemon_detector_E_p2
#define S_p mccemon_detector_S_p
#define S_pE mccemon_detector_S_pE
#define S_pE2 mccemon_detector_S_pE2
{   /* Declarations of emon_detector=E_monitor() SETTING parameters. */
char* filename = mccemon_detector_filename;
MCNUM xmin = mccemon_detector_xmin;
MCNUM xmax = mccemon_detector_xmax;
MCNUM ymin = mccemon_detector_ymin;
MCNUM ymax = mccemon_detector_ymax;
MCNUM xwidth = mccemon_detector_xwidth;
MCNUM yheight = mccemon_detector_yheight;
MCNUM Emin = mccemon_detector_Emin;
MCNUM Emax = mccemon_detector_Emax;
MCNUM restore_neutron = mccemon_detector_restore_neutron;
int nowritefile = mccemon_detector_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75708 "RITA-II.c"
}   /* End of emon_detector=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window1'. */
  SIG_MESSAGE("psd_window1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window1");
#define mccompcurname  psd_window1
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 135
#define nx mccpsd_window1_nx
#define ny mccpsd_window1_ny
#define filename mccpsd_window1_filename
#define PSD_N mccpsd_window1_PSD_N
#define PSD_p mccpsd_window1_PSD_p
#define PSD_p2 mccpsd_window1_PSD_p2
#define weight mccpsd_window1_weight
{   /* Declarations of psd_window1=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window1_xmin;
MCNUM xmax = mccpsd_window1_xmax;
MCNUM ymin = mccpsd_window1_ymin;
MCNUM ymax = mccpsd_window1_ymax;
MCNUM xwidth = mccpsd_window1_xwidth;
MCNUM yheight = mccpsd_window1_yheight;
MCNUM psf = mccpsd_window1_psf;
MCNUM k0 = mccpsd_window1_k0;
MCNUM eff = mccpsd_window1_eff;
MCNUM restore_neutron = mccpsd_window1_restore_neutron;
int nowritefile = mccpsd_window1_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75755 "RITA-II.c"
}   /* End of psd_window1=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window1'. */
  SIG_MESSAGE("emon_window1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window1");
#define mccompcurname  emon_window1
#define mccompcurtype  E_monitor
#define mccompcurindex 136
#define nE mccemon_window1_nE
#define E_N mccemon_window1_E_N
#define E_p mccemon_window1_E_p
#define E_p2 mccemon_window1_E_p2
#define S_p mccemon_window1_S_p
#define S_pE mccemon_window1_S_pE
#define S_pE2 mccemon_window1_S_pE2
{   /* Declarations of emon_window1=E_monitor() SETTING parameters. */
char* filename = mccemon_window1_filename;
MCNUM xmin = mccemon_window1_xmin;
MCNUM xmax = mccemon_window1_xmax;
MCNUM ymin = mccemon_window1_ymin;
MCNUM ymax = mccemon_window1_ymax;
MCNUM xwidth = mccemon_window1_xwidth;
MCNUM yheight = mccemon_window1_yheight;
MCNUM Emin = mccemon_window1_Emin;
MCNUM Emax = mccemon_window1_Emax;
MCNUM restore_neutron = mccemon_window1_restore_neutron;
int nowritefile = mccemon_window1_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75802 "RITA-II.c"
}   /* End of emon_window1=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window2'. */
  SIG_MESSAGE("psd_window2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window2");
#define mccompcurname  psd_window2
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 137
#define nx mccpsd_window2_nx
#define ny mccpsd_window2_ny
#define filename mccpsd_window2_filename
#define PSD_N mccpsd_window2_PSD_N
#define PSD_p mccpsd_window2_PSD_p
#define PSD_p2 mccpsd_window2_PSD_p2
#define weight mccpsd_window2_weight
{   /* Declarations of psd_window2=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window2_xmin;
MCNUM xmax = mccpsd_window2_xmax;
MCNUM ymin = mccpsd_window2_ymin;
MCNUM ymax = mccpsd_window2_ymax;
MCNUM xwidth = mccpsd_window2_xwidth;
MCNUM yheight = mccpsd_window2_yheight;
MCNUM psf = mccpsd_window2_psf;
MCNUM k0 = mccpsd_window2_k0;
MCNUM eff = mccpsd_window2_eff;
MCNUM restore_neutron = mccpsd_window2_restore_neutron;
int nowritefile = mccpsd_window2_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75849 "RITA-II.c"
}   /* End of psd_window2=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window2'. */
  SIG_MESSAGE("emon_window2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window2");
#define mccompcurname  emon_window2
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccemon_window2_nE
#define E_N mccemon_window2_E_N
#define E_p mccemon_window2_E_p
#define E_p2 mccemon_window2_E_p2
#define S_p mccemon_window2_S_p
#define S_pE mccemon_window2_S_pE
#define S_pE2 mccemon_window2_S_pE2
{   /* Declarations of emon_window2=E_monitor() SETTING parameters. */
char* filename = mccemon_window2_filename;
MCNUM xmin = mccemon_window2_xmin;
MCNUM xmax = mccemon_window2_xmax;
MCNUM ymin = mccemon_window2_ymin;
MCNUM ymax = mccemon_window2_ymax;
MCNUM xwidth = mccemon_window2_xwidth;
MCNUM yheight = mccemon_window2_yheight;
MCNUM Emin = mccemon_window2_Emin;
MCNUM Emax = mccemon_window2_Emax;
MCNUM restore_neutron = mccemon_window2_restore_neutron;
int nowritefile = mccemon_window2_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75896 "RITA-II.c"
}   /* End of emon_window2=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window3'. */
  SIG_MESSAGE("psd_window3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window3");
#define mccompcurname  psd_window3
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 139
#define nx mccpsd_window3_nx
#define ny mccpsd_window3_ny
#define filename mccpsd_window3_filename
#define PSD_N mccpsd_window3_PSD_N
#define PSD_p mccpsd_window3_PSD_p
#define PSD_p2 mccpsd_window3_PSD_p2
#define weight mccpsd_window3_weight
{   /* Declarations of psd_window3=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window3_xmin;
MCNUM xmax = mccpsd_window3_xmax;
MCNUM ymin = mccpsd_window3_ymin;
MCNUM ymax = mccpsd_window3_ymax;
MCNUM xwidth = mccpsd_window3_xwidth;
MCNUM yheight = mccpsd_window3_yheight;
MCNUM psf = mccpsd_window3_psf;
MCNUM k0 = mccpsd_window3_k0;
MCNUM eff = mccpsd_window3_eff;
MCNUM restore_neutron = mccpsd_window3_restore_neutron;
int nowritefile = mccpsd_window3_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75943 "RITA-II.c"
}   /* End of psd_window3=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window3'. */
  SIG_MESSAGE("emon_window3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window3");
#define mccompcurname  emon_window3
#define mccompcurtype  E_monitor
#define mccompcurindex 140
#define nE mccemon_window3_nE
#define E_N mccemon_window3_E_N
#define E_p mccemon_window3_E_p
#define E_p2 mccemon_window3_E_p2
#define S_p mccemon_window3_S_p
#define S_pE mccemon_window3_S_pE
#define S_pE2 mccemon_window3_S_pE2
{   /* Declarations of emon_window3=E_monitor() SETTING parameters. */
char* filename = mccemon_window3_filename;
MCNUM xmin = mccemon_window3_xmin;
MCNUM xmax = mccemon_window3_xmax;
MCNUM ymin = mccemon_window3_ymin;
MCNUM ymax = mccemon_window3_ymax;
MCNUM xwidth = mccemon_window3_xwidth;
MCNUM yheight = mccemon_window3_yheight;
MCNUM Emin = mccemon_window3_Emin;
MCNUM Emax = mccemon_window3_Emax;
MCNUM restore_neutron = mccemon_window3_restore_neutron;
int nowritefile = mccemon_window3_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 75990 "RITA-II.c"
}   /* End of emon_window3=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window4'. */
  SIG_MESSAGE("psd_window4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window4");
#define mccompcurname  psd_window4
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 141
#define nx mccpsd_window4_nx
#define ny mccpsd_window4_ny
#define filename mccpsd_window4_filename
#define PSD_N mccpsd_window4_PSD_N
#define PSD_p mccpsd_window4_PSD_p
#define PSD_p2 mccpsd_window4_PSD_p2
#define weight mccpsd_window4_weight
{   /* Declarations of psd_window4=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window4_xmin;
MCNUM xmax = mccpsd_window4_xmax;
MCNUM ymin = mccpsd_window4_ymin;
MCNUM ymax = mccpsd_window4_ymax;
MCNUM xwidth = mccpsd_window4_xwidth;
MCNUM yheight = mccpsd_window4_yheight;
MCNUM psf = mccpsd_window4_psf;
MCNUM k0 = mccpsd_window4_k0;
MCNUM eff = mccpsd_window4_eff;
MCNUM restore_neutron = mccpsd_window4_restore_neutron;
int nowritefile = mccpsd_window4_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76037 "RITA-II.c"
}   /* End of psd_window4=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window4'. */
  SIG_MESSAGE("emon_window4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window4");
#define mccompcurname  emon_window4
#define mccompcurtype  E_monitor
#define mccompcurindex 142
#define nE mccemon_window4_nE
#define E_N mccemon_window4_E_N
#define E_p mccemon_window4_E_p
#define E_p2 mccemon_window4_E_p2
#define S_p mccemon_window4_S_p
#define S_pE mccemon_window4_S_pE
#define S_pE2 mccemon_window4_S_pE2
{   /* Declarations of emon_window4=E_monitor() SETTING parameters. */
char* filename = mccemon_window4_filename;
MCNUM xmin = mccemon_window4_xmin;
MCNUM xmax = mccemon_window4_xmax;
MCNUM ymin = mccemon_window4_ymin;
MCNUM ymax = mccemon_window4_ymax;
MCNUM xwidth = mccemon_window4_xwidth;
MCNUM yheight = mccemon_window4_yheight;
MCNUM Emin = mccemon_window4_Emin;
MCNUM Emax = mccemon_window4_Emax;
MCNUM restore_neutron = mccemon_window4_restore_neutron;
int nowritefile = mccemon_window4_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76084 "RITA-II.c"
}   /* End of emon_window4=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window5'. */
  SIG_MESSAGE("psd_window5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window5");
#define mccompcurname  psd_window5
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 143
#define nx mccpsd_window5_nx
#define ny mccpsd_window5_ny
#define filename mccpsd_window5_filename
#define PSD_N mccpsd_window5_PSD_N
#define PSD_p mccpsd_window5_PSD_p
#define PSD_p2 mccpsd_window5_PSD_p2
#define weight mccpsd_window5_weight
{   /* Declarations of psd_window5=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window5_xmin;
MCNUM xmax = mccpsd_window5_xmax;
MCNUM ymin = mccpsd_window5_ymin;
MCNUM ymax = mccpsd_window5_ymax;
MCNUM xwidth = mccpsd_window5_xwidth;
MCNUM yheight = mccpsd_window5_yheight;
MCNUM psf = mccpsd_window5_psf;
MCNUM k0 = mccpsd_window5_k0;
MCNUM eff = mccpsd_window5_eff;
MCNUM restore_neutron = mccpsd_window5_restore_neutron;
int nowritefile = mccpsd_window5_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76131 "RITA-II.c"
}   /* End of psd_window5=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window5'. */
  SIG_MESSAGE("emon_window5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window5");
#define mccompcurname  emon_window5
#define mccompcurtype  E_monitor
#define mccompcurindex 144
#define nE mccemon_window5_nE
#define E_N mccemon_window5_E_N
#define E_p mccemon_window5_E_p
#define E_p2 mccemon_window5_E_p2
#define S_p mccemon_window5_S_p
#define S_pE mccemon_window5_S_pE
#define S_pE2 mccemon_window5_S_pE2
{   /* Declarations of emon_window5=E_monitor() SETTING parameters. */
char* filename = mccemon_window5_filename;
MCNUM xmin = mccemon_window5_xmin;
MCNUM xmax = mccemon_window5_xmax;
MCNUM ymin = mccemon_window5_ymin;
MCNUM ymax = mccemon_window5_ymax;
MCNUM xwidth = mccemon_window5_xwidth;
MCNUM yheight = mccemon_window5_yheight;
MCNUM Emin = mccemon_window5_Emin;
MCNUM Emax = mccemon_window5_Emax;
MCNUM restore_neutron = mccemon_window5_restore_neutron;
int nowritefile = mccemon_window5_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76178 "RITA-II.c"
}   /* End of emon_window5=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window6'. */
  SIG_MESSAGE("psd_window6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window6");
#define mccompcurname  psd_window6
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 145
#define nx mccpsd_window6_nx
#define ny mccpsd_window6_ny
#define filename mccpsd_window6_filename
#define PSD_N mccpsd_window6_PSD_N
#define PSD_p mccpsd_window6_PSD_p
#define PSD_p2 mccpsd_window6_PSD_p2
#define weight mccpsd_window6_weight
{   /* Declarations of psd_window6=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window6_xmin;
MCNUM xmax = mccpsd_window6_xmax;
MCNUM ymin = mccpsd_window6_ymin;
MCNUM ymax = mccpsd_window6_ymax;
MCNUM xwidth = mccpsd_window6_xwidth;
MCNUM yheight = mccpsd_window6_yheight;
MCNUM psf = mccpsd_window6_psf;
MCNUM k0 = mccpsd_window6_k0;
MCNUM eff = mccpsd_window6_eff;
MCNUM restore_neutron = mccpsd_window6_restore_neutron;
int nowritefile = mccpsd_window6_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76225 "RITA-II.c"
}   /* End of psd_window6=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window6'. */
  SIG_MESSAGE("emon_window6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window6");
#define mccompcurname  emon_window6
#define mccompcurtype  E_monitor
#define mccompcurindex 146
#define nE mccemon_window6_nE
#define E_N mccemon_window6_E_N
#define E_p mccemon_window6_E_p
#define E_p2 mccemon_window6_E_p2
#define S_p mccemon_window6_S_p
#define S_pE mccemon_window6_S_pE
#define S_pE2 mccemon_window6_S_pE2
{   /* Declarations of emon_window6=E_monitor() SETTING parameters. */
char* filename = mccemon_window6_filename;
MCNUM xmin = mccemon_window6_xmin;
MCNUM xmax = mccemon_window6_xmax;
MCNUM ymin = mccemon_window6_ymin;
MCNUM ymax = mccemon_window6_ymax;
MCNUM xwidth = mccemon_window6_xwidth;
MCNUM yheight = mccemon_window6_yheight;
MCNUM Emin = mccemon_window6_Emin;
MCNUM Emax = mccemon_window6_Emax;
MCNUM restore_neutron = mccemon_window6_restore_neutron;
int nowritefile = mccemon_window6_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76272 "RITA-II.c"
}   /* End of emon_window6=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window7'. */
  SIG_MESSAGE("psd_window7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window7");
#define mccompcurname  psd_window7
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 147
#define nx mccpsd_window7_nx
#define ny mccpsd_window7_ny
#define filename mccpsd_window7_filename
#define PSD_N mccpsd_window7_PSD_N
#define PSD_p mccpsd_window7_PSD_p
#define PSD_p2 mccpsd_window7_PSD_p2
#define weight mccpsd_window7_weight
{   /* Declarations of psd_window7=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window7_xmin;
MCNUM xmax = mccpsd_window7_xmax;
MCNUM ymin = mccpsd_window7_ymin;
MCNUM ymax = mccpsd_window7_ymax;
MCNUM xwidth = mccpsd_window7_xwidth;
MCNUM yheight = mccpsd_window7_yheight;
MCNUM psf = mccpsd_window7_psf;
MCNUM k0 = mccpsd_window7_k0;
MCNUM eff = mccpsd_window7_eff;
MCNUM restore_neutron = mccpsd_window7_restore_neutron;
int nowritefile = mccpsd_window7_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76319 "RITA-II.c"
}   /* End of psd_window7=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window7'. */
  SIG_MESSAGE("emon_window7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window7");
#define mccompcurname  emon_window7
#define mccompcurtype  E_monitor
#define mccompcurindex 148
#define nE mccemon_window7_nE
#define E_N mccemon_window7_E_N
#define E_p mccemon_window7_E_p
#define E_p2 mccemon_window7_E_p2
#define S_p mccemon_window7_S_p
#define S_pE mccemon_window7_S_pE
#define S_pE2 mccemon_window7_S_pE2
{   /* Declarations of emon_window7=E_monitor() SETTING parameters. */
char* filename = mccemon_window7_filename;
MCNUM xmin = mccemon_window7_xmin;
MCNUM xmax = mccemon_window7_xmax;
MCNUM ymin = mccemon_window7_ymin;
MCNUM ymax = mccemon_window7_ymax;
MCNUM xwidth = mccemon_window7_xwidth;
MCNUM yheight = mccemon_window7_yheight;
MCNUM Emin = mccemon_window7_Emin;
MCNUM Emax = mccemon_window7_Emax;
MCNUM restore_neutron = mccemon_window7_restore_neutron;
int nowritefile = mccemon_window7_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76366 "RITA-II.c"
}   /* End of emon_window7=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window8'. */
  SIG_MESSAGE("psd_window8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window8");
#define mccompcurname  psd_window8
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 149
#define nx mccpsd_window8_nx
#define ny mccpsd_window8_ny
#define filename mccpsd_window8_filename
#define PSD_N mccpsd_window8_PSD_N
#define PSD_p mccpsd_window8_PSD_p
#define PSD_p2 mccpsd_window8_PSD_p2
#define weight mccpsd_window8_weight
{   /* Declarations of psd_window8=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window8_xmin;
MCNUM xmax = mccpsd_window8_xmax;
MCNUM ymin = mccpsd_window8_ymin;
MCNUM ymax = mccpsd_window8_ymax;
MCNUM xwidth = mccpsd_window8_xwidth;
MCNUM yheight = mccpsd_window8_yheight;
MCNUM psf = mccpsd_window8_psf;
MCNUM k0 = mccpsd_window8_k0;
MCNUM eff = mccpsd_window8_eff;
MCNUM restore_neutron = mccpsd_window8_restore_neutron;
int nowritefile = mccpsd_window8_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76413 "RITA-II.c"
}   /* End of psd_window8=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window8'. */
  SIG_MESSAGE("emon_window8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window8");
#define mccompcurname  emon_window8
#define mccompcurtype  E_monitor
#define mccompcurindex 150
#define nE mccemon_window8_nE
#define E_N mccemon_window8_E_N
#define E_p mccemon_window8_E_p
#define E_p2 mccemon_window8_E_p2
#define S_p mccemon_window8_S_p
#define S_pE mccemon_window8_S_pE
#define S_pE2 mccemon_window8_S_pE2
{   /* Declarations of emon_window8=E_monitor() SETTING parameters. */
char* filename = mccemon_window8_filename;
MCNUM xmin = mccemon_window8_xmin;
MCNUM xmax = mccemon_window8_xmax;
MCNUM ymin = mccemon_window8_ymin;
MCNUM ymax = mccemon_window8_ymax;
MCNUM xwidth = mccemon_window8_xwidth;
MCNUM yheight = mccemon_window8_yheight;
MCNUM Emin = mccemon_window8_Emin;
MCNUM Emax = mccemon_window8_Emax;
MCNUM restore_neutron = mccemon_window8_restore_neutron;
int nowritefile = mccemon_window8_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76460 "RITA-II.c"
}   /* End of emon_window8=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_window9'. */
  SIG_MESSAGE("psd_window9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_window9");
#define mccompcurname  psd_window9
#define mccompcurtype  PSD_monitor_psf_eff
#define mccompcurindex 151
#define nx mccpsd_window9_nx
#define ny mccpsd_window9_ny
#define filename mccpsd_window9_filename
#define PSD_N mccpsd_window9_PSD_N
#define PSD_p mccpsd_window9_PSD_p
#define PSD_p2 mccpsd_window9_PSD_p2
#define weight mccpsd_window9_weight
{   /* Declarations of psd_window9=PSD_monitor_psf_eff() SETTING parameters. */
MCNUM xmin = mccpsd_window9_xmin;
MCNUM xmax = mccpsd_window9_xmax;
MCNUM ymin = mccpsd_window9_ymin;
MCNUM ymax = mccpsd_window9_ymax;
MCNUM xwidth = mccpsd_window9_xwidth;
MCNUM yheight = mccpsd_window9_yheight;
MCNUM psf = mccpsd_window9_psf;
MCNUM k0 = mccpsd_window9_k0;
MCNUM eff = mccpsd_window9_eff;
MCNUM restore_neutron = mccpsd_window9_restore_neutron;
int nowritefile = mccpsd_window9_nowritefile;
#line 128 "/usr/share/mcstas/2.5/monitors/PSD_monitor_psf_eff.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76507 "RITA-II.c"
}   /* End of psd_window9=PSD_monitor_psf_eff() SETTING parameter declarations. */
#undef weight
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef filename
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'emon_window9'. */
  SIG_MESSAGE("emon_window9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "emon_window9");
#define mccompcurname  emon_window9
#define mccompcurtype  E_monitor
#define mccompcurindex 152
#define nE mccemon_window9_nE
#define E_N mccemon_window9_E_N
#define E_p mccemon_window9_E_p
#define E_p2 mccemon_window9_E_p2
#define S_p mccemon_window9_S_p
#define S_pE mccemon_window9_S_pE
#define S_pE2 mccemon_window9_S_pE2
{   /* Declarations of emon_window9=E_monitor() SETTING parameters. */
char* filename = mccemon_window9_filename;
MCNUM xmin = mccemon_window9_xmin;
MCNUM xmax = mccemon_window9_xmax;
MCNUM ymin = mccemon_window9_ymin;
MCNUM ymax = mccemon_window9_ymax;
MCNUM xwidth = mccemon_window9_xwidth;
MCNUM yheight = mccemon_window9_yheight;
MCNUM Emin = mccemon_window9_Emin;
MCNUM Emax = mccemon_window9_Emax;
MCNUM restore_neutron = mccemon_window9_restore_neutron;
int nowritefile = mccemon_window9_nowritefile;
#line 132 "/usr/share/mcstas/2.5/monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 76554 "RITA-II.c"
}   /* End of emon_window9=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  printf("MCDISPLAY: end\n");
} /* end display */
#undef magnify
#undef line
#undef dashed_line
#undef multiline
#undef rectangle
#undef box
#undef circle
#undef cylinder
#undef sphere
/* end of generated C code RITA-II.c */
